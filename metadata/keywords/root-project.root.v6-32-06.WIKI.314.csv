id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/TMultiDimFit.html:33570,Integrability,message,message,33570,"lize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""ps"") const; Print statistics etc.; Options are; P Parameters; S Statistics; C Coefficients; R Result of parameterisation; F Result of fit; K Correlation Matrix; M Pretty print formula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels t",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:1524,Modifiability,variab,variables,1524,"ms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independen",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2478,Modifiability,variab,variables,2478,"This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2606,Modifiability,parameteriz,parameterization,2606,"This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2743,Modifiability,variab,variable,2743,"fore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:3306,Modifiability,variab,variable,3306,"est, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; Ther",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:3921,Modifiability,variab,variable,3921,"it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4059,Modifiability,variab,variable,4059,"the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-poin",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4580,Modifiability,variab,variable,4580,"ble to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample a",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:5600,Modifiability,variab,variables,5600,"ower of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which the columns ; are given by; . (4). (5). and ; is the component of ; orthogonal; to ; . Hence we obtain; [3],; .    if. (6). We now take as a new model ; . We thus want to; minimize; . (7). where ; is a vector of the; dependent quantity in the sample. Differentiation with respect to; gives, using (6),; . (8). or; . (9). Let be the sum of squares of residuals when taking functions; into account. Then; . (10). Using (9), we see that; .  ;  .  ;  . (11). So for each new function included in the model, we get a; reduction of the sum of squares of residuals of ; ,; where ; is given by (4) and by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Funct",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:8943,Modifiability,parameteriz,parameterization,8943,"ile fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10072,Modifiability,variab,variables,10072,"ions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and u",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10234,Modifiability,variab,variables,10234,"atrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselve",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10275,Modifiability,variab,variables,10275,"atrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselve",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10375,Modifiability,variab,variable,10375,"atrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselve",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10532,Modifiability,variab,variables,10532," we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, usin",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:11406,Modifiability,variab,variables,11406,"is class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sam",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:11569,Modifiability,parameteriz,parameterization,11569,"le; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:11846,Modifiability,parameteriz,parameterization,11846,"ions to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:11954,Modifiability,parameteriz,parameterization,11954,"e values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis f",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12097,Modifiability,variab,variables,12097,"Principal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12204,Modifiability,parameteriz,parameterization,12204,"nalysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:13255,Modifiability,parameteriz,parameterization,13255,"test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981.; . */. Function Members (Methods); public:. virtual~TMultiDimFit(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddRow(const Double_t* x, Double_t D, Double_t E = 0); virtual voidAddTestRow(const Double_t* x, Double_t D, Double_t E = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """")MENU ; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtu",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:22536,Modifiability,variab,variables,22536,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:22587,Modifiability,variab,variables,22587,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:22867,Modifiability,parameteriz,parameterization,22867,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23711,Modifiability,variab,variables,23711,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23819,Modifiability,variab,variables,23819,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:24123,Modifiability,variab,variables,24123,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:24224,Modifiability,variab,variables,24224,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25586,Modifiability,variab,variables,25586,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25679,Modifiability,variab,variables,25679,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26366,Modifiability,variab,variables,26366,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26513,Modifiability,parameteriz,parameterization,26513,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26548,Modifiability,variab,variables,26548,"dent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26974,Modifiability,variab,variables,26974,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27129,Modifiability,parameteriz,parameterization,27129,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27516,Modifiability,variab,variables,27516,"mple to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Opt",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27603,Modifiability,parameteriz,parameterization,27603,"ulated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27823,Modifiability,parameteriz,parameterization,27823,"value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); C",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28189,Modifiability,variab,variable,28189," This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28266,Modifiability,parameteriz,parameterization,28266,"ven Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <filename> with .C appended if argument doesn't; end in .cxx or .C. The contains the implementatio",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:29393,Modifiability,variab,variables,29393,"tion. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <filename> with .C appended if argument doesn't; end in .cxx or .C. The contains the implementation of the; function:. Double_t <funcname>(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the static variables:. Int_t gNVariables; Int_t gNCoefficients; Double_t gDMean; Double_t gXMean[]; Double_t gXMin[]; Double_t gXMax[]; Double_t gCoefficient[]; Int_t gPower[]. are initialized. The only ROOT header file needed is Rtypes.h. See TMultiDimFit::MakeRealCode for a list of options. void MakeCoefficientErrors(); PRIVATE METHOD:; Compute the errors on the coefficients. For this to be done, the; curvature matrix of the non-orthogonal functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this a",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30642,Modifiability,parameteriz,parameterization,30642,"ed is Rtypes.h. See TMultiDimFit::MakeRealCode for a list of options. void MakeCoefficientErrors(); PRIVATE METHOD:; Compute the errors on the coefficients. For this to be done, the; curvature matrix of the non-orthogonal functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30710,Modifiability,variab,variables,30710,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30742,Modifiability,variab,variables,30742,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30778,Modifiability,variab,variables,30778,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30809,Modifiability,variab,variables,30809,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30863,Modifiability,variab,variables,30863,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30904,Modifiability,variab,variable,30904,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:32044,Modifiability,variab,variables,32044,"method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <classname>.h and assumed to be provided by the; user. See TMultiDimFit::MakeRealCode for a list of options. The minimal class definition is:. class <classname> {; public:; Int_t <classname>::fgNVariables; // Number of variables; Int_t <classname>::fgNCoefficients; // Number of terms; Double_t <classname>::fgDMean; // Mean from training sample; Double_t <classname>::fgXMean[]; // Mean from training sample; Double_t <classname>::fgXMin[]; // Min from training sample; Double_t <classname>::fgXMax[]; // Max from training sample; Double_t <classname>::fgCoefficient[]; // Coefficients; Int_t <classname>::fgPower[]; // Function powers. Double_t Eval(Double_t *x);; };. Whether the method <classname>::Eval should be static or not, is; up to the user. void MakeNormalized(); PRIVATE METHOD:; Normalize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""p",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:32760,Modifiability,parameteriz,parameterization,32760,"lized, and assumed to exist. The class declaration is; assumed to be in <classname>.h and assumed to be provided by the; user. See TMultiDimFit::MakeRealCode for a list of options. The minimal class definition is:. class <classname> {; public:; Int_t <classname>::fgNVariables; // Number of variables; Int_t <classname>::fgNCoefficients; // Number of terms; Double_t <classname>::fgDMean; // Mean from training sample; Double_t <classname>::fgXMean[]; // Mean from training sample; Double_t <classname>::fgXMin[]; // Min from training sample; Double_t <classname>::fgXMax[]; // Max from training sample; Double_t <classname>::fgCoefficient[]; // Coefficients; Int_t <classname>::fgPower[]; // Function powers. Double_t Eval(Double_t *x);; };. Whether the method <classname>::Eval should be static or not, is; up to the user. void MakeNormalized(); PRIVATE METHOD:; Normalize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""ps"") const; Print statistics etc.; Options are; P Parameters; S Statistics; C Coefficients; R Result of parameterisation; F Result of fit; K Correlation Matrix; M Pretty print formula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For exa",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:33052,Modifiability,parameteriz,parameterization,33052,"assname> {; public:; Int_t <classname>::fgNVariables; // Number of variables; Int_t <classname>::fgNCoefficients; // Number of terms; Double_t <classname>::fgDMean; // Mean from training sample; Double_t <classname>::fgXMean[]; // Mean from training sample; Double_t <classname>::fgXMin[]; // Min from training sample; Double_t <classname>::fgXMax[]; // Max from training sample; Double_t <classname>::fgCoefficient[]; // Coefficients; Int_t <classname>::fgPower[]; // Function powers. Double_t Eval(Double_t *x);; };. Whether the method <classname>::Eval should be static or not, is; up to the user. void MakeNormalized(); PRIVATE METHOD:; Normalize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""ps"") const; Print statistics etc.; Options are; P Parameters; S Statistics; C Coefficients; R Result of parameterisation; F Result of fit; K Correlation Matrix; M Pretty print formula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vec",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:33672,Modifiability,variab,variables,33672,"lize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""ps"") const; Print statistics etc.; Options are; P Parameters; S Statistics; C Coefficients; R Result of parameterisation; F Result of fit; K Correlation Matrix; M Pretty print formula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels t",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:34648,Modifiability,variab,variable,34648," is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:34878,Modifiability,variab,variable,34878,"Angle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions(",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:35026,Modifiability,variab,variable,35026," to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4077,Performance,perform,perform,4077,"the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-poin",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:6656,Performance,perform,performed,6656,"d evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which the columns ; are given by; . (4). (5). and ; is the component of ; orthogonal; to ; . Hence we obtain; [3],; .    if. (6). We now take as a new model ; . We thus want to; minimize; . (7). where ; is a vector of the; dependent quantity in the sample. Differentiation with respect to; gives, using (6),; . (8). or; . (9). Let be the sum of squares of residuals when taking functions; into account. Then; . (10). Using (9), we see that; .  ;  .  ;  . (11). So for each new function included in the model, we get a; reduction of the sum of squares of residuals of ; ,; where ; is given by (4) and by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Function Selection Based on Residual; . Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function.; ; The sum of squares of residuals can be written as; . (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by; . (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not.; . Test 1; . Denoting by the subspace spanned by; ; the function ; is; by construction (see (4)) the projection of the function; onto the direction perpendicular to . Now, if the; length of ; (given by ; ); is very small compared to the length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . L",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:8268,Performance,perform,performing,8268," not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:8676,Performance,perform,perform,8676,"; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calc",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10139,Performance,perform,perform,10139,"ions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and u",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:6915,Testability,test,test,6915,". We now take as a new model ; . We thus want to; minimize; . (7). where ; is a vector of the; dependent quantity in the sample. Differentiation with respect to; gives, using (6),; . (8). or; . (9). Let be the sum of squares of residuals when taking functions; into account. Then; . (10). Using (9), we see that; .  ;  .  ;  . (11). So for each new function included in the model, we get a; reduction of the sum of squares of residuals of ; ,; where ; is given by (4) and by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Function Selection Based on Residual; . Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function.; ; The sum of squares of residuals can be written as; . (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by; . (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not.; . Test 1; . Denoting by the subspace spanned by; ; the function ; is; by construction (see (4)) the projection of the function; onto the direction perpendicular to . Now, if the; length of ; (given by ; ); is very small compared to the length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:7371,Testability,test,test,7371," by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Function Selection Based on Residual; . Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function.; ; The sum of squares of residuals can be written as; . (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by; . (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not.; . Test 1; . Denoting by the subspace spanned by; ; the function ; is; by construction (see (4)) the projection of the function; onto the direction perpendicular to . Now, if the; length of ; (given by ; ); is very small compared to the length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:8291,Testability,test,test,8291," not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:11908,Testability,test,testing,11908,"e values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis f",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12030,Testability,test,test,12030,"Principal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12258,Testability,test,test,12258,"nalysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12320,Testability,test,test,12320,"endent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computi",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12779,Testability,test,test,12779,"ansform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981.; . */. Function Members (Methods); public:. virtual~TMultiDimFit(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddRow(const Double_t* x, Double_t D, Double_t E =",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25336,Testability,test,test,25336,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25386,Testability,test,test,25386,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25474,Testability,test,test,25474,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27085,Testability,test,test,27085,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27117,Testability,test,test,27117,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28472,Testability,test,test,28472,"he TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <filename> with .C appended if argument doesn't; end in .cxx or .C. The contains the implementation of the; function:. Double_t <funcname>(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the static variables:. Int_t gNVariables; Int_t gNCoeffic",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28835,Testability,test,test,28835,"ff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <filename> with .C appended if argument doesn't; end in .cxx or .C. The contains the implementation of the; function:. Double_t <funcname>(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the static variables:. Int_t gNVariables; Int_t gNCoefficients; Double_t gDMean; Double_t gXMean[]; Double_t gXMin[]; Double_t gXMax[]; Double_t gCoefficient[]; Int_t gPower[]. are initialized. The only ROOT header file needed is Rtypes.h. See TMultiDimFit::MakeRealCode for a list of options. void MakeCoefficientErrors(); PRIVATE METHOD:; Compute the errors on the coefficients. For this to be done, the; curvature ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30981,Testability,test,test,30981,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10875,Usability,simpl,simple,10875,"e problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . T",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiGraph.html:8096,Availability,error,error,8096,"ject::AbstractMethod(const char* method) const; virtual voidAdd(TGraph* graph, Option_t* chopt = """"); virtual voidAdd(TMultiGraph* multigraph, Option_t* chopt = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TFitResultPtrFit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); virtual TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); virtual voidFitPanel()MENU ; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction(const char* name) const; virtual Option_t*GetGraphDrawOption(const TGraph* gr) const; TH1F*GetHistogram() const; virtual const char*TObject::GetIconName() const; TList*GetListOfFunctions(); const TList*GetListOfFuncti",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:8180,Availability,error,error,8180,"n_t* chopt = """"); virtual voidAdd(TMultiGraph* multigraph, Option_t* chopt = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TFitResultPtrFit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); virtual TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); virtual voidFitPanel()MENU ; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction(const char* name) const; virtual Option_t*GetGraphDrawOption(const TGraph* gr) const; TH1F*GetHistogram() const; virtual const char*TObject::GetIconName() const; TList*GetListOfFunctions(); const TList*GetListOfFunctions() const; TList*GetListOfGraphs() const; virtual const char*TNamed::GetName() con",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:16411,Availability,error,errors,16411," If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; TMultiGraph::Draw. Use GetDrawOption to return the option specified; when drawing the TMultiGraph. TFitResultPtr Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function with name fname. interface to TF1::Fit(TF1 *f1... TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); Fit this multigraph with function f1. In this function all graphs of the multigraph are fitted simultaneously. f1 is an already predefined function created by TF1.; Predefined functions such as gaus, expo and poln are automatically; created by ROOT. The list of fit options is given in parameter option.; option = ""W"" Set all errors to 1; = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; = ""R"" Use the Range specified in the function range; = ""N"" Do not store the graphics function, do not draw; = ""0"" Do not plot the result of the fit. By default the fitted function; is drawn unless the option""N"" above is specified.; = ""+"" Add this new fitted function to the list of fitted functions; (by default, any previous function is deleted); = ""C"" In case of linear fitting, not calculate the chisquare; (saves time); = ""F"" If fitting a polN, switch to minuit fitter; = ""ROB"" In case of linear fitting, compute the LTS regression; coefficients (robust(resistant) regression), using; the default fraction of good points; ""ROB=0.x"" - compute the LTS regression coefficients, using; 0.x as a fraction of good points. When the fit is drawn (by default), the parameter goption may be used; to specify a list of graphics options. See TGraph::P",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:17252,Availability,robust,robust,17252,"unction all graphs of the multigraph are fitted simultaneously. f1 is an already predefined function created by TF1.; Predefined functions such as gaus, expo and poln are automatically; created by ROOT. The list of fit options is given in parameter option.; option = ""W"" Set all errors to 1; = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; = ""R"" Use the Range specified in the function range; = ""N"" Do not store the graphics function, do not draw; = ""0"" Do not plot the result of the fit. By default the fitted function; is drawn unless the option""N"" above is specified.; = ""+"" Add this new fitted function to the list of fitted functions; (by default, any previous function is deleted); = ""C"" In case of linear fitting, not calculate the chisquare; (saves time); = ""F"" If fitting a polN, switch to minuit fitter; = ""ROB"" In case of linear fitting, compute the LTS regression; coefficients (robust(resistant) regression), using; the default fraction of good points; ""ROB=0.x"" - compute the LTS regression coefficients, using; 0.x as a fraction of good points. When the fit is drawn (by default), the parameter goption may be used; to specify a list of graphics options. See TGraph::Paint for a complete; list of these options. In order to use the Range option, one must first create a function; with the expression to be fitted. For example, if your graph; has a defined range between -4 and 4 and you want to fit a gaussian; only in the interval 1 to 3, you can do:; TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; graph->Fit(""f1"",""R"");. who is calling this function. Note that this function is called when calling TGraphErrors::Fit; or TGraphAsymmErrors::Fit ot TGraphBentErrors::Fit; see the discussion below on the errors calulation. Setting initial conditions. Parameters must b",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:18069,Availability,error,errors,18069,"by default, any previous function is deleted); = ""C"" In case of linear fitting, not calculate the chisquare; (saves time); = ""F"" If fitting a polN, switch to minuit fitter; = ""ROB"" In case of linear fitting, compute the LTS regression; coefficients (robust(resistant) regression), using; the default fraction of good points; ""ROB=0.x"" - compute the LTS regression coefficients, using; 0.x as a fraction of good points. When the fit is drawn (by default), the parameter goption may be used; to specify a list of graphics options. See TGraph::Paint for a complete; list of these options. In order to use the Range option, one must first create a function; with the expression to be fitted. For example, if your graph; has a defined range between -4 and 4 and you want to fit a gaussian; only in the interval 1 to 3, you can do:; TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; graph->Fit(""f1"",""R"");. who is calling this function. Note that this function is called when calling TGraphErrors::Fit; or TGraphAsymmErrors::Fit ot TGraphBentErrors::Fit; see the discussion below on the errors calulation. Setting initial conditions. Parameters must be initialized before invoking the Fit function.; The setting of the parameter initial values is automatic for the; predefined functions : poln, expo, gaus, landau. One can however disable; this automatic computation by specifying the option ""B"".; You can specify boundary limits for some or all parameters via; f1->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. Fit range. The fit range can be specified in two ways:; - specify rxmax > rxmin (default is ",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:20325,Availability,error,error,20325,"::EvaluateChi2.; In case of TGraphErrors an effective chi2 is used; (see TGraphErrors fit in TGraph::Fit) and is implemented in; FitUtil::EvaluateChi2Effective; To specify a User defined fitting function, specify option ""U"" and; call the following functions:; TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit and it converts; automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; the TFitResult and behaves as a smart pointer to it. For example one can do:; TFitResultPtr r = graph->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParErr",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:20492,Availability,error,error,20492,"lFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit and it converts; automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; the TFitResult and behaves as a smart pointer to it. For example one can do:; TFitResultPtr r = graph->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Fit Statistics. You can change the statistics box to display the fit parameters with; the TStyle::SetOptFit(mode) method. This mode has four digits.; mode = pcev (default = 0111); v = 1; print name/values of parameters; e = 1; prin",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:21270,Availability,error,error,21270,"GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Fit Statistics. You can change the statistics box to display the fit parameters with; the TStyle::SetOptFit(mode) method. This mode has four digits.; mode = pcev (default = 0111); v = 1; print name/values of parameters; e = 1; print errors (if e=1, v must be 1); c = 1; print Chisquare/Number of degress of freedom; p = 1; print Probability. For example: gStyle->SetOptFit(1011);; prints the fit probability, parameter names/values, and errors.; You can change the position of the statistics box with these lines; (where g is a pointer to the TGraph):. Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. void FitPanel(); Display a panel with all histogram fit options.; See class TFitPanel for example. Option_t ",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:21529,Availability,error,errors,21529,"e retrieved also; from the fitted function. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Fit Statistics. You can change the statistics box to display the fit parameters with; the TStyle::SetOptFit(mode) method. This mode has four digits.; mode = pcev (default = 0111); v = 1; print name/values of parameters; e = 1; print errors (if e=1, v must be 1); c = 1; print Chisquare/Number of degress of freedom; p = 1; print Probability. For example: gStyle->SetOptFit(1011);; prints the fit probability, parameter names/values, and errors.; You can change the position of the statistics box with these lines; (where g is a pointer to the TGraph):. Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. void FitPanel(); Display a panel with all histogram fit options.; See class TFitPanel for example. Option_t * GetGraphDrawOption(const TGraph* gr) const; Return the draw option for the TGraph gr in this TMultiGraph.; The return option is the one specified when calling TMultiGraph::Add(gr,option). void InitGaus(Double_t xmin, Double_t xmax); Compute Initial values of parameters for a gaussian. void InitExpo(Double_t xmin, Double_t xmax); Compute Initial values of parameters for an exponential. void Init",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:21733,Availability,error,errors,21733,"ctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Fit Statistics. You can change the statistics box to display the fit parameters with; the TStyle::SetOptFit(mode) method. This mode has four digits.; mode = pcev (default = 0111); v = 1; print name/values of parameters; e = 1; print errors (if e=1, v must be 1); c = 1; print Chisquare/Number of degress of freedom; p = 1; print Probability. For example: gStyle->SetOptFit(1011);; prints the fit probability, parameter names/values, and errors.; You can change the position of the statistics box with these lines; (where g is a pointer to the TGraph):. Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. void FitPanel(); Display a panel with all histogram fit options.; See class TFitPanel for example. Option_t * GetGraphDrawOption(const TGraph* gr) const; Return the draw option for the TGraph gr in this TMultiGraph.; The return option is the one specified when calling TMultiGraph::Add(gr,option). void InitGaus(Double_t xmin, Double_t xmax); Compute Initial values of parameters for a gaussian. void InitExpo(Double_t xmin, Double_t xmax); Compute Initial values of parameters for an exponential. void InitPolynom(Double_t xmin, Double_t xmax); Compute Initial values of parameters for a polynom. void LeastSquareFit(Int_t m, Double_t* a, Double_t xmin, ",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:15941,Integrability,interface,interface,15941," in ""multigraph"" will be added with; the ""chopt"" option.; If ""chopt"" is undefined each graph will be added with the option it had; in ""multigraph"". void Browse(TBrowser* b); Browse multigraph. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to each graph. void Draw(Option_t* chopt = """"); Draw this multigraph with its current attributes. Options to draw a graph are described in TGraphPainter. The drawing option for each TGraph may be specified as an optional; second argument of the Add function. You can use GetGraphDrawOption; to return this option.; If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; TMultiGraph::Draw. Use GetDrawOption to return the option specified; when drawing the TMultiGraph. TFitResultPtr Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function with name fname. interface to TF1::Fit(TF1 *f1... TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); Fit this multigraph with function f1. In this function all graphs of the multigraph are fitted simultaneously. f1 is an already predefined function created by TF1.; Predefined functions such as gaus, expo and poln are automatically; created by ROOT. The list of fit options is given in parameter option.; option = ""W"" Set all errors to 1; = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; = ""R"" Use the Range specified in the function range; = ""N"" Do not store the graphics function, do not draw; = ""0"" Do not plot the result of the fit. By default the fitted function; is drawn unless the option""N"" above is specified.; = ""+"" Add this new fitt",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:22916,Integrability,rout,routine,22916,"); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. void FitPanel(); Display a panel with all histogram fit options.; See class TFitPanel for example. Option_t * GetGraphDrawOption(const TGraph* gr) const; Return the draw option for the TGraph gr in this TMultiGraph.; The return option is the one specified when calling TMultiGraph::Add(gr,option). void InitGaus(Double_t xmin, Double_t xmax); Compute Initial values of parameters for a gaussian. void InitExpo(Double_t xmin, Double_t xmax); Compute Initial values of parameters for an exponential. void InitPolynom(Double_t xmin, Double_t xmax); Compute Initial values of parameters for a polynom. void LeastSquareFit(Int_t m, Double_t* a, Double_t xmin, Double_t xmax); Least squares lpolynomial fitting without weights. m number of parameters; a array of parameters; first 1st point number to fit (default =0); last last point number to fit (default=fNpoints-1). based on CERNLIB routine LSQ: Translated to C++ by Rene Brun. void LeastSquareLinearFit(Int_t ndata, Double_t& a0, Double_t& a1, Int_t& ifail, Double_t xmin, Double_t xmax); Least square linear fit without weights. Fit a straight line (a0 + a1*x) to the data in this graph.; ndata: number of points to fit; first: first point number to fit; last: last point to fit O(ndata should be last-first; ifail: return parameter indicating the status of the fit (ifail=0, fit is OK). extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun. Int_t IsInside(Double_t x, Double_t y) const; Return 1 if the point (x,y) is inside one of the graphs 0 otherwise. TH1F * GetHistogram() const; Returns a pointer to the histogram used to draw the axis.; Takes into account the two following cases.; 1- option 'A' was specified in TMultiGraph::Draw. Return fHistogram; 2- user had called TPad::DrawFrame. return pointer to hframe histogram. TF1 * GetFunction(const char* name) const; Return pointer to function with name. Functions such as TGraph:",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:747,Performance,perform,performed,747,". TMultiGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiGraph. class TMultiGraph: public TNamed. TMultiGraph class; A TMultiGraph is a collection of TGraph (or derived) objects. It allows to; manipulate a set of graphs as a single entity. In particular, when drawn,; the X and Y axis ranges are automatically computed such as all the graphs; will be visible. TMultiGraph::Add should be used to add a new graph to the list. The TMultiGraph owns the objects in the list. The drawing options are the same as for TGraph.; Like for TGraph, the painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class.; Example:. TGraph *gr1 = new TGraph(...; TGraphErrors *gr2 = new TGraphErrors(...; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1,""lp"");; mg->Add(gr2,""cp"");; mg->Draw(""a"");. A special option 3D allows to draw the graphs in a 3D space. See the; following example:. Picture; Source. {; c0 = new TCanvas(""c1"",""multigraph L3"",200,10,700,500);; c0->SetFrameFillColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;. for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->D",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiGraph.html:20171,Security,access,access,20171,"::EvaluateChi2.; In case of TGraphErrors an effective chi2 is used; (see TGraphErrors fit in TGraph::Fit) and is implemented in; FitUtil::EvaluateChi2Effective; To specify a User defined fitting function, specify option ""U"" and; call the following functions:; TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit and it converts; automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; the TFitResult and behaves as a smart pointer to it. For example one can do:; TFitResultPtr r = graph->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParErr",MatchSource.WIKI,root/html604/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiGraph.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:981,Availability,avail,available,981,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial mov",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:1681,Availability,error,errors,1681,"eurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3586,Availability,error,error,3586,"ver a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3628,Availability,error,error,3628,"tor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The p",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3695,Availability,error,error,3695,"tor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The p",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3816,Availability,error,error,3816," made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch le",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:4214,Availability,error,errors,4214,"ear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8272,Availability,avail,available,8272,"; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:10217,Availability,error,error,10217,"= """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawResult(Int_t index = 0, Option_t* option = ""test"") const; virtual voidTObject::Dump() constMENU ; Bool_tDumpWeights(Option_t* filename = ""-"") const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEvaluate(Int_t index, Double_t* params) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExport(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEpsilon() const; Double_tGetError(Int_t event) const; Double_tGetError(TMultiLayerPerceptron::EDataSet set) const; Double_tGetEta() const; Double_tGetEtaDecay() const; virtual const char*TObject::GetIconName() const; TMultiLayerPerceptron::ELearningMethodGetLearningMethod() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:10301,Availability,error,error,10301,"t char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawResult(Int_t index = 0, Option_t* option = ""test"") const; virtual voidTObject::Dump() constMENU ; Bool_tDumpWeights(Option_t* filename = ""-"") const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEvaluate(Int_t index, Double_t* params) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExport(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEpsilon() const; Double_tGetError(Int_t event) const; Double_tGetError(TMultiLayerPerceptron::EDataSet set) const; Double_tGetEta() const; Double_tGetEtaDecay() const; virtual const char*TObject::GetIconName() const; TMultiLayerPerceptron::ELearningMethodGetLearningMethod() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetReset() const; TStringGetStructure() co",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:26082,Availability,error,error,26082,"ay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:26159,Availability,error,error,26159,"ay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:26222,Availability,avail,available,26222,"ay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:26667,Availability,error,error,26667,"nt_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayer",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:26768,Availability,error,error,26768,"terations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3342,Deployability,continuous,continuous,3342,"MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimi",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:4480,Deployability,update,updated,4480,"methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients wi",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:4870,Deployability,update,updated,4870,"ights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matr",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8125,Deployability,update,update,8125,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayer",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8168,Deployability,update,update,8168,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayer",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8323,Deployability,update,update,8323,"ne them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObjec",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25886,Deployability,update,update,25886,"d SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25928,Deployability,update,update,25928,"d SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:27844,Deployability,update,updates,27844," output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Dou",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:29577,Deployability,update,updated,29577,"eights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used by a later stochastic step.; It returns true if the line search fails. void ConjugateGradientsDir(Double_t* , Double_t ); Sets the search direction to conjugate gradient direction; beta should be:; ||g_{(t+1)}||^2 / ||g_{(t)}||^2 (Fletcher-Reeves); g_{(t+1)} (g_{(t+1)}-g_{(t)}) / ||g_{(t)}||^2 (Ribiere-Polak). bool GetBFGSH(TMatrixD& , TMatrixD& , TMatrixD& ); Computes the hessian matrix using the BFGS update algorithm.; from gamma",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:29681,Deployability,update,updated,29681,"filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used by a later stochastic step.; It returns true if the line search fails. void ConjugateGradientsDir(Double_t* , Double_t ); Sets the search direction to conjugate gradient direction; beta should be:; ||g_{(t+1)}||^2 / ||g_{(t)}||^2 (Fletcher-Reeves); g_{(t+1)} (g_{(t+1)}-g_{(t)}) / ||g_{(t)}||^2 (Ribiere-Polak). bool GetBFGSH(TMatrixD& , TMatrixD& , TMatrixD& ); Computes the hessian matrix using the BFGS update algorithm.; from gamma (g_{(t+1)}-g_{(t)}) and delta (w_{(t+1)}-w_{(t)}).; It returns true if such a direction could not be found; (if gamma and delta are orthogonal). void SetGammaDelta(",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:30035,Deployability,update,updated,30035,"non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used by a later stochastic step.; It returns true if the line search fails. void ConjugateGradientsDir(Double_t* , Double_t ); Sets the search direction to conjugate gradient direction; beta should be:; ||g_{(t+1)}||^2 / ||g_{(t)}||^2 (Fletcher-Reeves); g_{(t+1)} (g_{(t+1)}-g_{(t)}) / ||g_{(t)}||^2 (Ribiere-Polak). bool GetBFGSH(TMatrixD& , TMatrixD& , TMatrixD& ); Computes the hessian matrix using the BFGS update algorithm.; from gamma (g_{(t+1)}-g_{(t)}) and delta (w_{(t+1)}-w_{(t)}).; It returns true if such a direction could not be found; (if gamma and delta are orthogonal). void SetGammaDelta(TMatrixD& , TMatrixD& , Double_t* ); Sets the gamma (g_{(t+1)}-g_{(t)}) and delta (w_{(t+1)}-w_{(t)}) vectors; Gamma is computed here, so ComputeDEDw cannot have been called before,; and delta is a direct translation of buffer into a TMatrixD. Double_t DerivDir(Double_t* ); scalar product between gradient and direction; = derivative along direction. void BFGSDir(TMatrixD& ,",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:30489,Deployability,update,update,30489," void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used by a later stochastic step.; It returns true if the line search fails. void ConjugateGradientsDir(Double_t* , Double_t ); Sets the search direction to conjugate gradient direction; beta should be:; ||g_{(t+1)}||^2 / ||g_{(t)}||^2 (Fletcher-Reeves); g_{(t+1)} (g_{(t+1)}-g_{(t)}) / ||g_{(t)}||^2 (Ribiere-Polak). bool GetBFGSH(TMatrixD& , TMatrixD& , TMatrixD& ); Computes the hessian matrix using the BFGS update algorithm.; from gamma (g_{(t+1)}-g_{(t)}) and delta (w_{(t+1)}-w_{(t)}).; It returns true if such a direction could not be found; (if gamma and delta are orthogonal). void SetGammaDelta(TMatrixD& , TMatrixD& , Double_t* ); Sets the gamma (g_{(t+1)}-g_{(t)}) and delta (w_{(t+1)}-w_{(t)}) vectors; Gamma is computed here, so ComputeDEDw cannot have been called before,; and delta is a direct translation of buffer into a TMatrixD. Double_t DerivDir(Double_t* ); scalar product between gradient and direction; = derivative along direction. void BFGSDir(TMatrixD& , Double_t* ); Computes the direction for the BFGS algorithm as the product; between the Hessian estimate (bfgsh) and the dir. void Draw(Option_t* option = """"); Draws the network structure.; Neurons are depicted by a blue disk, and synapses by; lines connecting neurons.; The line width is proportionnal to the weight. TMultiLayerPerceptron(). Double_t GetEta() const; { return fEta; }. Doubl",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:5877,Energy Efficiency,power,powerful,5877,"nimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:29067,Integrability,depend,dependant,29067," (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used b",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:1315,Modifiability,layers,layers,1315,"eurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:1368,Modifiability,layers,layers,1368,"eurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:2517,Modifiability,flexible,flexible,2517," of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3238,Modifiability,layers,layers,3238,"discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computatio",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:6338,Modifiability,layers,layers,6338,"e line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCu",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:6427,Modifiability,layers,layers,6427," the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning me",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:6484,Modifiability,layers,layers,6484,"; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic,",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8975,Modifiability,layers,layers,8975,"e; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawResult(Int_t index = 0, Option_t* option = ""test"") const; virtual voidTObject::Dump() constMENU ; ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:19967,Modifiability,layers,layers,19967,"steepest descent - Default=50; TStringfStructureString containing the network structure; TObjArrayfSynapsesCollection of all the synapses in the network; Double_tfTau! Tau - used in line search - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20042,Modifiability,layers,layers,20042,"rch - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: """,MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20099,Modifiability,layers,layers,20099,"fining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' i",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20192,Modifiability,variab,variable,20192," flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20893,Modifiability,layers,layers,20893,"g, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20968,Modifiability,layers,layers,20968,"giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21025,Modifiability,layers,layers,21025,"dden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21118,Modifiability,variab,variable,21118,"ers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be fol",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21824,Modifiability,layers,layers,21824,"TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, con",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21899,Modifiability,layers,layers,21899,"g; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just desc",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21956,Modifiability,layers,layers,21956,"layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are s",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22049,Modifiability,variab,variable,22049,"re separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepende",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22825,Modifiability,layers,layers,22825,"oid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22900,Modifiability,layers,layers,22900,"bed by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. vo",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22957,Modifiability,layers,layers,22957,"parated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets th",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:23050,Modifiability,variab,variable,23050," by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimizati",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:27072,Modifiability,layers,layers,27072," canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:27694,Modifiability,layers,layers,27694," for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:27866,Modifiability,layers,layers,27866," output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Dou",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:27245,Performance,perform,performance,27245,"ble. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:2022,Safety,predict,predictions,2022,"tion, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs o",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:753,Testability,test,test,753,". TMultiLayerPerceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis;",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:6988,Testability,test,test,6988,"e direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the nu",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:7220,Testability,test,test,7220,"ructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:9907,Testability,test,test,9907,,MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:13770,Testability,test,test,13770,"idTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidRandomize() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); Double_tResult(Int_t event, Int_t index = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetData(TTree*); voidSetDelta(Double_t delta); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsilon(Double_t eps); voidSetEta(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* tra",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:13808,Testability,test,test,13808,":Print(Option_t* option = """") const; voidRandomize() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); Double_tResult(Int_t event, Int_t index = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetData(TTree*); voidSetDelta(Double_t delta); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsilon(Double_t eps); voidSetEta(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* tes",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:14385,Testability,test,test,14385,"ption = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsilon(Double_t eps); voidSetEta(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); voidTrain(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsi",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:14579,Testability,test,test,14579,"(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); voidTrain(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:14808,Testability,test,test,14808,"(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); voidTrain(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:15022,Testability,test,test,15022,"(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); voidTrain(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:19136,Testability,test,test,19136,"FirstLayerCollection of the input neurons; subset of fNetwork; Double_tfLastAlpha! internal parameter used in line search; TObjArrayfLastLayerCollection of the output neurons; subset of fNetwork; TMultiLayerPerceptron::ELearningMethodfLearningMethod! The Learning Method; TTreeFormulaManager*fManager! TTreeFormulaManager for the weight and neurons; TObjArrayfNetworkCollection of all the neurons in the network; TNeuron::ENeuronTypefOutTypeType of output neurons; Int_tfReset! number of epochs between two resets of the search direction to the steepest descent - Default=50; TStringfStructureString containing the network structure; TObjArrayfSynapsesCollection of all the synapses in the network; Double_tfTau! Tau - used in line search - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:19804,Testability,test,test,19804,"steepest descent - Default=50; TStringfStructureString containing the network structure; TObjArrayfSynapsesCollection of all the synapses in the network; Double_tfTau! Tau - used in line search - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20420,Testability,test,test,20420,"ing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and th",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20730,Testability,test,test,20730,"g, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21346,Testability,test,test,21346,"ven as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testin",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21656,Testability,test,test,21656,"TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, con",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22277,Testability,test,test,22277,"rgument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22377,Testability,test,testing,22377,"rgument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22657,Testability,test,test,22657,"oid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:23278,Testability,test,test,23278,"vents; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod met",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:23378,Testability,test,testing,23378,"vents; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod met",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:23820,Testability,test,test,23820,"output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constru",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:24116,Testability,test,test,24116,"!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= E",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:26172,Testability,test,test,26172,"ay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:28195,Testability,test,test,28195,"ince this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:28378,Testability,test,test,28378,"ldNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used fo",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:960,Usability,learn,learning,960,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial mov",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:2507,Usability,clear,clear,2507," of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:2727,Usability,simpl,simple,2727,"fication based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In a",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:3544,Usability,learn,learning,3544,"ver a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:4273,Usability,learn,learning,4273,". A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:4359,Usability,learn,learning,4359,"; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum alo",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:4791,Usability,learn,learning,4791,"ights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matr",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:6305,Usability,simpl,simple,6305,"e line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCu",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:7355,Usability,learn,learning,7355,"euron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8054,Usability,simpl,simple,8054,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayer",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8648,Usability,learn,learning,8648," with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTO",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:8856,Usability,learn,learning,8856," with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTO",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:19934,Usability,simpl,simple,19934,"steepest descent - Default=50; TStringfStructureString containing the network structure; TObjArrayfSynapsesCollection of all the synapses in the network; Double_tfTau! Tau - used in line search - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:20860,Usability,simpl,simple,20860,"g, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:21791,Usability,simpl,simple,21791,"TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, con",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:22792,Usability,simpl,simple,22792,"oid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:24340,Usability,learn,learning,24340,"ormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constru",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:24522,Usability,learn,learning,24522,"uited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at ",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:24685,Usability,learn,learning,24685," char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry in",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:24856,Usability,learn,learning,24856,"aSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; -",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25025,Usability,learn,learning,25025,"raining dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25195,Usability,learn,learning,25195,"t.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25346,Usability,learn,learning,25346,"n::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the outpu",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25558,Usability,learn,learning,25558,"arameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:25813,Usability,simpl,simple,25813,"d SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMultiLayerPerceptron.html:27607,Usability,simpl,simple,27607,") const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps th",MatchSource.WIKI,root/html604/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiLayerPerceptron.html
https://root.cern/root/html604/TMutex.html:1475,Availability,error,error,1475," virtual~TMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tTVirtualMutex::Acquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t recursive = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*T",MatchSource.WIKI,root/html604/TMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutex.html
https://root.cern/root/html604/TMutex.html:1559,Availability,error,error,1559," Int_tTVirtualMutex::Acquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t recursive = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject:",MatchSource.WIKI,root/html604/TMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutex.html
https://root.cern/root/html604/TMutex.html:6249,Availability,error,error,6249,"c TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TMutexImp*fMutexImppointer to mutex implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMutex(Bool_t recursive = kFALSE); Create a mutex lock. The actual mutex implementation will be; provided via the TThreadFactory. Int_t Lock(); Lock the mutex. Returns 0 when no error, EDEADLK when mutex was already; locked by this thread and this mutex is not reentrant. Int_t TryLock(); Try to lock mutex. Returns 0 when no error, EDEADLK when mutex was; already locked by this thread and this mutex is not reentrant. Int_t UnLock(); Unlock the mutex. Returns 0 when no error, EPERM when mutex was already; unlocked by this thread. Int_t CleanUp(); Clean up of mutex. TVirtualMutex * Factory(Bool_t recursive = kFALSE); Create mutex and return pointer to it. Calling function must care; about proper deletion. The function is intended to be used in connection; with the R__LOCKGUARD2 macro for local thread protection. Since ""new"" is; used the TStorage class has to be protected by gGlobalMutex. TMutex(const TMutex& ). TMutex& operator=(const TMutex& ). virtual ~TMutex(); { delete fMutexImp; }. » Author: Fons Rademakers 26/06/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For com",MatchSource.WIKI,root/html604/TMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutex.html
https://root.cern/root/html604/TMutex.html:6397,Availability,error,error,6397,"::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TMutexImp*fMutexImppointer to mutex implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMutex(Bool_t recursive = kFALSE); Create a mutex lock. The actual mutex implementation will be; provided via the TThreadFactory. Int_t Lock(); Lock the mutex. Returns 0 when no error, EDEADLK when mutex was already; locked by this thread and this mutex is not reentrant. Int_t TryLock(); Try to lock mutex. Returns 0 when no error, EDEADLK when mutex was; already locked by this thread and this mutex is not reentrant. Int_t UnLock(); Unlock the mutex. Returns 0 when no error, EPERM when mutex was already; unlocked by this thread. Int_t CleanUp(); Clean up of mutex. TVirtualMutex * Factory(Bool_t recursive = kFALSE); Create mutex and return pointer to it. Calling function must care; about proper deletion. The function is intended to be used in connection; with the R__LOCKGUARD2 macro for local thread protection. Since ""new"" is; used the TStorage class has to be protected by gGlobalMutex. TMutex(const TMutex& ). TMutex& operator=(const TMutex& ). virtual ~TMutex(); { delete fMutexImp; }. » Author: Fons Rademakers 26/06/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutex.html
https://root.cern/root/html604/TMutex.html:6543,Availability,error,error,6543,"::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TMutexImp*fMutexImppointer to mutex implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMutex(Bool_t recursive = kFALSE); Create a mutex lock. The actual mutex implementation will be; provided via the TThreadFactory. Int_t Lock(); Lock the mutex. Returns 0 when no error, EDEADLK when mutex was already; locked by this thread and this mutex is not reentrant. Int_t TryLock(); Try to lock mutex. Returns 0 when no error, EDEADLK when mutex was; already locked by this thread and this mutex is not reentrant. Int_t UnLock(); Unlock the mutex. Returns 0 when no error, EPERM when mutex was already; unlocked by this thread. Int_t CleanUp(); Clean up of mutex. TVirtualMutex * Factory(Bool_t recursive = kFALSE); Create mutex and return pointer to it. Calling function must care; about proper deletion. The function is intended to be used in connection; with the R__LOCKGUARD2 macro for local thread protection. Since ""new"" is; used the TStorage class has to be protected by gGlobalMutex. TMutex(const TMutex& ). TMutex& operator=(const TMutex& ). virtual ~TMutex(); { delete fMutexImp; }. » Author: Fons Rademakers 26/06/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutex.html
https://root.cern/root/html604/TMutexImp.html:543,Availability,avail,available,543,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html604/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutexImp.html
https://root.cern/root/html604/TMutexImp.html:1510,Availability,error,error,1510," virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html604/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutexImp.html
https://root.cern/root/html604/TMutexImp.html:1594,Availability,error,error,1594," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutexImp.html
https://root.cern/root/html604/TMutexImp.html:333,Integrability,interface,interface,333,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html604/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutexImp.html
https://root.cern/root/html604/TMutexImp.html:353,Integrability,depend,dependent,353,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html604/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMutexImp.html
https://root.cern/root/html604/TMVA__BDTEventWrapper.html:1632,Modifiability,variab,variable,1632,"BDTEventWrapperBDTEventWrapper(const TMVA::BDTEventWrapper&); Double_tGetCumulativeWeight(Bool_t type) const; Double_tGetVal() const; const TMVA::Event*operator*() const; Bool_toperator<(const TMVA::BDTEventWrapper& other) const; TMVA::BDTEventWrapper&operator=(const TMVA::BDTEventWrapper&); voidSetCumulativeWeight(Bool_t type, Double_t weight); static voidSetVarIndex(Int_t iVar). private:. static Int_t&GetVarIndex(). Data Members; private:. Double_tfBkgWeightcumulative background weight for splitting; const TMVA::Event*fEventpointer to the event; Double_tfSigWeightsame for the signal weights. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BDTEventWrapper(const Event* e); constuctor. ~BDTEventWrapper(); destructor. void SetCumulativeWeight(Bool_t type, Double_t weight); Set the accumulated weight, for sorted signal/background events. * @param fType - true for signal, false for background; * @param weight - the total weight. Double_t GetCumulativeWeight(Bool_t type) const; Get the accumulated weight. Bool_t operator<(const TMVA::BDTEventWrapper& other) const. BDTEventWrapper( const Event* ). void SetVarIndex(Int_t iVar); Set the index of the variable to compare on. * @param iVar - index of the variable in fEvent to use. { if (iVar >= 0) GetVarIndex() = iVar; }. Double_t GetVal() const; Return the value of variable fVarIndex for this event. * @return value of variable fVarIndex for this event. { return fEvent->GetValue(GetVarIndex()); }. const Event* operator*() const; { return fEvent; }. Int_t& GetVarIndex(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(Int_t) fVarIndex(0); return fVarIndex;}. » Last changed: Tue Sep 8 17:45:48 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BDTEventWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BDTEventWrapper.html
https://root.cern/root/html604/TMVA__BDTEventWrapper.html:1685,Modifiability,variab,variable,1685,"BDTEventWrapperBDTEventWrapper(const TMVA::BDTEventWrapper&); Double_tGetCumulativeWeight(Bool_t type) const; Double_tGetVal() const; const TMVA::Event*operator*() const; Bool_toperator<(const TMVA::BDTEventWrapper& other) const; TMVA::BDTEventWrapper&operator=(const TMVA::BDTEventWrapper&); voidSetCumulativeWeight(Bool_t type, Double_t weight); static voidSetVarIndex(Int_t iVar). private:. static Int_t&GetVarIndex(). Data Members; private:. Double_tfBkgWeightcumulative background weight for splitting; const TMVA::Event*fEventpointer to the event; Double_tfSigWeightsame for the signal weights. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BDTEventWrapper(const Event* e); constuctor. ~BDTEventWrapper(); destructor. void SetCumulativeWeight(Bool_t type, Double_t weight); Set the accumulated weight, for sorted signal/background events. * @param fType - true for signal, false for background; * @param weight - the total weight. Double_t GetCumulativeWeight(Bool_t type) const; Get the accumulated weight. Bool_t operator<(const TMVA::BDTEventWrapper& other) const. BDTEventWrapper( const Event* ). void SetVarIndex(Int_t iVar); Set the index of the variable to compare on. * @param iVar - index of the variable in fEvent to use. { if (iVar >= 0) GetVarIndex() = iVar; }. Double_t GetVal() const; Return the value of variable fVarIndex for this event. * @return value of variable fVarIndex for this event. { return fEvent->GetValue(GetVarIndex()); }. const Event* operator*() const; { return fEvent; }. Int_t& GetVarIndex(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(Int_t) fVarIndex(0); return fVarIndex;}. » Last changed: Tue Sep 8 17:45:48 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BDTEventWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BDTEventWrapper.html
https://root.cern/root/html604/TMVA__BDTEventWrapper.html:1799,Modifiability,variab,variable,1799,"BDTEventWrapperBDTEventWrapper(const TMVA::BDTEventWrapper&); Double_tGetCumulativeWeight(Bool_t type) const; Double_tGetVal() const; const TMVA::Event*operator*() const; Bool_toperator<(const TMVA::BDTEventWrapper& other) const; TMVA::BDTEventWrapper&operator=(const TMVA::BDTEventWrapper&); voidSetCumulativeWeight(Bool_t type, Double_t weight); static voidSetVarIndex(Int_t iVar). private:. static Int_t&GetVarIndex(). Data Members; private:. Double_tfBkgWeightcumulative background weight for splitting; const TMVA::Event*fEventpointer to the event; Double_tfSigWeightsame for the signal weights. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BDTEventWrapper(const Event* e); constuctor. ~BDTEventWrapper(); destructor. void SetCumulativeWeight(Bool_t type, Double_t weight); Set the accumulated weight, for sorted signal/background events. * @param fType - true for signal, false for background; * @param weight - the total weight. Double_t GetCumulativeWeight(Bool_t type) const; Get the accumulated weight. Bool_t operator<(const TMVA::BDTEventWrapper& other) const. BDTEventWrapper( const Event* ). void SetVarIndex(Int_t iVar); Set the index of the variable to compare on. * @param iVar - index of the variable in fEvent to use. { if (iVar >= 0) GetVarIndex() = iVar; }. Double_t GetVal() const; Return the value of variable fVarIndex for this event. * @return value of variable fVarIndex for this event. { return fEvent->GetValue(GetVarIndex()); }. const Event* operator*() const; { return fEvent; }. Int_t& GetVarIndex(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(Int_t) fVarIndex(0); return fVarIndex;}. » Last changed: Tue Sep 8 17:45:48 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BDTEventWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BDTEventWrapper.html
https://root.cern/root/html604/TMVA__BDTEventWrapper.html:1853,Modifiability,variab,variable,1853,"BDTEventWrapperBDTEventWrapper(const TMVA::BDTEventWrapper&); Double_tGetCumulativeWeight(Bool_t type) const; Double_tGetVal() const; const TMVA::Event*operator*() const; Bool_toperator<(const TMVA::BDTEventWrapper& other) const; TMVA::BDTEventWrapper&operator=(const TMVA::BDTEventWrapper&); voidSetCumulativeWeight(Bool_t type, Double_t weight); static voidSetVarIndex(Int_t iVar). private:. static Int_t&GetVarIndex(). Data Members; private:. Double_tfBkgWeightcumulative background weight for splitting; const TMVA::Event*fEventpointer to the event; Double_tfSigWeightsame for the signal weights. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BDTEventWrapper(const Event* e); constuctor. ~BDTEventWrapper(); destructor. void SetCumulativeWeight(Bool_t type, Double_t weight); Set the accumulated weight, for sorted signal/background events. * @param fType - true for signal, false for background; * @param weight - the total weight. Double_t GetCumulativeWeight(Bool_t type) const; Get the accumulated weight. Bool_t operator<(const TMVA::BDTEventWrapper& other) const. BDTEventWrapper( const Event* ). void SetVarIndex(Int_t iVar); Set the index of the variable to compare on. * @param iVar - index of the variable in fEvent to use. { if (iVar >= 0) GetVarIndex() = iVar; }. Double_t GetVal() const; Return the value of variable fVarIndex for this event. * @return value of variable fVarIndex for this event. { return fEvent->GetValue(GetVarIndex()); }. const Event* operator*() const; { return fEvent; }. Int_t& GetVarIndex(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(Int_t) fVarIndex(0); return fVarIndex;}. » Last changed: Tue Sep 8 17:45:48 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BDTEventWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BDTEventWrapper.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:3807,Modifiability,variab,variable,3807,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:3927,Modifiability,variab,variable,3927,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:4001,Modifiability,variab,variable,4001,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:4072,Modifiability,variab,variable,4072,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:4266,Modifiability,variab,variables,4266,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:4339,Modifiability,variab,variable,4339,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:4517,Modifiability,variab,variable,4517,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:4678,Modifiability,variab,variable,4678,"vector<pair<double,const TMVA::Event*> >::iterator, vector<pair<double,const TMVA::Event*> >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:5934,Modifiability,variab,variables,5934,"(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert a new ""event"" in the binary tree. void Insert(const TMVA::Event* , TMVA::Node* ); private internal function to insert a event (node) at the proper position. TMVA::BinarySearchTreeNode* Search(TMVA::Event* event) const; search the tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*> >::iterator , vector<pair<double,const TMVA::Event*> >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:6104,Modifiability,variab,variables,6104,"L(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Event* ); insert a new ""event"" in the binary tree. void Insert(const TMVA::Event* , TMVA::Node* ); private internal function to insert a event (node) at the proper position. TMVA::BinarySearchTreeNode* Search(TMVA::Event* event) const; search the tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*> >::iterator , vector<pair<double,const TMVA::Event*> >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::B",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:6979,Modifiability,variab,variable,6979,"les specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*> >::iterator , vector<pair<double,const TMVA::Event*> >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][va",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7515,Modifiability,variab,variables,7515,"d up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Ste",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7598,Modifiability,variab,variables,7598,"(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7732,Modifiability,variab,variable,7732,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7890,Modifiability,variab,variable,7890,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:8050,Modifiability,variab,variable,8050,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:8210,Modifiability,variab,variable,8210,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:8315,Modifiability,variab,variable,8315,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7682,Security,access,access,7682,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7841,Security,access,access,7841,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:7997,Security,access,access,7997,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:8157,Security,access,access,8157,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:8292,Security,access,access,8292,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:6843,Testability,test,test,6843,"_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*> >::iterator , vector<pair<double,const TMVA::Event*> >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:356,Usability,simpl,simple,356,". TMVA::BinarySearchTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::BinarySearchTree. class TMVA::BinarySearchTree: public TMVA::BinaryTree. BinarySearchTree. A simple Binary search tree including a volume search method. Function Members (Methods); public:. virtual~BinarySearchTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; TMVA::BinarySearchTreeBinarySearchTree(); TMVA::BinarySearchTreeBinarySearchTree(const TMVA::BinarySearchTree& b); TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(); TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(const TMVA::BinaryTree&); voidCalcStatistics(TMVA::Node* n = 0); static TClass*Class(); virtual const char*ClassName() const; voidClear(TMVA::Node* n = 0); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = __null); static TMVA::BinarySearchTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); virtual TMVA::Node*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; Double_tFill(const vector<TMVA::Event*>& events, Int_t theType = -1); Double_tFill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); TMVA::Node*TMVA::BinaryTree::GetLeftDaughter(TMVA::Node* n); UInt_tTMVA::BinaryTree::GetNNodes() const; UInt_tGetPeriode() const; TMVA::Node*TMVA::BinaryTree::GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*TMVA::BinaryTree::GetRoot() const; Double_tGetSumOfWeights() const; Double_tGetSumOfWeights(Int_t theType) const; UInt_tTMVA::BinaryTree::GetTotalTreeDepth() const; voidInsert(const TMVA::Event*); virtual TClass*IsA() const; Float_tMax(TMVA::Types::ESBType sb, UInt_t var); Float_tMean(TMVA::Types::ESBType sb, UInt_t var); Float_tMin(TMVA::Types::ESBType sb, UInt_t var); voidNormalizeTree(); TMVA::BinarySearchTree&operator=(const TMVA::BinarySearchTree&); virtual voidT",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTree.html:6358,Usability,clear,clear,6358," proper position. TMVA::BinarySearchTreeNode* Search(TMVA::Event* event) const; search the tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*> >::iterator , vector<pair<double,const TMVA::Event*> >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* Creat",MatchSource.WIKI,root/html604/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html
https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html:578,Modifiability,variab,variable,578,". TMVA::BinarySearchTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::BinarySearchTreeNode. class TMVA::BinarySearchTreeNode: public TMVA::Node. Node for the BinarySearch or Decision Trees. for the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. in case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node, including; the respective cut value. Function Members (Methods); public:. virtual~BinarySearchTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*TMVA::Node::AddXMLTo(void* parent) const; TMVA::BinarySearchTreeNodeBinarySearchTreeNode(const TMVA::Event* e = __null, UInt_t signalClass = 0); TMVA::BinarySearchTreeNodeBinarySearchTreeNode(TMVA::BinarySearchTreeNode* parent, char pos); TMVA::BinarySearchTreeNodeBinarySearchTreeNode(const TMVA::BinarySearchTreeNode& n, TMVA::BinarySearchTreeNode* parent = __null); static TClass*Class(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; virtual Bool_tEqualsMe(const TMVA::Event&) const; UInt_tGetClass() const; intTMVA::Node::GetCount(); UInt_tTMVA::Node::GetDepth() const; const vector<Float_t>&GetEventV() const; virtual TMVA::Node*TMVA::Node::GetLeft() const; virtual TMVA::Node*TMVA::Node::GetParent() const; virtual TMVA::BinaryTree*TMVA::Node::GetParentTree() const; charTMVA::Node::GetPos() const; virtual TMVA::Node*TMVA::Node::GetRight() const; Short_tGetSelector() const; const vector<Float_t>&GetTargets() const; Float_tGetWeight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeTMVA::Node::Node(); TMVA::N",MatchSource.WIKI,root/html604/TMVA__BinarySearchTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html
https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html:3515,Modifiability,variab,variable,3515,"e::SetPos(char s); virtual voidTMVA::Node::SetRight(TMVA::Node* r); voidSetSelector(Short_t i); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657). Data Members; protected:. UInt_tTMVA::Node::fDepthdepth of the node within the tree (seen from root node); TMVA::Node*TMVA::Node::fLeftpointers to the two ""daughter"" nodes; TMVA::Node*TMVA::Node::fParentthe previous (parent) node; TMVA::BinaryTree*TMVA::Node::fParentTreepointer to the parent tree to which the Node belongs; charTMVA::Node::fPosposition, i.e. it is a left (l) or right (r) daughter; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes. private:. UInt_tfClass; vector<Float_t>fEventV; Short_tfSelectorindex of variable used in node selection (decision tree); vector<Float_t>fTargets; Float_tfWeight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTreeNode(const TMVA::Event* e = __null, UInt_t signalClass = 0); constructor of a node for the search tree. BinarySearchTreeNode(TMVA::BinarySearchTreeNode* parent, char pos); constructor of a daughter node as a daughter of 'p'. BinarySearchTreeNode(const TMVA::BinarySearchTreeNode& n, TMVA::BinarySearchTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~BinarySearchTreeNode(); node destructor. Bool_t GoesRight(const TMVA::Event& ) const; check if the event fed into the node goes/decends to the right daughter. Bool_t GoesLeft(const TMVA::Event& ) const; check if the event fed into the node goes/decends to the left daughter. Bool_t EqualsMe(const TMVA::Event& ) const; check if the event fed into the node actually equals th",MatchSource.WIKI,root/html604/TMVA__BinarySearchTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html
https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html:5241,Modifiability,variab,variable,5241,"t = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~BinarySearchTreeNode(); node destructor. Bool_t GoesRight(const TMVA::Event& ) const; check if the event fed into the node goes/decends to the right daughter. Bool_t GoesLeft(const TMVA::Event& ) const; check if the event fed into the node goes/decends to the left daughter. Bool_t EqualsMe(const TMVA::Event& ) const; check if the event fed into the node actually equals the event; that forms the node (in case of a search tree). void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. void AddAttributesToNode(void* node) const; adding attributes to tree node. void AddContentToNode(stringstream& s) const; adding attributes to tree node. void ReadContent(stringstream& s); read events from node. Node* CreateNode() const; { return new BinarySearchTreeNode(); }. void SetSelector(Short_t i); set index of variable used for discrimination at this node. { fSelector = i; }. Short_t GetSelector() const; return index of variable used for discrimination at this node. { return fSelector; }. const std::vector<Float_t> & GetEventV() const; { return fEventV; }. Float_t GetWeight() const; { return fWeight; }. UInt_t GetClass() const; Bool_t IsSignal() const { return (fClass == fSignalClass); }. { return fClass; }. const std::vector<Float_t> & GetTargets() const; { return fTargets; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html
https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html:5353,Modifiability,variab,variable,5353,"t = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~BinarySearchTreeNode(); node destructor. Bool_t GoesRight(const TMVA::Event& ) const; check if the event fed into the node goes/decends to the right daughter. Bool_t GoesLeft(const TMVA::Event& ) const; check if the event fed into the node goes/decends to the left daughter. Bool_t EqualsMe(const TMVA::Event& ) const; check if the event fed into the node actually equals the event; that forms the node (in case of a search tree). void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. void AddAttributesToNode(void* node) const; adding attributes to tree node. void AddContentToNode(stringstream& s) const; adding attributes to tree node. void ReadContent(stringstream& s); read events from node. Node* CreateNode() const; { return new BinarySearchTreeNode(); }. void SetSelector(Short_t i); set index of variable used for discrimination at this node. { fSelector = i; }. Short_t GetSelector() const; return index of variable used for discrimination at this node. { return fSelector; }. const std::vector<Float_t> & GetEventV() const; { return fEventV; }. Float_t GetWeight() const; { return fWeight; }. UInt_t GetClass() const; Bool_t IsSignal() const { return (fClass == fSignalClass); }. { return fClass; }. const std::vector<Float_t> & GetTargets() const; { return fTargets; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__BinarySearchTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTreeNode.html
https://root.cern/root/html604/TMVA__BinaryTree.html:487,Availability,avail,available,487,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; TMVA::BinaryTreeBinaryTree(); TMVA::BinaryTreeBinaryTree(const TMVA::BinaryTree&); static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = __null); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = 262657); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = __null); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinaryTree(const TMVA::BinaryTree& ); constructor for a yet ""empty"" tree. Needs to be filled afterwards. ",MatchSource.WIKI,root/html604/TMVA__BinaryTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinaryTree.html
https://root.cern/root/html604/TMVA__BinaryTree.html:2820,Integrability,depend,depends,2820,"ed Members; Includes; Libraries. Function documentation; BinaryTree(const TMVA::BinaryTree& ); constructor for a yet ""empty"" tree. Needs to be filled afterwards. ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* ); protected, recursive, function used by the class destructor and when Pruning. TMVA::Node* GetLeftDaughter(TMVA::Node* n); get left daughter node current node ""n"". TMVA::Node* GetRightDaughter(TMVA::Node* n); get right daughter node current node ""n"". UInt_t CountNodes(TMVA::Node* n = __null); return the number of nodes in the tree. (make a new count --> takes time). void Print(ostream& os) const; recursively print the tree. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. void Read(istream& istr, UInt_t tmva_Version_Code = 262657); Read the binary tree from an input stream.; The input stream format depends on the tree type,; it is defined be the node of the tree. void SetTotalTreeDepth( Node *n); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::MsgLogger& Log() const. BinaryTree(const TMVA::BinaryTree& ); or a tree with Root node ""n"", any daughters of this node are automatically in the tree. Node* CreateNode(UInt_t size = 0) const. BinaryTree* CreateTree() const; virtual BinaryTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE) = 0;. const char* ClassName() const. void SetRoot(TMVA::Node* r); set the root node of the tree. { fRoot = r; }. Node* GetRoot() const; Retrieves the address of the root node. { return fRoot; }. UInt_t GetNNodes() const; get number of Nodes in the Tree as counted while booking the nodes;. { return fNNodes; }. UInt_t GetTotalTreeDepth() const; { return fDepth; }. void SetTotalTreeDepth(Int_t depth); { fDepth = depth; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toe",MatchSource.WIKI,root/html604/TMVA__BinaryTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__BinaryTree.html
https://root.cern/root/html604/TMVA__CCPruner.html:467,Security,validat,validationSample,467,". TMVA::CCPruner. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CCPruner. class TMVA::CCPruner. Function Members (Methods); public:. ~CCPruner(); TMVA::CCPrunerCCPruner(const TMVA::CCPruner&); TMVA::CCPrunerCCPruner(TMVA::DecisionTree* t_max, const TMVA::CCPruner::EventList* validationSample, TMVA::SeparationBase* qualityIndex = __null); TMVA::CCPrunerCCPruner(TMVA::DecisionTree* t_max, const TMVA::DataSet* validationSample, TMVA::SeparationBase* qualityIndex = __null); vector<TMVA::DecisionTreeNode*>GetOptimalPruneSequence() const; Float_tGetOptimalPruneStrength() const; Float_tGetOptimalQualityIndex() const; TMVA::CCPruner&operator=(const TMVA::CCPruner&); voidOptimize(); voidSetPruneStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const Dat",MatchSource.WIKI,root/html604/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCPruner.html
https://root.cern/root/html604/TMVA__CCPruner.html:602,Security,validat,validationSample,602,". TMVA::CCPruner. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CCPruner. class TMVA::CCPruner. Function Members (Methods); public:. ~CCPruner(); TMVA::CCPrunerCCPruner(const TMVA::CCPruner&); TMVA::CCPrunerCCPruner(TMVA::DecisionTree* t_max, const TMVA::CCPruner::EventList* validationSample, TMVA::SeparationBase* qualityIndex = __null); TMVA::CCPrunerCCPruner(TMVA::DecisionTree* t_max, const TMVA::DataSet* validationSample, TMVA::SeparationBase* qualityIndex = __null); vector<TMVA::DecisionTreeNode*>GetOptimalPruneSequence() const; Float_tGetOptimalPruneStrength() const; Float_tGetOptimalQualityIndex() const; TMVA::CCPruner&operator=(const TMVA::CCPruner&); voidOptimize(); voidSetPruneStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const Dat",MatchSource.WIKI,root/html604/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCPruner.html
https://root.cern/root/html604/TMVA__CCPruner.html:1898,Security,validat,validationSample,1898,"PruneStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Sep 8 17:45:49 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCPruner.html
https://root.cern/root/html604/TMVA__CCPruner.html:2007,Security,validat,validationSample,2007,"PruneStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Sep 8 17:45:49 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCPruner.html
https://root.cern/root/html604/TMVA__CCPruner.html:2360,Security,validat,validationSample,2360,"PruneStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Sep 8 17:45:49 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCPruner.html
https://root.cern/root/html604/TMVA__CCPruner.html:2491,Security,validat,validation,2491,"PruneStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Sep 8 17:45:49 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCPruner.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1164,Integrability,wrap,wrapped,1164," Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CCTreeWrapper. class TMVA::CCTreeWrapper. Function Members (Methods); public:. ~CCTreeWrapper(); TMVA::CCTreeWrapperCCTreeWrapper(const TMVA::CCTreeWrapper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::S",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:848,Security,validat,validationSample,848,". TMVA::CCTreeWrapper. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CCTreeWrapper. class TMVA::CCTreeWrapper. Function Members (Methods); public:. ~CCTreeWrapper(); TMVA::CCTreeWrapperCCTreeWrapper(const TMVA::CCTreeWrapper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision ",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:912,Security,validat,validationSample,912,". TMVA::CCTreeWrapper. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CCTreeWrapper. class TMVA::CCTreeWrapper. Function Members (Methods); public:. ~CCTreeWrapper(); TMVA::CCTreeWrapperCCTreeWrapper(const TMVA::CCTreeWrapper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision ",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1625,Security,validat,validationSample,1625,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Sep 8 17:45:50 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1702,Security,validat,validation,1702,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Sep 8 17:45:50 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1788,Security,validat,validationSample,1788,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Sep 8 17:45:50 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1865,Security,validat,validation,1865,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Sep 8 17:45:50 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html
https://root.cern/root/html604/TMVA__Config.html:1339,Testability,log,logger,1339,:Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. virtual~Config(); TMVA::ConfigConfig(); TMVA::ConfigConfig(const TMVA::Config&); TMVA::MsgLogger&Log() const; TMVA::Config&operator=(const TMVA::Config&). Data Members; public:. IONamesfIONamesCustomisable weight file properties; VariablePlottingfVariablePlottingCustomisable plotting properties. private:. atomic<Bool_t>fDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; atomic<Bool_t>fSilentno output at all; atomic<Bool_t>fUseColoredConsolecoloured standard output; atomic<Bool_t>fWriteOptionsReferenceif set true: Configurable objects write file with option reference; static atomic<TMVA::Config*>fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. ~Config(); destructor. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariable,MatchSource.WIKI,root/html604/TMVA__Config.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Config.html
https://root.cern/root/html604/TMVA__Config.html:1263,Usability,progress bar,progress bar,1263,:Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. virtual~Config(); TMVA::ConfigConfig(); TMVA::ConfigConfig(const TMVA::Config&); TMVA::MsgLogger&Log() const; TMVA::Config&operator=(const TMVA::Config&). Data Members; public:. IONamesfIONamesCustomisable weight file properties; VariablePlottingfVariablePlottingCustomisable plotting properties. private:. atomic<Bool_t>fDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; atomic<Bool_t>fSilentno output at all; atomic<Bool_t>fUseColoredConsolecoloured standard output; atomic<Bool_t>fWriteOptionsReferenceif set true: Configurable objects write file with option reference; static atomic<TMVA::Config*>fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. ~Config(); destructor. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariable,MatchSource.WIKI,root/html604/TMVA__Config.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Config.html
https://root.cern/root/html604/TMVA__Configurable.html:1541,Availability,error,error,1541,"ct::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableConfigurable(const TString& theOption = """"); TMVA::ConfigurableConfigurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetConfigDescription() const; const char*GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&GetOptions() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__Configurable.html:1625,Availability,error,error,1625,"CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableConfigurable(const TString& theOption = """"); TMVA::ConfigurableConfigurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetConfigDescription() const; const char*GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&GetOptions() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__Configurable.html:6739,Integrability,message,message,6739,"nst TString& theOpt, TList& loo) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__Configurable.html:8750,Integrability,message,message,8750,"litOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void AddOptionsXMLTo(void* parent) const; write options to XML file. void ReadOptionsFromXML(void* node). void WriteOptionsReferenceToFile(); write complete options to output stream. void ReadOptionsFromStream(istream& istr); read option back from the weight file. Configurable(const TString& theOption = """"); constructur. const char* GetName() const; { return GetConfigName(); }. const char* GetConfigName() const; { return fConfigName; }. const char* GetConfigDescription() const; { return fConfigDescription; }. void SetConfigName(const char* n); { fConfigName = TString(n); }. void SetConfigDescription(const char* d); { fConfigDescription = TString(d); }. const TString& GetOptions() const; { return fOptions; }. void SetOptions(const TString& s); { fOptions = s; }. Bool_t LooseOptionCheckingEnabled() const; { return fLooseOptionCheckingEnabled; }. void EnableLooseOptions(Bool_t b = kTRUE); { fLooseOptionCheckingEnabled = b; }. const TString& GetReferenceFile() const; { return fReferenceFile; }. void SetMsgType(TMVA::EMsgType t); set message type. { fLogger->SetMinType(t); }. Log(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__Configurable.html:6557,Modifiability,config,configurable,6557,"nst TString& theOpt, TList& loo) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__Configurable.html:6606,Modifiability,config,configurable,6606,"nst TString& theOpt, TList& loo) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__Configurable.html:6747,Testability,log,logger,6747,"nst TString& theOpt, TList& loo) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html604/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Configurable.html
https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:2502,Availability,down,down,2502,"e* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Tue Sep 8 17:45:53 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html
https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:2830,Availability,error,error,2830,"e* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Tue Sep 8 17:45:53 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html
https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:537,Testability,test,testEvents,537,". TMVA::CostComplexityPruneTool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CostComplexityPruneTool. class TMVA::CostComplexityPruneTool: public TMVA::IPruneTool. Function Members (Methods); public:. virtual~CostComplexityPruneTool(); virtual TMVA::PruningInfo*CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE); TMVA::CostComplexityPruneToolCostComplexityPruneTool(TMVA::SeparationBase* qualityIndex = __null); TMVA::CostComplexityPruneToolCostComplexityPruneTool(const TMVA::CostComplexityPruneTool&); Double_tTMVA::IPruneTool::GetPruneStrength() const; TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(); TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(const TMVA::IPruneTool&); Bool_tTMVA::IPruneTool::IsAutomatic() const; TMVA::CostComplexityPruneTool&operator=(const TMVA::CostComplexityPruneTool&); voidTMVA::IPruneTool::SetAutomatic(); voidTMVA::IPruneTool::SetPruneStrength(Double_t alpha). private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries.",MatchSource.WIKI,root/html604/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html
https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:1502,Testability,log,logging,1502,"null, Bool_t isAutomatic = kFALSE); TMVA::CostComplexityPruneToolCostComplexityPruneTool(TMVA::SeparationBase* qualityIndex = __null); TMVA::CostComplexityPruneToolCostComplexityPruneTool(const TMVA::CostComplexityPruneTool&); Double_tTMVA::IPruneTool::GetPruneStrength() const; TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(); TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(const TMVA::IPruneTool&); Bool_tTMVA::IPruneTool::IsAutomatic() const; TMVA::CostComplexityPruneTool&operator=(const TMVA::CostComplexityPruneTool&); voidTMVA::IPruneTool::SetAutomatic(); voidTMVA::IPruneTool::SetPruneStrength(Double_t alpha). private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimiz",MatchSource.WIKI,root/html604/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html
https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:2288,Testability,test,testEvents,2288,"e* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Tue Sep 8 17:45:53 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html
https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html:2804,Testability,test,test,2804,"e* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Tue Sep 8 17:45:53 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CostComplexityPruneTool.html
https://root.cern/root/html604/TMVA__CrossEntropy.html:391,Testability,log,log,391,". TMVA::CrossEntropy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CrossEntropy. class TMVA::CrossEntropy: public TMVA::SeparationBase. Implementation of the CrossEntropy as separation criterion; -p log (p) - (1-p)log(1-p); p=purity. Function Members (Methods); public:. virtual~CrossEntropy(); static TClass*Class(); TMVA::CrossEntropyCrossEntropy(); TMVA::CrossEntropyCrossEntropy(const TMVA::CrossEntropy& g); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::CrossEntropy&operator=(const TMVA::CrossEntropy&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Cross Entropy defined as; -p log (p) - (1-p)log(1-p); p=purity = s/(s+b). CrossEntropy(); default constructor. { fName = ""CE""; }. CrossEntropy(const TMVA::CrossEntropy& g); copy constructor. {}. virtual ~CrossEntropy(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically gener",MatchSource.WIKI,root/html604/TMVA__CrossEntropy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CrossEntropy.html
https://root.cern/root/html604/TMVA__CrossEntropy.html:406,Testability,log,log,406,". TMVA::CrossEntropy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CrossEntropy. class TMVA::CrossEntropy: public TMVA::SeparationBase. Implementation of the CrossEntropy as separation criterion; -p log (p) - (1-p)log(1-p); p=purity. Function Members (Methods); public:. virtual~CrossEntropy(); static TClass*Class(); TMVA::CrossEntropyCrossEntropy(); TMVA::CrossEntropyCrossEntropy(const TMVA::CrossEntropy& g); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::CrossEntropy&operator=(const TMVA::CrossEntropy&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Cross Entropy defined as; -p log (p) - (1-p)log(1-p); p=purity = s/(s+b). CrossEntropy(); default constructor. { fName = ""CE""; }. CrossEntropy(const TMVA::CrossEntropy& g); copy constructor. {}. virtual ~CrossEntropy(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically gener",MatchSource.WIKI,root/html604/TMVA__CrossEntropy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CrossEntropy.html
https://root.cern/root/html604/TMVA__CrossEntropy.html:1601,Testability,log,log,1601,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CrossEntropy. class TMVA::CrossEntropy: public TMVA::SeparationBase. Implementation of the CrossEntropy as separation criterion; -p log (p) - (1-p)log(1-p); p=purity. Function Members (Methods); public:. virtual~CrossEntropy(); static TClass*Class(); TMVA::CrossEntropyCrossEntropy(); TMVA::CrossEntropyCrossEntropy(const TMVA::CrossEntropy& g); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::CrossEntropy&operator=(const TMVA::CrossEntropy&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Cross Entropy defined as; -p log (p) - (1-p)log(1-p); p=purity = s/(s+b). CrossEntropy(); default constructor. { fName = ""CE""; }. CrossEntropy(const TMVA::CrossEntropy& g); copy constructor. {}. virtual ~CrossEntropy(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CrossEntropy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CrossEntropy.html
https://root.cern/root/html604/TMVA__CrossEntropy.html:1616,Testability,log,log,1616,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CrossEntropy. class TMVA::CrossEntropy: public TMVA::SeparationBase. Implementation of the CrossEntropy as separation criterion; -p log (p) - (1-p)log(1-p); p=purity. Function Members (Methods); public:. virtual~CrossEntropy(); static TClass*Class(); TMVA::CrossEntropyCrossEntropy(); TMVA::CrossEntropyCrossEntropy(const TMVA::CrossEntropy& g); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::CrossEntropy&operator=(const TMVA::CrossEntropy&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Cross Entropy defined as; -p log (p) - (1-p)log(1-p); p=purity = s/(s+b). CrossEntropy(); default constructor. { fName = ""CE""; }. CrossEntropy(const TMVA::CrossEntropy& g); copy constructor. {}. virtual ~CrossEntropy(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__CrossEntropy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__CrossEntropy.html
https://root.cern/root/html604/TMVA__DecisionTree.html:12173,Availability,down,down,12173,"f internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:7235,Energy Efficiency,monitor,monitor,7235,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:534,Modifiability,variab,variable,534,". TMVA::DecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::DecisionTree. class TMVA::DecisionTree: public TMVA::BinaryTree. Implementation of a Decision Tree. In a decision tree successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:1070,Modifiability,variab,variable,1070,"e:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::DecisionTree. class TMVA::DecisionTree: public TMVA::BinaryTree. Implementation of a Decision Tree. In a decision tree successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(); TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(const TMVA::BinaryTree&); UInt_tBuildTree(con",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:3933,Modifiability,variab,variableMap,3933,,MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:6789,Modifiability,variab,variables,6789,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:7138,Modifiability,variab,variable,7138,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:7356,Modifiability,variab,variables,7356,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:7615,Modifiability,variab,variables,7615,"axDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:7960,Modifiability,variab,variables,7960,"t_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNva",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:8161,Modifiability,variab,variables,8161,"t_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNva",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:8454,Modifiability,variab,variables,8454,"ble_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); constructor specifying the separation type, the min number of; events in a no that is still subjected to further splitting, the; number of bins in the grid used in applying the cut for the node; splitting. DecisionTree(const TMVA::DecisionTree",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11286,Modifiability,variab,variable,11286,"llTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11484,Modifiability,variab,variables,11484,"Node* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning vali",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11850,Modifiability,variab,variable,11850,"nly a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows tes",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:13281,Modifiability,variab,variableMap,13281,"training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get ",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:13463,Modifiability,variab,variables,13463,"lidation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYes",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:13558,Modifiability,variab,variable,13558,"ind all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the gi",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:13722,Modifiability,variab,variables,13722,"a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calcula",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:13810,Modifiability,variab,variables,13810,"a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calcula",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:14071,Modifiability,variab,variables,14071,"sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calculates the purity S/(S+B) of a given event sample. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. Th",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:14889,Modifiability,variab,variable,14889,"fficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calculates the purity S/(S+B) of a given event sample. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); returns the relative improtance of variable ivar. DecisionTreeNode* GetRoot() const; Retrieves the address of the root node. { return dynamic_cast<TMVA::DecisionTreeNode*>(fRoot); }. DecisionTreeNode * CreateNode(UInt_t ) const; { return new DecisionTreeNode(); }. BinaryTree* CreateTree() const; { return new DecisionTree(); }. const char* ClassName() const; { return ""DecisionTree""; }. Double_t TrainNode(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); determine the way how a node is split (which variable, which cut value). { return TrainNodeFast( eventSample, node ); }. void SetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); { fPruneMethod = m; }. void SetPruneStrength",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:14929,Modifiability,variab,variables,14929,"fficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calculates the purity S/(S+B) of a given event sample. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); returns the relative improtance of variable ivar. DecisionTreeNode* GetRoot() const; Retrieves the address of the root node. { return dynamic_cast<TMVA::DecisionTreeNode*>(fRoot); }. DecisionTreeNode * CreateNode(UInt_t ) const; { return new DecisionTreeNode(); }. BinaryTree* CreateTree() const; { return new DecisionTree(); }. const char* ClassName() const; { return ""DecisionTree""; }. Double_t TrainNode(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); determine the way how a node is split (which variable, which cut value). { return TrainNodeFast( eventSample, node ); }. void SetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); { fPruneMethod = m; }. void SetPruneStrength",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:15041,Modifiability,variab,variable,15041,"for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calculates the purity S/(S+B) of a given event sample. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); returns the relative improtance of variable ivar. DecisionTreeNode* GetRoot() const; Retrieves the address of the root node. { return dynamic_cast<TMVA::DecisionTreeNode*>(fRoot); }. DecisionTreeNode * CreateNode(UInt_t ) const; { return new DecisionTreeNode(); }. BinaryTree* CreateTree() const; { return new DecisionTree(); }. const char* ClassName() const; { return ""DecisionTree""; }. Double_t TrainNode(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); determine the way how a node is split (which variable, which cut value). { return TrainNodeFast( eventSample, node ); }. void SetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); { fPruneMethod = m; }. void SetPruneStrength(Double_t p); manage the pruning strength parameter (iff < 0 -> automate the pruning process). { fPruneStrength = p; }. Double_t GetPruneStrengt",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:15193,Modifiability,variab,variable,15193,"mple, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events ends up. I.e. the result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calculates the purity S/(S+B) of a given event sample. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); returns the relative improtance of variable ivar. DecisionTreeNode* GetRoot() const; Retrieves the address of the root node. { return dynamic_cast<TMVA::DecisionTreeNode*>(fRoot); }. DecisionTreeNode * CreateNode(UInt_t ) const; { return new DecisionTreeNode(); }. BinaryTree* CreateTree() const; { return new DecisionTree(); }. const char* ClassName() const; { return ""DecisionTree""; }. Double_t TrainNode(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); determine the way how a node is split (which variable, which cut value). { return TrainNodeFast( eventSample, node ); }. void SetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); { fPruneMethod = m; }. void SetPruneStrength(Double_t p); manage the pruning strength parameter (iff < 0 -> automate the pruning process). { fPruneStrength = p; }. Double_t GetPruneStrength() const; { return fPruneStrength; }. void SetNodePurityLimit(Double_t p); { fNodePurityLimit = p; }. Double_t GetNod",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:15696,Modifiability,variab,variable,15696,"he result of the classification if; the event for this decision tree. Double_t SamplePurity(TMVA::DecisionTree::EventList eventSample); calculates the purity S/(S+B) of a given event sample. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); returns the relative improtance of variable ivar. DecisionTreeNode* GetRoot() const; Retrieves the address of the root node. { return dynamic_cast<TMVA::DecisionTreeNode*>(fRoot); }. DecisionTreeNode * CreateNode(UInt_t ) const; { return new DecisionTreeNode(); }. BinaryTree* CreateTree() const; { return new DecisionTree(); }. const char* ClassName() const; { return ""DecisionTree""; }. Double_t TrainNode(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); determine the way how a node is split (which variable, which cut value). { return TrainNodeFast( eventSample, node ); }. void SetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); { fPruneMethod = m; }. void SetPruneStrength(Double_t p); manage the pruning strength parameter (iff < 0 -> automate the pruning process). { fPruneStrength = p; }. Double_t GetPruneStrength() const; { return fPruneStrength; }. void SetNodePurityLimit(Double_t p); { fNodePurityLimit = p; }. Double_t GetNodePurityLimit() const; { return fNodePurityLimit; }. Int_t GetNNodesBeforePruning(); {return (fNNodesBeforePruning)?fNNodesBeforePruning:fNNodesBeforePruning=GetNNodes();}. void SetTreeID(Int_t treeID); {fTreeID = treeID;}. Int_t GetTreeID(); {return fTreeID;}. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. void SetAnalysisType(TMVA::Types::EAnalysisType t); { fAnalysisType = t;}. Types::EAnalysisType GetAnalysisType( void ); { return fAnal",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:6968,Performance,perform,perform,6968,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:13632,Performance,perform,performed,13632,"ind all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventConstList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event* , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the gi",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11196,Safety,avoid,avoid,11196,"llTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:1932,Security,validat,validationSample,1932,"ode. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(); TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(const TMVA::BinaryTree&); UInt_tBuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); Double_tCheckEvent(const TMVA::Event*, Bool_t UseYesNoLeaf = kFALSE) const; voidCheckEventWithPrunedTree(const TMVA::Event*) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCleanTree(TMVA::DecisionTreeNode* node = __null); voidClearTree(); UInt_tCountLeafNodes(TMVA::Node* n = __null); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = __null); static TMVA::DecisionTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); virtual TMVA::DecisionTreeNode*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::DecisionTreeDecisionTree(); TMVA::DecisionTreeDecisionTree(const TMVA::DecisionTree& d); TMVA::DecisionTreeDecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); voidDescendTree(TMVA::Node* n = __null); Bool_tDoRegression() const; voidFillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); voidFillTree(const TMVA::DecisionTree::EventList& eventSample); TMVA::Types::EAnalysisTypeGetAnalysisType(); TMVA::DecisionTreeNode*GetEventNode(const TMV",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:4136,Security,validat,validationSample,4136,,MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:4613,Security,validat,validationSample,4613,"MVA::Node*TMVA::BinaryTree::GetLeftDaughter(TMVA::Node* n); UInt_tTMVA::BinaryTree::GetNNodes() const; Int_tGetNNodesBeforePruning(); TMVA::Node*GetNode(ULong_t sequence, UInt_t depth); Double_tGetNodePurityLimit() const; Double_tGetPruneStrength() const; voidGetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars); TMVA::Node*TMVA::BinaryTree::GetRightDaughter(TMVA::Node* n); virtual TMVA::DecisionTreeNode*GetRoot() const; Double_tGetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; UInt_tTMVA::BinaryTree::GetTotalTreeDepth() const; Int_tGetTreeID(); vector<Double_t>GetVariableImportance(); Double_tGetVariableImportance(UInt_t ivar); virtual TClass*IsA() const; TMVA::DecisionTree&operator=(const TMVA::DecisionTree&); virtual voidTMVA::BinaryTree::Print(ostream& os) const; voidPruneNode(TMVA::DecisionTreeNode* node); voidPruneNodeInPlace(TMVA::DecisionTreeNode* node); Double_tPruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); virtual voidTMVA::BinaryTree::Read(istream& istr, UInt_t tmva_Version_Code = 262657); virtual voidTMVA::BinaryTree::ReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetAnalysisType(TMVA::Types::EAnalysisType t); voidSetMinLinCorrForFisher(Double_t min); voidSetNodePurityLimit(Double_t p); voidSetNVars(Int_t n); voidSetParentTreeInNodes(TMVA::Node* n = __null); voidSetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); voidSetPruneStrength(Double_t p); voidTMVA::BinaryTree::SetRoot(TMVA::Node* r); voidTMVA::BinaryTree::SetTotalTreeDepth(Int_t depth); voidTMVA::BinaryTree::SetTotalTreeDepth(TMVA::Node* n = __null); voidSetTreeID(Int_t treeID); voidSetUseExclusiveVars(Bool_t t = kTRUE); voidSetUseFisherCuts(Bool_t t = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Double_tTestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __n",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11113,Security,validat,validationSample,11113,"llTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11380,Security,validat,validationSample,11380,"Node* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning vali",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11413,Security,validat,validation,11413,"Node* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning vali",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11586,Security,validat,validation,11586,"e(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMV",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:12112,Security,validat,validation,12112,"f internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:12341,Security,validat,validationSample,12341,"sionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionT",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:12415,Security,validat,validation,12415,"sionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionT",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11925,Testability,test,testing,11925,"nly a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows tes",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:11956,Testability,test,test,11956,"nly a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows tes",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:12850,Testability,test,testing,12850,"e"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:8358,Usability,simpl,simple,8358,"l; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); constructor specifying the separation type, the min number of; events in a no that is still subjected to furthe",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTree.html:10572,Usability,clear,clear,10572,"isionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = __null); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample.",MatchSource.WIKI,root/html604/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:381,Modifiability,variab,variable,381,". TMVA::DecisionTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::DecisionTreeNode. class TMVA::DecisionTreeNode: public TMVA::Node. Node for the Decision Tree. The node specifies ONE variable out of the given set of selection variable; that is used to split the sample which ""arrives"" at the node, into a left; (background-enhanced) and a right (signal-enhanced) sample. Function Members (Methods); public:. virtual~DecisionTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; voidAddToSumTarget(Float_t t); voidAddToSumTarget2(Float_t t2); void*TMVA::Node::AddXMLTo(void* parent) const; static TClass*Class(); voidClearNodeAndAllDaughters(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; TMVA::DecisionTreeNodeDecisionTreeNode(); TMVA::DecisionTreeNodeDecisionTreeNode(TMVA::Node* p, char pos); TMVA::DecisionTreeNodeDecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); Double_tGetAlpha() const; Double_tGetAlphaMinSubtree() const; Double_tGetCC() const; intTMVA::Node::GetCount(); Bool_tGetCutType() const; Float_tGetCutValue() const; UInt_tTMVA::Node::GetDepth() const; Double_tGetFisherCoeff(Int_t ivar) const; virtual TMVA::DecisionTreeNode*GetLeft() const; Float_tGetNBkgEvents() const; Float_tGetNBkgEvents_unboosted() const; Float_tGetNBkgEvents_unweighted() const; Double_tGetNBValidation() const; Float_tGetNEvents() const; Float_tGetNEvents_unboosted() const; Float_tGetNEvents_unweighted() const; UInt_tGetNFisherCoeff() const; Double_tGetNodeR() const; Int_tGetNodeType() const; Float_tGetNSigEvents() const; Float_tGetNSigEvents_unboosted() const; Float_tGetNSigEvents_unweighted() const; Double_tGetNSValidation() const; Int_tGetNTerminal() con",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:424,Modifiability,variab,variable,424,". TMVA::DecisionTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::DecisionTreeNode. class TMVA::DecisionTreeNode: public TMVA::Node. Node for the Decision Tree. The node specifies ONE variable out of the given set of selection variable; that is used to split the sample which ""arrives"" at the node, into a left; (background-enhanced) and a right (signal-enhanced) sample. Function Members (Methods); public:. virtual~DecisionTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; voidAddToSumTarget(Float_t t); voidAddToSumTarget2(Float_t t2); void*TMVA::Node::AddXMLTo(void* parent) const; static TClass*Class(); voidClearNodeAndAllDaughters(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; TMVA::DecisionTreeNodeDecisionTreeNode(); TMVA::DecisionTreeNodeDecisionTreeNode(TMVA::Node* p, char pos); TMVA::DecisionTreeNodeDecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); Double_tGetAlpha() const; Double_tGetAlphaMinSubtree() const; Double_tGetCC() const; intTMVA::Node::GetCount(); Bool_tGetCutType() const; Float_tGetCutValue() const; UInt_tTMVA::Node::GetDepth() const; Double_tGetFisherCoeff(Int_t ivar) const; virtual TMVA::DecisionTreeNode*GetLeft() const; Float_tGetNBkgEvents() const; Float_tGetNBkgEvents_unboosted() const; Float_tGetNBkgEvents_unweighted() const; Double_tGetNBValidation() const; Float_tGetNEvents() const; Float_tGetNEvents_unboosted() const; Float_tGetNEvents_unweighted() const; UInt_tGetNFisherCoeff() const; Double_tGetNodeR() const; Int_tGetNodeType() const; Float_tGetNSigEvents() const; Float_tGetNSigEvents_unboosted() const; Float_tGetNSigEvents_unweighted() const; Double_tGetNSValidation() const; Int_tGetNTerminal() con",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:521,Modifiability,enhance,enhanced,521,". TMVA::DecisionTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::DecisionTreeNode. class TMVA::DecisionTreeNode: public TMVA::Node. Node for the Decision Tree. The node specifies ONE variable out of the given set of selection variable; that is used to split the sample which ""arrives"" at the node, into a left; (background-enhanced) and a right (signal-enhanced) sample. Function Members (Methods); public:. virtual~DecisionTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; voidAddToSumTarget(Float_t t); voidAddToSumTarget2(Float_t t2); void*TMVA::Node::AddXMLTo(void* parent) const; static TClass*Class(); voidClearNodeAndAllDaughters(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; TMVA::DecisionTreeNodeDecisionTreeNode(); TMVA::DecisionTreeNodeDecisionTreeNode(TMVA::Node* p, char pos); TMVA::DecisionTreeNodeDecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); Double_tGetAlpha() const; Double_tGetAlphaMinSubtree() const; Double_tGetCC() const; intTMVA::Node::GetCount(); Bool_tGetCutType() const; Float_tGetCutValue() const; UInt_tTMVA::Node::GetDepth() const; Double_tGetFisherCoeff(Int_t ivar) const; virtual TMVA::DecisionTreeNode*GetLeft() const; Float_tGetNBkgEvents() const; Float_tGetNBkgEvents_unboosted() const; Float_tGetNBkgEvents_unweighted() const; Double_tGetNBValidation() const; Float_tGetNEvents() const; Float_tGetNEvents_unboosted() const; Float_tGetNEvents_unweighted() const; UInt_tGetNFisherCoeff() const; Double_tGetNodeR() const; Int_tGetNodeType() const; Float_tGetNSigEvents() const; Float_tGetNSigEvents_unboosted() const; Float_tGetNSigEvents_unweighted() const; Double_tGetNSValidation() const; Int_tGetNTerminal() con",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:551,Modifiability,enhance,enhanced,551,". TMVA::DecisionTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::DecisionTreeNode. class TMVA::DecisionTreeNode: public TMVA::Node. Node for the Decision Tree. The node specifies ONE variable out of the given set of selection variable; that is used to split the sample which ""arrives"" at the node, into a left; (background-enhanced) and a right (signal-enhanced) sample. Function Members (Methods); public:. virtual~DecisionTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; voidAddToSumTarget(Float_t t); voidAddToSumTarget2(Float_t t2); void*TMVA::Node::AddXMLTo(void* parent) const; static TClass*Class(); voidClearNodeAndAllDaughters(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; TMVA::DecisionTreeNodeDecisionTreeNode(); TMVA::DecisionTreeNodeDecisionTreeNode(TMVA::Node* p, char pos); TMVA::DecisionTreeNodeDecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); Double_tGetAlpha() const; Double_tGetAlphaMinSubtree() const; Double_tGetCC() const; intTMVA::Node::GetCount(); Bool_tGetCutType() const; Float_tGetCutValue() const; UInt_tTMVA::Node::GetDepth() const; Double_tGetFisherCoeff(Int_t ivar) const; virtual TMVA::DecisionTreeNode*GetLeft() const; Float_tGetNBkgEvents() const; Float_tGetNBkgEvents_unboosted() const; Float_tGetNBkgEvents_unweighted() const; Double_tGetNBValidation() const; Float_tGetNEvents() const; Float_tGetNEvents_unboosted() const; Float_tGetNEvents_unweighted() const; UInt_tGetNFisherCoeff() const; Double_tGetNodeR() const; Int_tGetNodeType() const; Float_tGetNSigEvents() const; Float_tGetNSigEvents_unboosted() const; Float_tGetNSigEvents_unweighted() const; Double_tGetNSValidation() const; Int_tGetNTerminal() con",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:5129,Modifiability,variab,variable,5129," voidTMVA::Node::SetParentTree(TMVA::BinaryTree* t); voidTMVA::Node::SetPos(char s); voidSetPurity(); voidSetResponse(Float_t r); virtual voidSetRight(TMVA::Node* r); voidSetRMS(Float_t r); voidSetSampleMax(UInt_t ivar, Float_t xmax); voidSetSampleMin(UInt_t ivar, Float_t xmin); voidSetSelector(Short_t i); voidSetSeparationGain(Float_t sep); voidSetSeparationIndex(Float_t sep); voidSetSubTreeR(Double_t r); voidSetSumTarget(Float_t t); voidSetSumTarget2(Float_t t2); voidSetTerminal(Bool_t s = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. static TMVA::MsgLogger&Log(). private:. virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657). Data Members; public:. static boolfgIsTrainingstatic variable to flag training phase in which we need fTrainInfo; static UInt_tfgTmva_Version_Codeset only when read from weightfile. protected:. Bool_tfCutTypetrue: if event variable > cutValue ==> signal , false otherwise; Float_tfCutValuecut value appplied on this node to discriminate bkg against sig; UInt_tTMVA::Node::fDepthdepth of the node within the tree (seen from root node); vector<Double_t>fFisherCoeffthe fisher coeff (offset at the last element); Bool_tfIsTerminalNode! flag to set node as terminal (i.e., without deleting its descendants); TMVA::Node*TMVA::Node::fLeftpointers to the two ""daughter"" nodes; Int_tfNodeTypeType of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal; TMVA::Node*TMVA::Node::fParentthe previous (parent) node; TMVA::BinaryTree*TMVA::Node::fParentTreepointer to the parent tree to which the Node belongs; charTMVA::Node::fPosposition, i.e. it is a left (l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regressi",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:5299,Modifiability,variab,variable,5299,"; voidSetSelector(Short_t i); voidSetSeparationGain(Float_t sep); voidSetSeparationIndex(Float_t sep); voidSetSubTreeR(Double_t r); voidSetSumTarget(Float_t t); voidSetSumTarget2(Float_t t2); voidSetTerminal(Bool_t s = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. static TMVA::MsgLogger&Log(). private:. virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657). Data Members; public:. static boolfgIsTrainingstatic variable to flag training phase in which we need fTrainInfo; static UInt_tfgTmva_Version_Codeset only when read from weightfile. protected:. Bool_tfCutTypetrue: if event variable > cutValue ==> signal , false otherwise; Float_tfCutValuecut value appplied on this node to discriminate bkg against sig; UInt_tTMVA::Node::fDepthdepth of the node within the tree (seen from root node); vector<Double_t>fFisherCoeffthe fisher coeff (offset at the last element); Bool_tfIsTerminalNode! flag to set node as terminal (i.e., without deleting its descendants); TMVA::Node*TMVA::Node::fLeftpointers to the two ""daughter"" nodes; Int_tfNodeTypeType of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal; TMVA::Node*TMVA::Node::fParentthe previous (parent) node; TMVA::BinaryTree*TMVA::Node::fParentTreepointer to the parent tree to which the Node belongs; charTMVA::Node::fPosposition, i.e. it is a left (l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Deci",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:6274,Modifiability,variab,variable,6274,"nInfo; static UInt_tfgTmva_Version_Codeset only when read from weightfile. protected:. Bool_tfCutTypetrue: if event variable > cutValue ==> signal , false otherwise; Float_tfCutValuecut value appplied on this node to discriminate bkg against sig; UInt_tTMVA::Node::fDepthdepth of the node within the tree (seen from root node); vector<Double_t>fFisherCoeffthe fisher coeff (offset at the last element); Bool_tfIsTerminalNode! flag to set node as terminal (i.e., without deleting its descendants); TMVA::Node*TMVA::Node::fLeftpointers to the two ""daughter"" nodes; Int_tfNodeTypeType of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal; TMVA::Node*TMVA::Node::fParentthe previous (parent) node; TMVA::BinaryTree*TMVA::Node::fParentTreepointer to the parent tree to which the Node belongs; charTMVA::Node::fPosposition, i.e. it is a left (l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTreeNode(); constructor of an essentially ""empty"" node floating in space. DecisionTreeNode(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are ve",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:8049,Modifiability,variab,variable,8049," this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients. void AddContentToNode(stringstream& s) const; adding attributes to tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). void ReadContent(stringstream& s); reading attributes from tree node (well, was used in BinarySea",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:8183,Modifiability,variab,variable,8183," PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients. void AddContentToNode(stringstream& s) const; adding attributes to tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). void ReadContent(stringstream& s); reading attributes from tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). TMVA::MsgLogger& L",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:8319,Modifiability,variab,variable,8319,"am& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients. void AddContentToNode(stringstream& s) const; adding attributes to tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). void ReadContent(stringstream& s); reading attributes from tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). TMVA::MsgLogger& Log(). Node* CreateNode() const; { return new DecisionTreeNode(); }. void SetNFisherCoeff(Int_t nvars); {fFisherCoeff.resize(nvars);}. U",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:8455,Modifiability,variab,variable,8455,"on_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients. void AddContentToNode(stringstream& s) const; adding attributes to tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). void ReadContent(stringstream& s); reading attributes from tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). TMVA::MsgLogger& Log(). Node* CreateNode() const; { return new DecisionTreeNode(); }. void SetNFisherCoeff(Int_t nvars); {fFisherCoeff.resize(nvars);}. UInt_t GetNFisherCoeff() const; set fisher coefficients. { return fFisherCoeff.size();}. Double_t GetFisherCoeff(Int_t ivar) const; get f",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:9552,Modifiability,variab,variable,9552,"ode, UInt_t tmva_Version_Code = 262657). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients. void AddContentToNode(stringstream& s) const; adding attributes to tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). void ReadContent(stringstream& s); reading attributes from tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). TMVA::MsgLogger& Log(). Node* CreateNode() const; { return new DecisionTreeNode(); }. void SetNFisherCoeff(Int_t nvars); {fFisherCoeff.resize(nvars);}. UInt_t GetNFisherCoeff() const; set fisher coefficients. { return fFisherCoeff.size();}. Double_t GetFisherCoeff(Int_t ivar) const; get fisher coefficients. {return fFisherCoeff.at(ivar);}. void SetSelector(Short_t i); set index of variable used for discrimination at this node. { fSelector = i; }. Short_t GetSelector() const; return index of variable used for discrimination at this node. { return fSelector; }. void SetCutValue(Float_t c); set the cut value applied at this node. { fCutValue = c; }. Float_t GetCutValue( void ); return the cut value applied at this node. { return fCutValue; }. void SetCutType(Bool_t t); set true: if event variable > cutValue ==> signal , false otherwise. { fCutType = t; }. Bool_t GetCutType( void ); return kTRUE: Cuts select signal, kFALSE: Cuts select bkg. { return fCutType; }. void SetNodeType(Int_t t); set node type: 1 signal node, -1 bkg leave, 0 intermediate Node. { fNodeType = t;}. Int_t GetNodeType( void ); return node type: 1 signal node, -1 bkg leave, 0 intermediate Node. { return fNodeType; }. Float_t GetPurity( void ); return S/(S+B) (purity) at this node (from training). { return fPurity;}. void SetResponse(Float_t r); set the response of the node (for regression). { fResp",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:9664,Modifiability,variab,variable,9664," SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients. void AddContentToNode(stringstream& s) const; adding attributes to tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). void ReadContent(stringstream& s); reading attributes from tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). TMVA::MsgLogger& Log(). Node* CreateNode() const; { return new DecisionTreeNode(); }. void SetNFisherCoeff(Int_t nvars); {fFisherCoeff.resize(nvars);}. UInt_t GetNFisherCoeff() const; set fisher coefficients. { return fFisherCoeff.size();}. Double_t GetFisherCoeff(Int_t ivar) const; get fisher coefficients. {return fFisherCoeff.at(ivar);}. void SetSelector(Short_t i); set index of variable used for discrimination at this node. { fSelector = i; }. Short_t GetSelector() const; return index of variable used for discrimination at this node. { return fSelector; }. void SetCutValue(Float_t c); set the cut value applied at this node. { fCutValue = c; }. Float_t GetCutValue( void ); return the cut value applied at this node. { return fCutValue; }. void SetCutType(Bool_t t); set true: if event variable > cutValue ==> signal , false otherwise. { fCutType = t; }. Bool_t GetCutType( void ); return kTRUE: Cuts select signal, kFALSE: Cuts select bkg. { return fCutType; }. void SetNodeType(Int_t t); set node type: 1 signal node, -1 bkg leave, 0 intermediate Node. { fNodeType = t;}. Int_t GetNodeType( void ); return node type: 1 signal node, -1 bkg leave, 0 intermediate Node. { return fNodeType; }. Float_t GetPurity( void ); return S/(S+B) (purity) at this node (from training). { return fPurity;}. void SetResponse(Float_t r); set the response of the node (for regression). { fResponse = r;}. Float_t GetResponse( void ); return the response of the node (for regression). { return fResponse;",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:9964,Modifiability,variab,variable,9964,"ontent(stringstream& s); reading attributes from tree node (well, was used in BinarySearchTree,; and somehow I guess someone programmed it such that we need this in; this tree too, although we don't..). TMVA::MsgLogger& Log(). Node* CreateNode() const; { return new DecisionTreeNode(); }. void SetNFisherCoeff(Int_t nvars); {fFisherCoeff.resize(nvars);}. UInt_t GetNFisherCoeff() const; set fisher coefficients. { return fFisherCoeff.size();}. Double_t GetFisherCoeff(Int_t ivar) const; get fisher coefficients. {return fFisherCoeff.at(ivar);}. void SetSelector(Short_t i); set index of variable used for discrimination at this node. { fSelector = i; }. Short_t GetSelector() const; return index of variable used for discrimination at this node. { return fSelector; }. void SetCutValue(Float_t c); set the cut value applied at this node. { fCutValue = c; }. Float_t GetCutValue( void ); return the cut value applied at this node. { return fCutValue; }. void SetCutType(Bool_t t); set true: if event variable > cutValue ==> signal , false otherwise. { fCutType = t; }. Bool_t GetCutType( void ); return kTRUE: Cuts select signal, kFALSE: Cuts select bkg. { return fCutType; }. void SetNodeType(Int_t t); set node type: 1 signal node, -1 bkg leave, 0 intermediate Node. { fNodeType = t;}. Int_t GetNodeType( void ); return node type: 1 signal node, -1 bkg leave, 0 intermediate Node. { return fNodeType; }. Float_t GetPurity( void ); return S/(S+B) (purity) at this node (from training). { return fPurity;}. void SetResponse(Float_t r); set the response of the node (for regression). { fResponse = r;}. Float_t GetResponse( void ); return the response of the node (for regression). { return fResponse;}. void SetRMS(Float_t r); set the RMS of the response of the node (for regression). { fRMS = r;}. Float_t GetRMS( void ); return the RMS of the response of the node (for regression). { return fRMS;}. void SetNSigEvents(Float_t s); set the sum of the signal weights in the node. { fTrainInfo->fNSigEve",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:7742,Security,validat,validation,7742,"uctor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = 262657). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher coefficients.",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:16450,Security,validat,validation,16450,"ionTreeNode*>(p);}. void SetNodeR(Double_t r); the node resubstitution estimate, R(t), for Cost Complexity pruning. { fTrainInfo->fNodeR = r; }. Double_t GetNodeR() const; { return fTrainInfo->fNodeR; }. void SetSubTreeR(Double_t r); the resubstitution estimate, R(T_t), of the tree rooted at this node. { fTrainInfo->fSubTreeR = r; }. Double_t GetSubTreeR() const; { return fTrainInfo->fSubTreeR; }. void SetAlpha(Double_t alpha); R(t) - R(T_t); the critical point alpha = -------------; |~T_t| - 1. { fTrainInfo->fAlpha = alpha; }. Double_t GetAlpha() const; { return fTrainInfo->fAlpha; }. void SetAlphaMinSubtree(Double_t g); the minimum alpha in the tree rooted at this node. { fTrainInfo->fG = g; }. Double_t GetAlphaMinSubtree() const; { return fTrainInfo->fG; }. void SetNTerminal(Int_t n); number of terminal nodes in the subtree rooted here. { fTrainInfo->fNTerminal = n; }. Int_t GetNTerminal() const; { return fTrainInfo->fNTerminal; }. void SetNBValidation(Double_t b); number of background/signal events from the pruning validation sample. { fTrainInfo->fNB = b; }. void SetNSValidation(Double_t s); { fTrainInfo->fNS = s; }. Double_t GetNBValidation() const; { return fTrainInfo->fNB; }. Double_t GetNSValidation() const; { return fTrainInfo->fNS; }. void SetSumTarget(Float_t t); {fTrainInfo->fSumTarget = t; }. void SetSumTarget2(Float_t t2); {fTrainInfo->fSumTarget2 = t2; }. void AddToSumTarget(Float_t t); {fTrainInfo->fSumTarget += t; }. void AddToSumTarget2(Float_t t2); {fTrainInfo->fSumTarget2 += t2; }. Float_t GetSumTarget() const; {return fTrainInfo? fTrainInfo->fSumTarget : -9999;}. Float_t GetSumTarget2() const; {return fTrainInfo? fTrainInfo->fSumTarget2: -9999;}. Bool_t IsTerminal() const; flag indicates whether this node is terminal. { return fIsTerminalNode; }. void SetTerminal(Bool_t s = kTRUE); { fIsTerminalNode = s; }. Double_t GetCC() const; {return (fTrainInfo? fTrainInfo->fCC : -1.);}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Eckha",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:6911,Testability,test,test,6911,"eepointer to the parent tree to which the Node belongs; charTMVA::Node::fPosposition, i.e. it is a left (l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTreeNode(); constructor of an essentially ""empty"" node floating in space. DecisionTreeNode(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursi",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:7016,Testability,test,test,7016,"l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTreeNode(); constructor of an essentially ""empty"" node floating in space. DecisionTreeNode(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) con",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__DecisionTreeNode.html:7530,Usability,clear,clear,7530,"VA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* ",MatchSource.WIKI,root/html604/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html
https://root.cern/root/html604/TMVA__Event.html:4784,Integrability,depend,depending,4784,"Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Funct",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:2362,Modifiability,variab,variables,2362,"(ostream& o) const; voidScaleBoostWeight(Double_t s) const; voidSetBoostWeight(Double_t w) const; voidSetClass(UInt_t t); voidSetDoNotBoost() const; static voidSetIgnoreNegWeightsInTraining(Bool_t); static voidSetIsTraining(Bool_t); voidSetSpectator(UInt_t ivar, Float_t value); voidSetTarget(UInt_t itgt, Float_t value); voidSetVal(UInt_t ivar, Float_t val); voidSetVariableArrangement(vector<UInt_t>*const m) const; voidSetWeight(Double_t w). Data Members; private:. Double_tfBoostWeightinternal weight to be set by boosting algorithm; UInt_tfClassclass number; Bool_tfDoNotBoostmark event as not to be boosted (used to compensate for events with negative event weights; Bool_tfDynamicis set when the dynamic values are taken; vector<Float_t>fSpectators""visisting"" variables not used in MVAs ; mutable, to be able to copy the dynamic values in there; vector<Float_t>fTargetstarget values for regression; vector<Float_t>fValuesthe event values ; mutable, to be able to copy the dynamic values in there; vector<Float_t*>*fValuesDynamicthe event values; vector<Float_t>fValuesRearrangedthe event values ; mutable, to be able to copy the dynamic values in there; vector<UInt_t>*fVariableArrangementneeded for MethodCategories, where we can train on other than the main variables; Double_tfWeightevent weight (product of global and individual weights); static Bool_tfgIgnoreNegWeightsInTraining; static Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constr",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:2862,Modifiability,variab,variables,2862,"(ostream& o) const; voidScaleBoostWeight(Double_t s) const; voidSetBoostWeight(Double_t w) const; voidSetClass(UInt_t t); voidSetDoNotBoost() const; static voidSetIgnoreNegWeightsInTraining(Bool_t); static voidSetIsTraining(Bool_t); voidSetSpectator(UInt_t ivar, Float_t value); voidSetTarget(UInt_t itgt, Float_t value); voidSetVal(UInt_t ivar, Float_t val); voidSetVariableArrangement(vector<UInt_t>*const m) const; voidSetWeight(Double_t w). Data Members; private:. Double_tfBoostWeightinternal weight to be set by boosting algorithm; UInt_tfClassclass number; Bool_tfDoNotBoostmark event as not to be boosted (used to compensate for events with negative event weights; Bool_tfDynamicis set when the dynamic values are taken; vector<Float_t>fSpectators""visisting"" variables not used in MVAs ; mutable, to be able to copy the dynamic values in there; vector<Float_t>fTargetstarget values for regression; vector<Float_t>fValuesthe event values ; mutable, to be able to copy the dynamic values in there; vector<Float_t*>*fValuesDynamicthe event values; vector<Float_t>fValuesRearrangedthe event values ; mutable, to be able to copy the dynamic values in there; vector<UInt_t>*fVariableArrangementneeded for MethodCategories, where we can train on other than the main variables; Double_tfWeightevent weight (product of global and individual weights); static Bool_tfgIgnoreNegWeightsInTraining; static Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constr",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:3932,Modifiability,variab,variable,3932,"t of global and individual weights); static Bool_tfgIgnoreNegWeightsInTraining; static Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negeti",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4016,Modifiability,variab,variable,4016,"ic Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL p",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4091,Modifiability,variab,variable,4091,"esting"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4292,Modifiability,variab,variables,4292,"at_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when t",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4478,Modifiability,variab,variable,4478,"rgetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. Bool_t IsDynamic() const; accessors. {return fDynamic; }. Doubl",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4266,Security,access,accessor,4266,"at_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when t",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4331,Security,access,accessor,4331,"ss = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events w",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:4397,Security,access,accessor,4397,"tor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or n",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:5430,Security,access,accessors,5430,"f spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Function,"" on p. 23, in Item 3 ""Use const whenever possible,"" in Effective C++, 3d ed by Scott Meyers, ISBN-13: 9780321334879.; http://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets(); { return fTargets; }. const std::vector<Float_t>& GetTargets() const; { return fTargets; }. std::vector<Float_t>& GetSpectators(); { return fSpectators; }. const std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void SetWeight(Double_t w); { fWeight=w; }. vo",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Event.html:3065,Testability,test,testing,3065,"(ostream& o) const; voidScaleBoostWeight(Double_t s) const; voidSetBoostWeight(Double_t w) const; voidSetClass(UInt_t t); voidSetDoNotBoost() const; static voidSetIgnoreNegWeightsInTraining(Bool_t); static voidSetIsTraining(Bool_t); voidSetSpectator(UInt_t ivar, Float_t value); voidSetTarget(UInt_t itgt, Float_t value); voidSetVal(UInt_t ivar, Float_t val); voidSetVariableArrangement(vector<UInt_t>*const m) const; voidSetWeight(Double_t w). Data Members; private:. Double_tfBoostWeightinternal weight to be set by boosting algorithm; UInt_tfClassclass number; Bool_tfDoNotBoostmark event as not to be boosted (used to compensate for events with negative event weights; Bool_tfDynamicis set when the dynamic values are taken; vector<Float_t>fSpectators""visisting"" variables not used in MVAs ; mutable, to be able to copy the dynamic values in there; vector<Float_t>fTargetstarget values for regression; vector<Float_t>fValuesthe event values ; mutable, to be able to copy the dynamic values in there; vector<Float_t*>*fValuesDynamicthe event values; vector<Float_t>fValuesRearrangedthe event values ; mutable, to be able to copy the dynamic values in there; vector<UInt_t>*fVariableArrangementneeded for MethodCategories, where we can train on other than the main variables; Double_tfWeightevent weight (product of global and individual weights); static Bool_tfgIgnoreNegWeightsInTraining; static Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constr",MatchSource.WIKI,root/html604/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Event.html
https://root.cern/root/html604/TMVA__Factory.html:4576,Availability,error,error,4576,"ual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; TTree*CreateEventAssignTrees(const TString& name); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteAllMethods(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvaluateAllMethods(); voidEvaluateAllVariables(TString options = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TMVA::FactoryFactory(const TMVA::Factory&); TMVA::FactoryFactory(TString theJobName, TFile* theTargetFile, TString theOption = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMVA::IMethod*GetMethod(const TString& title) const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Con",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:4660,Availability,error,error,4660,"ewname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; TTree*CreateEventAssignTrees(const TString& name); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteAllMethods(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvaluateAllMethods(); voidEvaluateAllVariables(TString options = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TMVA::FactoryFactory(const TMVA::Factory&); TMVA::FactoryFactory(TString theJobName, TFile* theTargetFile, TString theOption = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMVA::IMethod*GetMethod(const TString& title) const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; virtual const char*TObject::GetTitle() const; virtual",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:344,Integrability,interface,interfaces,344,". TMVA::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TMVA::Factory. class TMVA::Factory: public TMVA::Configurable. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. virtual~Factory(); voidTObject::AbstractMethod(const char* method) const; voidAddBackgroundTestEvent(const vector<Double_t>& event, Double_t weight = 1.); voidAddBackgroundTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.); voidAddBackgroundTree(TTree* background, Double_t weight = 1., TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddBackgroundTree(TString datFileB, Double_t weight = 1., TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddBackgroundTree(TTree* background, Double_t weight, const TString& treetype); voidAddCut(const TString& cut, const TString& className = """"); voidAddCut(const TCut& cut, const TString& className = """"); TMVA::DataSetInfo&AddDataSet(TMVA::DataSetInfo&); TMVA::DataSetInfo&AddDataSet(const TString&); voidAddEvent(const TString& className, TMVA::Types::ETreeType tt, const vector<Double_t>& event, Double_t weight); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0); voidAddRegressionTree(TTree* tree, Double_t weight = 1., TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddSignalTestEvent(const vector<Double_t>& event, Double_t weight = 1.); voidAddSignalTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.); voidAddSignalTree(TTree* signal, Double_t weight = 1., TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddSignalTree(TString datFileS, Double_t weight = 1., TMVA::Types::ETreeTy",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:8549,Modifiability,variab,variable,8549,"ual voidTObject::Print(Option_t* option = """") const; voidPrintHelpMessage(const TString& methodTitle = """") const; voidTMVA::Configurable::PrintOptions() const; virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); static TDirectory*RootBaseDir(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBackgroundTree(TTree* background, Double_t weight = 1.); voidSetBackgroundWeightExpression(const TString& variable); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); voidSetCut(const TString& cut, const TString& className = """"); voidSetCut(const TCut& cut, const TString& className = """"); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInputTrees(TTree* inputTree, const TCut& SigCut, const TCut& BgCut); voidSetInputTrees(const TString& signalFileName, const TString& backgroundFileName, Double_t signalWeight = 1., Double_t backgroundWeight = 1.); voidSetInputTrees(TTree* signal, TTree* background, Double_t signalWeight = 1., Double_t backgroundWeight = 1.); voidSetInputVariables(vector<TString>* theVariables); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalTree(TTree* signal, Double_t weight = 1.); voidSetSignalWeightExpression(const TString& variable); voidSetTree(TTree* tree, const TString& className, Double_t weight); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVerbose(Bool_t v = kTRUE); voidSetWeightExpression(const TString& variable",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:9625,Modifiability,variab,variable,9625,"ight = 1., Double_t backgroundWeight = 1.); voidSetInputTrees(TTree* signal, TTree* background, Double_t signalWeight = 1., Double_t backgroundWeight = 1.); voidSetInputVariables(vector<TString>* theVariables); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalTree(TTree* signal, Double_t weight = 1.); voidSetSignalWeightExpression(const TString& variable); voidSetTree(TTree* tree, const TString& className, Double_t weight); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVerbose(Bool_t v = kTRUE); voidSetWeightExpression(const TString& variable, const TString& className = """"); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidTestAllMethods(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTrainAllMethods(); voidTrainAllMethodsForClassification(); voidTrainAllMethodsForRegression(); virtual voidTObject::UseCurrentStyle(); Bool_tUserAssignEvents(UInt_t clIndex); Bool_tVerbose() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTMVA::Configurable::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA:",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:9824,Modifiability,variab,variable,9824,"ight = 1., Double_t backgroundWeight = 1.); voidSetInputTrees(TTree* signal, TTree* background, Double_t signalWeight = 1., Double_t backgroundWeight = 1.); voidSetInputVariables(vector<TString>* theVariables); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalTree(TTree* signal, Double_t weight = 1.); voidSetSignalWeightExpression(const TString& variable); voidSetTree(TTree* tree, const TString& className, Double_t weight); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVerbose(Bool_t v = kTRUE); voidSetWeightExpression(const TString& variable, const TString& className = """"); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidTestAllMethods(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTrainAllMethods(); voidTrainAllMethodsForClassification(); voidTrainAllMethodsForRegression(); virtual voidTObject::UseCurrentStyle(); Bool_tUserAssignEvents(UInt_t clIndex); Bool_tVerbose() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTMVA::Configurable::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA:",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:12165,Modifiability,variab,variables,12165,")TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Float_t*fATreeEventevent variables; Int_tfATreeTypetype of event (=classIndex); Float_tfATreeWeightweight of the event; TMVA::Types::EAnalysisTypefAnalysisType! the training type; TMVA::Factory::DataAssignTypefDataAssignType! flags for data assigning; TMVA::DataInputHandler*fDataInputHandler; TMVA::DataSetManager*fDataSetManagerDSMTEST; vector<TMVA::VariableTransformBase*>fDefaultTrfs! list of transformations on default DataSet; TStringfJobName! jobname, used as extension in weight file names; TMVA::Factory::MVectorfMethods! all MVA methods; TStringfOptions! option string given by construction (presently only ""V""); vector<TTree*>fTestAssignTree! for each class: tmp tree if user wants to assign the events directly; vector<TTree*>fTrainAssignTree! for each class: tmp tree if user wants to assign the events directly; TStringfTransformations! List of transformations to test; Bool_tfVerbose! verbose mode; static TFile*fgTargetFile! ROOT output file; static TMVA::Factory::DataAssignTypekAssignEvents; static TMVA::Factory::DataAssignTypekAssignTrees; static TMVA::Factory::DataAssignTypekUndefined. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: L. Moneta Fri Dec 22 14:43:33 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__Factory.html:13018,Testability,test,test,13018,")TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Float_t*fATreeEventevent variables; Int_tfATreeTypetype of event (=classIndex); Float_tfATreeWeightweight of the event; TMVA::Types::EAnalysisTypefAnalysisType! the training type; TMVA::Factory::DataAssignTypefDataAssignType! flags for data assigning; TMVA::DataInputHandler*fDataInputHandler; TMVA::DataSetManager*fDataSetManagerDSMTEST; vector<TMVA::VariableTransformBase*>fDefaultTrfs! list of transformations on default DataSet; TStringfJobName! jobname, used as extension in weight file names; TMVA::Factory::MVectorfMethods! all MVA methods; TStringfOptions! option string given by construction (presently only ""V""); vector<TTree*>fTestAssignTree! for each class: tmp tree if user wants to assign the events directly; vector<TTree*>fTrainAssignTree! for each class: tmp tree if user wants to assign the events directly; TStringfTransformations! List of transformations to test; Bool_tfVerbose! verbose mode; static TFile*fgTargetFile! ROOT output file; static TMVA::Factory::DataAssignTypekAssignEvents; static TMVA::Factory::DataAssignTypekAssignTrees; static TMVA::Factory::DataAssignTypekUndefined. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: L. Moneta Fri Dec 22 14:43:33 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Factory.html
https://root.cern/root/html604/TMVA__FitterBase.html:538,Availability,avail,available,538,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t p",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:1841,Availability,error,error,1841,"dOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseFitterBase(const TMVA::FitterBase&); TMVA::FitterBaseFitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; Int_tGetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:1925,Availability,error,error,1925,"st; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseFitterBase(const TMVA::FitterBase&); TMVA::FitterBaseFitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; Int_tGetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configura",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:393,Integrability,interface,interface,393,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t p",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:7949,Integrability,interface,interface,7949,"ct::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); constructor. Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:8049,Integrability,interface,interface,8049,"ct::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); constructor. Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:8309,Security,access,accessor,8309,"ct::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); constructor. Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__FitterBase.html:7588,Testability,log,logger,7588,":MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); constructor. Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyri",MatchSource.WIKI,root/html604/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:4989,Energy Efficiency,reduce,reduce,4989,"different individuals of; the population. this function calls implicitly (many times) the ""fitnessFunction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.10000000000000001); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generat",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:2823,Modifiability,variab,variable,2823,"arget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); std::vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; a",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:4574,Modifiability,variab,variable,4574,"event the new chi-square (newValue) has to be simply; added to the oldValue. this function has to be overridden eventually; it might contain only the following return statement.; return oldValue + newValue;. Double_t CalculateFitness(); starts the evaluation of the fitness of all different individuals of; the population. this function calls implicitly (many times) the ""fitnessFunction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.10000000000000001); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:1807,Testability,log,logger,1807,"00001); voidInit(); virtual TClass*IsA() const; virtual Double_tNewFitness(Double_t oldValue, Double_t newValue); TMVA::GeneticAlgorithm&operator=(const TMVA::GeneticAlgorithm&); voidSetMakeCopies(Bool_t s); voidSetSpread(Double_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TMVA::MsgLogger&Log() const. Data Members; public:. Int_tfConvCounterconverging? ... keeps track of the number of improvements. protected:. Double_tfBestFitness; Double_tfConvValuekeeps track of the quantity of improvement; Bool_tfFirstTimeif true its the first time, so no evolution yet; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); std::vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which a",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:2604,Testability,test,tested,2604,"arget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); std::vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; a",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:3721,Usability,simpl,simply,3721,"MVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; after every event the new chi-square (newValue) has to be simply; added to the oldValue. this function has to be overridden eventually; it might contain only the following return statement.; return oldValue + newValue;. Double_t CalculateFitness(); starts the evaluation of the fitness of all different individuals of; the population. this function calls implicitly (many times) the ""fitnessFunction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor ",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticAlgorithm.html:5293,Usability,simpl,simple,5293,"as been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.10000000000000001); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticAlgorithm.html
https://root.cern/root/html604/TMVA__GeneticFitter.html:1688,Availability,error,error,1688,"static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); TMVA::GeneticFitterGeneticFitter(const TMVA::GeneticFitter&); TMVA::GeneticFitterGeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root/html604/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticFitter.html
https://root.cern/root/html604/TMVA__GeneticFitter.html:1772,Availability,error,error,1772,"bject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); TMVA::GeneticFitterGeneticFitter(const TMVA::GeneticFitter&); TMVA::GeneticFitterGeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*",MatchSource.WIKI,root/html604/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticFitter.html
https://root.cern/root/html604/TMVA__GeneticFitter.html:9770,Deployability,configurat,configuration,9770,"onvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are included as ""hints"" in the last cycle of GA calculation); Int_tfSaveBestFromGenerationstore the best individuals from one generation (these are included as ""hints"" in the last cycle of GA calculation); UInt_tfSeedSeed for the random generator (0 takes random seeds); Bool_tfTrimtake care, that the number of individuals is less fPopSize (trimming is done after the fitness of the individuals is assessed). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare GA options. void SetParameters(Int_t cycles, Int_t nsteps, Int_t popSize, Int_t SC_steps, Int_t SC_rate, Double_t SC_factor, Double_t convCrit); set GA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. GeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. Double_t NewFitness(Double_t oldF, Double_t newF); { return oldF + newF; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticFitter.html
https://root.cern/root/html604/TMVA__GeneticFitter.html:9770,Modifiability,config,configuration,9770,"onvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are included as ""hints"" in the last cycle of GA calculation); Int_tfSaveBestFromGenerationstore the best individuals from one generation (these are included as ""hints"" in the last cycle of GA calculation); UInt_tfSeedSeed for the random generator (0 takes random seeds); Bool_tfTrimtake care, that the number of individuals is less fPopSize (trimming is done after the fitness of the individuals is assessed). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare GA options. void SetParameters(Int_t cycles, Int_t nsteps, Int_t popSize, Int_t SC_steps, Int_t SC_rate, Double_t SC_factor, Double_t convCrit); set GA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. GeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. Double_t NewFitness(Double_t oldF, Double_t newF); { return oldF + newF; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticFitter.html
https://root.cern/root/html604/TMVA__GeneticFitter.html:7991,Testability,log,logger,7991,"ptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfConvCritimprovements bigger than fConvCrit are counted as ""improvement""; Int_tfCyclesnumber of (nearly) independent calculation cycles; Int_tfNstepsconvergence criteria: if no improvements > fConvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are inclu",MatchSource.WIKI,root/html604/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticFitter.html
https://root.cern/root/html604/TMVA__GeneticGenes.html:316,Integrability,interface,interface,316,. TMVA::GeneticGenes. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::GeneticGenes. class TMVA::GeneticGenes. Cut optimisation interface class for genetic algorithm. Function Members (Methods); public:. virtual~GeneticGenes(); static TClass*Class(); TMVA::GeneticGenesGeneticGenes(); TMVA::GeneticGenesGeneticGenes(vector<Double_t>& f); TMVA::GeneticGenesGeneticGenes(const TMVA::GeneticGenes&); vector<Double_t>&GetFactors(); Double_tGetFitness() const; virtual TClass*IsA() const; TMVA::GeneticGenes&operator=(const TMVA::GeneticGenes&); voidSetFitness(Double_t fitness); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. vector<Double_t>fFactorsstores the factors (coefficients) of one individual; Double_tfFitness. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticGenes(vector<Double_t>& f); Constructor:; set the factors of this individual. GeneticGenes(); {}. GeneticGenes(vector<Double_t>& f). virtual ~GeneticGenes(); {}. std::vector<Double_t>& GetFactors(); { return fFactors; }. void SetFitness(Double_t fitness); { fFitness = fitness; }. Double_t GetFitness() const; { return fFitness; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html604/TMVA__GeneticGenes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticGenes.html
https://root.cern/root/html604/TMVA__GeneticPopulation.html:5500,Modifiability,variab,variables,5500,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root/html604/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticPopulation.html
https://root.cern/root/html604/TMVA__GeneticPopulation.html:5551,Modifiability,variab,variables,5551,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root/html604/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticPopulation.html
https://root.cern/root/html604/TMVA__GeneticPopulation.html:5579,Performance,perform,perform,5579,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root/html604/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticPopulation.html
https://root.cern/root/html604/TMVA__GeneticPopulation.html:2119,Testability,log,logger,2119,"Copies(int number); voidMutate(Double_t probability = 20, Int_t startIndex = 0, Bool_t near = kFALSE, Double_t spread = 0.10000000000000001, Bool_t mirror = kFALSE); voidNextGeneration(); TMVA::GeneticPopulation&operator=(const TMVA::GeneticPopulation&); voidPrint(Int_t untilIndex = -1); voidPrint(ostream& out, Int_t utilIndex = -1); voidSetRandomSeed(UInt_t seed = 0); virtual voidShowMembers(TMemberInspector& insp) const; voidSort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTrimPopulation(); vector<Double_t>VariableDistribution(Int_t varNumber); TH1F*VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max). private:. TMVA::MsgLogger&Log() const; TMVA::GeneticGenesMakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female). Data Members; private:. vector<TMVA::GeneticGenes>fGenePoolthe ""genePool"" where the individuals of the current generation are stored; TMVA::MsgLogger*fLoggermessage logger; Int_tfPopulationSizeLimit; TRandom3*fRandomGeneratorrandom Generator for this population; vector<TMVA::GeneticRange*>fRangescontains the ranges inbetween the values of the coefficients have to be. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0); Constructor. ~GeneticPopulation(); destructor. void SetRandomSeed(UInt_t seed = 0); the random seed of the random generator. void MakeCopies(int number); produces offspring which is are copies of their parents; Parameters:; int number : the number of the last individual to be copied. void MakeChildren(); does what the name says,... it creates children out of members of the; current generation; children have a combination of the coefficients of their parents. TMVA::GeneticGenes MakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female); this function takes two individuals and produces offspring by mixing (recombining) their; coefficients. v",MatchSource.WIKI,root/html604/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GeneticPopulation.html
https://root.cern/root/html604/TMVA__GiniIndex.html:1757,Availability,down,down,1757,"GiniIndex(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); TMVA::GiniIndexGiniIndex(); TMVA::GiniIndexGiniIndex(const TMVA::GiniIndex& g); virtual TClass*IsA() const; TMVA::GiniIndex&operator=(const TMVA::GiniIndex&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Gini(Sample M) = 1 - (c(1)/N)^2 - (c(2)/N)^2 .... - (c(k)/N)^2; Where: M is a smaple of whatever N elements (events); that belong to K different classes; c(k) is the number of elements that belong to class k; for just Signal and Background classes this boils down to:; Gini(Sample) = 2s*b/(s+b)^2 ( = 2 * purity * (1-purity) ). !! what we use here is 2*Gini.. as for the later use the factor; 2 is irrelevant and hence I'd like to save this calculation. GiniIndex(); construtor for the GiniIndex. { fName=""Gini""; }. GiniIndex(const TMVA::GiniIndex& g); copy constructor. {}. virtual ~GiniIndex(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__GiniIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GiniIndex.html
https://root.cern/root/html604/TMVA__GiniIndexWithLaplace.html:1956,Availability,down,down,1956,"rationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); TMVA::GiniIndexWithLaplaceGiniIndexWithLaplace(); TMVA::GiniIndexWithLaplaceGiniIndexWithLaplace(const TMVA::GiniIndexWithLaplace& g); virtual TClass*IsA() const; TMVA::GiniIndexWithLaplace&operator=(const TMVA::GiniIndexWithLaplace&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Gini(Sample M) = 1 - (c(1)/N)^2 - (c(2)/N)^2 .... - (c(k)/N)^2; Where: M is a smaple of whatever N elements (events); that belong to K different classes; c(k) is the number of elements that belong to class k; Laplace's correction to the prob.density c/N --> (c+1)/(N+2); for just Signal and Background classes this then boils down to:; Gini(Sample) = 2(s*b+s+b+1)/(s+b+2)^2. GiniIndexWithLaplace(); construtor for the GiniIndexWithLaplace. { fName=""GiniLaplace""; }. GiniIndexWithLaplace(const TMVA::GiniIndexWithLaplace& g); copy constructor. {}. virtual ~GiniIndexWithLaplace(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__GiniIndexWithLaplace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__GiniIndexWithLaplace.html
https://root.cern/root/html604/TMVA__IFitterTarget.html:530,Availability,avail,available,530,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); TMVA::IFitterTargetIFitterTarget(); TMVA::IFitterTargetIFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IFitterTarget(); constructor. IFitterTarget(). virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__IFitterTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IFitterTarget.html
https://root.cern/root/html604/TMVA__IFitterTarget.html:358,Integrability,interface,interface,358,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); TMVA::IFitterTargetIFitterTarget(); TMVA::IFitterTargetIFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IFitterTarget(); constructor. IFitterTarget(). virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__IFitterTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IFitterTarget.html
https://root.cern/root/html604/TMVA__IMethod.html:418,Availability,avail,available,418,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMVA::IMethodIMethod(); TMVA::IMethodIMethod(const TMVA::IMethod&); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read",MatchSource.WIKI,root/html604/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html
https://root.cern/root/html604/TMVA__IMethod.html:1885,Availability,error,error,1885,"VA::IMethod&); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed",MatchSource.WIKI,root/html604/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html
https://root.cern/root/html604/TMVA__IMethod.html:2094,Energy Efficiency,monitor,monitoring,2094,"ge() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html
https://root.cern/root/html604/TMVA__IMethod.html:2345,Integrability,message,message,2345,"ge() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html
https://root.cern/root/html604/TMVA__IMethod.html:2713,Integrability,message,message,2713,"ge() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html
https://root.cern/root/html604/TMVA__Interval.html:318,Deployability,continuous,continuous,318,". TMVA::Interval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Interval. class TMVA::Interval. Interval. Interval definition, continuous and discrete. Interval(min,max) : a continous interval [min,max]; Interval(min,max,n): a ""discrete interval"" [min,max], i.e the n numbers:; min, min+step, min+2*step,...., min+(n-1)*step, min+n*step=max; e.g.: Interval(1,5,5)=1,2,3,4,5; Interval(.5,1.,6)= .5, .6., .7, .8, .9, 1.0. Note: **bin** counting starts from ZERO unlike in ROOT histograms. the TMVA::Interval Class. Interval definition, continuous and discrete; ; Interval(min,max) : a continous interval [min,max]; Interval(min,max,n): a ""discrete interval"" [min,max], i.e the n numbers:; min, min+step, min+2*step,...., min+(n-1)*step=max ; e.g.: Interval(1,5,5)=1,2,3,4,5 ; Interval(.5,1.,6)= .5, .6., .7, .8, .9, 1.0 . Example: Interval(.5,1.,6); [ min max ]; ------------------------------------------------------------; | | | | | |; .5 .6 .7 .8 .9 1.0; bin 0 1 2 3 4 5. . Function Members (Methods); public:. virtual~Interval(); static TClass*Class(); virtual Double_tGetElement(Int_t position) const; virtual Double_tGetMax() const; virtual Double_tGetMean() const; virtual Double_tGetMin() const; virtual Int_tGetNbins() const; virtual Double_tGetRndm(TRandom3&) const; virtual Double_tGetStepSize(Int_t iBin = 0) const; virtual Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); virtual voidPrint(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::Ms",MatchSource.WIKI,root/html604/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Interval.html
https://root.cern/root/html604/TMVA__Interval.html:725,Deployability,continuous,continuous,725,". TMVA::Interval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Interval. class TMVA::Interval. Interval. Interval definition, continuous and discrete. Interval(min,max) : a continous interval [min,max]; Interval(min,max,n): a ""discrete interval"" [min,max], i.e the n numbers:; min, min+step, min+2*step,...., min+(n-1)*step, min+n*step=max; e.g.: Interval(1,5,5)=1,2,3,4,5; Interval(.5,1.,6)= .5, .6., .7, .8, .9, 1.0. Note: **bin** counting starts from ZERO unlike in ROOT histograms. the TMVA::Interval Class. Interval definition, continuous and discrete; ; Interval(min,max) : a continous interval [min,max]; Interval(min,max,n): a ""discrete interval"" [min,max], i.e the n numbers:; min, min+step, min+2*step,...., min+(n-1)*step=max ; e.g.: Interval(1,5,5)=1,2,3,4,5 ; Interval(.5,1.,6)= .5, .6., .7, .8, .9, 1.0 . Example: Interval(.5,1.,6); [ min max ]; ------------------------------------------------------------; | | | | | |; .5 .6 .7 .8 .9 1.0; bin 0 1 2 3 4 5. . Function Members (Methods); public:. virtual~Interval(); static TClass*Class(); virtual Double_tGetElement(Int_t position) const; virtual Double_tGetMax() const; virtual Double_tGetMean() const; virtual Double_tGetMin() const; virtual Int_tGetNbins() const; virtual Double_tGetRndm(TRandom3&) const; virtual Double_tGetStepSize(Int_t iBin = 0) const; virtual Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); virtual voidPrint(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::Ms",MatchSource.WIKI,root/html604/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Interval.html
https://root.cern/root/html604/TMVA__Interval.html:2204,Deployability,continuous,continuous,2204," .8 .9 1.0; bin 0 1 2 3 4 5. . Function Members (Methods); public:. virtual~Interval(); static TClass*Class(); virtual Double_tGetElement(Int_t position) const; virtual Double_tGetMax() const; virtual Double_tGetMean() const; virtual Double_tGetMin() const; virtual Int_tGetNbins() const; virtual Double_tGetRndm(TRandom3&) const; virtual Double_tGetStepSize(Int_t iBin = 0) const; virtual Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); virtual voidPrint(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; protected:. Double_tfMaxthe constraints of the Interval; Double_tfMinthe constraints of the Interval; Int_tfNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0); defines minimum and maximum of an interval; when nbins > 0, interval describes a discrete distribution (equally distributed in the interval); when nbins == 0, interval describes a continous interval. Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. void Print(ostream& os) const. TMVA::MsgLogger& Log() const. Double_t GetMin() const; accessors; accessors. {",MatchSource.WIKI,root/html604/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Interval.html
https://root.cern/root/html604/TMVA__Interval.html:3113,Security,access,accessors,3113,"& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); virtual voidPrint(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; protected:. Double_tfMaxthe constraints of the Interval; Double_tfMinthe constraints of the Interval; Int_tfNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0); defines minimum and maximum of an interval; when nbins > 0, interval describes a discrete distribution (equally distributed in the interval); when nbins == 0, interval describes a continous interval. Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. void Print(ostream& os) const. TMVA::MsgLogger& Log() const. Double_t GetMin() const; accessors; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Interval.html
https://root.cern/root/html604/TMVA__Interval.html:3124,Security,access,accessors,3124,"& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); virtual voidPrint(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; protected:. Double_tfMaxthe constraints of the Interval; Double_tfMinthe constraints of the Interval; Int_tfNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0); defines minimum and maximum of an interval; when nbins > 0, interval describes a discrete distribution (equally distributed in the interval); when nbins == 0, interval describes a continous interval. Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. void Print(ostream& os) const. TMVA::MsgLogger& Log() const. Double_t GetMin() const; accessors; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Interval.html
https://root.cern/root/html604/TMVA__KDEKernel.html:2111,Energy Efficiency,adapt,adaptive,2111,"=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::KDEKernel::EKernelIterkAdaptiveKDE; static TMVA::KDEKernel::EKernelTypekGauss; static TMVA::KDEKernel::EKernelBorderkKernelRenorm; static TMVA::KDEKernel::EKernelBorderkNoTreatment; static TMVA::KDEKernel::EKernelIterkNonadaptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelI",MatchSource.WIKI,root/html604/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html
https://root.cern/root/html604/TMVA__KDEKernel.html:2643,Energy Efficiency,adapt,adaptive,2643,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html
https://root.cern/root/html604/TMVA__KDEKernel.html:2111,Modifiability,adapt,adaptive,2111,"=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::KDEKernel::EKernelIterkAdaptiveKDE; static TMVA::KDEKernel::EKernelTypekGauss; static TMVA::KDEKernel::EKernelBorderkKernelRenorm; static TMVA::KDEKernel::EKernelBorderkNoTreatment; static TMVA::KDEKernel::EKernelIterkNonadaptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelI",MatchSource.WIKI,root/html604/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html
https://root.cern/root/html604/TMVA__KDEKernel.html:2643,Modifiability,adapt,adaptive,2643,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html
https://root.cern/root/html604/TMVA__KDEKernel.html:2489,Safety,sanity check,sanity check,2489,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html
https://root.cern/root/html604/TMVA__KDEKernel.html:1970,Testability,log,logger,1970,"=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::KDEKernel::EKernelIterkAdaptiveKDE; static TMVA::KDEKernel::EKernelTypekGauss; static TMVA::KDEKernel::EKernelBorderkKernelRenorm; static TMVA::KDEKernel::EKernelBorderkNoTreatment; static TMVA::KDEKernel::EKernelIterkNonadaptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelI",MatchSource.WIKI,root/html604/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html
https://root.cern/root/html604/TMVA__kNN__Event.html:2065,Integrability,depend,depending,2065,"NN::Event&operator=(const TMVA::kNN::Event&); voidPrint() const; voidPrint(ostream& os) const; voidSetTargets(const TMVA::kNN::VarVec& tvec). Data Members; private:. TMVA::kNN::VarVecfTgttargets for regression analysis; Short_tfTypeevent type ==0 or == 1, expand it to arbitrary class types?; TMVA::kNN::VarVecfVarcoordinates (variables) for knn search; Double_tfWeightevent weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event( const std::vector<Float_t>& ev, const std::vector<Float_t>& tg, UInt_t cls, Double_t weight, Double_t boostweight ); constructor. Event( const std::vector<Float_t>& ev, const std::vector<Float_t>& tg, const std::vector<Float_t>& vi, UInt_t cls, Double_t weight, Double_t boostweight ); constructor. Event(const TMVA::kNN::VarVec& vec, Double_t weight, Short_t type, const TMVA::kNN::VarVec& tvec); constructor. ~Event(); Event destructor. void Print(ostream& os) const; print method. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. VarType GetVar(UInt_t i) const. VarType GetTgt(UInt_t i) const. UInt_t GetNVar() const. UInt_t GetNTgt() const. Short_t GetType() const. VarType GetDist(TMVA::kNN::VarType var, UInt_t ivar) const; keep these two function separate. VarType GetDist(const TMVA::kNN::Event& other) const. void SetTargets(const TMVA::kNN::VarVec& tvec). const VarVec& GetTargets() const. const VarVec& GetVars() const. void Print() const. » Author: Rustem Ospanov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__kNN__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__kNN__Event.html
https://root.cern/root/html604/TMVA__kNN__Event.html:1346,Modifiability,variab,variables,1346," Function Members (Methods); public:. ~Event(); TMVA::kNN::EventEvent(); TMVA::kNN::EventEvent(const TMVA::kNN::Event&); TMVA::kNN::EventEvent(const TMVA::kNN::VarVec& vec, Double_t weight, Short_t type); TMVA::kNN::EventEvent(const TMVA::kNN::VarVec& vec, Double_t weight, Short_t type, const TMVA::kNN::VarVec& tvec); TMVA::kNN::VarTypeGetDist(const TMVA::kNN::Event& other) const; TMVA::kNN::VarTypeGetDist(TMVA::kNN::VarType var, UInt_t ivar) const; UInt_tGetNTgt() const; UInt_tGetNVar() const; const TMVA::kNN::VarVec&GetTargets() const; TMVA::kNN::VarTypeGetTgt(UInt_t i) const; Short_tGetType() const; TMVA::kNN::VarTypeGetVar(UInt_t i) const; const TMVA::kNN::VarVec&GetVars() const; Double_tGetWeight() const; TMVA::kNN::Event&operator=(const TMVA::kNN::Event&); voidPrint() const; voidPrint(ostream& os) const; voidSetTargets(const TMVA::kNN::VarVec& tvec). Data Members; private:. TMVA::kNN::VarVecfTgttargets for regression analysis; Short_tfTypeevent type ==0 or == 1, expand it to arbitrary class types?; TMVA::kNN::VarVecfVarcoordinates (variables) for knn search; Double_tfWeightevent weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); copy constructor. Event( const std::vector<Float_t>& ev, const std::vector<Float_t>& tg, UInt_t cls, Double_t weight, Double_t boostweight ); constructor. Event( const std::vector<Float_t>& ev, const std::vector<Float_t>& tg, const std::vector<Float_t>& vi, UInt_t cls, Double_t weight, Double_t boostweight ); constructor. Event(const TMVA::kNN::VarVec& vec, Double_t weight, Short_t type, const TMVA::kNN::VarVec& tvec); constructor. ~Event(); Event destructor. void Print(ostream& os) const; print method. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; e",MatchSource.WIKI,root/html604/TMVA__kNN__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__kNN__Event.html
https://root.cern/root/html604/TMVA__LogInterval.html:1589,Deployability,continuous,continuous,1589,"le_tGetMean() const; virtual Double_tGetMin() const; virtual Int_tGetNbins() const; virtual Double_tGetRndm(TRandom3&) const; virtual Double_tGetStepSize(Int_t iBin = 0) const; virtual Double_tGetWidth() const; TMVA::IntervalTMVA::Interval::Interval(const TMVA::Interval& other); TMVA::IntervalTMVA::Interval::Interval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::MsgLogger&Log() const; TMVA::LogIntervalLogInterval(const TMVA::LogInterval& other); TMVA::LogIntervalLogInterval(Double_t min, Double_t max, Int_t nbins = 0); TMVA::LogInterval&operator=(const TMVA::LogInterval&); virtual voidTMVA::Interval::Print(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. Double_tTMVA::Interval::fMaxthe constraints of the Interval; Double_tTMVA::Interval::fMinthe constraints of the Interval; Int_tTMVA::Interval::fNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LogInterval(Double_t min, Double_t max, Int_t nbins = 0). LogInterval(const TMVA::LogInterval& other). ~LogInterval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete LogInterval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. TMVA::MsgLogger& Log() const. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Last changed: Tue",MatchSource.WIKI,root/html604/TMVA__LogInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__LogInterval.html
https://root.cern/root/html604/TMVA__LogInterval.html:2282,Security,access,accessors,2282,"VA::IntervalTMVA::Interval::Interval(const TMVA::Interval& other); TMVA::IntervalTMVA::Interval::Interval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::MsgLogger&Log() const; TMVA::LogIntervalLogInterval(const TMVA::LogInterval& other); TMVA::LogIntervalLogInterval(Double_t min, Double_t max, Int_t nbins = 0); TMVA::LogInterval&operator=(const TMVA::LogInterval&); virtual voidTMVA::Interval::Print(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. Double_tTMVA::Interval::fMaxthe constraints of the Interval; Double_tTMVA::Interval::fMinthe constraints of the Interval; Int_tTMVA::Interval::fNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LogInterval(Double_t min, Double_t max, Int_t nbins = 0). LogInterval(const TMVA::LogInterval& other). ~LogInterval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete LogInterval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. TMVA::MsgLogger& Log() const. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Last changed: Tue Jun 2 16:16:21 2015 » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__LogInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__LogInterval.html
https://root.cern/root/html604/TMVA__MCFitter.html:1693,Availability,error,error,1693,"static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; vi",MatchSource.WIKI,root/html604/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MCFitter.html
https://root.cern/root/html604/TMVA__MCFitter.html:1777,Availability,error,error,1777,"bject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html604/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MCFitter.html
https://root.cern/root/html604/TMVA__MCFitter.html:8500,Deployability,configurat,configuration,8500,"itsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MCFitter.html
https://root.cern/root/html604/TMVA__MCFitter.html:8500,Modifiability,config,configuration,8500,"itsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MCFitter.html
https://root.cern/root/html604/TMVA__MCFitter.html:7812,Testability,log,logger,7812,"ptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Hel",MatchSource.WIKI,root/html604/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MCFitter.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:527,Availability,avail,available,527,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMu",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:2420,Availability,error,error,2420,"figurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:2504,Availability,error,error,2504,"bject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18090,Energy Efficiency,monitor,monitoring,18090,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18159,Energy Efficiency,monitor,monitoring,18159,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18224,Energy Efficiency,monitor,monitoring,18224,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:15581,Integrability,message,message,15581,"onst char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); voidForceNetworkCalculations(); voidForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); virtual voidTMVA::IMethod::GetHelpMessage() const; TMVA::TNeuron*GetInputNeuron(Int_t index); const TString&TMVA::MethodBase::GetInternalVarName(Int_t ivar) const; Double_tGetNetworkOutput(); const TString&TMVA::MethodBase::GetOriginalVarName(Int_t ivar) const; TMVA::TNeuron*GetOutputNeuron(Int_t index = 0); const TString&TMVA::Configurable::GetReferenceFile() const; static TMVA::MethodBase*TMVA::MethodBase::GetThisBase(); const TString&TMVA::MethodBase::GetWeightFileDir() const; Bool_tTMVA::MethodBase::HasTrainingTree() const; Bool_tTMVA::MethodBase::Help() const; Bool_tTMVA::MethodBase::IgnoreEventsWithNegWeightsInTraining() const; Bool_tTMVA::MethodBase::IsConstructedFromWeightFile() const; Bool_tTMVA::MethodBase::IsNormalised() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; virtual voidMakeClassSpecific(ostream&, const TString&) const; virtual voidTMVA::MethodBase::MakeClassSpecificHeader(ostream&, const TString& = """") const; voidTObject::MakeZombie(); voidTMVA::MethodBase::NoErrorCalc(Double_t*const err, Double_t*const errUpper); Int_tNumCycles(); vector<Int_t>*ParseLayoutString(TString layerSpec); voidPrintMessage(TString message, Bool_t force = kFALSE) const; voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidWaitForKeyboard(); voidTMVA::Configurable::WriteOptionsReferenceToFile().",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:19339,Integrability,depend,depending,19339,"ression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorfEstimator; TH1F*fEstimatorHistTestmonitors convergence of independent test sample; TH1F*fEstimatorHistTrainmonitors convergence of training sample; TStringfEstimatorS; TMVA::TActivation*fIdentityactivation for input and output layers; TMVA::TNeuronInput*fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDfInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tfNcyclesnumber of epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses.",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:22721,Integrability,message,message,22721," Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for each input neuron. void ForceNetworkCalculations(); calculate input values to each neuron. void PrintMessage(TString message, Bool_t force = kFALSE) const; print messages, turn off printing by setting verbose and debug flag appropriately. void WaitForKeyboard(); wait for keyboard input, for debugging. void PrintNetwork() const; print network representation, for debugging. void PrintLayer(TObjArray* layer) const; print a single layer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ra",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:22766,Integrability,message,messages,22766," Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for each input neuron. void ForceNetworkCalculations(); calculate input values to each neuron. void PrintMessage(TString message, Bool_t force = kFALSE) const; print messages, turn off printing by setting verbose and debug flag appropriately. void WaitForKeyboard(); wait for keyboard input, for debugging. void PrintNetwork() const; print network representation, for debugging. void PrintLayer(TObjArray* layer) const; print a single layer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ra",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:17861,Modifiability,layers,layers,17861,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18517,Modifiability,layers,layers,18517,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18654,Modifiability,variab,variables,18654,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18867,Modifiability,variab,variable,18867,"VA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorfEstimator; TH1F*fEstimatorHistTestmonitors convergence of independent test sample; TH1F*fEstimatorHistTrainmonitors convergence of training sample; TStringfEstimatorS; TMVA::TActivation*fIdentityactivation for input and output layers; TMVA::TNeuronInput*fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDfInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tfNcyclesnumber of epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural da",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:19331,Modifiability,layers,layers,19331,"ression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorfEstimator; TH1F*fEstimatorHistTestmonitors convergence of independent test sample; TH1F*fEstimatorHistTrainmonitors convergence of training sample; TStringfEstimatorS; TMVA::TActivation*fIdentityactivation for input and output layers; TMVA::TNeuronInput*fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDfInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tfNcyclesnumber of epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses.",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:21071,Modifiability,variab,variables,21071,"fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); standard constructor; Note: Right now it is an option to choose the neuron input function,; but only the input function ""sum"" leads to weight convergence --; otherwise the weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = __null, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file ",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:21153,Modifiability,layers,layers,21153,"fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); standard constructor; Note: Right now it is an option to choose the neuron input function,; but only the input function ""sum"" leads to weight convergence --; otherwise the weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = __null, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file ",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:21973,Modifiability,layers,layers,21973," for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = __null, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for each input neuron. void ForceNetworkCalculations(); calculate input values to each neuron. void PrintMessage(TString message, Bool_t force = kFALSE) const; print messages, turn off printing by setting verbose and debug flag appropriately. void WaitForKeyboard(); wait for keyboard input, for debugging. void PrintNetwork() const; ",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:23783,Modifiability,variab,variables,23783,"ges, turn off printing by setting verbose and debug flag appropriately. void WaitForKeyboard(); wait for keyboard input, for debugging. void PrintNetwork() const; print network representation, for debugging. void PrintLayer(TObjArray* layer) const; print a single layer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); constructors dictated by subclassing off of MethodBase. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:12537,Performance,tune,tuneParameters,12537," voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:20005,Security,access,access,20005,"epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; vector<TMVA::TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); standard constructor; Note: Right now it is an option to choose the neuron input function,; but only the input function ""sum"" leads to weight convergence --; otherwise the weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalise",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:20115,Security,access,access,20115,"epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; vector<TMVA::TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); standard constructor; Note: Right now it is an option to choose the neuron input function,; but only the input function ""sum"" leads to weight convergence --; otherwise the weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalise",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:24716,Security,access,accessors,24716,"onst std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); constructors dictated by subclassing off of MethodBase. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:12339,Testability,test,testTime,12339,"n(TMVA::TActivation* activation); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:16781,Testability,test,testing,16781,"voidBuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); voidBuildLayers(vector<Int_t>* layout, Bool_t from_file = false); voidDeleteNetwork(); voidDeleteNetworkLayer(TObjArray*& layer); voidForceWeights(vector<Double_t>* weights); voidInitWeights(); voidPrintLayer(TObjArray* layer) const; voidPrintNeuron(TMVA::TNeuron* neuron) const. Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TMVA::MethodANNBase::EEstimatorkCE; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMVA::MethodANNBase::EEstimatorkMSE; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::TActivation*fActivationactivation function to be used for hidden layers; TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHist",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:18360,Testability,test,test,18360,,MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:21609,Usability,clear,clear,21609,"weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = __null, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value f",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodANNBase.html:23658,Usability,clear,clear,23658,"ate input values to each neuron. void PrintMessage(TString message, Bool_t force = kFALSE) const; print messages, turn off printing by setting verbose and debug flag appropriately. void WaitForKeyboard(); wait for keyboard input, for debugging. void PrintNetwork() const; print network representation, for debugging. void PrintLayer(TObjArray* layer) const; print a single layer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); constructors dictated by subclassing off of MethodBase. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputN",MatchSource.WIKI,root/html604/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:1981,Availability,avail,available,1981,"of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*Data() const; TMVA::Data",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:3639,Availability,error,error,3639,"::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*Data() const; TMVA::DataSetInfo&DataInfo() const; virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDoMulticlass() const; Bool_tDoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeGetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*GetEvent() const; const TMVA::Event*GetEvent(const TMVA::Event* ev) const; const TMVA::Event*GetEvent(Long64_t ievt) const; const TMVA::Event*GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&GetEventCollection(TMVA::Types::ETreeType type); virtual",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:3723,Availability,error,error,3723,"ble(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*Data() const; TMVA::DataSetInfo&DataInfo() const; virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDoMulticlass() const; Bool_tDoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeGetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*GetEvent() const; const TMVA::Event*GetEvent(const TMVA::Event* ev) const; const TMVA::Event*GetEvent(Long64_t ievt) const; const TMVA::Event*GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&GetEventCollection(TMVA::Types::ETreeType type); virtual const char*TObject::GetIconName() const; const TString&GetInputLabel(Int_t i) const",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:23093,Availability,avail,availabel,23093,"ing phase). void CheckSetup(); check may be overridden by derived class; (sometimes, eg, fitters are used which can only be implemented during training phase). void InitBase(); default initialization called by all constructors. void DeclareBaseOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviatio",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:33503,Availability,error,error,33503,"ngEvent(Long64_t ievt) const. MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); default constructur. void Train(). void SetTrainTime(Double_t trainTime); store and retrieve time used for training. { fTrainTime = trainTime; }. Double_t GetTrainTime() const; { return fTrainTime; }. void SetTestTime(Double_t testTime); store and retrieve time used for testing. { fTestTime = testTime; }. Double_t GetTestTime() const; { return fTestTime; }. void Init(); options treatment. void DeclareOptions(). void ProcessOptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { re",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:33519,Availability,error,error,33519,"ngEvent(Long64_t ievt) const. MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); default constructur. void Train(). void SetTrainTime(Double_t trainTime); store and retrieve time used for training. { fTrainTime = trainTime; }. Double_t GetTrainTime() const; { return fTrainTime; }. void SetTestTime(Double_t testTime); store and retrieve time used for testing. { fTestTime = testTime; }. Double_t GetTestTime() const; { return fTestTime; }. void Init(); options treatment. void DeclareOptions(). void ProcessOptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { re",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:26501,Deployability,configurat,configuration,26501,"squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; wri",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:37294,Deployability,update,update,37294," fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir); { fBaseDir = methodDir; }. void SetMethodBaseDir(TDirectory* methodDir); { fMethodBaseDir = methodDir; }. UInt_t GetTrainingTMVAVersionCode() const; the TMVA version can be obtained and checked using; if (GetTrainingTMVAVersionCode()>TMVA_VERSION(3,7,2)) {...}; or; if (GetTrainingROOTVersionCode()>ROOT_VERSION(5,15,5)) {...}. { return fTMVATrainingVersion; }. UInt_t GetTrainingROOTVersionCode() const; { return fROOTTrainingVersion; }. TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true). const TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const. void RerouteTransformationHandler(TMVA::TransformationHandler* fTargetTransformation); { fTransformationPointer=fTargetTransformation; }. DataSetInfo& DataInfo() const; { return fDataSetInfo; }. UInt_t GetNEvents() const; event reference and update; NOTE: these Event accessors make sure that you get the events transformed according to the; particular clasifiers transformation chosen. { return Data()->GetNEvents(); }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:28430,Energy Efficiency,monitor,monitoring,28430,"void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* buf); reads one line from the input stream; checks for certain keywords and interprets; the line if keywords are found. void CreateMVAPdfs(); Create PDFs of the MVA output variables. Double_t GetProba(const TMVA::Event* ev); the simple one, automatically calcualtes the mvaVal and uses the; SAME sig/bkg ratio as given in the training sample (typically 50/50; .. (NormMode=EqualNumEvents) but can be different). Double_t GetProba(Double_t mvaVal, Double_t ap_sig); compute likelihood ratio. Double_t GetRarity(Double_t mvaVal, TMVA::Types::ESBType reftype = Types::kBackground) const; compute rarity:; R(x) = Integrate_[-oo..x] { PDF(x') dx' }; where PDF(x) is the PDF of the classifier's signal or background distribution. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& err); fill background efficiency (resp. rejection) versus signal efficiency plots; returns signal e",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:511,Integrability,depend,depends,511,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:23023,Integrability,message,message,23023,"ethods. void ProcessSetup(); process all options; the ""CheckForUnusedOptions"" is done in an independent call, since it may be overridden by derived class; (sometimes, eg, fitters are used which can only be implemented during training phase). void CheckSetup(); check may be overridden by derived class; (sometimes, eg, fitters are used which can only be implemented during training phase). void InitBase(); default initialization called by all constructors. void DeclareBaseOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameter",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:31377,Integrability,interface,interface,31377,"= 0) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetMaximumSignificance(Double_t SignalEvents, Double_t BackgroundEvents, Double_t& optimal_significance_value) const; plot significance, S/Sqrt(S^2 + B^2), curve for given number; of signal and background events; returns cut for maximum significance; also returned via reference is the maximum significance. void Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& ); calculates rms,mean, xmin, xmax of the event variable; this can be either done for the variables as they are or for; normalised variables (in the range of 0-1) if ""norm"" is set to kTRUE. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for method (classification only at present). void PrintHelpMessage() const; prints out method-specific help method. Double_t IGetEffForRoot(Double_t ); interface for RootFinder. Double_t GetEffForRoot(Double_t ); returns efficiency as function of cut. const std::vector<TMVA::Event*>& GetEventCollection(TMVA::Types::ETreeType type); returns the event collection (i.e. the dataset) TRANSFORMED using the; classifiers specific Variable Transformation (e.g. Decorr or Decorr:Gauss:Decorr). TString GetTrainingTMVAVersionString() const; calculates the TMVA version string from the training version code on the fly. TString GetTrainingROOTVersionString() const; calculates the ROOT version string from the training version code on the fly. TMVA::MethodBase* GetThisBase(); return a pointer the base class of this method. void ResetThisBase(); reset required for RootFinder. Double_t GetKSTrainingVsTest(Char_t SorB, TString opt = ""X""). const TMVA::Event* GetEvent(const TMVA::Event* ev) const. const TMVA::Event* GetEvent() const. const TMVA::Event* GetEvent(Long64_t ievt) const. const TMVA::Event* GetEvent(Long64_t ievt, TMVA::Types::ETreeType typ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:1793,Modifiability,variab,variables,1793," at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& th",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:17185,Modifiability,variab,variables,17185,"asUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypekROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypekTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypefAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tfBackgroundClassindex of the Background-class; vector<TString>*fInputVarsvector of input variables used in MVA; vector<Float_t>*fMulticlassReturnValholds the return-values for the multiclass classification; Int_tfNbinsnumber of bins in input variable histograms; Int_tfNbinsHnumber of bins in evaluation histograms; Int_tfNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*fRegressionReturnValholds the return-values for the regression; UInt_tfSignalClassindex of the Signal-class. private:. TDirectory*fBaseDirbase directory for the instance, needed to know where to jump back from localDir; Bool_tfConstructedFromWeightFileis it obtained from weight file?; TMVA::MethodBase::ECutOrientationfCutOrientation+1 if Sig>Bkg, -1 otherwise; TMVA::DataSetInfo&fDataSetInfo! the data set information (sometimes needed); TMVA::PDF*fDefaultPDFdefault PDF definitions; Bool_tfDisableWriting! set to true in order to suppress writing to XML; TH1*fEffSefficiency histogram for rootfinder; vector<const vector<TMVA::Event*>*>fEventCollectionsif the method needs the complete event-collection, the transformed event coll. ist stored here.; TStringfFi",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:17338,Modifiability,variab,variable,17338,"asUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypekROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypekTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypefAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tfBackgroundClassindex of the Background-class; vector<TString>*fInputVarsvector of input variables used in MVA; vector<Float_t>*fMulticlassReturnValholds the return-values for the multiclass classification; Int_tfNbinsnumber of bins in input variable histograms; Int_tfNbinsHnumber of bins in evaluation histograms; Int_tfNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*fRegressionReturnValholds the return-values for the regression; UInt_tfSignalClassindex of the Signal-class. private:. TDirectory*fBaseDirbase directory for the instance, needed to know where to jump back from localDir; Bool_tfConstructedFromWeightFileis it obtained from weight file?; TMVA::MethodBase::ECutOrientationfCutOrientation+1 if Sig>Bkg, -1 otherwise; TMVA::DataSetInfo&fDataSetInfo! the data set information (sometimes needed); TMVA::PDF*fDefaultPDFdefault PDF definitions; Bool_tfDisableWriting! set to true in order to suppress writing to XML; TH1*fEffSefficiency histogram for rootfinder; vector<const vector<TMVA::Event*>*>fEventCollectionsif the method needs the complete event-collection, the transformed event coll. ist stored here.; TStringfFi",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:19062,Modifiability,variab,variables,19062,"ress writing to XML; TH1*fEffSefficiency histogram for rootfinder; vector<const vector<TMVA::Event*>*>fEventCollectionsif the method needs the complete event-collection, the transformed event coll. ist stored here.; TStringfFileDirunix sub-directory for weight files (default: ""weights""); Bool_tfHasMVAPdfsMVA Pdfs are created for this classifier; Bool_tfHelphelp flag; Bool_tfIgnoreNegWeightsInTrainingIf true, events with negative weights are not used in training; TStringfJobNamename of job -> user defined, appears in weight files; TMVA::PDF*fMVAPdfBbackground MVA PDF; TMVA::PDF*fMVAPdfSsignal MVA PDF; Double_tfMeanBmean (background); Double_tfMeanSmean (signal); TDirectory*fMethodBaseDirbase directory for the method; TStringfMethodNamename of the method (set in derived class); TMVA::Types::EMVAfMethodTypetype of method (set in derived class); Int_tfNbinsMVAPdfnumber of bins used in histogram that creates PDF; Bool_tfNormalisenormalise input variables; Int_tfNsmoothMVAPdfnumber of times a histogram is smoothed before creating the PDF; TStringfParentDirmethod parent name, like booster name; UInt_tfROOTTrainingVersionROOT version used for training; Double_tfRmsBRMS (background); Double_tfRmsSRMS (signal); Double_tfSignalReferenceCutminimum requirement on the MVA output to declare an event signal-like; Double_tfSignalReferenceCutOrientationminimum requirement on the MVA output to declare an event signal-like; TMVA::PDF*fSplBPDFs of MVA distribution (background); TMVA::TSpline1*fSplRefBhelper splines for RootFinder (background); TMVA::TSpline1*fSplRefShelper splines for RootFinder (signal); TMVA::PDF*fSplSPDFs of MVA distribution (signal); TMVA::PDF*fSplTrainBPDFs of training MVA distribution (background); TSpline*fSplTrainEffBvsSsplines for training signal eff. versus background eff.; TMVA::TSpline1*fSplTrainRefBhelper splines for RootFinder (background); TMVA::TSpline1*fSplTrainRefShelper splines for RootFinder (signal); TMVA::PDF*fSplTrainSPDFs of training MVA distribu",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:20703,Modifiability,variab,variable,20703,"SplSPDFs of MVA distribution (signal); TMVA::PDF*fSplTrainBPDFs of training MVA distribution (background); TSpline*fSplTrainEffBvsSsplines for training signal eff. versus background eff.; TMVA::TSpline1*fSplTrainRefBhelper splines for RootFinder (background); TMVA::TSpline1*fSplTrainRefShelper splines for RootFinder (signal); TMVA::PDF*fSplTrainSPDFs of training MVA distribution (signal); TSpline*fSpleffBvsSsplines for signal eff. versus background eff.; UInt_tfTMVATrainingVersionTMVA version used for training; Double_tfTestTimefor timing measurements; TStringfTestvarvariable used in evaluation, etc (mostly the MVA); Double_tfTrainTimefor timing measurements; TMVA::TransformationHandlerfTransformationthe list of transformations; TMVA::TransformationHandler*fTransformationPointerpointer to the rest of transformations; Bool_tfTxtWeightsOnlyif TRUE, write weights only to text files; Bool_tfUseDecorrsynonymous for decorrelation; TStringfVarTransformStringlabels variable transform method; TMVA::Types::ESBTypefVariableTransformTypethis is the event type (sig or bgd) assumed for variable transform; TStringfVariableTransformTypeStringlabels variable transform type; Bool_tfVerboseverbose flag; TMVA::EMsgTypefVerbosityLevelverbosity level; TStringfVerbosityLevelStringverbosity level (user input string); TStringfWeightFileweight file name; Double_tfXmaxmaximum (signal and background); Double_tfXminminimum (signal and background); static TMVA::MethodBase::ECutOrientationkNegative; static TMVA::MethodBase::ECutOrientationkPositive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); standard constructur. MethodBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); constructor used for Testing + Application of",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:20820,Modifiability,variab,variable,20820,"SplSPDFs of MVA distribution (signal); TMVA::PDF*fSplTrainBPDFs of training MVA distribution (background); TSpline*fSplTrainEffBvsSsplines for training signal eff. versus background eff.; TMVA::TSpline1*fSplTrainRefBhelper splines for RootFinder (background); TMVA::TSpline1*fSplTrainRefShelper splines for RootFinder (signal); TMVA::PDF*fSplTrainSPDFs of training MVA distribution (signal); TSpline*fSpleffBvsSsplines for signal eff. versus background eff.; UInt_tfTMVATrainingVersionTMVA version used for training; Double_tfTestTimefor timing measurements; TStringfTestvarvariable used in evaluation, etc (mostly the MVA); Double_tfTrainTimefor timing measurements; TMVA::TransformationHandlerfTransformationthe list of transformations; TMVA::TransformationHandler*fTransformationPointerpointer to the rest of transformations; Bool_tfTxtWeightsOnlyif TRUE, write weights only to text files; Bool_tfUseDecorrsynonymous for decorrelation; TStringfVarTransformStringlabels variable transform method; TMVA::Types::ESBTypefVariableTransformTypethis is the event type (sig or bgd) assumed for variable transform; TStringfVariableTransformTypeStringlabels variable transform type; Bool_tfVerboseverbose flag; TMVA::EMsgTypefVerbosityLevelverbosity level; TStringfVerbosityLevelStringverbosity level (user input string); TStringfWeightFileweight file name; Double_tfXmaxmaximum (signal and background); Double_tfXminminimum (signal and background); static TMVA::MethodBase::ECutOrientationkNegative; static TMVA::MethodBase::ECutOrientationkPositive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); standard constructur. MethodBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); constructor used for Testing + Application of",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:20882,Modifiability,variab,variable,20882,"SplSPDFs of MVA distribution (signal); TMVA::PDF*fSplTrainBPDFs of training MVA distribution (background); TSpline*fSplTrainEffBvsSsplines for training signal eff. versus background eff.; TMVA::TSpline1*fSplTrainRefBhelper splines for RootFinder (background); TMVA::TSpline1*fSplTrainRefShelper splines for RootFinder (signal); TMVA::PDF*fSplTrainSPDFs of training MVA distribution (signal); TSpline*fSpleffBvsSsplines for signal eff. versus background eff.; UInt_tfTMVATrainingVersionTMVA version used for training; Double_tfTestTimefor timing measurements; TStringfTestvarvariable used in evaluation, etc (mostly the MVA); Double_tfTrainTimefor timing measurements; TMVA::TransformationHandlerfTransformationthe list of transformations; TMVA::TransformationHandler*fTransformationPointerpointer to the rest of transformations; Bool_tfTxtWeightsOnlyif TRUE, write weights only to text files; Bool_tfUseDecorrsynonymous for decorrelation; TStringfVarTransformStringlabels variable transform method; TMVA::Types::ESBTypefVariableTransformTypethis is the event type (sig or bgd) assumed for variable transform; TStringfVariableTransformTypeStringlabels variable transform type; Bool_tfVerboseverbose flag; TMVA::EMsgTypefVerbosityLevelverbosity level; TStringfVerbosityLevelStringverbosity level (user input string); TStringfWeightFileweight file name; Double_tfXmaxmaximum (signal and background); Double_tfXminminimum (signal and background); static TMVA::MethodBase::ECutOrientationkNegative; static TMVA::MethodBase::ECutOrientationkPositive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); standard constructur. MethodBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); constructor used for Testing + Application of",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:22542,Modifiability,variab,variables,22542,"hodBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); constructor used for Testing + Application of the MVA,; only (no training), using given WeightFiles. ~MethodBase( void ); destructor. void SetupMethod(); setup of methods. void ProcessSetup(); process all options; the ""CheckForUnusedOptions"" is done in an independent call, since it may be overridden by derived class; (sometimes, eg, fitters are used which can only be implemented during training phase). void CheckSetup(); check may be overridden by derived class; (sometimes, eg, fitters are used which can only be implemented during training phase). void InitBase(); default initialization called by all constructors. void DeclareBaseOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:23306,Modifiability,variab,variable,23306,"g phase). void InitBase(); default initialization called by all constructors. void DeclareBaseOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:24288,Modifiability,variab,variable,24288,"mationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's di",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:24406,Modifiability,variab,variable,24406,"yOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& r",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:25129,Modifiability,variab,variable,25129,"tion(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType anal",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:25251,Modifiability,variab,variable,25251,"utput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:25855,Modifiability,variab,variables,25855,"es a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header f",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:25866,Modifiability,variab,variable,25866,"es a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header f",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:26210,Modifiability,variab,variables,26210,"A::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. I",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:26221,Modifiability,variab,variable,26221,"A::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. I",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:26501,Modifiability,config,configuration,26501,"squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; wri",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:26956,Modifiability,variab,variables,26956,"ing& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDi",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:27087,Modifiability,variab,variables,27087,"teToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set direc",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:27276,Modifiability,variab,variable,27276,"fied. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. voi",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:27554,Modifiability,variab,variable,27554,"file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* b",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:28713,Modifiability,variab,variables,28713," read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* buf); reads one line from the input stream; checks for certain keywords and interprets; the line if keywords are found. void CreateMVAPdfs(); Create PDFs of the MVA output variables. Double_t GetProba(const TMVA::Event* ev); the simple one, automatically calcualtes the mvaVal and uses the; SAME sig/bkg ratio as given in the training sample (typically 50/50; .. (NormMode=EqualNumEvents) but can be different). Double_t GetProba(Double_t mvaVal, Double_t ap_sig); compute likelihood ratio. Double_t GetRarity(Double_t mvaVal, TMVA::Types::ESBType reftype = Types::kBackground) const; compute rarity:; R(x) = Integrate_[-oo..x] { PDF(x') dx' }; where PDF(x) is the PDF of the classifier's signal or background distribution. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& err); fill background efficiency (resp. rejection) versus signal efficiency plots; returns signal efficiency at background efficiency indicated in theString. Double_t GetTrainingEfficiency(const TString& ). std::vector<Float_t> GetMulticlassEfficiency(vector<vector<Float_t> >& purity). std::vector<Float_t> GetMulticlassTrainingEfficiency(vector<vecto",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:30997,Modifiability,variab,variable,30997,"(x)) dx }. Double_t GetSeparation(TMVA::PDF* pdfS = 0, TMVA::PDF* pdfB = 0) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetROCIntegral(TH1D* histS, TH1D* histB) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetROCIntegral(TMVA::PDF* pdfS = 0, TMVA::PDF* pdfB = 0) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetMaximumSignificance(Double_t SignalEvents, Double_t BackgroundEvents, Double_t& optimal_significance_value) const; plot significance, S/Sqrt(S^2 + B^2), curve for given number; of signal and background events; returns cut for maximum significance; also returned via reference is the maximum significance. void Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& ); calculates rms,mean, xmin, xmax of the event variable; this can be either done for the variables as they are or for; normalised variables (in the range of 0-1) if ""norm"" is set to kTRUE. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for method (classification only at present). void PrintHelpMessage() const; prints out method-specific help method. Double_t IGetEffForRoot(Double_t ); interface for RootFinder. Double_t GetEffForRoot(Double_t ); returns efficiency as function of cut. const std::vector<TMVA::Event*>& GetEventCollection(TMVA::Types::ETreeType type); returns the event collection (i.e. the dataset) TRANSFORMED using the; classifiers specific Variable Transformation (e.g. Decorr or Decorr:Gauss:Decorr). TString GetTrainingTMVAVersionString() const; calculates the TMVA version string from the training version code on the fly. TString GetTrainingROOTVersionString() const; calculates the ROOT version string from the training version code on the fly. TMVA::Met",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:31039,Modifiability,variab,variables,31039,"(x)) dx }. Double_t GetSeparation(TMVA::PDF* pdfS = 0, TMVA::PDF* pdfB = 0) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetROCIntegral(TH1D* histS, TH1D* histB) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetROCIntegral(TMVA::PDF* pdfS = 0, TMVA::PDF* pdfB = 0) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetMaximumSignificance(Double_t SignalEvents, Double_t BackgroundEvents, Double_t& optimal_significance_value) const; plot significance, S/Sqrt(S^2 + B^2), curve for given number; of signal and background events; returns cut for maximum significance; also returned via reference is the maximum significance. void Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& ); calculates rms,mean, xmin, xmax of the event variable; this can be either done for the variables as they are or for; normalised variables (in the range of 0-1) if ""norm"" is set to kTRUE. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for method (classification only at present). void PrintHelpMessage() const; prints out method-specific help method. Double_t IGetEffForRoot(Double_t ); interface for RootFinder. Double_t GetEffForRoot(Double_t ); returns efficiency as function of cut. const std::vector<TMVA::Event*>& GetEventCollection(TMVA::Types::ETreeType type); returns the event collection (i.e. the dataset) TRANSFORMED using the; classifiers specific Variable Transformation (e.g. Decorr or Decorr:Gauss:Decorr). TString GetTrainingTMVAVersionString() const; calculates the TMVA version string from the training version code on the fly. TString GetTrainingROOTVersionString() const; calculates the ROOT version string from the training version code on the fly. TMVA::Met",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:31080,Modifiability,variab,variables,31080,"(x)) dx }. Double_t GetSeparation(TMVA::PDF* pdfS = 0, TMVA::PDF* pdfB = 0) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetROCIntegral(TH1D* histS, TH1D* histB) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetROCIntegral(TMVA::PDF* pdfS = 0, TMVA::PDF* pdfB = 0) const; calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. Double_t GetMaximumSignificance(Double_t SignalEvents, Double_t BackgroundEvents, Double_t& optimal_significance_value) const; plot significance, S/Sqrt(S^2 + B^2), curve for given number; of signal and background events; returns cut for maximum significance; also returned via reference is the maximum significance. void Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& ); calculates rms,mean, xmin, xmax of the event variable; this can be either done for the variables as they are or for; normalised variables (in the range of 0-1) if ""norm"" is set to kTRUE. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for method (classification only at present). void PrintHelpMessage() const; prints out method-specific help method. Double_t IGetEffForRoot(Double_t ); interface for RootFinder. Double_t GetEffForRoot(Double_t ); returns efficiency as function of cut. const std::vector<TMVA::Event*>& GetEventCollection(TMVA::Types::ETreeType type); returns the event collection (i.e. the dataset) TRANSFORMED using the; classifiers specific Variable Transformation (e.g. Decorr or Decorr:Gauss:Decorr). TString GetTrainingTMVAVersionString() const; calculates the TMVA version string from the training version code on the fly. TString GetTrainingROOTVersionString() const; calculates the ROOT version string from the training version code on the fly. TMVA::Met",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:34830,Modifiability,variab,variable,34830,"(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expressions of input variables. { return DataInfo().GetVariableInfo(i).GetInternalName(); }. const TString& GetInputLabel(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetLabel(); }. const TString& GetInputTitle(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetTitle(); }. Double_t GetMean(Int_t ivar) const; normalisation and limit accessors. { return GetTransformationHandler().GetMean(ivar); }. Double_t GetRMS(Int_t ivar) const; { return GetTransformationHandler().GetRMS(ivar); }. Double_t GetXmin(Int_t ivar) const; { return GetTransformationHandler().GetMin(ivar); }. Double_t GetXmax(Int_t ivar) const; { return GetTransformationHandler().GetMax(ivar); }. Double_t GetSignalReferenceCut() const; sets ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:35118,Modifiability,variab,variables,35118,"accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expressions of input variables. { return DataInfo().GetVariableInfo(i).GetInternalName(); }. const TString& GetInputLabel(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetLabel(); }. const TString& GetInputTitle(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetTitle(); }. Double_t GetMean(Int_t ivar) const; normalisation and limit accessors. { return GetTransformationHandler().GetMean(ivar); }. Double_t GetRMS(Int_t ivar) const; { return GetTransformationHandler().GetRMS(ivar); }. Double_t GetXmin(Int_t ivar) const; { return GetTransformationHandler().GetMin(ivar); }. Double_t GetXmax(Int_t ivar) const; { return GetTransformationHandler().GetMax(ivar); }. Double_t GetSignalReferenceCut() const; sets the minimum requirement on the MVA output to declare an event signal-like. { return fSignalReferenceCut; }. Double_t GetSignalReferenceCutOrientation() const; { return fSignalReferenceCutOrientation; }. void SetSignalReferenceCut(Double_t cut); sets the min",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:38085,Modifiability,variab,variables,38085,"onHandler(TMVA::TransformationHandler* fTargetTransformation); { fTransformationPointer=fTargetTransformation; }. DataSetInfo& DataInfo() const; { return fDataSetInfo; }. UInt_t GetNEvents() const; event reference and update; NOTE: these Event accessors make sure that you get the events transformed according to the; particular clasifiers transformation chosen. { return Data()->GetNEvents(); }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:38234,Modifiability,variab,variables,38234,"event reference and update; NOTE: these Event accessors make sure that you get the events transformed according to the; particular clasifiers transformation chosen. { return Data()->GetNEvents(); }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:38568,Modifiability,variab,variables,38568,"sisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Bool_t IsConstructedFromWeightFile() const; access to event information that needs method-specific information. { return fConstructedFromWeightFile; }. ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:474,Performance,perform,performance,474,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:646,Performance,perform,performance,646,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:11804,Performance,tune,tuneParameters,11804,"MENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteEv",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:23787,Performance,tune,tuned,23787," Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:23839,Performance,tune,tuneParameters,23839,"umber of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalRe",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:34081,Security,access,accessors,34081,"ptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expr",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:35448,Security,access,accessors,35448,"odType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expressions of input variables. { return DataInfo().GetVariableInfo(i).GetInternalName(); }. const TString& GetInputLabel(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetLabel(); }. const TString& GetInputTitle(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetTitle(); }. Double_t GetMean(Int_t ivar) const; normalisation and limit accessors. { return GetTransformationHandler().GetMean(ivar); }. Double_t GetRMS(Int_t ivar) const; { return GetTransformationHandler().GetRMS(ivar); }. Double_t GetXmin(Int_t ivar) const; { return GetTransformationHandler().GetMin(ivar); }. Double_t GetXmax(Int_t ivar) const; { return GetTransformationHandler().GetMax(ivar); }. Double_t GetSignalReferenceCut() const; sets the minimum requirement on the MVA output to declare an event signal-like. { return fSignalReferenceCut; }. Double_t GetSignalReferenceCutOrientation() const; { return fSignalReferenceCutOrientation; }. void SetSignalReferenceCut(Double_t cut); sets the minimum requirement on the MVA output to declare an event signal-like. { fSignalReferenceCut = cut; }. void SetSignalReferenceCutOrientation(Double_t cutOrientation); { fSignalReferenceCutOrientation = cutOrientation; }. void SetMethodDir(TDirectory* methodDir); { fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir)",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:37320,Security,access,accessors,37320," fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir); { fBaseDir = methodDir; }. void SetMethodBaseDir(TDirectory* methodDir); { fMethodBaseDir = methodDir; }. UInt_t GetTrainingTMVAVersionCode() const; the TMVA version can be obtained and checked using; if (GetTrainingTMVAVersionCode()>TMVA_VERSION(3,7,2)) {...}; or; if (GetTrainingROOTVersionCode()>ROOT_VERSION(5,15,5)) {...}. { return fTMVATrainingVersion; }. UInt_t GetTrainingROOTVersionCode() const; { return fROOTTrainingVersion; }. TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true). const TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const. void RerouteTransformationHandler(TMVA::TransformationHandler* fTargetTransformation); { fTransformationPointer=fTargetTransformation; }. DataSetInfo& DataInfo() const; { return fDataSetInfo; }. UInt_t GetNEvents() const; event reference and update; NOTE: these Event accessors make sure that you get the events transformed according to the; particular clasifiers transformation chosen. { return Data()->GetNEvents(); }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:38512,Security,access,accessors,38512,"sisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Bool_t IsConstructedFromWeightFile() const; access to event information that needs method-specific information. { return fConstructedFromWeightFile; }. ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:39358,Security,access,access,39358,"(only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Bool_t IsConstructedFromWeightFile() const; access to event information that needs method-specific information. { return fConstructedFromWeightFile; }. ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. Bool_t IgnoreEventsWithNegWeightsInTraining() const; { return fIgnoreNegWeightsInTraining; }. MethodBase*& GetThisBaseThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodBase*) fgThisBase(nullptr); return fgThisBase; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:605,Testability,benchmark,benchmark,605,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:698,Testability,test,test,698,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructo",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:11660,Testability,test,testTime,11660,"rmation); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:15282,Testability,log,log,15282,"ing fileDir); voidSetWeightFileName(TString); voidStatistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTxtWeightsOnly() const; Bool_tVerbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidAddClassesXMLTo(void* parent) const; virtual voidAddClassifierOutput(TMVA::Types::ETreeType type); virtual voidAddClassifierOutputProb(TMVA::Types::ETreeType type); voidAddInfoItem(void* gi, const TString& name, const TString& value) const; virtual voidAddMulticlassOutput(TMVA::Types::ETreeType type); virtual voidAddRegressionOutput(TMVA::Types::ETreeType type); voidAddSpectatorsXMLTo(void* parent) const; voidAddTargetsXMLTo(void* parent) const; voidAddVarsXMLTo(void* parent) const; voidCreateMVAPdfs(); static voidCreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); voidDeclareBaseOptions(); TMVA::MethodBase::ECutOrientationGetCutOrientation() const; Double_tGetEffForRoot(Double_t); Bool_tGetLine(istream& fin, char* buf); static TMVA::MethodBase*&GetThisBaseThreadLocal(); static Double_tIGetEffForRoot(Double_t); voidInitBase(); voidProcessBaseOptions(); voidReadClassesFromXML(void* clsnode); voidReadSpectatorsFromXML(void* specnode); voidReadStateFromXML(void* parent); voidReadTargetsFromXML(void* tarnode); voidReadVariablesFromXML(void* varnode); voidReadVarsFromStream(istream& istr); voidResetThisBase(); voidWriteStateToStream(ostream& tf) const; voidWriteStateToXML(void* parent) const; voidWriteVarsToStream(ostream& tf, const TString& prefix = """") const. Data Members; public:. Bool_tfSetupCompletedis method setup; const TMVA::Event*fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; s",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:16104,Testability,test,testing,16104,"; static Double_tIGetEffForRoot(Double_t); voidInitBase(); voidProcessBaseOptions(); voidReadClassesFromXML(void* clsnode); voidReadSpectatorsFromXML(void* specnode); voidReadStateFromXML(void* parent); voidReadTargetsFromXML(void* tarnode); voidReadVariablesFromXML(void* varnode); voidReadVarsFromStream(istream& istr); voidResetThisBase(); voidWriteStateToStream(ostream& tf) const; voidWriteStateToXML(void* parent) const; voidWriteVarsToStream(ostream& tf, const TString& prefix = """") const. Data Members; public:. Bool_tfSetupCompletedis method setup; const TMVA::Event*fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypekROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypekTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypefAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tfBackgroundClassindex of the Background-class; vector<TString>*fInputVarsvector of input variables used in MVA; vector<Float_t>*fMulticlassReturnValholds the return-values for the multiclass classification; Int_tfNbinsnumber of bins in input variable histograms; Int_tfNbinsHnumber of bins in evaluation histograms; Int_tfNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*fRankingp",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:23293,Testability,log,log,23293,"g phase). void InitBase(); default initialization called by all constructors. void DeclareBaseOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:25538,Testability,test,test,25538," variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteSt",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:25658,Testability,test,test,25658,"tSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStat",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:32900,Testability,test,testTime,32900,"tring from the training version code on the fly. TMVA::MethodBase* GetThisBase(); return a pointer the base class of this method. void ResetThisBase(); reset required for RootFinder. Double_t GetKSTrainingVsTest(Char_t SorB, TString opt = ""X""). const TMVA::Event* GetEvent(const TMVA::Event* ev) const. const TMVA::Event* GetEvent() const. const TMVA::Event* GetEvent(Long64_t ievt) const. const TMVA::Event* GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const. const TMVA::Event* GetTrainingEvent(Long64_t ievt) const. const TMVA::Event* GetTestingEvent(Long64_t ievt) const. MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); default constructur. void Train(). void SetTrainTime(Double_t trainTime); store and retrieve time used for training. { fTrainTime = trainTime; }. Double_t GetTrainTime() const; { return fTrainTime; }. void SetTestTime(Double_t testTime); store and retrieve time used for testing. { fTestTime = testTime; }. Double_t GetTestTime() const; { return fTestTime; }. void Init(); options treatment. void DeclareOptions(). void ProcessOptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void R",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:32944,Testability,test,testing,32944,"tring from the training version code on the fly. TMVA::MethodBase* GetThisBase(); return a pointer the base class of this method. void ResetThisBase(); reset required for RootFinder. Double_t GetKSTrainingVsTest(Char_t SorB, TString opt = ""X""). const TMVA::Event* GetEvent(const TMVA::Event* ev) const. const TMVA::Event* GetEvent() const. const TMVA::Event* GetEvent(Long64_t ievt) const. const TMVA::Event* GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const. const TMVA::Event* GetTrainingEvent(Long64_t ievt) const. const TMVA::Event* GetTestingEvent(Long64_t ievt) const. MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); default constructur. void Train(). void SetTrainTime(Double_t trainTime); store and retrieve time used for training. { fTrainTime = trainTime; }. Double_t GetTrainTime() const; { return fTrainTime; }. void SetTestTime(Double_t testTime); store and retrieve time used for testing. { fTestTime = testTime; }. Double_t GetTestTime() const; { return fTestTime; }. void Init(); options treatment. void DeclareOptions(). void ProcessOptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void R",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:32967,Testability,test,testTime,32967,"::MethodBase* GetThisBase(); return a pointer the base class of this method. void ResetThisBase(); reset required for RootFinder. Double_t GetKSTrainingVsTest(Char_t SorB, TString opt = ""X""). const TMVA::Event* GetEvent(const TMVA::Event* ev) const. const TMVA::Event* GetEvent() const. const TMVA::Event* GetEvent(Long64_t ievt) const. const TMVA::Event* GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const. const TMVA::Event* GetTrainingEvent(Long64_t ievt) const. const TMVA::Event* GetTestingEvent(Long64_t ievt) const. MethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); default constructur. void Train(). void SetTrainTime(Double_t trainTime); store and retrieve time used for training. { fTrainTime = trainTime; }. Double_t GetTrainTime() const; { return fTrainTime; }. void SetTestTime(Double_t testTime); store and retrieve time used for testing. { fTestTime = testTime; }. Double_t GetTestTime() const; { return fTestTime; }. void Init(); options treatment. void DeclareOptions(). void ProcessOptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFr",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBase.html:28770,Usability,simpl,simple,28770,") const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* buf); reads one line from the input stream; checks for certain keywords and interprets; the line if keywords are found. void CreateMVAPdfs(); Create PDFs of the MVA output variables. Double_t GetProba(const TMVA::Event* ev); the simple one, automatically calcualtes the mvaVal and uses the; SAME sig/bkg ratio as given in the training sample (typically 50/50; .. (NormMode=EqualNumEvents) but can be different). Double_t GetProba(Double_t mvaVal, Double_t ap_sig); compute likelihood ratio. Double_t GetRarity(Double_t mvaVal, TMVA::Types::ESBType reftype = Types::kBackground) const; compute rarity:; R(x) = Integrate_[-oo..x] { PDF(x') dx' }; where PDF(x) is the PDF of the classifier's signal or background distribution. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& err); fill background efficiency (resp. rejection) versus signal efficiency plots; returns signal efficiency at background efficiency indicated in theString. Double_t GetTrainingEfficiency(const TString& ). std::vector<Float_t> GetMulticlassEfficiency(vector<vector<Float_t> >& purity). std::vector<Float_t> GetMulticlassTrainingEfficiency(vector<vector<Float_t> >& purity). Double_t GetSignificance( void ); compute significance of mean difference; significance = |<S> - <",MatchSource.WIKI,root/html604/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:2248,Availability,error,error,2248,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:2332,Availability,error,error,2332,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:18094,Availability,avail,availabel,18094,"odBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with 2 classes. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodBayesClassifier( void ); destructor. void Train( void ); some training. void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromStream(istream& istr); read back the training results from a file (stream). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). void ReadWeightsFromXML(void* ); {}. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Abhishek Narain » Copyright (c) 2005-2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-0",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:18583,Integrability,message,message,18583,"ression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with 2 classes. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodBayesClassifier( void ); destructor. void Train( void ); some training. void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromStream(istream& istr); read back the training results from a file (stream). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). void ReadWeightsFromXML(void* ); {}. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Abhishek Narain » Copyright (c) 2005-2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:16700,Modifiability,variab,variables,16700,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with ",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:16889,Modifiability,variab,variable,16889,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with ",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:18945,Modifiability,variab,variables,18945,"ression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with 2 classes. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodBayesClassifier( void ); destructor. void Train( void ); some training. void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromStream(istream& istr); read back the training results from a file (stream). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). void ReadWeightsFromXML(void* ); {}. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Abhishek Narain » Copyright (c) 2005-2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:12278,Performance,tune,tuneParameters,12278,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:12080,Testability,test,testTime,12080,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBayesClassifier.html:15529,Testability,test,testing,15529,"::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBayesClassifier.html
https://root.cern/root/html604/TMVA__MethodBDT.html:2767,Availability,error,error,2767,"ructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as sign",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:5946,Availability,error,error,5946,"igurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const vector<double>&GetBoostWeights() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::M",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:6030,Availability,error,error,6030,"gurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const vector<double>&GetBoostWeights() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:23737,Availability,error,error,23737,"ool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfCbbCost factor; Double_tfCssCost factor; Double_tfCtb_ssCost factor; Double_tfCts_sbCost factor; Bool_tfDoBoostMonitorcreate control plot with ROC integral vs tree number; Bool_tfDoPreselectiondo or do not perform automatic pre-selection of 100% eff. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*>fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions""; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight rathre than boostweight; vector<Bool_t>fIsHighBkgCut; vector<Bool_t>fIsHighSigCut; vector<Bool_t>fIsLowBkgCut; vector<Bool_t>fIsLowSigCut; vector<Double_t>fLowBkgCut; vector<Double_t>fLowSigCut; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; TTree*fMonitorNtuplemonitoring ntuple; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNTreesnumber of decision trees requested; T",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:26292,Availability,down,down,26292,"purity limit for sig/bkg nodes; Bool_tfPairNegWeightsGlobalpair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; map<const TMVA::Event*,vector<double> >fResidualsindividual event residuals for gradient boost; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; Double_tfShrinkagelearning rate for gradient boost;; Double_tfSigToBkgFractionSignal to Background fraction assumed during training; vector<const TMVA::Event*>fSubSamplesubsample for bagged grad boost; Double_tfSumOfWeightssum of all event weights; vector<const TMVA::Event*>*fTrainSamplepointer to sample actually used in training (fEventSample or fSubSample) for example; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<const TMVA::Event*>fValidationSamplethe Validation events; vector<Double_t>fVariableImportancethe relative importance of the different variables; map<const TMVA::Event*,pair<Double_t,Double_t> >fWeightedResidualsweighte",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:29119,Availability,error,error,29119," type, UInt_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..); known: AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost; AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal P",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:30024,Availability,avail,available,30024,"purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search t",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:33906,Availability,error,error,33906,"he training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into account when calculating the misclass. cost (former: error fraction):. err = sum_events ( weight* y_true*y_sel * beta(event). Double_t Bagging(); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" poisson weights to each event. void GetBaggedSubSample(vector<const TMVA::Event*>& ); fills fEventSample with fBaggedSampleFraction*NEvents random training events. Double_t RegBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H.Drucker 1997). void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* parent); reads the BDT from the xml file. void ReadWeightsFromStream(istream& istr); read the weights (BDT coefficients). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). Double_t GetMvaValue(Double_t* err, Double_t* errUpper, U",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:31768,Deployability,update,update,31768,"). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. Double_t GetGradBoostMVA(const TMVA::Event* e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:2139,Energy Efficiency,adapt,adaptive,2139,"g the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Fo",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:32881,Energy Efficiency,monitor,monitoring,32881,"ouble_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into ac",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:34499,Energy Efficiency,adapt,adaption,34499,"(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into account when calculating the misclass. cost (former: error fraction):. err = sum_events ( weight* y_true*y_sel * beta(event). Double_t Bagging(); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" poisson weights to each event. void GetBaggedSubSample(vector<const TMVA::Event*>& ); fills fEventSample with fBaggedSampleFraction*NEvents random training events. Double_t RegBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H.Drucker 1997). void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* parent); reads the BDT from the xml file. void ReadWeightsFromStream(istream& istr); read the weights (BDT coefficients). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). Double_t GetMvaValue(Double_t* err, Double_t* errUpper, UInt_t useNTrees); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regressi",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:3725,Integrability,depend,depending,3725,"termined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection. Function Members (Methods); public:. virtual~MethodBDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Double_tBoost(vector<const TMVA::Event*>&, TMVA::DecisionTree* dt, UInt_t cls = 0); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtua",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:30826,Integrability,rout,routine,30826,"d compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. Double_t GetGradBoostMVA(const TMVA::Event* e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quant",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:36259,Integrability,message,message,36259,"ding to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursively descends a tree and writes the node instance to the output streem. void DeterminePreselectionCuts(const vector<const TMVA::Event*>& eventSample); find useful preselection cuts that will be applied before; and Decision Tree training.. (and of course also applied; in the GetMVA .. --> -1 for background +1 for Signal; /*. Double_t ApplyPreselectionCuts(const TMVA::Event* ev); aply the preselection cuts before even bothing about any; Decision Trees in the GetMVA .. --> -1 for background +1 for Signal. const std::vecto",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:904,Modifiability,variab,variable,904,". TMVA::MethodBDT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBDT. class TMVA::MethodBDT: public TMVA::MethodBase. Analysis of Boosted Decision Trees. Boosted decision trees have been successfully used in High Energy; Physics analysis for example by the MiniBooNE experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. Decision trees:. Successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then calle",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:1440,Modifiability,variab,variable,1440,"experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. Decision trees:. Successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting ",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:2139,Modifiability,adapt,adaptive,2139,"g the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Fo",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:3409,Modifiability,variab,variables,3409,"t leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection. Function Members (Methods); public:. virtual~MethodBDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); vi",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:22137,Modifiability,variab,variables,22137,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightnt",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:22326,Modifiability,variab,variable,22326,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightnt",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:24031,Modifiability,variab,variable,24031,"ool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfCbbCost factor; Double_tfCssCost factor; Double_tfCtb_ssCost factor; Double_tfCts_sbCost factor; Bool_tfDoBoostMonitorcreate control plot with ROC integral vs tree number; Bool_tfDoPreselectiondo or do not perform automatic pre-selection of 100% eff. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*>fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions""; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight rathre than boostweight; vector<Bool_t>fIsHighBkgCut; vector<Bool_t>fIsHighSigCut; vector<Bool_t>fIsLowBkgCut; vector<Bool_t>fIsLowSigCut; vector<Double_t>fLowBkgCut; vector<Double_t>fLowSigCut; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; TTree*fMonitorNtuplemonitoring ntuple; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNTreesnumber of decision trees requested; T",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:24482,Modifiability,variab,variables,24482,"f. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*>fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions""; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight rathre than boostweight; vector<Bool_t>fIsHighBkgCut; vector<Bool_t>fIsHighSigCut; vector<Bool_t>fIsLowBkgCut; vector<Bool_t>fIsLowSigCut; vector<Double_t>fLowBkgCut; vector<Double_t>fLowSigCut; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; TTree*fMonitorNtuplemonitoring ntuple; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNTreesnumber of decision trees requested; TStringfNegWeightTreatmentvariable that holds the option of how to treat negative event weights in training; Bool_tfNoNegWeightsInTrainingignore negative event weights in the training; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPairNegWeightsGlobalpair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; map<const TMVA::Event*,vector<double> >fResidualsindividual event residuals for gradient boost; TMVA::Separation",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:25524,Modifiability,variab,variables,25524,"purity limit for sig/bkg nodes; Bool_tfPairNegWeightsGlobalpair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; map<const TMVA::Event*,vector<double> >fResidualsindividual event residuals for gradient boost; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; Double_tfShrinkagelearning rate for gradient boost;; Double_tfSigToBkgFractionSignal to Background fraction assumed during training; vector<const TMVA::Event*>fSubSamplesubsample for bagged grad boost; Double_tfSumOfWeightssum of all event weights; vector<const TMVA::Event*>*fTrainSamplepointer to sample actually used in training (fEventSample or fSubSample) for example; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<const TMVA::Event*>fValidationSamplethe Validation events; vector<Double_t>fVariableImportancethe relative importance of the different variables; map<const TMVA::Event*,pair<Double_t,Double_t> >fWeightedResidualsweighte",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:26362,Modifiability,variab,variables,26362,"purity limit for sig/bkg nodes; Bool_tfPairNegWeightsGlobalpair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; map<const TMVA::Event*,vector<double> >fResidualsindividual event residuals for gradient boost; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; Double_tfShrinkagelearning rate for gradient boost;; Double_tfSigToBkgFractionSignal to Background fraction assumed during training; vector<const TMVA::Event*>fSubSamplesubsample for bagged grad boost; Double_tfSumOfWeightssum of all event weights; vector<const TMVA::Event*>*fTrainSamplepointer to sample actually used in training (fEventSample or fSubSample) for example; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<const TMVA::Event*>fValidationSamplethe Validation events; vector<Double_t>fVariableImportancethe relative importance of the different variables; map<const TMVA::Event*,pair<Double_t,Double_t> >fWeightedResidualsweighte",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:26667,Modifiability,variab,variables,26667,"purity limit for sig/bkg nodes; Bool_tfPairNegWeightsGlobalpair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; map<const TMVA::Event*,vector<double> >fResidualsindividual event residuals for gradient boost; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; Double_tfShrinkagelearning rate for gradient boost;; Double_tfSigToBkgFractionSignal to Background fraction assumed during training; vector<const TMVA::Event*>fSubSamplesubsample for bagged grad boost; Double_tfSumOfWeightssum of all event weights; vector<const TMVA::Event*>*fTrainSamplepointer to sample actually used in training (fEventSample or fSubSample) for example; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<const TMVA::Event*>fValidationSamplethe Validation events; vector<Double_t>fVariableImportancethe relative importance of the different variables; map<const TMVA::Event*,pair<Double_t,Double_t> >fWeightedResidualsweighte",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:27039,Modifiability,variab,variables,27039,"htssum of all event weights; vector<const TMVA::Event*>*fTrainSamplepointer to sample actually used in training (fEventSample or fSubSample) for example; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<const TMVA::Event*>fValidationSamplethe Validation events; vector<Double_t>fVariableImportancethe relative importance of the different variables; map<const TMVA::Event*,pair<Double_t,Double_t> >fWeightedResidualsweighted regression residuals; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for the ""boosted decision trees"". MethodBDT(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boos",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:28274,Modifiability,variab,variables,28274," type, UInt_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..); known: AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost; AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal P",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:28307,Modifiability,variab,variables,28307," type, UInt_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..); known: AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost; AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal P",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:34499,Modifiability,adapt,adaption,34499,"(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into account when calculating the misclass. cost (former: error fraction):. err = sum_events ( weight* y_true*y_sel * beta(event). Double_t Bagging(); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" poisson weights to each event. void GetBaggedSubSample(vector<const TMVA::Event*>& ); fills fEventSample with fBaggedSampleFraction*NEvents random training events. Double_t RegBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H.Drucker 1997). void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* parent); reads the BDT from the xml file. void ReadWeightsFromStream(istream& istr); read the weights (BDT coefficients). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). Double_t GetMvaValue(Double_t* err, Double_t* errUpper, UInt_t useNTrees); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regressi",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:35714,Modifiability,variab,variable,35714,"omStream(istream& istr); read the weights (BDT coefficients). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). Double_t GetMvaValue(Double_t* err, Double_t* errUpper, UInt_t useNTrees); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursiv",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:35754,Modifiability,variab,variables,35754,"omStream(istream& istr); read the weights (BDT coefficients). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). Double_t GetMvaValue(Double_t* err, Double_t* errUpper, UInt_t useNTrees); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursiv",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:35866,Modifiability,variab,variable,35866,"lue(Double_t* err, Double_t* errUpper, UInt_t useNTrees); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursively descends a tree and writes the node instance to the output streem. void DeterminePreselectionCuts(const vector<const TMVA::Event*>& eventSam",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:36011,Modifiability,variab,variable,36011,"of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursively descends a tree and writes the node instance to the output streem. void DeterminePreselectionCuts(const vector<const TMVA::Event*>& eventSample); find useful preselection cuts that will be applied before; and Decision Tree training.. (and of course also applied; in the GetMVA .. --> -1 for background +1 for Signal",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:36034,Modifiability,variab,variable,36034,"of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursively descends a tree and writes the node instance to the output streem. void DeterminePreselectionCuts(const vector<const TMVA::Event*>& eventSample); find useful preselection cuts that will be applied before; and Decision Tree training.. (and of course also applied; in the GetMVA .. --> -1 for background +1 for Signal",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:36125,Modifiability,variab,variable,36125,"of; decision trees. Double_t PrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursively descends a tree and writes the node instance to the output streem. void DeterminePreselectionCuts(const vector<const TMVA::Event*>& eventSample); find useful preselection cuts that will be applied before; and Decision Tree training.. (and of course also applied; in the GetMVA .. --> -1 for background +1 for Signal",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:36210,Modifiability,variab,variables,36210,"n the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the BDTs. void WriteMonitoringHistosToFile( void ); Here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); Return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); Returns the measure for the variable importance of variable ""ivar""; which is later used in GetVariableImportance() to calculate the; relative variable importances. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void MakeClassSpecificHeader(ostream& , const TString& ) const; specific class header. void MakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; recursively descends a tree and writes the node instance to the output streem. void DeterminePreselectionCuts(const vector<const TMVA::Event*>& eventSample); find useful preselection cuts that will be applied before; and Decision Tree training.. (and of course also applied; in the GetMVA .. --> -1 for background +1 for Signal; /*. Double_t ApplyPreselectionCuts(const TMVA::Event* ev); aply the preselection cuts before even bothing about any; Decision Trees in the ",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:16547,Performance,tune,tuneParameters,16547,"figurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxDepth(Int_t d); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidSetMinNodeSize(Double_t sizeInPercent); voidSetMinNodeSize(TString sizeInPercent); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNodePurityLimit(Double_t l); voidSetNTrees(Int_t d); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetShrinkage(Double_t s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); voidSetUseNvars(Int_t n); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const ch",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:23634,Performance,perform,perform,23634,"e return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfCbbCost factor; Double_tfCssCost factor; Double_tfCtb_ssCost factor; Double_tfCts_sbCost factor; Bool_tfDoBoostMonitorcreate control plot with ROC integral vs tree number; Bool_tfDoPreselectiondo or do not perform automatic pre-selection of 100% eff. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*>fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions""; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight rathre than boostweight; vector<B",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:29412,Performance,optimiz,optimizing,29412,"n distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor; Note: fEventSample and ValidationSample are alread",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:31273,Performance,tune,tuned,31273,"initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. Double_t GetGradBoostMVA(const TMVA::Event* e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value ",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:31325,Performance,tune,tuneParameters,31325,"dBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. Double_t GetGradBoostMVA(const TMVA::Event* e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss functi",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:29355,Safety,avoid,avoided,29355,"es; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~Met",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:23000,Security,validat,validation,23000,"e return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfCbbCost factor; Double_tfCssCost factor; Double_tfCtb_ssCost factor; Double_tfCts_sbCost factor; Bool_tfDoBoostMonitorcreate control plot with ROC integral vs tree number; Bool_tfDoPreselectiondo or do not perform automatic pre-selection of 100% eff. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*>fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions""; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight rathre than boostweight; vector<B",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:2792,Testability,log,log,2792,"ructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as sign",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:3523,Testability,test,test,3523," set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection. Function Members (Methods); public:. virtual~MethodBDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Double_tBoost(vector<const TMVA::Event*>&, TMVA::DecisionTree* dt",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:16367,Testability,test,testTime,16367,"SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxDepth(Int_t d); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidSetMinNodeSize(Double_t sizeInPercent); voidSetMinNodeSize(TString sizeInPercent); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNodePurityLimit(Double_t l); voidSetNTrees(Int_t d); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetShrinkage(Double_t s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); voidSetUseNvars(Int_t n); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTM",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:20966,Testability,test,testing,20966,"VA::DecisionTree* dt); virtual voidInit(); voidInitGradBoost(vector<const TMVA::Event*>&); voidPreProcessNegativeEventWeights(); Double_tPrivateGetMvaValue(const TMVA::Event* ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Double_tRegBoost(vector<const TMVA::Event*>&, TMVA::DecisionTree* dt); voidUpdateTargets(vector<const TMVA::Event*>&, UInt_t cls = 0); voidUpdateTargetsRegression(vector<const TMVA::Event*>&, Bool_t first = kFALSE). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:32504,Testability,test,test,32504,"rns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(v",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:32862,Testability,test,testSample,32862,"ouble_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into ac",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:32936,Testability,test,testing,32936,"ates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into account when calculating the misclass. cost (former: error fraction):. err = sum_ev",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:3124,Usability,simpl,simple,3124," the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection. Function Members (Methods); public:. v",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:28911,Usability,simpl,simply,28911," type, UInt_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..); known: AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost; AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal P",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBDT.html:33583,Usability,simpl,simple,33583,"tion. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into account when calculating the misclass. cost (former: error fraction):. err = sum_events ( weight* y_true*y_sel * beta(event). Double_t Bagging(); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" poisson weights to each event. void GetBaggedSubSample(vector<const TMVA::Event*>& ); fills fEventSample with fBaggedSampleFraction*NEvents random training events. Double_t RegBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H",MatchSource.WIKI,root/html604/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBDT.html
https://root.cern/root/html604/TMVA__MethodBoost.html:2428,Availability,error,error,2428,"Object* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetBoostNum(); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:2512,Availability,error,error,2512,"& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetBoostNum(); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::Method",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:20351,Availability,error,error,20351,"r to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions""; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions""; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); d",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:20040,Energy Efficiency,monitor,monitoring,20040,"r to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions""; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions""; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); d",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:20475,Energy Efficiency,monitor,monitor,20475,"r to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions""; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions""; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); d",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:23951,Energy Efficiency,monitor,monitoring,23951,"Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:24157,Energy Efficiency,monitor,monitoring,24157,"rlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:21938,Integrability,rout,routine,21938,"udes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); Boost can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(). void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. Bool_t BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); just registering the string from which the boosted classifier will be created. void Init(). void InitHistos(); initialisation routine. void CheckSetup(). void Train(). void CleanBoostOptions(). void CreateMVAHistorgrams(). void ResetBoostWeights(); resetting back the boosted weights of the events to 1. void WriteMonitoringHistosToFile( void ). void TestClassification(). void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype). void ProcessOptions(); process user options. void SingleTrain(); initialization. void FindMVACut(TMVA::MethodBase* method); find the CUT on the individual MVA that defines an event as; correct or misclassified (to be used in the boosting process). Double_t SingleBoost(TMVA::MethodBase* method). Double_t AdaBoost(TMVA::MethodBase* method, Bool_t useYesNoLeaf); the standard (discrete or real) AdaBoost algorithm. Double_t Bagging(); Bagging or Bootstrap boosting, gives new random poisson weight for every event. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const TMV",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:22804,Integrability,message,message,22804," TString theOption); just registering the string from which the boosted classifier will be created. void Init(). void InitHistos(); initialisation routine. void CheckSetup(). void Train(). void CleanBoostOptions(). void CreateMVAHistorgrams(). void ResetBoostWeights(); resetting back the boosted weights of the events to 1. void WriteMonitoringHistosToFile( void ). void TestClassification(). void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype). void ProcessOptions(); process user options. void SingleTrain(); initialization. void FindMVACut(TMVA::MethodBase* method); find the CUT on the individual MVA that defines an event as; correct or misclassified (to be used in the boosting process). Double_t SingleBoost(TMVA::MethodBase* method). Double_t AdaBoost(TMVA::MethodBase* method, Bool_t useYesNoLeaf); the standard (discrete or real) AdaBoost algorithm. Double_t Bagging(); Bagging or Bootstrap boosting, gives new random poisson weight for every event. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const TMVA::Ranking* CreateRanking(). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Ca",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:24065,Integrability,depend,depends,24065,"rlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:18701,Modifiability,variab,variables,18701,"tMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<TMVA::IMethod*>TMVA::MethodCompositeBase::fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMet",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:19032,Modifiability,variab,variable,19032,"tMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<TMVA::IMethod*>TMVA::MethodCompositeBase::fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMet",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:20110,Modifiability,variab,variable,20110,"r to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions""; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions""; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); d",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:20191,Modifiability,variab,variable,20191,"r to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions""; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions""; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); d",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:520,Performance,perform,performed,520,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBa",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:13002,Performance,tune,tuneParameters,13002,"ct::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoostedMethodName(TString methodName); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t b",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:538,Testability,test,test,538,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBa",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:12804,Testability,test,testTime,12804,"t::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoostedMethodName(TString methodName); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const cha",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:17418,Testability,test,testing,17418,"rtual voidInit(); voidInitHistos(); voidMonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); voidPrintResults(const TString&, vector<Double_t>&, const Double_t) const; virtual voidProcessOptions(); voidResetBoostWeights(); Double_tSingleBoost(TMVA::MethodBase* method); voidSingleTrain(); virtual voidTestClassification(); virtual voidWriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); virtual voidWriteMonitoringHistosToFile() const. Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<TMVA::IMethod*>TMVA::",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodBoost.html:23266,Testability,test,testing,23266,"(); process user options. void SingleTrain(); initialization. void FindMVACut(TMVA::MethodBase* method); find the CUT on the individual MVA that defines an event as; correct or misclassified (to be used in the boosting process). Double_t SingleBoost(TMVA::MethodBase* method). Double_t AdaBoost(TMVA::MethodBase* method, Bool_t useYesNoLeaf); the standard (discrete or real) AdaBoost algorithm. Double_t Bagging(); Bagging or Bootstrap boosting, gives new random poisson weight for every event. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const TMVA::Ranking* CreateRanking(). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetIn",MatchSource.WIKI,root/html604/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html
https://root.cern/root/html604/TMVA__MethodCategory.html:2584,Availability,error,error,2584,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:2668,Availability,error,error,2668,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:20743,Integrability,message,message,20743,"tor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); check whether method category has analysis type; the method type has to be the same for all sub-methods. void DeclareOptions(); options for this method. TMVA::IMethod* AddMethod(const TCut& , const TString& theVariables, TMVA::Types::EMVA theMethod, const TString& theTitle, const TString& theOptions); adds sub-classifier for a category. TMVA::DataSetInfo& CreateCategoryDSI(const TCut& , const TString& , const TString& ); create a DataSetInfo object for a sub-classifier. void Init(); initialize the method. void InitCircularTree(const TMVA::DataSetInfo& dsi); initialize the circular tree. void Train(); train all sub-classifiers. void AddWeightsXMLTo(void* parent) const; create XML description of Category classifier. void ReadWeightsFromXML(void* wghtnode); read weights of sub-classifiers of MethodCategory from xml weight file. void ProcessOptions(); process user options. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const TMVA::Ranking* CreateRanking(); no ranking. Bool_t PassesCut(const TMVA::Event* ev, UInt_t methodIdx). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the mva value of the right sub-classifier. const std::vector<Float_t> & GetRegressionValues(); returns the mva value of the right sub-classifier. MethodCategory(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void MakeClass(const TString& = TString("""")) const; {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:473,Modifiability,variab,variab,473,". TMVA::MethodCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCategory. class TMVA::MethodCategory: public TMVA::MethodCompositeBase. This class is meant to allow categorisation of the data. For different; categories, different classifiers may be booked and different variab-; les may be considered. The aim is to account for the difference that; is due to different locations/angles. Function Members (Methods); public:. virtual~MethodCategory(); voidTObject::AbstractMethod(const char* method) const; TMVA::IMethod*AddMethod(const TCut&, const TString& theVariables, TMVA::Types::EMVA theMethod, const TString& theTitle, const TString& theOptions); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t*",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:18254,Modifiability,variab,variables,18254,"StatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TCut>fCategoryCuts; vector<UInt_t>fCategorySpecIdx; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<TMVA::IMethod*>fMethods; vector<TMVA::IMethod*>TMVA::MethodCompositeBase::fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; vector<vector<UInt_t> >fVarMaps; vector<TString>fVars. private:. vector<TTreeFormula*>fCatFormulas; TTree*fCatTree! needed in conjunction with TTreeFormulas for evaluation category expressions; TMVA::DataSetManager*fDataSetManagerDSMTEST. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCategory(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& the",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:18617,Modifiability,variab,variable,18617,"StatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TCut>fCategoryCuts; vector<UInt_t>fCategorySpecIdx; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<TMVA::IMethod*>fMethods; vector<TMVA::IMethod*>TMVA::MethodCompositeBase::fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; vector<vector<UInt_t> >fVarMaps; vector<TString>fVars. private:. vector<TTreeFormula*>fCatFormulas; TTree*fCatTree! needed in conjunction with TTreeFormulas for evaluation category expressions; TMVA::DataSetManager*fDataSetManagerDSMTEST. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCategory(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& the",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:12953,Performance,tune,tuneParameters,12953,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:12755,Testability,test,testTime,12755,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCategory.html:16912,Testability,test,testing,16912,"s::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); virtual voidInit(); voidInitCircularTree(const TMVA::DataSetInfo& dsi); Bool_tPassesCut(const TMVA::Event* ev, UInt_t methodIdx); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TCut>fCategoryCuts; vector<UInt_t>fCategorySpecIdx; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::Metho",MatchSource.WIKI,root/html604/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCategory.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:3621,Availability,error,error,3621,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetClass(Int_t ivar) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetData(Int_t isel, Int_t ivar) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:3705,Availability,error,error,3705,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetClass(Int_t ivar) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetData(Int_t isel, Int_t ivar) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:1574,Energy Efficiency,power,power,1574,"ropagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:23634,Energy Efficiency,reduce,reduced,23634,"cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input varia",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:24972,Integrability,interface,interface,24972,"NN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { re",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:25551,Integrability,message,message,25551,"-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:626,Modifiability,variab,variables,626,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:770,Modifiability,layers,layers,770,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:783,Modifiability,variab,variable,783,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:812,Modifiability,layers,layers,812,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:900,Modifiability,layers,layers,900,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:949,Modifiability,layers,layers,949,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:963,Modifiability,config,configured,963,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ET",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:20471,Modifiability,variab,variables,20471,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Int_t>*fClassthe event class (1=signal, 2=background); struct(anonymous)TMVA::MethodCFMlpANN_Utils::fCost_1; TMatrixF*fDatathe (data,var) string; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fDel_1; TStringfLayerSpecthe hidden layer specification string; Int_tfNcyclesnumber of training cycles; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fNeur_1; Int_tfNlayersnumber of layers (including input and output layers); Int_t*fNodesnumber of nodes per layer; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fParam_1; VARn2TMVA::MethodCFMlpANN_Utils::fVar",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:20660,Modifiability,variab,variable,20660,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Int_t>*fClassthe event class (1=signal, 2=background); struct(anonymous)TMVA::MethodCFMlpANN_Utils::fCost_1; TMatrixF*fDatathe (data,var) string; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fDel_1; TStringfLayerSpecthe hidden layer specification string; Int_tfNcyclesnumber of training cycles; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fNeur_1; Int_tfNlayersnumber of layers (including input and output layers); Int_t*fNodesnumber of nodes per layer; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fParam_1; VARn2TMVA::MethodCFMlpANN_Utils::fVar",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:21481,Modifiability,layers,layers,21481,"::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Int_t>*fClassthe event class (1=signal, 2=background); struct(anonymous)TMVA::MethodCFMlpANN_Utils::fCost_1; TMatrixF*fDatathe (data,var) string; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fDel_1; TStringfLayerSpecthe hidden layer specification string; Int_tfNcyclesnumber of training cycles; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fNeur_1; Int_tfNlayersnumber of layers (including input and output layers); Int_t*fNodesnumber of nodes per layer; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fParam_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn2_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn3_1; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fVarn_1; Double_t**fYNNweights; static TMVA::MethodCFMlpANN*fgThisthis carrier; static Int_tTMVA::MethodCFMlpANN_Utils::fg_0constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_100constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_999constant; static const char*constTMVA::MethodCFMlpANN_Utils::fg_MethodNamemethod name for print; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nNodes_maximum number of nodes per variable; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nVar_static maximum number of input variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number o",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:21516,Modifiability,layers,layers,21516,"::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Int_t>*fClassthe event class (1=signal, 2=background); struct(anonymous)TMVA::MethodCFMlpANN_Utils::fCost_1; TMatrixF*fDatathe (data,var) string; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fDel_1; TStringfLayerSpecthe hidden layer specification string; Int_tfNcyclesnumber of training cycles; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fNeur_1; Int_tfNlayersnumber of layers (including input and output layers); Int_t*fNodesnumber of nodes per layer; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fParam_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn2_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn3_1; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fVarn_1; Double_t**fYNNweights; static TMVA::MethodCFMlpANN*fgThisthis carrier; static Int_tTMVA::MethodCFMlpANN_Utils::fg_0constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_100constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_999constant; static const char*constTMVA::MethodCFMlpANN_Utils::fg_MethodNamemethod name for print; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nNodes_maximum number of nodes per variable; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nVar_static maximum number of input variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number o",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:22171,Modifiability,variab,variable,22171,"::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Int_t>*fClassthe event class (1=signal, 2=background); struct(anonymous)TMVA::MethodCFMlpANN_Utils::fCost_1; TMatrixF*fDatathe (data,var) string; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fDel_1; TStringfLayerSpecthe hidden layer specification string; Int_tfNcyclesnumber of training cycles; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fNeur_1; Int_tfNlayersnumber of layers (including input and output layers); Int_t*fNodesnumber of nodes per layer; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fParam_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn2_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn3_1; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fVarn_1; Double_t**fYNNweights; static TMVA::MethodCFMlpANN*fgThisthis carrier; static Int_tTMVA::MethodCFMlpANN_Utils::fg_0constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_100constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_999constant; static const char*constTMVA::MethodCFMlpANN_Utils::fg_MethodNamemethod name for print; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nNodes_maximum number of nodes per variable; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nVar_static maximum number of input variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number o",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:22270,Modifiability,variab,variables,22270,"::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Int_t>*fClassthe event class (1=signal, 2=background); struct(anonymous)TMVA::MethodCFMlpANN_Utils::fCost_1; TMatrixF*fDatathe (data,var) string; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fDel_1; TStringfLayerSpecthe hidden layer specification string; Int_tfNcyclesnumber of training cycles; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fNeur_1; Int_tfNlayersnumber of layers (including input and output layers); Int_t*fNodesnumber of nodes per layer; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fParam_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn2_1; VARn2TMVA::MethodCFMlpANN_Utils::fVarn3_1; struct(anonymous)TMVA::MethodCFMlpANN_Utils::fVarn_1; Double_t**fYNNweights; static TMVA::MethodCFMlpANN*fgThisthis carrier; static Int_tTMVA::MethodCFMlpANN_Utils::fg_0constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_100constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_999constant; static const char*constTMVA::MethodCFMlpANN_Utils::fg_MethodNamemethod name for print; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nNodes_maximum number of nodes per variable; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nVar_static maximum number of input variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number o",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:22700,Modifiability,layers,layers,22700,"ct(anonymous)TMVA::MethodCFMlpANN_Utils::fVarn_1; Double_t**fYNNweights; static TMVA::MethodCFMlpANN*fgThisthis carrier; static Int_tTMVA::MethodCFMlpANN_Utils::fg_0constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_100constant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_999constant; static const char*constTMVA::MethodCFMlpANN_Utils::fg_MethodNamemethod name for print; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nNodes_maximum number of nodes per variable; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nVar_static maximum number of input variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA:",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:22937,Modifiability,variab,variables,22937,"stant; static Int_tTMVA::MethodCFMlpANN_Utils::fg_999constant; static const char*constTMVA::MethodCFMlpANN_Utils::fg_MethodNamemethod name for print; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nNodes_maximum number of nodes per variable; static const Int_tTMVA::MethodCFMlpANN_Utils::fg_max_nVar_static maximum number of input variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can hand",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:24179,Modifiability,layers,layers,24179,"ayer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeights",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:24633,Modifiability,variab,variables,24633," this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:26065,Modifiability,variab,variables,26065,"-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:1219,Performance,perform,performed,1219,"; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual v",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:13655,Performance,tune,tuneParameters,13655,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t b",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:23461,Performance,perform,performance,23461,"ectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output ",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:25885,Security,access,accessors,25885,"-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:13457,Testability,test,testTime,13457,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::Train",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:19300,Testability,test,testing,19300,"Int_t* nlayer, Int_t* nodes, Int_t* ncycle); Double_tTMVA::MethodCFMlpANN_Utils::W_ref(const Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3) const; Double_t&TMVA::MethodCFMlpANN_Utils::W_ref(Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3); voidTMVA::MethodCFMlpANN_Utils::Wini(); Double_tTMVA::MethodCFMlpANN_Utils::Ww_ref(const Double_t[] wwNN, Int_t a_1, Int_t a_2) const; Double_t&TMVA::MethodCFMlpANN_Utils::Ww_ref(Double_t[] wwNN, Int_t a_1, Int_t a_2). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:23278,Testability,test,tested,23278,"ries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:1711,Usability,learn,learning,1711,"s. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configu",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:744,Availability,avail,available,744,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(); TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(const TMVA::MethodCFMlpANN_Utils&); TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Doubl",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:4689,Availability,error,error,4689,"ts to be added]. void Leclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_arriere(Int_t* ievent); [smart comments to be added]. void Out(Int_t* iii, Int_t* maxcycle); write weights to file. void Innit(char* det, Double_t* tout2, Double_t* tin2, Int_t ); Initialization. void TestNN(); [smart comments to be added]. void Cout(Int_t* , Double_t* xxx); [smart comments to be added]. void Inl(); [smart comments to be added]. Double_t Fdecroi(Int_t* i__); [smart comments to be added]. void GraphNN(Int_t* ilearn, Double_t* , Double_t* , char* , Int_t ); [smart comments to be added]. Double_t Sen3a( void ); [smart comments to be added]. void Foncf(Int_t* i__, Double_t* u, Double_t* f); [needs to be checked]. void Cout2(Int_t* , Double_t* yyy); [smart comments to be added]. void Lecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_avant2(Int_t* ievent); [smart comments to be added]. void Arret(const char* mot); fatal error occurred: stop execution. void CollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); // [smart comments to be added]; Int_t i__1;. MethodCFMlpANN_Utils(). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ). Double_t W_ref(const Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3) const. Double_t& W_ref(Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3). Double_t Ww_ref(const Double_t[] wwNN, Int_t a_1, Int_t a_2) const. Double_t& Ww_ref(Double_t[] wwNN, Int_t a_1, Int_t a_2). Double_t operator=(const TMVA::MethodCFMlpANN_Utils& ); { return val; }. void SetLogger(TMVA::MsgLogger* l); { fLogger = l; }. MsgLogger& ULog(); { if (fLogger) return *fLogger; return *(fLogger = new MsgLogger(""CFMLP_Utils"")); }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:3399,Integrability,interface,interface,3399,"&W_ref(Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3); voidWini(); Double_tWw_ref(const Double_t[] wwNN, Int_t a_1, Int_t a_2) const; Double_t&Ww_ref(Double_t[] wwNN, Int_t a_1, Int_t a_2). private:. TMVA::MsgLogger&ULog(). Data Members; protected:. struct(anonymous)fCost_1; struct(anonymous)fDel_1; struct(anonymous)fNeur_1; struct(anonymous)fParam_1; VARn2fVarn2_1; VARn2fVarn3_1; struct(anonymous)fVarn_1; static Int_tfg_0constant; static Int_tfg_100constant; static Int_tfg_999constant; static const char*constfg_MethodNamemethod name for print; static const Int_tfg_max_nNodes_maximum number of nodes per variable; static const Int_tfg_max_nVar_static maximum number of input variables. private:. TMVA::MsgLogger*fLogger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN_Utils(); default constructor. ~MethodCFMlpANN_Utils(); destructor. void Train_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); training interface - called from MethodCFMlpANN class object. void Entree_new(Int_t* , char* , Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t ); first initialisation of ANN. void Wini(); [smart comments to be added]. void En_avant(Int_t* ievent); [smart comments to be added]. void Leclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_arriere(Int_t* ievent); [smart comments to be added]. void Out(Int_t* iii, Int_t* maxcycle); write weights to file. void Innit(char* det, Double_t* tout2, Double_t* tin2, Int_t ); Initialization. void TestNN(); [smart comments to be added]. void Cout(Int_t* , Double_t* xxx); [smart comments to be added]. void Inl(); [smart comments to be added]. Double_t Fdecroi(Int_t* i__); [smart comments to be added]. void GraphNN(Int_t* ilearn, Double_t* , Double_t* , char* , Int_t ); [smart comments to be added]. Double_t Sen3a( void ); [smart comments to ",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:2965,Modifiability,variab,variable,2965,"ar*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); Double_tW_ref(const Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3) const; Double_t&W_ref(Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3); voidWini(); Double_tWw_ref(const Double_t[] wwNN, Int_t a_1, Int_t a_2) const; Double_t&Ww_ref(Double_t[] wwNN, Int_t a_1, Int_t a_2). private:. TMVA::MsgLogger&ULog(). Data Members; protected:. struct(anonymous)fCost_1; struct(anonymous)fDel_1; struct(anonymous)fNeur_1; struct(anonymous)fParam_1; VARn2fVarn2_1; VARn2fVarn3_1; struct(anonymous)fVarn_1; static Int_tfg_0constant; static Int_tfg_100constant; static Int_tfg_999constant; static const char*constfg_MethodNamemethod name for print; static const Int_tfg_max_nNodes_maximum number of nodes per variable; static const Int_tfg_max_nVar_static maximum number of input variables. private:. TMVA::MsgLogger*fLogger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN_Utils(); default constructor. ~MethodCFMlpANN_Utils(); destructor. void Train_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); training interface - called from MethodCFMlpANN class object. void Entree_new(Int_t* , char* , Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t ); first initialisation of ANN. void Wini(); [smart comments to be added]. void En_avant(Int_t* ievent); [smart comments to be added]. void Leclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_arriere(Int_t* ievent)",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html
https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:3036,Modifiability,variab,variables,3036,"ar*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); Double_tW_ref(const Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3) const; Double_t&W_ref(Double_t[] wNN, Int_t a_1, Int_t a_2, Int_t a_3); voidWini(); Double_tWw_ref(const Double_t[] wwNN, Int_t a_1, Int_t a_2) const; Double_t&Ww_ref(Double_t[] wwNN, Int_t a_1, Int_t a_2). private:. TMVA::MsgLogger&ULog(). Data Members; protected:. struct(anonymous)fCost_1; struct(anonymous)fDel_1; struct(anonymous)fNeur_1; struct(anonymous)fParam_1; VARn2fVarn2_1; VARn2fVarn3_1; struct(anonymous)fVarn_1; static Int_tfg_0constant; static Int_tfg_100constant; static Int_tfg_999constant; static const char*constfg_MethodNamemethod name for print; static const Int_tfg_max_nNodes_maximum number of nodes per variable; static const Int_tfg_max_nVar_static maximum number of input variables. private:. TMVA::MsgLogger*fLogger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCFMlpANN_Utils(); default constructor. ~MethodCFMlpANN_Utils(); destructor. void Train_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); training interface - called from MethodCFMlpANN class object. void Entree_new(Int_t* , char* , Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t ); first initialisation of ANN. void Wini(); [smart comments to be added]. void En_avant(Int_t* ievent); [smart comments to be added]. void Leclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_arriere(Int_t* ievent)",MatchSource.WIKI,root/html604/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:723,Availability,avail,available,723,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:2571,Availability,error,error,2571,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:2655,Availability,error,error,2655,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:17468,Modifiability,variab,variables,17468,"Cleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*fCurrentMethod; UInt_tfCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>fMethodWeight; vector<TMVA::IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); {}. MethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); {}. TMVA::IMethod* GetMethod(const TString& title) const; returns poi",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:17745,Modifiability,variab,variable,17745,"Cleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*fCurrentMethod; UInt_tfCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>fMethodWeight; vector<TMVA::IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); {}. MethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); {}. TMVA::IMethod* GetMethod(const TString& title) const; returns poi",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:531,Performance,load,loading,531,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:12676,Performance,tune,tuneParameters,12676,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:19342,Performance,perform,performs,19342," the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); {}. MethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); {}. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return composite MVA response. MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). void Train(); performs classifier training. const Ranking* CreateRanking(); create ranking. void DeclareOptions(). void ProcessOptions(). UInt_t GetCurrentMethodIndex(); { return fCurrentMethodIdx; }. IMethod* GetLastMethod(); { return fMethods.back(); }. IMethod* GetPreviousMethod(); { return (fCurrentMethodIdx>0)?fMethods[fCurrentMethodIdx-1]:0; }. MethodBase* GetCurrentMethod(); { return fCurrentMethod;}. MethodBase* GetCurrentMethod(UInt_t idx); {return dynamic_cast<MethodBase*>(fMethods.at(idx)); }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:12478,Testability,test,testTime,12478,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCompositeBase.html:16239,Testability,test,testing,16239,"voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*fCurrentMethod; UInt_tfCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>fMethodWeight; vector<TMVA::IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnV",MatchSource.WIKI,root/html604/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html
https://root.cern/root/html604/TMVA__MethodCuts.html:4419,Availability,error,error,4419,"g*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static TMVA::MethodCuts*DynamicCast(TMVA::IMethod* method); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tEstimatorFunction(Int_t ievt1, Int_t ievt2); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; Double_tGetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t&); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) con",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:4503,Availability,error,error,4503,"MVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static TMVA::MethodCuts*DynamicCast(TMVA::IMethod* method); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tEstimatorFunction(Int_t ievt1, Int_t ievt2); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; Double_tGetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t&); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::E",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:23587,Availability,avail,available,23587,"odCuts::EFitMethodTypekUseMonteCarlo; static TMVA::MethodCuts::EFitMethodTypekUseMonteCarloEvents; static TMVA::MethodCuts::EEffMethodkUsePDFs; static TMVA::MethodCuts::EFitMethodTypekUseSimulatedAnnealing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0); standard constructor. MethodCuts(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:23729,Availability,avail,available,23729,"FitMethodTypekUseSimulatedAnnealing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0); standard constructor. MethodCuts(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:23926,Availability,avail,available,23926,"thodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0); standard constructor. MethodCuts(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:28546,Availability,avail,available,28546,"gnal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0). MethodCuts* DynamicCast(TMVA::IMethod* method); this is a workaround which is necessary since CINT is not capable of handling dynamic casts. { return dynamic_cast<MethodCuts*>(method); }. Double_t GetSeparation(TH1* , TH1* ) const; also overwrite --> not computed for cuts. { return -1; }. Double_t GetSeparation(TMVA::PDF* = 0, TMVA::PDF* = 0) const; { return -1; }. Double_t GetSignificance( void ); { return -1; }. Double_t GetmuTransform(TTree* ); { return -1; }. Double_t GetRarity(Double_t , TMVA::Types::ESBType ) const; rarity distributions (signal or background (default) is uniform in [0,1]). { return 0; }. void SetTestSignalEfficiency(Double_t effS); { fTestSignalEff = effS; }. const Ranking* CreateRanking(); ranking of input variables (not available for cuts). { return 0; }. void CheckSetup(); no check of options at this place. {}. void MatchParsToCuts( const std::vector<Double_t>&, Double_t*, Double_t* ); the definition of fit parameters can be different from the actual; cut requirements; these functions provide the matching. » Author: Andreas Hoecker, Matt Jachowski, Peter Speckmayer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:26494,Energy Efficiency,monitor,monitoring,26494,"uble_t>& , Double_t** , Double_t** , Int_t ibin); translate the cuts into parameters (obsolete function). void MatchCutsToPars(vector<Double_t>& , Double_t* , Double_t* ); translates cuts into parameters. void GetEffsfromPDFs(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies from PDFs; for given cut sample. void GetEffsfromSelection(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies from event counting; for given cut sample. void CreateVariablePDFs( void ); for PDF method: create efficiency reference histograms and PDFs. void ReadWeightsFromStream(istream& i); read the cuts from stream. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. Double_t GetTrainingEfficiency(const TString& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:1402,Integrability,depend,depending,1402," efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:27512,Integrability,message,message,27512,"oring purposes. Double_t GetTrainingEfficiency(const TString& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0). MethodCuts* DynamicCast(TMVA::IMethod* method); this is a workaround which is necessary since CINT is not capable of handling dynamic casts. { return dynamic_cast<MethodCuts*>(method); }. Double_t GetSeparation(TH1* , TH1* ) const; also overwrite --> not computed for cuts. { return -1; }. Double_t GetSeparation(TMVA::PDF* = 0, TMVA::PDF* = 0) const; { return -1; }. Double_t GetSignificance( void ); { return -1; }. Double_t GetmuTransform(TTree* ); { return -1; }. Double_t GetRarity(Double_t , TMVA::Types::ESBType ) const; rarity distributions (signal or background (default) is uniform in [0,1]). { return 0; }. void SetTestSignalEfficiency(Double_t effS); { fTestSignalEff = effS; }. const Ranking* Cr",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:634,Modifiability,variab,variables,634,". TMVA::MethodCuts. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCuts. class TMVA::MethodCuts: public TMVA::MethodBase, public TMVA::IFitterTarget. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, a",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:1230,Modifiability,variab,variable,1230," » TMVA::MethodCuts. class TMVA::MethodCuts: public TMVA::MethodBase, public TMVA::IFitterTarget. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelat",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:1631,Modifiability,variab,variable,1631,"ich improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::A",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:1734,Modifiability,config,configurable,1734,"ising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBas",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:1835,Modifiability,variab,variables,1835,"und yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckFor",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:19559,Modifiability,variab,variables,19559,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TString*fAllVarsIwhat to do with variables; TMVA::BinarySearchTree*fBinaryTreeB; TMVA::BinarySearchTree*fBinaryTreeS; Double_t**fCutMaxmaximum requirement; Double_t**fCutMinminimum requirement; vector<TMVA::Interval*>fCutRangeallowed ranges for cut optimisation; Double_t*fCutRangeMaxmaximum of allowed cut range; Double_t*fCutRangeMinminimum of allowed cut range; TH1*fEffBvsSLocalintermediate eff. background versus eff signal histo; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calcul",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:19748,Modifiability,variab,variable,19748,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TString*fAllVarsIwhat to do with variables; TMVA::BinarySearchTree*fBinaryTreeB; TMVA::BinarySearchTree*fBinaryTreeS; Double_t**fCutMaxmaximum requirement; Double_t**fCutMinminimum requirement; vector<TMVA::Interval*>fCutRangeallowed ranges for cut optimisation; Double_t*fCutRangeMaxmaximum of allowed cut range; Double_t*fCutRangeMinminimum of allowed cut range; TH1*fEffBvsSLocalintermediate eff. background versus eff signal histo; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calcul",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:20223,Modifiability,variab,variables,20223," regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TString*fAllVarsIwhat to do with variables; TMVA::BinarySearchTree*fBinaryTreeB; TMVA::BinarySearchTree*fBinaryTreeS; Double_t**fCutMaxmaximum requirement; Double_t**fCutMinminimum requirement; vector<TMVA::Interval*>fCutRangeallowed ranges for cut optimisation; Double_t*fCutRangeMaxmaximum of allowed cut range; Double_t*fCutRangeMinminimum of allowed cut range; TH1*fEffBvsSLocalintermediate eff. background versus eff signal histo; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<TMVA::MethodCuts::EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC op",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:21144,Modifiability,variab,variables,21144,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:21200,Modifiability,variab,variables,21200,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:21517,Modifiability,variab,variables,21517,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:21571,Modifiability,variab,variables,21571,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:23806,Modifiability,variab,variable,23806,"es. Function documentation; MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0); standard constructor. MethodCuts(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Dou",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:24127,Modifiability,variab,variables,24127,"rgetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t EstimatorFunction(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA. Double_t ComputeEstimator(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA; there are two requirements:; 1) the sign",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:28531,Modifiability,variab,variables,28531,"gnal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0). MethodCuts* DynamicCast(TMVA::IMethod* method); this is a workaround which is necessary since CINT is not capable of handling dynamic casts. { return dynamic_cast<MethodCuts*>(method); }. Double_t GetSeparation(TH1* , TH1* ) const; also overwrite --> not computed for cuts. { return -1; }. Double_t GetSeparation(TMVA::PDF* = 0, TMVA::PDF* = 0) const; { return -1; }. Double_t GetSignificance( void ); { return -1; }. Double_t GetmuTransform(TTree* ); { return -1; }. Double_t GetRarity(Double_t , TMVA::Types::ESBType ) const; rarity distributions (signal or background (default) is uniform in [0,1]). { return 0; }. void SetTestSignalEfficiency(Double_t effS); { fTestSignalEff = effS; }. const Ranking* CreateRanking(); ranking of input variables (not available for cuts). { return 0; }. void CheckSetup(); no check of options at this place. {}. void MatchParsToCuts( const std::vector<Double_t>&, Double_t*, Double_t* ); the definition of fit parameters can be different from the actual; cut requirements; these functions provide the matching. » Author: Andreas Hoecker, Matt Jachowski, Peter Speckmayer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:1248,Performance,perform,performed,1248," » TMVA::MethodCuts. class TMVA::MethodCuts: public TMVA::MethodBase, public TMVA::IFitterTarget. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelat",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:2074,Performance,perform,performed,2074," should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:14707,Performance,tune,tuneParameters,14707,"ject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestSignalEfficiency(Double_t effS); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:20833,Performance,optimiz,optimized,20833,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:20891,Performance,optimiz,optimized,20891,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:21626,Performance,optimiz,optimized,21626,:MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<TMVA::MethodCuts::EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC optimisation method; vector<Int_t>*fRangeSignused to match cuts to fit parameters (and vice versa); vector<Double_t>*fRmsBRMSs of variables (background); vector<Double_t>*fRmsSRMSs of variables (signal); Double_tfTestSignalEffused to test optimized signal efficiency; Double_t*fTmpCutMaxtemporary maximum requirement; Double_t*fTmpCutMintemporary minimum requirement; vector<TH1*>*fVarHistBreference histograms (background); vector<TH1*>*fVarHistB_smoothsmoothed reference histograms (background); vector<TH1*>*fVarHistSreference histograms (signal); vector<TH1*>*fVarHistS_smoothsmoothed reference histograms (signal); vector<TMVA::PDF*>*fVarPdfBreference PDFs (background); vector<TMVA::PDF*>*fVarPdfSreference PDFs (signal); static TMVA::MethodCuts::EFitParameterskForceMax; static TMVA::MethodCuts::EFitParameterskForceMin; static TMVA::MethodCuts::EFitParameterskForceSmart; static TMVA::MethodCuts::EFitParameterskNotEnforced; static TMVA::MethodCuts::EFitMethodTypekUseEventScan; static TMVA::MethodCuts::EEffMethodkUseEventSelection; static TMVA::MethodCuts::EFitMethodTypekUseGeneticAlgorithm; static TMVA::MethodCuts::EFitMethodTypekUseMinuit; static TMVA::MethodCuts::EFitMethodTypekUseMonteCarlo; static TMVA::MethodCuts::EFitMethod,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:24090,Safety,sanity check,sanity check,24090,"rgetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t EstimatorFunction(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA. Double_t ComputeEstimator(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA; there are two requirements:; 1) the sign",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:2060,Testability,test,tests,2060," should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* ",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:14509,Testability,test,testTime,14509,"ect::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestSignalEfficiency(Double_t effS); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virt",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:18351,Testability,test,testing,18351,"Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); voidGetEffsfromSelection(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); virtual voidInit(); voidMatchCutsToPars(vector<Double_t>&, Double_t*, Double_t*); voidMatchCutsToPars(vector<Double_t>&, Double_t**, Double_t**, Int_t ibin); voidMatchParsToCuts(const vector<Double_t>&, Double_t*, Double_t*); voidMatchParsToCuts(Double_t*, Double_t*, Double_t*). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static const Double_tfgMaxAbsCutVal; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histo",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:20828,Testability,test,test,20828,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:20886,Testability,test,test,20886,,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:21621,Testability,test,test,21621,o; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<TMVA::MethodCuts::EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC optimisation method; vector<Int_t>*fRangeSignused to match cuts to fit parameters (and vice versa); vector<Double_t>*fRmsBRMSs of variables (background); vector<Double_t>*fRmsSRMSs of variables (signal); Double_tfTestSignalEffused to test optimized signal efficiency; Double_t*fTmpCutMaxtemporary maximum requirement; Double_t*fTmpCutMintemporary minimum requirement; vector<TH1*>*fVarHistBreference histograms (background); vector<TH1*>*fVarHistB_smoothsmoothed reference histograms (background); vector<TH1*>*fVarHistSreference histograms (signal); vector<TH1*>*fVarHistS_smoothsmoothed reference histograms (signal); vector<TMVA::PDF*>*fVarPdfBreference PDFs (background); vector<TMVA::PDF*>*fVarPdfSreference PDFs (signal); static TMVA::MethodCuts::EFitParameterskForceMax; static TMVA::MethodCuts::EFitParameterskForceMin; static TMVA::MethodCuts::EFitParameterskForceSmart; static TMVA::MethodCuts::EFitParameterskNotEnforced; static TMVA::MethodCuts::EFitMethodTypekUseEventScan; static TMVA::MethodCuts::EEffMethodkUseEventSelection; static TMVA::MethodCuts::EFitMethodTypekUseGeneticAlgorithm; static TMVA::MethodCuts::EFitMethodTypekUseMinuit; static TMVA::MethodCuts::EFitMethodTypekUseMonteCarlo; static TMVA::MethodCuts::EFi,MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodCuts.html:24819,Testability,test,test,24819," of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t EstimatorFunction(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA. Double_t ComputeEstimator(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA; there are two requirements:; 1) the signal efficiency must be equal to the required one in the; efficiency scan; 2) the background efficiency must be as small as possible; the requirement 1) has priority over 2). void MatchParsToCuts( const std::vector<Double_t> & pars, Double_t* cutMin, Double_t* cutMax ); translates parameters into cuts. void MatchCutsToPars(vector<Double_t>& , Double_t** , Double_t** , Int_t ibin); translate the cuts into parameters (obsolete function). void MatchCutsToPars(vector<Double_t>& , Double_t* , Double_t* ); translates cuts into parameters. void GetEffsfromPDFs(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies f",MatchSource.WIKI,root/html604/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodCuts.html
https://root.cern/root/html604/TMVA__MethodDT.html:5212,Availability,error,error,5212,"nst TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:5296,Availability,error,error,5296,"st TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:20671,Availability,error,error,20671,"rn-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLea",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:23557,Availability,error,error,23557,"t TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:23974,Availability,avail,available,23974,"he separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Double_t PruneTree(); prune the decision tree if requested (good for individual trees that are best grown out, and then; pruned back, while boosted decision trees are best 'small' trees to start with. Well, at least the; standard ""optimal pruning algorithms"" don't result in 'weak enough' classifiers !!. Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). MethodDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& t",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:3029,Integrability,depend,depending,3029,"ain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """,MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:901,Modifiability,variab,variable,901,". TMVA::MethodDT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodDT. class TMVA::MethodDT: public TMVA::MethodBase. Analysis of Boosted Decision Trees. Boosted decision trees have been successfully used in High Energy; Physics analysis for example by the MiniBooNE experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. Decision trees:. successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called """,MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:1437,Modifiability,variab,variable,1437,"experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. Decision trees:. successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied s",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:19779,Modifiability,variab,variables,19779,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tf",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:19968,Modifiability,variab,variable,19968,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tf",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:21101,Modifiability,variab,variable,21101,"rn-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLea",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:21416,Modifiability,variab,variables,21416,"lethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-targe",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:21666,Modifiability,variab,variables,21666,"lethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-targe",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:22005,Modifiability,variab,variables,22005,"lethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-targe",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:22884,Modifiability,variab,variables,22884,"t TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:22917,Modifiability,variab,variables,22917,"t TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:15361,Performance,tune,tuneParameters,15361,"(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidSetMinNodeSize(Double_t sizeInPercent); voidSetMinNodeSize(TString sizeInPercent); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:23793,Safety,avoid,avoided,23793," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Double_t PruneTree(); prune the decision tree if requested (good for individual trees that are best grown out, and then; pruned back, while boosted decision trees are best 'small' trees to start with. Well, at least the; standard ""optimal pruning algorithms"" don't result in 'weak enough' classifiers !!. Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); ",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:20496,Security,validat,validation,20496,"rn-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLea",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:2827,Testability,test,test,2827,"is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurab",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:15163,Testability,test,testTime,15163,"option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidSetMinNodeSize(Double_t sizeInPercent); voidSetMinNodeSize(TString sizeInPercent); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::Meth",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:18608,Testability,test,testing,18608,"lised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidInit(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:2705,Usability,simpl,simple,2705,"(left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* p",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodDT.html:23349,Usability,simpl,simply,23349,"t TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root/html604/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodDT.html
https://root.cern/root/html604/TMVA__MethodFDA.html:2672,Availability,error,error,2672,"urableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>&); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:2756,Availability,error,error,2756,"ct::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>&); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:19953,Availability,avail,availabel,19953,"ance; Inherited Members; Includes; Libraries. Function documentation; MethodFDA(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodFDA(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::ve",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:448,Deployability,configurat,configuration,448,". TMVA::MethodFDA. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFDA. class TMVA::MethodFDA: public TMVA::MethodBase, public TMVA::IFitterTarget. Function discriminant analysis (FDA). This simple classifier; fits any user-defined TFormula (via option configuration string) to; the training data by requiring a formula response of 1 (0) to signal; (background) events. The parameter fitting is done via the abstract; class FitterBase, featuring Monte Carlo sampling, Genetic; Algorithm, Simulated Annealing, MINUIT and combinations of these. Can compute regression value for one dimensional output. Function Members (Methods); public:. virtual~MethodFDA(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); vir",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:21594,Integrability,message,message,21594,"id ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write FDA-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFDA(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. void CheckSetup(); no check of options at this place. {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005-2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:448,Modifiability,config,configuration,448,". TMVA::MethodFDA. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFDA. class TMVA::MethodFDA: public TMVA::MethodBase, public TMVA::IFitterTarget. Function discriminant analysis (FDA). This simple classifier; fits any user-defined TFormula (via option configuration string) to; the training data by requiring a formula response of 1 (0) to signal; (background) events. The parameter fitting is done via the abstract; class FitterBase, featuring Monte Carlo sampling, Genetic; Algorithm, Simulated Annealing, MINUIT and combinations of these. Can compute regression value for one dimensional output. Function Members (Methods); public:. virtual~MethodFDA(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); vir",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:17437,Modifiability,variab,variables,17437,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Double_t>fBestParsthe pars that optimise (minimise) the estimator; TStringfConvergerfitmethod uses fConverger as intermediate step to converge into local minimas; TMVA::IFitterTarget*fConvergerFitterintermediate fitter; TStringfFitMethodestimator optimisation method; TMVA::FitterBase*fFitterthe fitter used in the training; TFormula*fFormulathe discrimination function; TStringfFormulaStringPstring with function; TStringfFormulaStringTstring with function; UInt_tfNParsnumber of parameters; Int_tfOutputDimensionsnumber of output values; vector<",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:17626,Modifiability,variab,variable,17626,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Double_t>fBestParsthe pars that optimise (minimise) the estimator; TStringfConvergerfitmethod uses fConverger as intermediate step to converge into local minimas; TMVA::IFitterTarget*fConvergerFitterintermediate fitter; TStringfFitMethodestimator optimisation method; TMVA::FitterBase*fFitterthe fitter used in the training; TFormula*fFormulathe discrimination function; TStringfFormulaStringPstring with function; TStringfFormulaStringTstring with function; UInt_tfNParsnumber of parameters; Int_tfOutputDimensionsnumber of output values; vector<",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:19568,Modifiability,variab,variables,19568,"number of parameters; Int_tfOutputDimensionsnumber of output values; vector<TMVA::Interval*>fParRangeranges of parameters; TStringfParRangeStringPstring with ranges of parameters; TStringfParRangeStringTstring with ranges of parameters; Double_tfSumOfWeightssum of weights; Double_tfSumOfWeightsBkgsum of weights (background); Double_tfSumOfWeightsSigsum of weights (signal). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodFDA(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodFDA(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be ",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:20434,Modifiability,variab,variable,20434,"ptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). ",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:21907,Modifiability,variab,variables,21907,"id ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write FDA-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFDA(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. void CheckSetup(); no check of options at this place. {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005-2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:12684,Performance,tune,tuneParameters,12684,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:12486,Testability,test,testTime,12486,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:16266,Testability,test,testing,16266,"nst; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidCalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); voidClearAll(); voidCreateFormula(); virtual voidDeclareOptions(); Double_tInterpretFormula(const TMVA::Event*, vector<double>::iterator begin, vector<double>::iterator end); voidPrintResults(const TString&, vector<Double_t>&, const Double_t) const; virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:386,Usability,simpl,simple,386,". TMVA::MethodFDA. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFDA. class TMVA::MethodFDA: public TMVA::MethodBase, public TMVA::IFitterTarget. Function discriminant analysis (FDA). This simple classifier; fits any user-defined TFormula (via option configuration string) to; the training data by requiring a formula response of 1 (0) to signal; (background) events. The parameter fitting is done via the abstract; class FitterBase, featuring Monte Carlo sampling, Genetic; Algorithm, Simulated Annealing, MINUIT and combinations of these. Can compute regression value for one dimensional output. Function Members (Methods); public:. virtual~MethodFDA(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); vir",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFDA.html:20248,Usability,clear,clear,20248,"eWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLT",MatchSource.WIKI,root/html604/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFDA.html
https://root.cern/root/html604/TMVA__MethodFisher.html:4478,Availability,error,error,4478,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:4562,Availability,error,error,4562,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2287,Energy Efficiency,power,power,2287,"le means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2376,Energy Efficiency,power,power,2376,"hin- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(con",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2455,Energy Efficiency,power,power,2455,"hin- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(con",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2495,Energy Efficiency,power,power,2495,"e means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); ",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:19879,Energy Efficiency,power,power,19879,"TMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPowdiscriminating power; Double_tfF0offset; vector<Double_t>*fFisherCoeffFisher coefficients; TMVA::MethodFisher::EFisherMethodfFisherMethodFisher or Mahalanobis; TMatrixD*fMeanMatx; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; TStringfTheMethodFisher or Mahalanobis; TMatrixD*fWithwithin-class matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); standard constructor for the ""Fisher"". MethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialization called by all constructors. void DeclareOptions(). MethodFisher options:; format and syntax of option string: ""type""; where type is ""Fisher"" or ""Mahalanobis"". void ProcessOptions(); process user options. ~MethodFisher( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType typ",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22412,Energy Efficiency,power,power,22412,"verall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22680,Energy Efficiency,power,power,22680,"v_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { retu",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22885,Energy Efficiency,power,power,22885," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automa",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:23346,Integrability,message,message,23346," Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:480,Modifiability,variab,variable,480,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa th",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:703,Modifiability,variab,variables,703,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa th",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:1092,Modifiability,variab,variable,1092,"Fisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very s",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:1268,Modifiability,variab,variable,1268,"OT; » TMVA; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-cla",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2091,Modifiability,variab,variables,2091,"trix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virt",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2298,Modifiability,variab,variable,2298,"le means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2466,Modifiability,variab,variable,2466,"hin- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(con",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2518,Modifiability,variab,variables,2518,"e means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); ",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:19132,Modifiability,variab,variables,19132,"her::EFisherMethodkMahalanobis; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPowdiscriminating power; Double_tfF0offset; vector<Double_t>*fFisherCoeffFisher coefficients; TMVA::MethodFisher::EFisherMethodfFisherMethodFisher or Mahalanobis; TMatrixD*fMeanMatx; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; TStringfTheMethodFisher or Mahalanobis; TMatrixD*fWithwithin-class matrix. Class Charts. Inheritance; Inherited Members; Includes; Librarie",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:19321,Modifiability,variab,variable,19321,"her::EFisherMethodkMahalanobis; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPowdiscriminating power; Double_tfF0offset; vector<Double_t>*fFisherCoeffFisher coefficients; TMVA::MethodFisher::EFisherMethodfFisherMethodFisher or Mahalanobis; TMatrixD*fMeanMatx; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; TStringfTheMethodFisher or Mahalanobis; TMatrixD*fWithwithin-class matrix. Class Charts. Inheritance; Inherited Members; Includes; Librarie",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:21435,Modifiability,variab,variables,21435,"st TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); standard constructor for the ""Fisher"". MethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialization called by all constructors. void DeclareOptions(). MethodFisher options:; format and syntax of option string: ""type""; where type is ""Fisher"" or ""Mahalanobis"". void ProcessOptions(); process user options. ~MethodFisher( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Fisher can only handle classification with 2 classes. void Train( void ); computation of Fisher coefficients by series of matrix operations. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the Fisher value (no fixed range). void InitMatrices( void ); initializaton method; creates global matrices and vectors. void GetMean( void ); compute mean values of variables in each sample, and the overall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22023,Modifiability,variab,variables,22023,"e type, UInt_t numberClasses, UInt_t numberTargets); Fisher can only handle classification with 2 classes. void Train( void ); computation of Fisher coefficients by series of matrix operations. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the Fisher value (no fixed range). void InitMatrices( void ); initializaton method; creates global matrices and vectors. void GetMean( void ); compute mean values of variables in each sample, and the overall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher co",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22079,Modifiability,variab,variables,22079," Fisher coefficients by series of matrix operations. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the Fisher value (no fixed range). void InitMatrices( void ); initializaton method; creates global matrices and vectors. void GetMean( void ); compute mean values of variables in each sample, and the overall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22148,Modifiability,variab,variables,22148," Fisher coefficients by series of matrix operations. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the Fisher value (no fixed range). void InitMatrices( void ); initializaton method; creates global matrices and vectors. void GetMean( void ); compute mean values of variables in each sample, and the overall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22437,Modifiability,variab,variable,22437,"verall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22795,Modifiability,variab,variables,22795,"a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyri",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22900,Modifiability,variab,variable,22900," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automa",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:22934,Modifiability,variab,variable,22934," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automa",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:452,Performance,perform,performed,452,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa th",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:14435,Performance,tune,tuneParameters,14435,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:2110,Testability,test,test,2110,"es; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidT",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:14237,Testability,test,testTime,14237,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:17858,Testability,test,testing,17858," Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); voidGetCov_BetweenClass(); voidGetCov_Full(); voidGetCov_WithinClass(); voidGetDiscrimPower(); voidGetFisherCoeff(); voidGetMean(); virtual voidInit(); voidInitMatrices(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TMVA::MethodFisher::EFisherMethodkFisher; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMVA::MethodFisher::EFisherMethodkMahalanobis; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumbe",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodFisher.html:1756,Usability,simpl,simplifies,1756," projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const c",MatchSource.WIKI,root/html604/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:2949,Availability,error,error,2949,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:3033,Availability,error,error,3033,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:19955,Integrability,message,message,19955,"eightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialization called by all constructors. ~MethodHMatrix( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); MethodHMatrix options: none (apart from those implemented in MethodBase). void ProcessOptions(); process user options. void Train( void ); computes H-matrices for signal and background samples. void ComputeCovariance(Bool_t , TMatrixD* ); compute covariance matrix. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the H-matrix signal estimator. Double_t GetChi2(TMVA::Types::ESBType ); compute chi2-estimator for event according to type (signal/background). void AddWeightsXMLTo(void* parent) const; create XML description for HMatrix classification. void ReadWeightsFromXML(void* wghtnode); read weights from XML file. void ReadWeightsFromStream(istream& istr); read variable names and min/max; NOTE: the latter values are mandatory for the normalisation; in the reader application !!!. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:509,Modifiability,variab,variables,509,". TMVA::MethodHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodHMatrix. class TMVA::MethodHMatrix: public TMVA::MethodBase. /*; H-Matrix method, which is implemented as a simple comparison of; chi-squared estimators for signal and background, taking into; account the linear correlations between the input variables; This MVA approach is used by the DØ collaboration (FNAL) for the; purpose of electron identification (see, eg.,; hep-ex/9507007).; As it is implemented in TMVA, it is usually equivalent or worse than; the Fisher-Mahalanobis discriminant, and it has only been added for; the purpose of completeness.; Two χ2 estimators are computed for an event, each one; for signal and background, using the estimates for the means and; covariance matrices obtained from the training sample:. TMVA then uses as normalised analyser for event (i) the ratio:; (χS(i)2 − χB2(i)); (χS2(i) + χB2(i)).; */. Function Members (Methods); public:. virtual~MethodHMatrix(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::C",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:17419,Modifiability,variab,variables,17419,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fInvHMatrixBinverse H-matrix (background); TMatrixD*fInvHMatrixSinverse H-matrix (signal); TVectorD*fVecMeanBvector of mean values (background); TVectorD*fVecMeanSvector of mean values (signal). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor for the H-Matrix method. MethodHMatrix(TMVA::DataSetInfo& theData, const TString& ",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:17608,Modifiability,variab,variable,17608,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fInvHMatrixBinverse H-matrix (background); TMatrixD*fInvHMatrixSinverse H-matrix (signal); TVectorD*fVecMeanBvector of mean values (background); TVectorD*fVecMeanSvector of mean values (signal). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor for the H-Matrix method. MethodHMatrix(TMVA::DataSetInfo& theData, const TString& ",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:19696,Modifiability,variab,variable,19696,"eightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialization called by all constructors. ~MethodHMatrix( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); MethodHMatrix options: none (apart from those implemented in MethodBase). void ProcessOptions(); process user options. void Train( void ); computes H-matrices for signal and background samples. void ComputeCovariance(Bool_t , TMatrixD* ); compute covariance matrix. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the H-matrix signal estimator. Double_t GetChi2(TMVA::Types::ESBType ); compute chi2-estimator for event according to type (signal/background). void AddWeightsXMLTo(void* parent) const; create XML description for HMatrix classification. void ReadWeightsFromXML(void* wghtnode); read weights from XML file. void ReadWeightsFromStream(istream& istr); read variable names and min/max; NOTE: the latter values are mandatory for the normalisation; in the reader application !!!. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:20272,Modifiability,variab,variables,20272,"eightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialization called by all constructors. ~MethodHMatrix( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); MethodHMatrix options: none (apart from those implemented in MethodBase). void ProcessOptions(); process user options. void Train( void ); computes H-matrices for signal and background samples. void ComputeCovariance(Bool_t , TMatrixD* ); compute covariance matrix. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the H-matrix signal estimator. Double_t GetChi2(TMVA::Types::ESBType ); compute chi2-estimator for event according to type (signal/background). void AddWeightsXMLTo(void* parent) const; create XML description for HMatrix classification. void ReadWeightsFromXML(void* wghtnode); read weights from XML file. void ReadWeightsFromStream(istream& istr); read variable names and min/max; NOTE: the latter values are mandatory for the normalisation; in the reader application !!!. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:12896,Performance,tune,tuneParameters,12896,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:12698,Testability,test,testTime,12698,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:16248,Testability,test,testing,16248,"odBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidComputeCovariance(Bool_t, TMatrixD*); virtual voidDeclareOptions(); Double_tGetChi2(TMVA::Types::ESBType); virtual voidInit(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodHMatrix.html:374,Usability,simpl,simple,374,". TMVA::MethodHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodHMatrix. class TMVA::MethodHMatrix: public TMVA::MethodBase. /*; H-Matrix method, which is implemented as a simple comparison of; chi-squared estimators for signal and background, taking into; account the linear correlations between the input variables; This MVA approach is used by the DØ collaboration (FNAL) for the; purpose of electron identification (see, eg.,; hep-ex/9507007).; As it is implemented in TMVA, it is usually equivalent or worse than; the Fisher-Mahalanobis discriminant, and it has only been added for; the purpose of completeness.; Two χ2 estimators are computed for an event, each one; for signal and background, using the estimates for the means and; covariance matrices obtained from the training sample:. TMVA then uses as normalised analyser for event (i) the ratio:; (χS(i)2 − χB2(i)); (χS2(i) + χB2(i)).; */. Function Members (Methods); public:. virtual~MethodHMatrix(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::C",MatchSource.WIKI,root/html604/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodHMatrix.html
https://root.cern/root/html604/TMVA__MethodInfo.html:1284,Availability,error,error,1284," virtual~MethodInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::G",MatchSource.WIKI,root/html604/TMVA__MethodInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodInfo.html
https://root.cern/root/html604/TMVA__MethodInfo.html:1368,Availability,error,error,1368,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html604/TMVA__MethodInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodInfo.html
https://root.cern/root/html604/TMVA__MethodKNN.html:2138,Availability,error,error,2138,"Object* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:2222,Availability,error,error,2222,"& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:19772,Availability,avail,available,19772,"tandard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void Init(); Initialization. void MakeKNN(); create kNN. void Train(); kNN training. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Compute classifier response. const std::vector< Float_t >& GetRegressionValues(). Return vector of averages for target values of k-nearest neighbors.; Use own copy of the regression vector, I do not like using a pointer to vector. const TMVA::Ranking* CreateRanking(); no ranking available. void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read the weights. void WriteWeightsToStream(TFile& rf) const; save weights to ROOT file. void ReadWeightsFromStream(TFile& rf); read weights from ROOT file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t PolnKernel(Double_t value) const; polynomial kernel. Double_t GausKernel(const TMVA::kNN::Event& event_knn, const TMVA::kNN::Event& event, const vector<Double_t>& svec) const; Gaussian kernel. Double_t getKernelRadius(const TMVA::kNN::List& rlist) const. Get polynomial kernel radius. const std::vector<Double_t> getRMS(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn) const. Get polynomial kern",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:20220,Integrability,message,message,20220,", UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void Init(); Initialization. void MakeKNN(); create kNN. void Train(); kNN training. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Compute classifier response. const std::vector< Float_t >& GetRegressionValues(). Return vector of averages for target values of k-nearest neighbors.; Use own copy of the regression vector, I do not like using a pointer to vector. const TMVA::Ranking* CreateRanking(); no ranking available. void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read the weights. void WriteWeightsToStream(TFile& rf) const; save weights to ROOT file. void ReadWeightsFromStream(TFile& rf); read weights from ROOT file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t PolnKernel(Double_t value) const; polynomial kernel. Double_t GausKernel(const TMVA::kNN::Event& event_knn, const TMVA::kNN::Event& event, const vector<Double_t>& svec) const; Gaussian kernel. Double_t getKernelRadius(const TMVA::kNN::List& rlist) const. Get polynomial kernel radius. const std::vector<Double_t> getRMS(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn) const. Get polynomial kernel radius. Double_t getLDAValue(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn). MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = __null). » Author: Rustem Ospanov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regardin",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:16949,Modifiability,variab,variables,16949,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weight",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:17138,Modifiability,variab,variable,17138,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weight",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:17948,Modifiability,variab,variable,17948,"> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = __null); standard constructor. MethodKNN(TMVA::DataSetInfo",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:11996,Performance,tune,tuneParameters,11996,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:18220,Performance,optimiz,optimization,18220,"VAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = __null); standard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA ca",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:11798,Testability,test,testTime,11798,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:15778,Testability,test,testing,15778,"rnel(const TMVA::kNN::Event& event_knn, const TMVA::kNN::Event& event, const vector<Double_t>& svec) const; Double_tgetKernelRadius(const TMVA::kNN::List& rlist) const; doublegetLDAValue(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn); const vector<Double_t>getRMS(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn) const; virtual voidInit(); voidMakeKNN(); Double_tPolnKernel(Double_t value) const; virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodKNN.html:17707,Usability,learn,learning,17707,"> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = __null); standard constructor. MethodKNN(TMVA::DataSetInfo",MatchSource.WIKI,root/html604/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodKNN.html
https://root.cern/root/html604/TMVA__MethodLD.html:2182,Availability,error,error,2182,"tion = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:2266,Availability,error,error,2266,"ble&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:19386,Integrability,message,message,19386,"with one regression-target. void Train( void ); compute fSumMatx. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Returns the MVA classification output. const std::vector< Float_t >& GetRegressionValues(); Calculates the regression output. void InitMatrices( void ); Initializaton method; creates global matrices and vectors. void GetSum( void ); Calculates the matrix transposed(X)*W*X with W being the diagonal weight matrix; and X the coordinates values. void GetSumVal( void ); Calculates the vector transposed(X)*W*Y with Y being the target vector. void GetLDCoeff( void ); Calculates the coeffiecients used for classification/regression. void ReadWeightsFromStream(istream& i); read LD coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write LD-specific classifier response. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void DeclareOptions(); MethodLD options. void ProcessOptions(); this is the preparation for training. void PrintCoefficients( void ); Display the classification/regression coefficients for each variable. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); constructor. » Author: Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk, Jan Therhaag » Copyright (c) 2008-2011: *; » Last changed: Tue Jun 2 16:17:09 2015 » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:16469,Modifiability,variab,variables,16469,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fCoeffMatxMatrix of coefficients; vector<vector<Double_t>*>*fLDCoeffLD coefficients; Int_tfNRegOutsize of the output; TMatrixD*fSumMatxSum of coordinates product matrix; TMatrixD*fSumValMatxSum of values multiplied by coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); standard constructor for the LD. MethodLD(TMVA::DataSetInfo& dsi, const TS",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:16658,Modifiability,variab,variable,16658,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fCoeffMatxMatrix of coefficients; vector<vector<Double_t>*>*fLDCoeffLD coefficients; Int_tfNRegOutsize of the output; TMatrixD*fSumMatxSum of coordinates product matrix; TMatrixD*fSumValMatxSum of values multiplied by coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); standard constructor for the LD. MethodLD(TMVA::DataSetInfo& dsi, const TS",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:19133,Modifiability,variab,variables,19133,"with one regression-target. void Train( void ); compute fSumMatx. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Returns the MVA classification output. const std::vector< Float_t >& GetRegressionValues(); Calculates the regression output. void InitMatrices( void ); Initializaton method; creates global matrices and vectors. void GetSum( void ); Calculates the matrix transposed(X)*W*X with W being the diagonal weight matrix; and X the coordinates values. void GetSumVal( void ); Calculates the vector transposed(X)*W*Y with Y being the target vector. void GetLDCoeff( void ); Calculates the coeffiecients used for classification/regression. void ReadWeightsFromStream(istream& i); read LD coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write LD-specific classifier response. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void DeclareOptions(); MethodLD options. void ProcessOptions(); this is the preparation for training. void PrintCoefficients( void ); Display the classification/regression coefficients for each variable. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); constructor. » Author: Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk, Jan Therhaag » Copyright (c) 2008-2011: *; » Last changed: Tue Jun 2 16:17:09 2015 » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:19338,Modifiability,variab,variable,19338,"with one regression-target. void Train( void ); compute fSumMatx. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Returns the MVA classification output. const std::vector< Float_t >& GetRegressionValues(); Calculates the regression output. void InitMatrices( void ); Initializaton method; creates global matrices and vectors. void GetSum( void ); Calculates the matrix transposed(X)*W*X with W being the diagonal weight matrix; and X the coordinates values. void GetSumVal( void ); Calculates the vector transposed(X)*W*Y with Y being the target vector. void GetLDCoeff( void ); Calculates the coeffiecients used for classification/regression. void ReadWeightsFromStream(istream& i); read LD coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write LD-specific classifier response. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void DeclareOptions(); MethodLD options. void ProcessOptions(); this is the preparation for training. void PrintCoefficients( void ); Display the classification/regression coefficients for each variable. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); constructor. » Author: Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk, Jan Therhaag » Copyright (c) 2008-2011: *; » Last changed: Tue Jun 2 16:17:09 2015 » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:11993,Performance,tune,tuneParameters,11993,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:11795,Testability,test,testTime,11795,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLD.html:15298,Testability,test,testing,15298,"ase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidGetLDCoeff(); voidGetSum(); voidGetSumVal(); virtual voidInit(); voidInitMatrices(); voidPrintCoefficients(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLD.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:2578,Availability,recover,recovered,2578,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TSt",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:4465,Availability,error,error,4465,"Object* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:4549,Availability,error,error,4549,"& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:23283,Energy Efficiency,monitor,monitoring,23283,"ect boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Peter Speckmayer, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:23568,Integrability,message,message,23568,"ect boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Peter Speckmayer, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:537,Modifiability,variab,variables,537,". TMVA::MethodLikelihood. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalisin",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:958,Modifiability,variab,variables,958,". TMVA::MethodLikelihood. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalisin",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:1156,Modifiability,variab,variables,1156,"rch. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlate",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:1426,Modifiability,variab,variables,1426,"plemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalis",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:2113,Modifiability,variab,variables,2113,"he distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voi",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:2172,Modifiability,variab,variable,2172,"he distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voi",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:2459,Modifiability,variab,variables,2459,"ant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """"",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:19034,Modifiability,variab,variables,19034,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackg",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:19223,Modifiability,variab,variable,19223,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackg",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:20467,Modifiability,variab,variable,20467,"istograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<TMVA::PDF*>*fPDFBgdlist of PDFs (background); vector<TMVA::PDF*>*fPDFSiglist of PDFs (signal); Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* ",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:22871,Modifiability,variab,variables,22871,"patibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(). void Train( void ); create reference distributions (PDFs) from signal and background events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). » Aut",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:2251,Performance,perform,performed,2251,"Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const ch",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:14487,Performance,tune,tuneParameters,14487,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:1243,Safety,avoid,avoid,1243,"ethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:2578,Safety,recover,recovered,2578,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TSt",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:20122,Safety,avoid,avoid,20122,"istograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<TMVA::PDF*>*fPDFBgdlist of PDFs (background); vector<TMVA::PDF*>*fPDFSiglist of PDFs (signal); Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* ",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:14289,Testability,test,testTime,14289,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:17863,Testability,test,testing,17863,"voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); virtual voidInit(); virtual voidProcessOptions(); Double_tTransformLikelihoodOutput(Double_t ps, Double_t pb) const. Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:20067,Testability,test,test,20067,"istograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<TMVA::PDF*>*fPDFBgdlist of PDFs (background); vector<TMVA::PDF*>*fPDFSiglist of PDFs (signal); Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* ",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodLikelihood.html:22525,Testability,test,testTree,22525,"sType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. void DeclareOptions(); define the options (their key words) that can be set in the option string; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(). void Train( void ); create reference distributions (PDFs) from signal and background events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpeci",MatchSource.WIKI,root/html604/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodLikelihood.html
https://root.cern/root/html604/TMVA__MethodMLP.html:2632,Availability,error,error,2632," voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*TMVA::MethodANNBase::CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tTMVA::MethodANNBase::Debug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Float_tTMVA::ConvergenceTest::GetCurrentValue(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:2716,Availability,error,error,2716,"NNBase::CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tTMVA::MethodANNBase::Debug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Float_tTMVA::ConvergenceTest::GetCurrentValue(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vect",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26076,Availability,avail,available,26076,"zjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26388,Availability,avail,available,26388," TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir). Double_t DerivDir(TMatrixD& Dir). Bool_t LineSearch(TMatrixD& Dir, vector<Double_t>& Buffer, Double_t* dError = 0). void SetDirWeight",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:29294,Availability,error,error,29294,"esiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Jachowski, Kamil Kraszewski, Maciej Kruk, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Jan Therhaag, J",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:28444,Deployability,update,update,28444,"MSEErr(const TMVA::Event* ev, UInt_t index = 0). Double_t GetCEErr(const TMVA::Event* ev, UInt_t index = 0). void BackPropagationMinimize(Int_t nEpochs); minimize estimator / train network with backpropagation algorithm. void TrainOneEpoch(); train network over a single epoch/cyle of events. void Shuffle(Int_t* index, Int_t n); Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for sequential training. void DecaySynapseWeights(Bool_t lateEpoch); decay synapse weights; in last 10 epochs, lower learning rate even more to find a good minimum. void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void Update",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:28603,Deployability,update,update,28603,"ize estimator / train network with backpropagation algorithm. void TrainOneEpoch(); train network over a single epoch/cyle of events. void Shuffle(Int_t* index, Int_t n); Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for sequential training. void DecaySynapseWeights(Bool_t lateEpoch); decay synapse weights; in last 10 epochs, lower learning rate even more to find a good minimum. void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeC",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:29279,Deployability,update,update,29279,"esiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Jachowski, Kamil Kraszewski, Maciej Kruk, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Jan Therhaag, J",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:21092,Energy Efficiency,monitor,monitoring,21092,,MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:21182,Energy Efficiency,monitor,monitoring,21182,,MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:21268,Energy Efficiency,monitor,monitoring,21268,,MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:23963,Energy Efficiency,monitor,monitoring,23963,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:17143,Integrability,message,message,17143,"idTMVA::MethodANNBase::ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); virtual voidGetHelpMessage() const; TMVA::TNeuron*TMVA::MethodANNBase::GetInputNeuron(Int_t index); const TString&TMVA::MethodBase::GetInternalVarName(Int_t ivar) const; Double_tTMVA::MethodANNBase::GetNetworkOutput(); const TString&TMVA::MethodBase::GetOriginalVarName(Int_t ivar) const; TMVA::TNeuron*TMVA::MethodANNBase::GetOutputNeuron(Int_t index = 0); const TString&TMVA::Configurable::GetReferenceFile() const; static TMVA::MethodBase*TMVA::MethodBase::GetThisBase(); const TString&TMVA::MethodBase::GetWeightFileDir() const; Bool_tTMVA::MethodBase::HasTrainingTree() const; Bool_tTMVA::MethodBase::Help() const; Bool_tTMVA::MethodBase::IgnoreEventsWithNegWeightsInTraining() const; Bool_tTMVA::MethodBase::IsConstructedFromWeightFile() const; Bool_tTMVA::MethodBase::IsNormalised() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; virtual voidMakeClassSpecific(ostream&, const TString&) const; virtual voidTMVA::MethodBase::MakeClassSpecificHeader(ostream&, const TString& = """") const; voidTObject::MakeZombie(); voidTMVA::MethodBase::NoErrorCalc(Double_t*const err, Double_t*const errUpper); Int_tTMVA::MethodANNBase::NumCycles(); vector<Int_t>*TMVA::MethodANNBase::ParseLayoutString(TString layerSpec); voidTMVA::MethodANNBase::PrintMessage(TString message, Bool_t force = kFALSE) const; voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::MethodANNBase::WaitForKeyboard(); voidTMVA::Configurable::WriteOptionsReferenceToFile().",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:22679,Integrability,depend,depending,22679,"ple; TH1F*TMVA::MethodANNBase::fEstimatorHistTrainmonitors convergence of training sample; TStringTMVA::MethodANNBase::fEstimatorS; TMVA::TActivation*TMVA::MethodANNBase::fIdentityactivation for input and output layers; Float_tTMVA::ConvergenceTest::fImprovement; TMVA::TNeuronInput*TMVA::MethodANNBase::fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDTMVA::MethodANNBase::fInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tTMVA::MethodANNBase::fNcyclesnumber of epochs to train; TObjArray*TMVA::MethodANNBase::fNetworkTObjArray of TObjArrays representing network; TStringTMVA::MethodANNBase::fNeuronInputTypename of neuron input calculator class; TStringTMVA::MethodANNBase::fNeuronTypename of neuron activation function class; TMVA::TActivation*TMVA::MethodANNBase::fOutputactivation function to be used for output layers, depending on estimator; Int_tTMVA::MethodANNBase::fRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>TMVA::MethodANNBase::fRegulatorIdxindex to different priors from every synapses; vector<Double_t>TMVA::MethodANNBase::fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; Int_tTMVA::ConvergenceTest::fSteps; TObjArray*TMVA::MethodANNBase::fSynapsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses.",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:29113,Integrability,interface,interface,29113,". void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInver",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:29763,Integrability,message,message,29763,"red, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Jachowski, Kamil Kraszewski, Maciej Kruk, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Jan Therhaag, Jiahang Zhong » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:20797,Modifiability,layers,layers,20797,,MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:21666,Modifiability,layers,layers,21666,,MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:21868,Modifiability,variab,variables,21868," : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Float_tTMVA::ConvergenceTest::fCurrentValue; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorTMVA::MethodANNBase::fEstimator; TH1F*TMVA::MethodANNBase::fEstimatorHistTestmonitors convergence of independent test sample; TH1F*TMVA::MethodANNBase::fEstimatorHistTrainmonitors convergence of training sample; TStringTMVA::MethodANNBase::fEstimatorS; TMVA::TActivation*TMVA::MethodANNBase::fIdentityactivation for input and output layers; Float_tTMVA::ConvergenceTest::fImprovement; TMVA::TNeuronInput*TMVA::MethodANNBase::fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDTMVA::MethodANNBase::fInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tTMVA::MethodANNBase::fNcyclesnumber of epochs to train; TObjArray*TMVA::MethodANNBase::fNetworkTObjArray of TObjArrays representing network; TStringTMVA::MethodANNBase::fNeuronInputTypename of neuron input calculator class; TStringTMVA::MethodANNBase::fNeuronTypename of neuron activation function class; TMVA::TActivation*TMVA::MethodANNBase::fOutputactivation function to be used for output layers, depending on estimator; Int_tTMVA::MethodANNBase::fRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classi",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:22102,Modifiability,variab,variable,22102,"ograms for background; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorTMVA::MethodANNBase::fEstimator; TH1F*TMVA::MethodANNBase::fEstimatorHistTestmonitors convergence of independent test sample; TH1F*TMVA::MethodANNBase::fEstimatorHistTrainmonitors convergence of training sample; TStringTMVA::MethodANNBase::fEstimatorS; TMVA::TActivation*TMVA::MethodANNBase::fIdentityactivation for input and output layers; Float_tTMVA::ConvergenceTest::fImprovement; TMVA::TNeuronInput*TMVA::MethodANNBase::fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDTMVA::MethodANNBase::fInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tTMVA::MethodANNBase::fNcyclesnumber of epochs to train; TObjArray*TMVA::MethodANNBase::fNetworkTObjArray of TObjArrays representing network; TStringTMVA::MethodANNBase::fNeuronInputTypename of neuron input calculator class; TStringTMVA::MethodANNBase::fNeuronTypename of neuron activation function class; TMVA::TActivation*TMVA::MethodANNBase::fOutputactivation function to be used for output layers, depending on estimator; Int_tTMVA::MethodANNBase::fRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>TMVA::MethodANNBase::fRegulatorIdxindex to different priors from every synapses; vector<Double_t>TMVA::MethodANNBas",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:22671,Modifiability,layers,layers,22671,"ple; TH1F*TMVA::MethodANNBase::fEstimatorHistTrainmonitors convergence of training sample; TStringTMVA::MethodANNBase::fEstimatorS; TMVA::TActivation*TMVA::MethodANNBase::fIdentityactivation for input and output layers; Float_tTMVA::ConvergenceTest::fImprovement; TMVA::TNeuronInput*TMVA::MethodANNBase::fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDTMVA::MethodANNBase::fInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; Int_tTMVA::MethodANNBase::fNcyclesnumber of epochs to train; TObjArray*TMVA::MethodANNBase::fNetworkTObjArray of TObjArrays representing network; TStringTMVA::MethodANNBase::fNeuronInputTypename of neuron input calculator class; TStringTMVA::MethodANNBase::fNeuronTypename of neuron activation function class; TMVA::TActivation*TMVA::MethodANNBase::fOutputactivation function to be used for output layers, depending on estimator; Int_tTMVA::MethodANNBase::fRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>TMVA::MethodANNBase::fRegulatorIdxindex to different priors from every synapses; vector<Double_t>TMVA::MethodANNBase::fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; Int_tTMVA::ConvergenceTest::fSteps; TObjArray*TMVA::MethodANNBase::fSynapsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses.",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:24263,Modifiability,variab,variable,24263,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:24803,Modifiability,variab,variable,24803,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:13823,Performance,tune,tuneParameters,13823,":ConvergenceTest::SetConvergenceParameters(Int_t steps, Double_t improvement); voidTMVA::ConvergenceTest::SetCurrentValue(Float_t value); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; Float_tTMVA::ConvergenceTest::SpeedControl(UInt_t ofSteps); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, I",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:24849,Performance,perform,performed,24849,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26310,Performance,perform,performed,26310,"gs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir).",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:29242,Performance,optimiz,optimization,29242," TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Ja",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:13625,Testability,test,testTime,13625,"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); voidTMVA::ConvergenceTest::SetConvergenceParameters(Int_t steps, Double_t improvement); voidTMVA::ConvergenceTest::SetCurrentValue(Float_t value); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; Float_tTMVA::ConvergenceTest::SpeedControl(UInt_t ofSteps); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voi",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:19421,Testability,test,testing,19421,"); voidTrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); voidUpdateNetwork(Double_t desired, Double_t eventWeight = 1.); voidUpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); voidUpdatePriors(); voidUpdateRegulators(); voidUpdateSynapses(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TMVA::MethodMLP::ETrainingMethodkBFGS; static TMVA::MethodMLP::ETrainingMethodkBP; static TMVA::MethodMLP::EBPTrainingModekBatch; static TObject::(anonymous)TObject::kBitMask; static TMVA::MethodANNBase::EEstimatorTMVA::MethodANNBase::kCE; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TMVA::MethodMLP::ETrainingMethodkGA; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMVA::MethodANNBase::EEstimatorTMVA::MethodANNBase::kMSE; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TMVA::MethodMLP::EBPTrainingModekSequential; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::TActivation*TMVA::MethodANNBase::fActivationactivation function to be used for hidden layers; TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; ",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:21446,Testability,test,test,21446,,MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:24613,Testability,test,testing,24613,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:23514,Usability,learn,learning,23514,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:23603,Usability,learn,learning,23603,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:23642,Usability,learn,learning,23642,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:23811,Usability,learn,learning,23811,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:24426,Usability,clear,clear,24426,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26195,Usability,learn,learning,26195,"gs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir).",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26253,Usability,learn,learning,26253,"gs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir).",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26373,Usability,learn,learning,26373," TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir). Double_t DerivDir(TMatrixD& Dir). Bool_t LineSearch(TMatrixD& Dir, vector<Double_t>& Buffer, Double_t* dError = 0). void SetDirWeight",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:26642,Usability,learn,learning,26642," ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir). Double_t DerivDir(TMatrixD& Dir). Bool_t LineSearch(TMatrixD& Dir, vector<Double_t>& Buffer, Double_t* dError = 0). void SetDirWeights(vector<Double_t>& Origin, TMatrixD& Dir, Double_t alpha). Double_t GetError(). Double_t GetMSEErr(const TMVA::Event* ev, UInt_t index = 0). Double_t GetCEErr(const TMVA::Event* ev, UInt_t index = 0). void BackPropagationMinimize(Int_t nEpochs); minimize esti",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodMLP.html:28050,Usability,learn,learning,28050,"_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir). Double_t DerivDir(TMatrixD& Dir). Bool_t LineSearch(TMatrixD& Dir, vector<Double_t>& Buffer, Double_t* dError = 0). void SetDirWeights(vector<Double_t>& Origin, TMatrixD& Dir, Double_t alpha). Double_t GetError(). Double_t GetMSEErr(const TMVA::Event* ev, UInt_t index = 0). Double_t GetCEErr(const TMVA::Event* ev, UInt_t index = 0). void BackPropagationMinimize(Int_t nEpochs); minimize estimator / train network with backpropagation algorithm. void TrainOneEpoch(); train network over a single epoch/cyle of events. void Shuffle(Int_t* index, Int_t n); Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for sequential training. void DecaySynapseWeights(Bool_t lateEpoch); decay synapse weights; in last 10 epochs, lower learning rate even more to find a good minimum. void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, ",MatchSource.WIKI,root/html604/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:2929,Availability,error,error,2929,"Object* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:3013,Availability,error,error,3013,"& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:19193,Availability,error,error,19193,"d-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompress foam output file; Bool_tfCutNminKeep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default); TStringfDTLogicuse DT algorithm to split cells; TMVA::EDTSeparationfDTSeparationenum which specifies the separation to use for the DT logic; Float_tfDiscrErrCutcut on discrimant error; Int_tfEvPerBinMaximum events (equiv.) per bin in buid-up (1000); Bool_tfFillFoamWithOrigWeightsfill the foam with boost weights; vector<TMVA::PDEFoam*>fFoamgrown PDEFoams; Float_tfFracFraction used for calc of Xmin, Xmax; TMVA::MethodPDEFoam::EKernelfKernelKernel for GetMvaValue(); TMVA::PDEFoamKernelBase*fKernelEstimatorKernel estimator; TStringfKernelStrKernel for GetMvaValue() (option string); UInt_tfMaxDepthmaximum depth of cell tree; Bool_tfMultiTargetRegressiondo regression on multible targets; UInt_tfNminminimal number of events in cell necessary to split cell""; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; Bool_tfSigBgSeparatedSeparate Sig and Bg, or not; TMVA::ETargetSelectionfTargetSelectionmethod of selecting the target (only mulit target regr.); TStringfTargetSelectionStrmethod of select",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:23334,Availability,error,error,23334,"getRegression(); Training one (mono target regression) foam, whose cells contain; the average 0th target. The dimension of the foam = number of; non-targets (= number of variables). void TrainMultiTargetRegression(); Training one (multi target regression) foam, whose cells contain; the average event density. The dimension of the foam = number; of non-targets + number of targets. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' (one unifiend PDEFoam was; trained) the function returns the content of the cell, which; corresponds to the current TMVA::Event, i.e. D =; N_sig/(N_bg+N_sig). In case of 'fSigBgSeparated==true' (two separate PDEFoams were; trained) the function returns. D = Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t CalculateMVAError(); Calculate the error on the Mva value. If fSigBgSeparated == true the error is calculated from the; number of events in the signal and background PDEFoam cells. If fSigBgSeparated == false, the error is taken directly from; the PDEFoam cell. const std::vector<Float_t>& GetMulticlassValues(); Get the multiclass MVA response for the PDEFoam classifier. The; returned MVA values are normalized, i.e. their sum equals 1. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables from the number of cuts made; in each PDEFoam dimension. The PDEFoam dimension (the variable); for which the most cuts were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell t",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:23534,Availability,error,error,23534,"f variables). void TrainMultiTargetRegression(); Training one (multi target regression) foam, whose cells contain; the average event density. The dimension of the foam = number; of non-targets + number of targets. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' (one unifiend PDEFoam was; trained) the function returns the content of the cell, which; corresponds to the current TMVA::Event, i.e. D =; N_sig/(N_bg+N_sig). In case of 'fSigBgSeparated==true' (two separate PDEFoams were; trained) the function returns. D = Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t CalculateMVAError(); Calculate the error on the Mva value. If fSigBgSeparated == true the error is calculated from the; number of events in the signal and background PDEFoam cells. If fSigBgSeparated == false, the error is taken directly from; the PDEFoam cell. const std::vector<Float_t>& GetMulticlassValues(); Get the multiclass MVA response for the PDEFoam classifier. The; returned MVA values are normalized, i.e. their sum equals 1. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables from the number of cuts made; in each PDEFoam dimension. The PDEFoam dimension (the variable); for which the most cuts were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell to start the counting from. - nCuts - the number of cuts are saved in this vector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pde",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:23589,Availability,error,error,23589,"hose cells contain; the average event density. The dimension of the foam = number; of non-targets + number of targets. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' (one unifiend PDEFoam was; trained) the function returns the content of the cell, which; corresponds to the current TMVA::Event, i.e. D =; N_sig/(N_bg+N_sig). In case of 'fSigBgSeparated==true' (two separate PDEFoams were; trained) the function returns. D = Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t CalculateMVAError(); Calculate the error on the Mva value. If fSigBgSeparated == true the error is calculated from the; number of events in the signal and background PDEFoam cells. If fSigBgSeparated == false, the error is taken directly from; the PDEFoam cell. const std::vector<Float_t>& GetMulticlassValues(); Get the multiclass MVA response for the PDEFoam classifier. The; returned MVA values are normalized, i.e. their sum equals 1. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables from the number of cuts made; in each PDEFoam dimension. The PDEFoam dimension (the variable); for which the most cuts were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell to start the counting from. - nCuts - the number of cuts are saved in this vector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pdefoam object. TMVA::PDEFoam* InitFoam(TString , TMVA::EFoamType , UInt_t cls = 0); Create a new ",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:23713,Availability,error,error,23713,"umber of targets. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' (one unifiend PDEFoam was; trained) the function returns the content of the cell, which; corresponds to the current TMVA::Event, i.e. D =; N_sig/(N_bg+N_sig). In case of 'fSigBgSeparated==true' (two separate PDEFoams were; trained) the function returns. D = Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t CalculateMVAError(); Calculate the error on the Mva value. If fSigBgSeparated == true the error is calculated from the; number of events in the signal and background PDEFoam cells. If fSigBgSeparated == false, the error is taken directly from; the PDEFoam cell. const std::vector<Float_t>& GetMulticlassValues(); Get the multiclass MVA response for the PDEFoam classifier. The; returned MVA values are normalized, i.e. their sum equals 1. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables from the number of cuts made; in each PDEFoam dimension. The PDEFoam dimension (the variable); for which the most cuts were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell to start the counting from. - nCuts - the number of cuts are saved in this vector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pdefoam object. TMVA::PDEFoam* InitFoam(TString , TMVA::EFoamType , UInt_t cls = 0); Create a new PDEFoam, set the PDEFoam options (nCells, nBin,; Xmin, Xmax, etc.) and initialize the PDEFoam by calli",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:1080,Deployability,integrat,integration,1080,"Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDEFoam. class TMVA::MethodPDEFoam: public TMVA::MethodBase. MethodPDEFoam. The PDEFoam method is an extension of the PDERS method, which; divides the multi-dimensional phase space in a finite number of; hyper-rectangles (cells) of constant event density. This ""foam"" of; cells is filled with averaged probability-density information; sampled from a training event sample. For a given number of cells, the binning algorithm adjusts the size; and position of the cells inside the multidimensional phase space; based on a binary-split algorithm, minimizing the variance of the; event density in the cell.; The binned event density information of the final foam is stored in; binary trees, allowing for a fast and memory-efficient; classification of events. The implementation of PDEFoam is based on the Monte-Carlo; integration package TFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~MethodPDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configura",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:984,Energy Efficiency,efficient,efficient,984,". TMVA::MethodPDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDEFoam. class TMVA::MethodPDEFoam: public TMVA::MethodBase. MethodPDEFoam. The PDEFoam method is an extension of the PDERS method, which; divides the multi-dimensional phase space in a finite number of; hyper-rectangles (cells) of constant event density. This ""foam"" of; cells is filled with averaged probability-density information; sampled from a training event sample. For a given number of cells, the binning algorithm adjusts the size; and position of the cells inside the multidimensional phase space; based on a binary-split algorithm, minimizing the variance of the; event density in the cell.; The binned event density information of the final foam is stored in; binary trees, allowing for a fast and memory-efficient; classification of events. The implementation of PDEFoam is based on the Monte-Carlo; integration package TFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~MethodPDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurabl",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:1080,Integrability,integrat,integration,1080,"Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDEFoam. class TMVA::MethodPDEFoam: public TMVA::MethodBase. MethodPDEFoam. The PDEFoam method is an extension of the PDERS method, which; divides the multi-dimensional phase space in a finite number of; hyper-rectangles (cells) of constant event density. This ""foam"" of; cells is filled with averaged probability-density information; sampled from a training event sample. For a given number of cells, the binning algorithm adjusts the size; and position of the cells inside the multidimensional phase space; based on a binary-split algorithm, minimizing the variance of the; event density in the cell.; The binned event density information of the final foam is stored in; binary trees, allowing for a fast and memory-efficient; classification of events. The implementation of PDEFoam is based on the Monte-Carlo; integration package TFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~MethodPDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configura",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:21630,Integrability,depend,depending,21630,"m(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0); init PDEFoam objects. MethodPDEFoam(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDEFoam can handle classification with multiple classes and regression; with one or more regression-targets. void Init( void ); default initialization called by all constructors. void DeclareOptions(). Declare MethodPDEFoam options. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); process user options. ~MethodPDEFoam( void ); destructor. void CalcXminXmax(); Determine foam range [fXmin, fXmax] for all dimensions, such; that a fraction of 'fFrac' events lie outside the foam. void Train( void ); Train PDE-Foam depending on the set options. void TrainSeparatedClassification(); Creation of 2 separated foams: one for signal events, one for; backgound events. At the end the foam cells of fFoam[0] will; contain the average number of signal events and fFoam[1] will; contain the average number of background events. void TrainUnifiedClassification(); Create only one unified foam (fFoam[0]) whose cells contain the; average discriminator (N_sig)/(N_sig + N_bg). void TrainMultiClassification(); Create one unified foam (see TrainUnifiedClassification()) for; each class, where the cells of foam i (fFoam[i]) contain the; average fraction of events of class i, i.e. D = number events of class i / total number of events. void TrainMonoTargetRegression(); Training one (mono target regression) foam, whose cells contain; the average 0th target. The dimension of the foam = number of; non-targets (= number of variables). void TrainMultiTargetRegression(); Training one (multi target regression) foam, whose cell",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:25163,Integrability,depend,depends,25163,"s were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell to start the counting from. - nCuts - the number of cuts are saved in this vector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pdefoam object. TMVA::PDEFoam* InitFoam(TString , TMVA::EFoamType , UInt_t cls = 0); Create a new PDEFoam, set the PDEFoam options (nCells, nBin,; Xmin, Xmax, etc.) and initialize the PDEFoam by calling; pdefoam->Initialize(). Parameters:. - foamcaption - name of PDEFoam object. - ft - type of PDEFoam; Candidates are:; - kSeparate - creates TMVA::PDEFoamEvent; - kDiscr - creates TMVA::PDEFoamDiscriminant; - kMonoTarget - creates TMVA::PDEFoamTarget; - kMultiTarget - creates TMVA::MultiTarget; - kMultiClass - creates TMVA::PDEFoamDiscriminant. If 'fDTSeparation != kFoam' then a TMVA::PDEFoamDecisionTree; is created (the separation type depends on fDTSeparation). - cls - marked event class (optional, default value = 0). const std::vector<Float_t>& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:25451,Integrability,depend,depending,25451,"ector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pdefoam object. TMVA::PDEFoam* InitFoam(TString , TMVA::EFoamType , UInt_t cls = 0); Create a new PDEFoam, set the PDEFoam options (nCells, nBin,; Xmin, Xmax, etc.) and initialize the PDEFoam by calling; pdefoam->Initialize(). Parameters:. - foamcaption - name of PDEFoam object. - ft - type of PDEFoam; Candidates are:; - kSeparate - creates TMVA::PDEFoamEvent; - kDiscr - creates TMVA::PDEFoamDiscriminant; - kMonoTarget - creates TMVA::PDEFoamTarget; - kMultiTarget - creates TMVA::MultiTarget; - kMultiClass - creates TMVA::PDEFoamDiscriminant. If 'fDTSeparation != kFoam' then a TMVA::PDEFoamDecisionTree; is created (the separation type depends on fDTSeparation). - cls - marked event class (optional, default value = 0). const std::vector<Float_t>& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with nam",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:26954,Integrability,message,message,26954,"ables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0). EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKernel ker) const; { return UInt_t(ker); }. EKernel UIntToKernel(UInt_t iker). UInt_t TargetSelectionToUInt(TMVA::ETargetSelection ts) const; { return UInt_t(ts); }. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:18239,Modifiability,variab,variables,18239,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TMVA::MethodPDEFoam::EKernelkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompress foam output file; Bool_tfCutNminKeep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default); TStringfDTLogicuse DT algorithm to split cells; TMVA::EDTSeparationfDTSeparationenum which specifies the separation to use for the DT logic; Float_tfDiscrErrCutcut on discrimant error; Int_tfEvPerBinMaximum events (equiv.) per bin in buid-up (1000); Bool_tfFillFoamWithOrigWeightsfill the foam with boost weights; vector<TMVA::PDEFoam*>fFoamgrown PDEFoams; Float_tfFracFraction used for calc of Xmin, Xmax; TM",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:18428,Modifiability,variab,variable,18428,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TMVA::MethodPDEFoam::EKernelkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompress foam output file; Bool_tfCutNminKeep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default); TStringfDTLogicuse DT algorithm to split cells; TMVA::EDTSeparationfDTSeparationenum which specifies the separation to use for the DT logic; Float_tfDiscrErrCutcut on discrimant error; Int_tfEvPerBinMaximum events (equiv.) per bin in buid-up (1000); Bool_tfFillFoamWithOrigWeightsfill the foam with boost weights; vector<TMVA::PDEFoam*>fFoamgrown PDEFoams; Float_tfFracFraction used for calc of Xmin, Xmax; TM",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:22525,Modifiability,variab,variables,22525,"[fXmin, fXmax] for all dimensions, such; that a fraction of 'fFrac' events lie outside the foam. void Train( void ); Train PDE-Foam depending on the set options. void TrainSeparatedClassification(); Creation of 2 separated foams: one for signal events, one for; backgound events. At the end the foam cells of fFoam[0] will; contain the average number of signal events and fFoam[1] will; contain the average number of background events. void TrainUnifiedClassification(); Create only one unified foam (fFoam[0]) whose cells contain the; average discriminator (N_sig)/(N_sig + N_bg). void TrainMultiClassification(); Create one unified foam (see TrainUnifiedClassification()) for; each class, where the cells of foam i (fFoam[i]) contain the; average fraction of events of class i, i.e. D = number events of class i / total number of events. void TrainMonoTargetRegression(); Training one (mono target regression) foam, whose cells contain; the average 0th target. The dimension of the foam = number of; non-targets (= number of variables). void TrainMultiTargetRegression(); Training one (multi target regression) foam, whose cells contain; the average event density. The dimension of the foam = number; of non-targets + number of targets. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' (one unifiend PDEFoam was; trained) the function returns the content of the cell, which; corresponds to the current TMVA::Event, i.e. D =; N_sig/(N_bg+N_sig). In case of 'fSigBgSeparated==true' (two separate PDEFoams were; trained) the function returns. D = Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:24001,Modifiability,variab,variables,24001,"N_bg+N_sig). In case of 'fSigBgSeparated==true' (two separate PDEFoams were; trained) the function returns. D = Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t CalculateMVAError(); Calculate the error on the Mva value. If fSigBgSeparated == true the error is calculated from the; number of events in the signal and background PDEFoam cells. If fSigBgSeparated == false, the error is taken directly from; the PDEFoam cell. const std::vector<Float_t>& GetMulticlassValues(); Get the multiclass MVA response for the PDEFoam classifier. The; returned MVA values are normalized, i.e. their sum equals 1. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables from the number of cuts made; in each PDEFoam dimension. The PDEFoam dimension (the variable); for which the most cuts were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell to start the counting from. - nCuts - the number of cuts are saved in this vector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pdefoam object. TMVA::PDEFoam* InitFoam(TString , TMVA::EFoamType , UInt_t cls = 0); Create a new PDEFoam, set the PDEFoam options (nCells, nBin,; Xmin, Xmax, etc.) and initialize the PDEFoam by calling; pdefoam->Initialize(). Parameters:. - foamcaption - name of PDEFoam object. - ft - type of PDEFoam; Candidates are:; - kSeparate - creates TMVA::PDEFoamEvent; - kDiscr - creates TMVA::PDEFoamDiscriminant; - kMonoTarget - creates TMVA::PDEFoamTarget; - kMultiTarget - creates TMV",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:24095,Modifiability,variab,variable,24095,"= Density_sig/(Density_sig+Density_bg). where 'Density_sig' is the content of the cell in the signal; PDEFoam (fFoam[0]) and 'Density_bg' is the content of the cell; in the background PDEFoam (fFoam[1]). In both cases the error on the discriminant is stored in 'err'; and 'errUpper'. (Of course err and errUpper must be non-zero; and point to valid address to make this work.). Double_t CalculateMVAError(); Calculate the error on the Mva value. If fSigBgSeparated == true the error is calculated from the; number of events in the signal and background PDEFoam cells. If fSigBgSeparated == false, the error is taken directly from; the PDEFoam cell. const std::vector<Float_t>& GetMulticlassValues(); Get the multiclass MVA response for the PDEFoam classifier. The; returned MVA values are normalized, i.e. their sum equals 1. const TMVA::Ranking* CreateRanking(); Compute ranking of input variables from the number of cuts made; in each PDEFoam dimension. The PDEFoam dimension (the variable); for which the most cuts were done is ranked highest. void GetNCuts(TMVA::PDEFoamCell* cell, vector<UInt_t>& nCuts); Fill in 'nCuts' the number of cuts made in every foam dimension,; starting at the root cell 'cell'. Parameters:. - cell - root cell to start the counting from. - nCuts - the number of cuts are saved in this vector. void SetXminXmax(TMVA::PDEFoam* ); Set Xmin, Xmax for every dimension in the given pdefoam object. TMVA::PDEFoam* InitFoam(TString , TMVA::EFoamType , UInt_t cls = 0); Create a new PDEFoam, set the PDEFoam options (nCells, nBin,; Xmin, Xmax, etc.) and initialize the PDEFoam by calling; pdefoam->Initialize(). Parameters:. - foamcaption - name of PDEFoam object. - ft - type of PDEFoam; Candidates are:; - kSeparate - creates TMVA::PDEFoamEvent; - kDiscr - creates TMVA::PDEFoamDiscriminant; - kMonoTarget - creates TMVA::PDEFoamTarget; - kMultiTarget - creates TMVA::MultiTarget; - kMultiClass - creates TMVA::PDEFoamDiscriminant. If 'fDTSeparation != kFoam' then a TMVA::PDE",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:25746,Modifiability,variab,variables,25746," by calling; pdefoam->Initialize(). Parameters:. - foamcaption - name of PDEFoam object. - ft - type of PDEFoam; Candidates are:; - kSeparate - creates TMVA::PDEFoamEvent; - kDiscr - creates TMVA::PDEFoamDiscriminant; - kMonoTarget - creates TMVA::PDEFoamTarget; - kMultiTarget - creates TMVA::MultiTarget; - kMultiClass - creates TMVA::PDEFoamDiscriminant. If 'fDTSeparation != kFoam' then a TMVA::PDEFoamDecisionTree; is created (the separation type depends on fDTSeparation). - cls - marked event class (optional, default value = 0). const std::vector<Float_t>& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). v",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:25944,Modifiability,variab,variables,25944,"MonoTarget - creates TMVA::PDEFoamTarget; - kMultiTarget - creates TMVA::MultiTarget; - kMultiClass - creates TMVA::PDEFoamDiscriminant. If 'fDTSeparation != kFoam' then a TMVA::PDEFoamDecisionTree; is created (the separation type depends on fDTSeparation). - cls - marked event class (optional, default value = 0). const std::vector<Float_t>& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage(",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:26759,Modifiability,variab,variable,26759,"riables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0). EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKernel ker) const; { return UInt_t(ker); }. EKernel UIntToKernel(UInt_t iker). UInt_t TargetSelectionToUInt(TMVA::ETargetSelection ts) const; { return UInt_t(ts); }. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support.",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:12979,Performance,tune,tuneParameters,12979,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); voidTrainMonoTargetRegression(); voidTrainMultiClassification(); voidTrainMultiTargetRegression(); voidTrainSeparatedClassification(); voidTrainUnifiedClassification",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:26279,Performance,load,load,26279,">& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0). EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKer",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:12781,Testability,test,testTime,12781,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); v",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:16942,Testability,test,testing,16942,", const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidInit(); voidPrintCoefficients(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TMVA::MethodPDEFoam::EKernelkGaus; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMVA::MethodPDEFoam::EKernelkLinN; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TMVA::MethodPDEFoam::EKernelkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase:",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDEFoam.html:19149,Testability,log,logic,19149,"d-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompress foam output file; Bool_tfCutNminKeep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default); TStringfDTLogicuse DT algorithm to split cells; TMVA::EDTSeparationfDTSeparationenum which specifies the separation to use for the DT logic; Float_tfDiscrErrCutcut on discrimant error; Int_tfEvPerBinMaximum events (equiv.) per bin in buid-up (1000); Bool_tfFillFoamWithOrigWeightsfill the foam with boost weights; vector<TMVA::PDEFoam*>fFoamgrown PDEFoams; Float_tfFracFraction used for calc of Xmin, Xmax; TMVA::MethodPDEFoam::EKernelfKernelKernel for GetMvaValue(); TMVA::PDEFoamKernelBase*fKernelEstimatorKernel estimator; TStringfKernelStrKernel for GetMvaValue() (option string); UInt_tfMaxDepthmaximum depth of cell tree; Bool_tfMultiTargetRegressiondo regression on multible targets; UInt_tfNminminimal number of events in cell necessary to split cell""; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; Bool_tfSigBgSeparatedSeparate Sig and Bg, or not; TMVA::ETargetSelectionfTargetSelectionmethod of selecting the target (only mulit target regr.); TStringfTargetSelectionStrmethod of select",MatchSource.WIKI,root/html604/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:3609,Availability,error,error,3609,"st; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:3693,Availability,error,error,3693,"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23040,Availability,avail,available,23040,"PDERS::EVolumeRangeModekUnscaled; static TMVA::MethodPDERS::EVolumeRangeModekUnsupported; static TMVA::MethodPDERS::EVolumeRangeModekkNN. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor for the PDERS method. MethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construct MethodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; tra",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23163,Availability,avail,available,23163,"mentation; MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor for the PDERS method. MethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construct MethodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction o",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:26032,Availability,error,error,26032,"ySearchTreeNode*>& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. cons",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:26496,Deployability,update,update,26496,"he normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. MethodPDERS*& GetMethodPDERSThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodPDERS*) fgThisPDERS(nullptr); return fgThisPDERS;}. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This p",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:1143,Energy Efficiency,reduce,reduce,1143,"r viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) cons",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:1766,Energy Efficiency,adapt,adaptive,1766,"ity density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtua",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20150,Energy Efficiency,adapt,adaptive,20150,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20207,Energy Efficiency,adapt,adaptive,20207,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20289,Energy Efficiency,adapt,adaptive,20289,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20504,Energy Efficiency,adapt,adapt,20504,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20608,Energy Efficiency,adapt,adaptive,20608,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20671,Energy Efficiency,adapt,adaptive,20671,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23433,Energy Efficiency,adapt,adaptive,23433,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23502,Energy Efficiency,adapt,adaptive,23502,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23579,Energy Efficiency,adapt,adaptive,23579,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23641,Energy Efficiency,adapt,adaptive,23641,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:24370,Energy Efficiency,adapt,adaptive,24370,"ventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*>& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_dis",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:25815,Energy Efficiency,efficient,efficient,25815,"TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, con",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:22798,Integrability,rout,routine,22798,"EKernelEstimatorkSinc9; static TMVA::MethodPDERS::EKernelEstimatorkSphere; static TMVA::MethodPDERS::EKernelEstimatorkTeepee; static TMVA::MethodPDERS::EKernelEstimatorkTrim; static TMVA::MethodPDERS::EVolumeRangeModekUnscaled; static TMVA::MethodPDERS::EVolumeRangeModekUnsupported; static TMVA::MethodPDERS::EVolumeRangeModekkNN. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor for the PDERS method. MethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); construct MethodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options ",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:26656,Integrability,message,message,26656,"stance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. MethodPDERS*& GetMethodPDERSThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodPDERS*) fgThisPDERS(nullptr); return fgThisPDERS;}. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:437,Modifiability,variab,variables,437,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::Meth",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:1319,Modifiability,variab,variable,1319,"TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurabl",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:1766,Modifiability,adapt,adaptive,1766,"ity density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtua",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:19230,Modifiability,variab,variable,19230,"tusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Int_tfFcnCallnumber of external function calls (RootFinder); TMVA::Volume*fHelpVolumeauxiliary variable; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Float_t>fAverageRMSaverage RMS of signal and background; TMVA::BinarySearchTree*fBinaryTreebinary tree; vector<Float_t>*fDeltasize of volume; Float_tfDeltaFracfraction of RMS; Double_tfGaussSigmasize of Gauss in adaptive volume; Double_tfGaussSigmaNormsize of Gauss in adaptive volume (normalised to dimensions); Float_tfInitialScaleinitial scale for adaptive volume; Bool_tfInitializedVolumeEleis volume element initialized ?; enum EKernelEstimatorfKernelEstimator; TStringfKernelStringoption k",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:19300,Modifiability,variab,variables,19300,"tusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Int_tfFcnCallnumber of external function calls (RootFinder); TMVA::Volume*fHelpVolumeauxiliary variable; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Float_t>fAverageRMSaverage RMS of signal and background; TMVA::BinarySearchTree*fBinaryTreebinary tree; vector<Float_t>*fDeltasize of volume; Float_tfDeltaFracfraction of RMS; Double_tfGaussSigmasize of Gauss in adaptive volume; Double_tfGaussSigmaNormsize of Gauss in adaptive volume (normalised to dimensions); Float_tfInitialScaleinitial scale for adaptive volume; Bool_tfInitializedVolumeEleis volume element initialized ?; enum EKernelEstimatorfKernelEstimator; TStringfKernelStringoption k",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:19489,Modifiability,variab,variable,19489,"tusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Int_tfFcnCallnumber of external function calls (RootFinder); TMVA::Volume*fHelpVolumeauxiliary variable; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Float_t>fAverageRMSaverage RMS of signal and background; TMVA::BinarySearchTree*fBinaryTreebinary tree; vector<Float_t>*fDeltasize of volume; Float_tfDeltaFracfraction of RMS; Double_tfGaussSigmasize of Gauss in adaptive volume; Double_tfGaussSigmaNormsize of Gauss in adaptive volume (normalised to dimensions); Float_tfInitialScaleinitial scale for adaptive volume; Bool_tfInitializedVolumeEleis volume element initialized ?; enum EKernelEstimatorfKernelEstimator; TStringfKernelStringoption k",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20150,Modifiability,adapt,adaptive,20150,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20207,Modifiability,adapt,adaptive,20207,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20289,Modifiability,adapt,adaptive,20289,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20504,Modifiability,adapt,adapt,20504,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20608,Modifiability,adapt,adaptive,20608,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:20671,Modifiability,adapt,adaptive,20671,,MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23433,Modifiability,adapt,adaptive,23433,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23502,Modifiability,adapt,adaptive,23502,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23579,Modifiability,adapt,adaptive,23579,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:23641,Modifiability,adapt,adaptive,23641,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:24370,Modifiability,adapt,adaptive,24370,"ventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*>& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_dis",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:27043,Modifiability,variab,variables,27043,"nce(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. MethodPDERS*& GetMethodPDERSThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodPDERS*) fgThisPDERS(nullptr); return fgThisPDERS;}. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:13568,Performance,tune,tuneParameters,13568,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:26958,Security,access,accessors,26958,"nce(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. MethodPDERS*& GetMethodPDERSThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodPDERS*) fgThisPDERS(nullptr); return fgThisPDERS;}. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:872,Testability,test,test,872,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::Meth",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:1014,Testability,test,test,1014,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::Meth",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:13370,Testability,test,testTime,13370,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::Tra",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:18024,Testability,test,testing,18024,"tCRScalc(const TMVA::Event&); virtual voidDeclareOptions(); Float_tGetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; static TMVA::MethodPDERS*&GetMethodPDERSThreadLocal(); voidGetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*>& events, TMVA::Volume* volume); virtual voidInit(); virtual voidProcessOptions(); voidRRScalc(const TMVA::Event&, vector<Float_t>* count); voidSetVolumeElement(); voidUpdateThis(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Int_tfFcnCallnumber of external function calls (RootFinder); TMVA::Volume*fHelpVolumeauxiliary variable; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multicl",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:24057,Testability,test,test,24057," determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*>& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>&",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodPDERS.html:769,Usability,simpl,simple,769,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::Meth",MatchSource.WIKI,root/html604/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:2201,Availability,error,error,2201,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:2285,Availability,error,error,2285,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:21637,Availability,avail,available,21637," initial s/b fraction in training data; Double_tfTreeEveFracfraction of events used for traing each tree; Bool_tfUseBoostuse boosted events for forest generation; Bool_tfUseRuleFitJFif true interface with J.Friedmans RuleFit module. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodRuleFit(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodRuleFit( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); RuleFit can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:22043,Availability,error,error,22043,"ss Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodRuleFit(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodRuleFit( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); RuleFit can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the opti",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:22280,Availability,avail,available,22280,"ctor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); RuleFit can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of ru",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:22595,Availability,avail,available,22595,"an be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXML",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:22747,Deployability,install,installed,22747,"it threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errU",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:19260,Energy Efficiency,monitor,monitor,19260,,MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:22983,Energy Efficiency,monitor,monitoring,22983,"dient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpe",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:23909,Energy Efficiency,monitor,monitoring,23909,"cess the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:20868,Integrability,interface,interface,20868,"uble_tfGDValidEveFracGD path: fraction of subsamples used for the fitting; Double_tfLinQuantilequantile cut to remove outliers - see RuleEnsemble; Double_tfMaxFracNEveditto max; Double_tfMinFracNEvemin fraction of number events; Double_tfMinimprule/linear: minimum importance; TStringfModelTypeSrule ensemble: which model (rule,linear or both); TTree*fMonitorNtuplepointer to monitor rule ntuple; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNTCoefficientntuple: rule coefficient; Double_tfNTImportancentuple: rule importance; Int_tfNTNcutsntuple: rule number of cuts; Int_tfNTNvarsntuple: rule number of vars; Double_tfNTPbbntuple: rule P(tag b, true b); Double_tfNTPbsntuple: rule P(tag b, true s); Double_tfNTPsbntuple: rule P(tag s, true b); Double_tfNTPssntuple: rule P(tag s, true s); Double_tfNTPtagntuple: rule P(tag); Double_tfNTSSBntuple: rule S/(S+B); Double_tfNTSupportntuple: rule support; Int_tfNTTypentuple: rule type (+1->signal, -1->bkg); Int_tfNTreesnumber of trees in forest; TMVA::DecisionTree::EPruneMethodfPruneMethodforest generation: method used for pruning - see DecisionTree; TStringfPruneMethodSforest generation: prune method - see DecisionTree; Double_tfPruneStrengthforest generation: prune strength - see DecisionTree; Int_tfRFNendnodesmax number of rules (only Friedmans module); Int_tfRFNrulesmax number of rules (only Friedmans module); TStringfRFWorkDirworking directory from Friedmans module; TMVA::RuleFitfRuleFitRuleFit instance; TStringfRuleFitModuleSwhich rulefit module to use; Double_tfRuleMinDistrule min distance - see RuleEnsemble; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSforest generation: separation type - see DecisionTree; Double_tfSignalFractionscalefactor for bkg events to modify initial s/b fraction in training data; Double_tfTreeEveFracfraction of events used for traing each tree; Bool_tfUseBoostuse boosted events for forest generation; Bool_tfUseRuleFitJFif true interface with J.",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:24219,Integrability,message,message,24219,"isting trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees() const; { return fNTrees; }. Double_t GetTreeEveFrac() const; { return fTreeEveFrac; }. const SeparationBase* GetSeparationBaseConst() const; { return fSepType; }. SeparationBase* GetSeparationBase() const; { return fSepType; }. TMVA::DecisionTree::EPruneMethod GetPruneMethod() const; { return fPrune",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:17598,Modifiability,variab,variables,17598,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<TMVA::Event*>fEventSamplethe complete training sample; vector<TMVA::DecisionTree*>fForestthe forest; TStringfForestTypeSforest generation: how the trees are generated; Double_tfGDErrScaleGD path: stop; Int_tfGDNPathStepsGD path: number of steps; Double_tfGDPathEveFracGD path: fraction of subsamples used for the fitting; Double_tfGDPathStepGD path: step size in path; Double_tfGDTauGD path: def threshhold fraction [0..1]; Double_tfGDTauMaxGD path: max threshhold fraction [0..1]; Double_tfGDTauMinGD path: min threshhold fraction [0..1]; Double_",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:17787,Modifiability,variab,variable,17787,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<TMVA::Event*>fEventSamplethe complete training sample; vector<TMVA::DecisionTree*>fForestthe forest; TStringfForestTypeSforest generation: how the trees are generated; Double_tfGDErrScaleGD path: stop; Int_tfGDNPathStepsGD path: number of steps; Double_tfGDPathEveFracGD path: fraction of subsamples used for the fitting; Double_tfGDPathStepGD path: step size in path; Double_tfGDTauGD path: def threshhold fraction [0..1]; Double_tfGDTauMaxGD path: max threshhold fraction [0..1]; Double_tfGDTauMinGD path: min threshhold fraction [0..1]; Double_",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:22364,Modifiability,variab,variables,22364,"ctor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); RuleFit can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of ru",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:23530,Modifiability,variab,variables,23530,"een rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). Bool_t UseBoost(",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:12980,Performance,tune,tuneParameters,12980,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0);",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:24561,Security,access,accessors,24561,"ghtsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees() const; { return fNTrees; }. Double_t GetTreeEveFrac() const; { return fTreeEveFrac; }. const SeparationBase* GetSeparationBaseConst() const; { return fSepType; }. SeparationBase* GetSeparationBase() const; { return fSepType; }. TMVA::DecisionTree::EPruneMethod GetPruneMethod() const; { return fPruneMethod; }. Double_t GetPruneStrength() const; { return fPruneStrength; }. Double_t GetMinFracNEve() const; { return fMinFracNEve; }. Double_t GetMaxFracNEve() const; { return fMaxFracNEve; }. Int_t GetNCuts() const. { return fNCuts; }. Int_t GetGDNPathSteps() const; { return fGDNPathSteps; }. Double_t GetGDPathStep() const; { return fGDPathStep;",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:12782,Testability,test,testTime,12782,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; vi",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodRuleFit.html:16427,Testability,test,testing,16427,":MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); voidTrainJFRuleFit(); voidTrainTMVARuleFit(); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodRuleFit.html
https://root.cern/root/html604/TMVA__MethodSVM.html:2159,Availability,error,error,2159,"Object* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:2243,Availability,error,error,2243,"& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:18628,Availability,avail,available,18628,"tfOrderfor Polynomial Kernel ( polynomial order ); TMVA::SVKernelFunction*fSVKernelFunctionkernel function; vector<TMVA::SVEvent*>*fSupportVectorscontains support vectors; TStringfTheKernelkernel name; Float_tfThetafor Sigmoidal Kernel; Float_tfTolerancetolerance parameter; TMVA::SVWorkingSet*fWgSetsvm working set. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodSVM(const TString& jobName, const TString& methodTi",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:18902,Deployability,configurat,configuration,18902,"eter; TMVA::SVWorkingSet*fWgSetsvm working set. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Las",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:19452,Integrability,message,message,19452," methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:16541,Modifiability,variab,variables,16541,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Float_tfBparmfree plane coefficient; Float_tfCostcost value; Float_tfDoubleSigmaSquaredfor RBF Kernel; Float_tfGammaRBF Kernel parameter; vector<TMVA::SVEvent*>*fInputDatavector of training data in SVM format; Float_tfKappafor Sigmoidal Kernel; UInt_tfMaxItermax number of iteration; TVectorD*fMaxVarsfor normalization //is it still needed??; TVectorD*fMinVarsfor normalization //is it still needed??; UShort_tfNSubSetsnr of subsets, default 1; Int_tfOrderfor Polynomial Kernel ( polynomial order ); TMVA::SVKernelFunction*fSVKernelFunctionkernel functio",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:16730,Modifiability,variab,variable,16730,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Float_tfBparmfree plane coefficient; Float_tfCostcost value; Float_tfDoubleSigmaSquaredfor RBF Kernel; Float_tfGammaRBF Kernel parameter; vector<TMVA::SVEvent*>*fInputDatavector of training data in SVM format; Float_tfKappafor Sigmoidal Kernel; UInt_tfMaxItermax number of iteration; TVectorD*fMaxVarsfor normalization //is it still needed??; TVectorD*fMinVarsfor normalization //is it still needed??; UShort_tfNSubSetsnr of subsets, default 1; Int_tfOrderfor Polynomial Kernel ( polynomial order ); TMVA::SVKernelFunction*fSVKernelFunctionkernel functio",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:18902,Modifiability,config,configuration,18902,"eter; TMVA::SVWorkingSet*fWgSetsvm working set. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Las",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:19765,Modifiability,variab,variables,19765," methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:12031,Performance,tune,tuneParameters,12031,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:11833,Testability,test,testTime,11833,"t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodSVM.html:15370,Testability,test,testing,15370,"VA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodSVM.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:2501,Availability,error,error,2501,"figurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:2585,Availability,error,error,2585,"igurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19686,Availability,avail,available,19686,"oid ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier r",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:366,Integrability,interface,interface,366,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual In",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:20788,Integrability,message,message,20788,"ue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:16961,Modifiability,variab,variables,16961,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlp",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:17150,Modifiability,variab,variable,17150,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlp",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19036,Modifiability,layers,layers,19036,"Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weigh",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19409,Modifiability,layers,layers,19409,"Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weigh",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:21195,Modifiability,variab,variables,21195,"ue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:12488,Performance,tune,tuneParameters,12488,"ct::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHiddenLayer(TString hiddenlayer = """"); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19659,Performance,perform,performs,19659,"oid ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier r",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:20221,Performance,load,load,20221,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking o",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:18033,Security,validat,validation,18033,"ssification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:413,Testability,test,testing,413,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual In",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:12290,Testability,test,testTime,12290,"t::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHiddenLayer(TString hiddenlayer = """"); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:15790,Testability,test,testing,15790,"odBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidCreateMLPOptions(TString); virtual voidDeclareOptions(); virtual voidInit(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19959,Testability,test,test,19959,"iddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, c",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:20017,Testability,test,testing,20017,"iddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, c",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:483,Usability,learn,learning,483,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual In",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:17727,Usability,learn,learning,17727,"ssification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19187,Usability,simpl,simply,19187,"Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weigh",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MethodTMlpANN.html:19696,Usability,learn,learning,19696,"oid ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier r",MatchSource.WIKI,root/html604/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:1683,Availability,error,error,1683,"ptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>& pars); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; vi",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:1767,Availability,error,error,1767,"; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>& pars); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:8261,Availability,error,error,8261,"TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:8056,Integrability,wrap,wrapper,8056,"te:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:8978,Performance,perform,performs,8978,"::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:9048,Performance,perform,performs,9048,"::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitFitter.html:8012,Testability,log,logger,8012,"te:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_",MatchSource.WIKI,root/html604/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:1720,Availability,error,error,1720,"ject*Clone(const char*) const; virtual Int_tTMinuit::Command(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*TMinuit::Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTMinuit::DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTMinuit::DeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t, Double_t*, Double_t&, Double_t*, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTMinuit::FixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); virtual const char*TObject::GetIconName() const; Int_tTMinuit::GetMaxIterations() const; TMethodCall*TMinuit::GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tTMinuit::GetNumFixedPars() const; virtual Int_tTMinuit::GetNumFreePars() const; virtual Int_tTMinui",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:1804,Availability,error,error,1804,"irtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*TMinuit::Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTMinuit::DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTMinuit::DeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t, Double_t*, Double_t&, Double_t*, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTMinuit::FixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); virtual const char*TObject::GetIconName() const; Int_tTMinuit::GetMaxIterations() const; TMethodCall*TMinuit::GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tTMinuit::GetNumFixedPars() const; virtual Int_tTMinuit::GetNumFreePars() const; virtual Int_tTMinuit::GetNumPars() const; TObject*TMinuit::GetObjectFit() const; virtual char*TObject::",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:6056,Availability,toler,toler,6056," Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); virtual voidTMinuit::mnemat(Double_t* emat, Int_t ndim); virtual voidTMinuit::mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); virtual voidTMinuit::mneval(Double_t anext, Double_t& fnext, Int_t& ierev); virtual voidTMinuit::mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); virtual voidTMinuit::mnexin(Double_t* pint); virtual voidTMinuit::mnfixp(Int_t iint, Int_t& ierr); virtual voidTMinuit::mnfree(Int_t k); virtual voidTMinuit::mngrad(); virtual voidTMinuit::mnhelp(TString comd); virtual voidTMinuit::mnhelp(const char* command = """"); virtual voidTMinuit::mnhes1(); virtual voidTMinuit::mnhess(); virtual voidTMinuit::mnimpr(); virtual voidTMinuit::mninex(Double_t* pint); virtual voidTMinuit::mninit(Int_t i1, Int_t i2, Int_t i3); virtual voidTMinuit::mnlims(); virtual voidTMinuit::mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); virtual voidTMinuit::mnmatu(Int_t kode); virtual voidTMinuit::mnmigr(); virtual voidTMinuit::mnmnos(); virtual voidTMinuit::mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); virtual voidTMinuit::mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); virtual voidTMinuit::mnpars(TString& crdbuf, Int_t& icondn); virtual voidTMinuit::mnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); virtual voidTMinuit::mnpint(Double_t& pexti, Int_t i, Double_t& pinti); virtual voidTMinuit::mnplot(Double_t* xpt, Double_t* ypt, char* chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); virtual voidTMinuit::mnpout(Int_t iuext, TString& chnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; virtual voidTMinuit::mnprin(Int_t inkode, Double_t fval); virtual voidTMinuit::mnpsdf(); virtual voidTMinuit::mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& j",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:11928,Availability,error,errors,11928,"t*TMinuit::fCONTgcc[fMaxpar] array used in mncont; Double_t*TMinuit::fCONTw[fMaxpar] array used in mncont; TStringTMinuit::fCfrom; char*TMinuit::fChpt!Character to be plotted at the X,Y contour positions; TStringTMinuit::fCovmes[4]; TString*TMinuit::fCpnam[fMaxpar2] Array of parameters names; TStringTMinuit::fCstatu; TStringTMinuit::fCtitl; TStringTMinuit::fCundef; TStringTMinuit::fCvrsn; TStringTMinuit::fCword; Double_tTMinuit::fDcovarRelative change in covariance matrix; Double_t*TMinuit::fDgrd[fMaxpar] Uncertainties; Double_t*TMinuit::fDirin[fMaxpar] (Internal) step sizes for current step; Double_t*TMinuit::fDirins[fMaxpar] (Internal) step sizes for current step for fixed params; Double_tTMinuit::fEDMEstimated vertical distance to the minimum; Int_tTMinuit::fEmptyInitialization flag (1 = Minuit initialized); Double_tTMinuit::fEpsi; Double_tTMinuit::fEpsma2sqrt(fEpsmac); Double_tTMinuit::fEpsmacmachine precision for floating points:; Double_t*TMinuit::fErn[fMaxpar] Negative Minos errors if calculated; Double_t*TMinuit::fErp[fMaxpar] Positive Minos errors if calculated; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)TMinuit::fFCN!; Double_t*TMinuit::fFIXPyy[fMaxpar] array used in mnfixp; Double_tTMinuit::fFval3; Double_t*TMinuit::fG2[fMaxpar]; Double_t*TMinuit::fG2s[fMaxpar]; Double_t*TMinuit::fGRADgf[fMaxpar] array used in mngrad; Double_t*TMinuit::fGin[fMaxpar2]; Double_t*TMinuit::fGlobcc[fMaxpar] Global Correlation Coefficients; Bool_tTMinuit::fGraphicsModetrue if graphics mode on (default); Double_t*TMinuit::fGrd[fMaxpar] First derivatives; Double_t*TMinuit::fGrds[fMaxpar]; Double_t*TMinuit::fGstep[fMaxpar] Step sizes; Double_t*TMinuit::fGsteps[fMaxpar]; Double_t*TMinuit::fHESSyy[fMaxpar] array used in mnhess; Double_t*TMinuit::fIMPRdsav[fMaxpar] array used in mnimpr; Double_t*TMinuit::fIMPRy[fMaxpar] array used in mnimpr; Int_tTMinuit::fISW[7]Array of switches; Int_tTMinuit::fIcirc[2]; Int_tTMinuit::fIcomndNumber of commands; Int_tTMinuit::fIdbg[11]Array of",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:11997,Availability,error,errors,11997,"fCONTw[fMaxpar] array used in mncont; TStringTMinuit::fCfrom; char*TMinuit::fChpt!Character to be plotted at the X,Y contour positions; TStringTMinuit::fCovmes[4]; TString*TMinuit::fCpnam[fMaxpar2] Array of parameters names; TStringTMinuit::fCstatu; TStringTMinuit::fCtitl; TStringTMinuit::fCundef; TStringTMinuit::fCvrsn; TStringTMinuit::fCword; Double_tTMinuit::fDcovarRelative change in covariance matrix; Double_t*TMinuit::fDgrd[fMaxpar] Uncertainties; Double_t*TMinuit::fDirin[fMaxpar] (Internal) step sizes for current step; Double_t*TMinuit::fDirins[fMaxpar] (Internal) step sizes for current step for fixed params; Double_tTMinuit::fEDMEstimated vertical distance to the minimum; Int_tTMinuit::fEmptyInitialization flag (1 = Minuit initialized); Double_tTMinuit::fEpsi; Double_tTMinuit::fEpsma2sqrt(fEpsmac); Double_tTMinuit::fEpsmacmachine precision for floating points:; Double_t*TMinuit::fErn[fMaxpar] Negative Minos errors if calculated; Double_t*TMinuit::fErp[fMaxpar] Positive Minos errors if calculated; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)TMinuit::fFCN!; Double_t*TMinuit::fFIXPyy[fMaxpar] array used in mnfixp; Double_tTMinuit::fFval3; Double_t*TMinuit::fG2[fMaxpar]; Double_t*TMinuit::fG2s[fMaxpar]; Double_t*TMinuit::fGRADgf[fMaxpar] array used in mngrad; Double_t*TMinuit::fGin[fMaxpar2]; Double_t*TMinuit::fGlobcc[fMaxpar] Global Correlation Coefficients; Bool_tTMinuit::fGraphicsModetrue if graphics mode on (default); Double_t*TMinuit::fGrd[fMaxpar] First derivatives; Double_t*TMinuit::fGrds[fMaxpar]; Double_t*TMinuit::fGstep[fMaxpar] Step sizes; Double_t*TMinuit::fGsteps[fMaxpar]; Double_t*TMinuit::fHESSyy[fMaxpar] array used in mnhess; Double_t*TMinuit::fIMPRdsav[fMaxpar] array used in mnimpr; Double_t*TMinuit::fIMPRy[fMaxpar] array used in mnimpr; Int_tTMinuit::fISW[7]Array of switches; Int_tTMinuit::fIcirc[2]; Int_tTMinuit::fIcomndNumber of commands; Int_tTMinuit::fIdbg[11]Array of internal debug switches; Int_t*TMinuit::fIpfix[fMaxpar] List of fixe",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:16451,Availability,error,errors,16451,,MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:16726,Availability,error,error,16726," used in mnpars; Double_t*TMinuit::fPSDFs[fMaxpar] array used in mnpsdf; Double_t*TMinuit::fPbar[fMaxpar]; TObject*TMinuit::fPlotPointer to TGraph object created by mncont; Double_t*TMinuit::fPrho[fMaxpar] Minimum point of parabola; Double_t*TMinuit::fPstar[fMaxpar2]; Double_t*TMinuit::fPstst[fMaxpar]; Double_t*TMinuit::fSEEKxbest[fMaxpar] array used in mnseek; Double_t*TMinuit::fSEEKxmid[fMaxpar] array used in mnseek; Double_t*TMinuit::fSIMPy[fMaxpar] array used in mnsimp; Int_tTMinuit::fStatusStatus flag for the last called Minuit function; Double_t*TMinuit::fU[fMaxpar2] External (visible to user in FCN) value of parameters; Double_tTMinuit::fUndefiUndefined number = -54321; Double_tTMinuit::fUpFCN+-UP defines errors (for chisquare fits UP=1); Double_tTMinuit::fUpdflt; Double_t*TMinuit::fVERTpp[fMaxpar] array used in mnvert; Double_t*TMinuit::fVERTq[fMaxpar] array used in mnvert; Double_t*TMinuit::fVERTs[fMaxpar] array used in mnvert; Double_t*TMinuit::fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tTMinuit::fVlimhi; Double_tTMinuit::fVlimlo; Double_t*TMinuit::fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringTMinuit::fWarmes[100]; Double_t*TMinuit::fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*TMinuit::fWord7[fMaxpar]; Double_t*TMinuit::fX[fMaxpar] Internal parameters values; Double_tTMinuit::fXdircr; Double_tTMinuit::fXmidcr; Double_t*TMinuit::fXpt[fMaxcpt] X array of points for contours; Double_t*TMinuit::fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*TMinuit::fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*TMinuit::fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tTMinuit::fYdircr; Double_tTMinuit::fYmidcr; Double_t*TMinuit::fYpt[fMaxcpt] Y array of points for contours; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static ",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:17014,Availability,error,error,17014,"Pstst[fMaxpar]; Double_t*TMinuit::fSEEKxbest[fMaxpar] array used in mnseek; Double_t*TMinuit::fSEEKxmid[fMaxpar] array used in mnseek; Double_t*TMinuit::fSIMPy[fMaxpar] array used in mnsimp; Int_tTMinuit::fStatusStatus flag for the last called Minuit function; Double_t*TMinuit::fU[fMaxpar2] External (visible to user in FCN) value of parameters; Double_tTMinuit::fUndefiUndefined number = -54321; Double_tTMinuit::fUpFCN+-UP defines errors (for chisquare fits UP=1); Double_tTMinuit::fUpdflt; Double_t*TMinuit::fVERTpp[fMaxpar] array used in mnvert; Double_t*TMinuit::fVERTq[fMaxpar] array used in mnvert; Double_t*TMinuit::fVERTs[fMaxpar] array used in mnvert; Double_t*TMinuit::fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tTMinuit::fVlimhi; Double_tTMinuit::fVlimlo; Double_t*TMinuit::fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringTMinuit::fWarmes[100]; Double_t*TMinuit::fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*TMinuit::fWord7[fMaxpar]; Double_t*TMinuit::fX[fMaxpar] Internal parameters values; Double_tTMinuit::fXdircr; Double_tTMinuit::fXmidcr; Double_t*TMinuit::fXpt[fMaxcpt] X array of points for contours; Double_t*TMinuit::fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*TMinuit::fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*TMinuit::fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tTMinuit::fYdircr; Double_tTMinuit::fYmidcr; Double_t*TMinuit::fYpt[fMaxcpt] Y array of points for contours; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMinuit::(anonymous)TMinuit::kMAXWARN; stat",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:19516,Availability,error,errors,19516,"ter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar). virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:19579,Availability,error,error,19579,"ter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar). virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:19601,Availability,error,error,19601,"ter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar). virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:19627,Availability,error,error,19627,"ter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar). virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:19925,Availability,error,error,19925,"; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar). virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:14897,Modifiability,variab,variable,14897,"if a heading should be put out for the next parameter definition; Bool_tTMinuit::fLreportrue if exceptional conditions are put out (default=false); Bool_tTMinuit::fLwarntrue if warning messges are to be put out (default=true); Double_t*TMinuit::fMATUvline[fMaxpar] array used in mnmatu; Double_t*TMinuit::fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRgs[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRstep[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRvg[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*TMinuit::fMNOTw[fMaxpar] array used in mnmnot; Double_t*TMinuit::fMNOTxdev[fMaxpar] array used in mnmnot; Int_tTMinuit::fMaxIterationsMaximum number of iterations; Int_tTMinuit::fMaxcpt; Int_tTMinuit::fMaxextMaximum number of external parameters; Int_tTMinuit::fMaxintMaximum number of internal parameters; Int_tTMinuit::fMaxparMaximum number of parameters; Int_tTMinuit::fMaxpar1fMaxpar*(fMaxpar+1); Int_tTMinuit::fMaxpar2fMaxpar*fMaxpar; Int_tTMinuit::fMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*TMinuit::fMethodCallPointer to MethodCall in case of interpreted function; Int_tTMinuit::fNblockNumber of Minuit data blocks; Int_tTMinuit::fNewpag; Int_t*TMinuit::fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tTMinuit::fNfcnNumber of calls to FCN; Int_tTMinuit::fNfcnfr; Int_tTMinuit::fNfcnlc; Int_tTMinuit::fNfcnmxMaximum number of calls to FCN; Int_tTMinuit::fNfcwar[20]; Int_t*TMinuit::fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tTMinuit::fNpaglnNumber of lines per page; Int_tTMinuit::fNpagwdPage width; Int_tTMinuit::fNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tTMinuit::fNpfixNumber of fixed parameters; Int_tTMinuit::fNstkrd; Int_tTMinuit::fNstkwr; Int_tTMinuit::fNu; Int_t*TMinuit::fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:15173,Modifiability,variab,variable,15173,"if a heading should be put out for the next parameter definition; Bool_tTMinuit::fLreportrue if exceptional conditions are put out (default=false); Bool_tTMinuit::fLwarntrue if warning messges are to be put out (default=true); Double_t*TMinuit::fMATUvline[fMaxpar] array used in mnmatu; Double_t*TMinuit::fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRgs[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRstep[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRvg[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*TMinuit::fMNOTw[fMaxpar] array used in mnmnot; Double_t*TMinuit::fMNOTxdev[fMaxpar] array used in mnmnot; Int_tTMinuit::fMaxIterationsMaximum number of iterations; Int_tTMinuit::fMaxcpt; Int_tTMinuit::fMaxextMaximum number of external parameters; Int_tTMinuit::fMaxintMaximum number of internal parameters; Int_tTMinuit::fMaxparMaximum number of parameters; Int_tTMinuit::fMaxpar1fMaxpar*(fMaxpar+1); Int_tTMinuit::fMaxpar2fMaxpar*fMaxpar; Int_tTMinuit::fMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*TMinuit::fMethodCallPointer to MethodCall in case of interpreted function; Int_tTMinuit::fNblockNumber of Minuit data blocks; Int_tTMinuit::fNewpag; Int_t*TMinuit::fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tTMinuit::fNfcnNumber of calls to FCN; Int_tTMinuit::fNfcnfr; Int_tTMinuit::fNfcnlc; Int_tTMinuit::fNfcnmxMaximum number of calls to FCN; Int_tTMinuit::fNfcwar[20]; Int_t*TMinuit::fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tTMinuit::fNpaglnNumber of lines per page; Int_tTMinuit::fNpagwdPage width; Int_tTMinuit::fNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tTMinuit::fNpfixNumber of fixed parameters; Int_tTMinuit::fNstkrd; Int_tTMinuit::fNstkwr; Int_tTMinuit::fNu; Int_t*TMinuit::fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MinuitWrapper.html:19344,Modifiability,variab,variable,19344,"TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMVA::IFitterTarget&fFitterTargetfitter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar). virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; ",MatchSource.WIKI,root/html604/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MinuitWrapper.html
https://root.cern/root/html604/TMVA__MisClassificationError.html:1671,Availability,error,error,1671,"TMVA::MisClassificationError. class TMVA::MisClassificationError: public TMVA::SeparationBase. Implementation of the MisClassificationError as separation criterion. Function Members (Methods); public:. virtual~MisClassificationError(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::MisClassificationErrorMisClassificationError(); TMVA::MisClassificationErrorMisClassificationError(const TMVA::MisClassificationError& g); TMVA::MisClassificationError&operator=(const TMVA::MisClassificationError&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Misclassifiacton error criterion: 1-max(p, 1-p) (p: purity= s/(s+b)). MisClassificationError(); consturctor for the Misclassification error. { fName = ""MisCl""; }. MisClassificationError(const TMVA::MisClassificationError& g); copy constructor. {}. virtual ~MisClassificationError(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MisClassificationError.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MisClassificationError.html
https://root.cern/root/html604/TMVA__MisClassificationError.html:1788,Availability,error,error,1788,"TMVA::MisClassificationError. class TMVA::MisClassificationError: public TMVA::SeparationBase. Implementation of the MisClassificationError as separation criterion. Function Members (Methods); public:. virtual~MisClassificationError(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); virtual Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::MisClassificationErrorMisClassificationError(); TMVA::MisClassificationErrorMisClassificationError(const TMVA::MisClassificationError& g); TMVA::MisClassificationError&operator=(const TMVA::MisClassificationError&); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Misclassifiacton error criterion: 1-max(p, 1-p) (p: purity= s/(s+b)). MisClassificationError(); consturctor for the Misclassification error. { fName = ""MisCl""; }. MisClassificationError(const TMVA::MisClassificationError& g); copy constructor. {}. virtual ~MisClassificationError(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MisClassificationError.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MisClassificationError.html
https://root.cern/root/html604/TMVA__MsgLogger.html:2154,Availability,error,error,2154,"tual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& __rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate __except); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); boolbasic_ios<char,char_traits<char> >::fail() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill() const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill(basic_ios<char,char_traits<char> >::char_type __ch); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ios_base::fmtflagsios_base::flags() const; ios_base::fmtflagsios_base::flags(ios_base::fmtflags __fmtfl); basic_ostream<char,char_traits<char> >::__ostream_type&basic_ostream<char,char_traits<char> >::flush(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); stringGetFormattedSource() const; virtual const char*TObj",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:2238,Availability,error,error,2238,"ect& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& __rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate __except); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); boolbasic_ios<char,char_traits<char> >::fail() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill() const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill(basic_ios<char,char_traits<char> >::char_type __ch); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ios_base::fmtflagsios_base::flags() const; ios_base::fmtflagsios_base::flags(ios_base::fmtflags __fmtfl); basic_ostream<char,char_traits<char> >::__ostream_type&basic_ostream<char,char_traits<char> >::flush(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); stringGetFormattedSource() const; virtual const char*TObject::GetIconName() const; localeios_base::getloc() const; static UInt_tGetMaxSourceS",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:15341,Integrability,message,message,15341," name; static const stringfgSuffixsuffix following source name; static atomic<const map<TMVA::EMsgType,string>*>fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (const UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). MsgLogger& operator<<( std::ios& ( *_f )( std::ios& ) ). MsgLogger& operator<<( EMsgType type ); Accept message type specification. » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been auto",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:15498,Integrability,message,message,15498,"put types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (const UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). MsgLogger& operator<<( std::ios& ( *_f )( std::ios& ) ). MsgLogger& operator<<( EMsgType type ); Accept message type specification. » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:16097,Integrability,message,message,16097,"put types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (const UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). MsgLogger& operator<<( std::ios& ( *_f )( std::ios& ) ). MsgLogger& operator<<( EMsgType type ); Accept message type specification. » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:1789,Testability,log,logger,1789,"""""); boolbasic_ios<char,char_traits<char> >::bad() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidbasic_ios<char,char_traits<char> >::clear(ios_base::iostate __state = goodbit); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& __rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate __except); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); boolbasic_ios<char,char_traits<char> >::fail() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill() const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill(basic_ios<char,char_traits<char> >::char_type __ch); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* o",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:15191,Testability,log,logger,15191,"urce name; static atomic<Bool_t>fgOutputSupresseddisable the output globaly (used by generic booster); static const stringfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static atomic<const map<TMVA::EMsgType,string>*>fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (const UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). MsgLogger& operator<<( std::ios& ( *_f )( std::ios& ) ). MsgLogger& operator<<( EMsgType type ); Accept message type specification. » Author: Attila Krasznahorkay, Andreas Hoecker, ",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:15233,Testability,log,logger,15233,"able the output globaly (used by generic booster); static const stringfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static atomic<const map<TMVA::EMsgType,string>*>fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (const UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). MsgLogger& operator<<( std::ios& ( *_f )( std::ios& ) ). MsgLogger& operator<<( EMsgType type ); Accept message type specification. » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 20",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:15451,Testability,log,logger,15451,">fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (const UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). MsgLogger& operator<<( std::ios& ( *_f )( std::ios& ) ). MsgLogger& operator<<( EMsgType type ); Accept message type specification. » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__MsgLogger.html:1046,Usability,clear,clear,1046," virtual~MsgLogger(); const locale&ios_base::_M_getloc() const; voidbasic_ios<char,char_traits<char> >::_M_setstate(ios_base::iostate __state); voidbasic_ostream<char,char_traits<char> >::_M_write(const basic_ostream<char,char_traits<char> >::char_type* __s, streamsize __n); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); boolbasic_ios<char,char_traits<char> >::bad() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidbasic_ios<char,char_traits<char> >::clear(ios_base::iostate __state = goodbit); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& __rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voi",MatchSource.WIKI,root/html604/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__MsgLogger.html
https://root.cern/root/html604/TMVA__Node.html:731,Availability,avail,available,731,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeNode(); TMVA::NodeNode(const TMVA::Node& n); TMVA::NodeNode(TMVA::Node* p, char pos); TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = 262657); voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); v",MatchSource.WIKI,root/html604/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Node.html
https://root.cern/root/html604/TMVA__Node.html:511,Modifiability,variab,variable,511,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeNode(); TMVA::NodeNode(const TMVA::Node& n); TMVA::NodeNode(TMVA::Node* p, char pos); TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = 262657); voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); v",MatchSource.WIKI,root/html604/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Node.html
https://root.cern/root/html604/TMVA__Node.html:3520,Testability,test,test,3520,"A::Node*fRightpointers to the two ""daughter"" nodes. private:. static Int_tfgCountcounter of all nodes present.. for debug.. to spot memory leaks... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Node(); default constructor. Node(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. Node(const TMVA::Node& n); copy constructor, make sure you don't just copy the poiter to the node, but; that the parents/daugthers are initialized to 0 (and set by the copy; constructors of the derived classes. ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() co",MatchSource.WIKI,root/html604/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Node.html
https://root.cern/root/html604/TMVA__Node.html:3625,Testability,test,test,3625,"sent.. for debug.. to spot memory leaks... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Node(); default constructor. Node(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. Node(const TMVA::Node& n); copy constructor, make sure you don't just copy the poiter to the node, but; that the parents/daugthers are initialized to 0 (and set by the copy; constructors of the derived classes. ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() const; Return depth, layer of the where the node is within the tree, seen from the top (root). {return fDep",MatchSource.WIKI,root/html604/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Node.html
https://root.cern/root/html604/TMVA__Node.html:3708,Testability,test,test,3708,"e(); default constructor. Node(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. Node(const TMVA::Node& n); copy constructor, make sure you don't just copy the poiter to the node, but; that the parents/daugthers are initialized to 0 (and set by the copy; constructors of the derived classes. ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() const; Return depth, layer of the where the node is within the tree, seen from the top (root). {return fDepth;}. void SetPos(char s); set node position, i.e, the node is a left (l) or right (r) daugther. {fPos=s;}. char GetPos() const; Return th",MatchSource.WIKI,root/html604/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Node.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:4275,Availability,reliab,reliably,4275,"d::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t GetBkgRejAtSigEff(Double_t sigEff = 0.5); calculate the background rejection for a given signal efficiency. OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Tue Jun 2 16:17:38 2015 » Last generated: 2015-06-02 16:17; This p",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3781,Integrability,interface,interface,3781,"tring,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:729,Performance,optimiz,optimize,729,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::OptimizeConfigParameters&operator=(const TMVA::OptimizeConfigParameters&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<F",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:951,Performance,tune,tuneParameters,951,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::OptimizeConfigParameters&operator=(const TMVA::OptimizeConfigParameters&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<F",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:1007,Performance,optimiz,optimizationType,1007,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::OptimizeConfigParameters&operator=(const TMVA::OptimizeConfigParameters&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<F",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:2975,Performance,tune,tuneParameters,2975,"; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase*constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; Bool_tfNotDoneYetflat to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSep",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3031,Performance,optimiz,optimizationType,3031,"; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase*constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; Bool_tfNotDoneYetflat to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSep",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3263,Performance,optimiz,optimize,3263,"ine fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; Bool_tfNotDoneYetflat to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distribu",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3424,Performance,optimiz,optimizeScan,3424,"at to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3454,Performance,optimiz,optimization,3454,"at to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3603,Performance,optimiz,optimizeFit,3603," to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff ",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3867,Performance,optimiz,optimization,3867,"bers; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal effici",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:5048,Performance,tune,tuneParameters,5048,"timizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t GetBkgRejAtSigEff(Double_t sigEff = 0.5); calculate the background rejection for a given signal efficiency. OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Tue Jun 2 16:17:38 2015 » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:5104,Performance,optimiz,optimizationType,5104,"timizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t GetBkgRejAtSigEff(Double_t sigEff = 0.5); calculate the background rejection for a given signal efficiency. OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Tue Jun 2 16:17:38 2015 » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:2126,Testability,log,logger,2126,"idShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase*constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; Bool_tfNotDoneYetflat to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regres",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:3475,Usability,simpl,simple,3475,"at to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root/html604/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html
https://root.cern/root/html604/TMVA__PDEFoam.html:2823,Availability,error,error,2823,"pendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidFinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tGetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tGetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tGetMaxDepth() const; UInt_tGetNActiveCells() const; virtual c",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:2907,Availability,error,error,2907,"ll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidFinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tGetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tGetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tGetMaxDepth() const; UInt_tGetNActiveCells() const; virtual const char*TObject::GetName() const; UInt_tGetNCells() const; UInt_tGetNInActiveCells",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:15580,Availability,failure,failures,15580,"x is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (PDEFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. Double_t Eval(Double_t* xRand, Double_t& event_density); Internal subprogram.; Evaluates (training) distribution. void Grow(); Internal subrogram used by Create.; It grow new cells by the binary division process.; This function is overridden by the PDEFoam class to stop the foam buildup process; if one of the cut conditions stop the cell split. void SetInhiDiv(Int_t , Int_t ); This can be called before Create, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable. void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCell(Long_t iCell = 0); Prints geometry of and elements of 'iCell', as well as relations; to parent and daughter cells. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills a weight 'wt' into the PDEFoam cell, which; corresponds to the given event 'ev'. Per default cell element 0; is filled with the weight 'wt', and cell element 1 is filled; with the squared weight. This function can be overridden by a; subclass in order to change the values stored in the foam cells. void ResetCellElements(); Remove the cell elements from all cells. Bool_t CellValueIsUndefined(TMVA::PDEFoamCell* ); Returns true, if the value of the given cell is undefined.; Default value: kFALSE. This function can be overridden by; sub-classes. Float_t GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase* ); This function finds the cell, whic",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:15621,Availability,failure,failures,15621,"x is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (PDEFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. Double_t Eval(Double_t* xRand, Double_t& event_density); Internal subprogram.; Evaluates (training) distribution. void Grow(); Internal subrogram used by Create.; It grow new cells by the binary division process.; This function is overridden by the PDEFoam class to stop the foam buildup process; if one of the cut conditions stop the cell split. void SetInhiDiv(Int_t , Int_t ); This can be called before Create, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable. void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCell(Long_t iCell = 0); Prints geometry of and elements of 'iCell', as well as relations; to parent and daughter cells. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills a weight 'wt' into the PDEFoam cell, which; corresponds to the given event 'ev'. Per default cell element 0; is filled with the weight 'wt', and cell element 1 is filled; with the squared weight. This function can be overridden by a; subclass in order to change the values stored in the foam cells. void ResetCellElements(); Remove the cell elements from all cells. Bool_t CellValueIsUndefined(TMVA::PDEFoamCell* ); Returns true, if the value of the given cell is undefined.; Default value: kFALSE. This function can be overridden by; sub-classes. Float_t GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase* ); This function finds the cell, whic",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:924,Deployability,integrat,integration,924,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual vo",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:10013,Deployability,integrat,integration,10013,"public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of acti",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:13313,Deployability,update,updated,13313," using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t[] , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Create.; Provides random vector Alpha 0< Alpha(i) < 1. Long_t PeekMax(); Internal subprogram used by Create. It finds cell with maximal; driver integral for the purpose of the division. This function; is overridden by the PDEFoam Class to apply cuts on the number; of events i",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:14661,Deployability,update,updated,14661,"l subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Create.; Provides random vector Alpha 0< Alpha(i) < 1. Long_t PeekMax(); Internal subprogram used by Create. It finds cell with maximal; driver integral for the purpose of the division. This function; is overridden by the PDEFoam Class to apply cuts on the number; of events in the cell (fNmin) and the cell tree depth; (GetMaxDepth() > 0) during cell buildup. Int_t Divide(TMVA::PDEFoamCell* ); Internal subrogram used by Create.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (PDEFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. Double_t Eval(Double_t* xRand, Double_t& event_density); Internal subprogram.; Evaluates (training) distribution. void Grow(); Internal subrogram used by Create.; It grow new cells by the binary division process.; This function is overridden by the PDEFoam class to stop the foam buildup process; if one of the cut conditions stop the cell split. void SetInhiDiv(Int_t , Int_t ); This can be called before Create, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable. void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCell(Long_t iCell = 0); Prints geometry of and elements of 'iCell', as we",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:400,Energy Efficiency,adapt,adapting,400,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual vo",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:824,Energy Efficiency,efficient,efficient,824,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual vo",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:12707,Energy Efficiency,allocate,allocated,12707," for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t[] , Int_t",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:924,Integrability,integrat,integration,924,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual vo",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:1033,Integrability,interface,interface,1033,"; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* =",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:10013,Integrability,integrat,integration,10013,"public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of acti",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:10515,Integrability,message,message,10515,"textMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:13431,Integrability,rout,routine,13431," space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t[] , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Create.; Provides random vector Alpha 0< Alpha(i) < 1. Long_t PeekMax(); Internal subprogram used by Create. It finds cell with maximal; driver integral for the purpose of the division. This function; is overridden by the PDEFoam Class to apply cuts on the number; of events in the cell (fNmin) and the cell tree depth; (GetMaxDepth() > 0) during cell buildup. Int_t ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:400,Modifiability,adapt,adapting,400,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual vo",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:10786,Modifiability,variab,variables,10786,"TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*fXmax[fDim] maximum for variable transform; Double_t*fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoam(); Default constructor for streamer, user should not use ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:11364,Modifiability,variab,variable,11364,"iv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*fXmax[fDim] maximum for variable transform; Double_t*fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoam(); Default constructor for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is re",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:11505,Modifiability,variab,variable,11505,"iv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*fXmax[fDim] maximum for variable transform; Double_t*fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoam(); Default constructor for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is re",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:11558,Modifiability,variab,variable,11558,"iv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*fXmax[fDim] maximum for variable transform; Double_t*fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoam(); Default constructor for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is re",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:12393,Modifiability,variab,variables,12393,"racBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*fXmax[fDim] maximum for variable transform; Double_t*fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoam(); Default constructor for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:15288,Modifiability,variab,variables,15288," the number; of events in the cell (fNmin) and the cell tree depth; (GetMaxDepth() > 0) during cell buildup. Int_t Divide(TMVA::PDEFoamCell* ); Internal subrogram used by Create.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (PDEFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. Double_t Eval(Double_t* xRand, Double_t& event_density); Internal subprogram.; Evaluates (training) distribution. void Grow(); Internal subrogram used by Create.; It grow new cells by the binary division process.; This function is overridden by the PDEFoam class to stop the foam buildup process; if one of the cut conditions stop the cell split. void SetInhiDiv(Int_t , Int_t ); This can be called before Create, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable. void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCell(Long_t iCell = 0); Prints geometry of and elements of 'iCell', as well as relations; to parent and daughter cells. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills a weight 'wt' into the PDEFoam cell, which; corresponds to the given event 'ev'. Per default cell element 0; is filled with the weight 'wt', and cell element 1 is filled; with the squared weight. This function can be overridden by a; subclass in order to change the values stored in the foam cells. void ResetCellElements(); Remove the cell e",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:15411,Modifiability,variab,variable,15411,"ide(TMVA::PDEFoamCell* ); Internal subrogram used by Create.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (PDEFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. Double_t Eval(Double_t* xRand, Double_t& event_density); Internal subprogram.; Evaluates (training) distribution. void Grow(); Internal subrogram used by Create.; It grow new cells by the binary division process.; This function is overridden by the PDEFoam class to stop the foam buildup process; if one of the cut conditions stop the cell split. void SetInhiDiv(Int_t , Int_t ); This can be called before Create, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable. void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCell(Long_t iCell = 0); Prints geometry of and elements of 'iCell', as well as relations; to parent and daughter cells. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills a weight 'wt' into the PDEFoam cell, which; corresponds to the given event 'ev'. Per default cell element 0; is filled with the weight 'wt', and cell element 1 is filled; with the squared weight. This function can be overridden by a; subclass in order to change the values stored in the foam cells. void ResetCellElements(); Remove the cell elements from all cells. Bool_t CellValueIsUndefined(TMVA::PDEFoamCell* ); Returns true, if the value of the given cell ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:16818,Modifiability,variab,variables,16818,"ells. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills a weight 'wt' into the PDEFoam cell, which; corresponds to the given event 'ev'. Per default cell element 0; is filled with the weight 'wt', and cell element 1 is filled; with the squared weight. This function can be overridden by a; subclass in order to change the values stored in the foam cells. void ResetCellElements(); Remove the cell elements from all cells. Bool_t CellValueIsUndefined(TMVA::PDEFoamCell* ); Returns true, if the value of the given cell is undefined.; Default value: kFALSE. This function can be overridden by; sub-classes. Float_t GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase* ); This function finds the cell, which corresponds to the given; untransformed event vector 'xvec' and return its value, which is; given by the parameter 'cv'. If kernel != NULL, then; PDEFoamKernelBase::Estimate() is called on the transformed event; variables. Parameters:. - xvec - event vector (untransformed, [fXmin,fXmax]). - cv - the cell value to return. - kernel - PDEFoam kernel estimator. If NULL is given, than the; pure cell value is returned. Return:. The cell value, corresponding to 'xvec', estimated by the given; kernel. std::vector<Float_t> GetCellValue( const std::map<Int_t,Float_t>& xvec, ECellValue cv ); This function finds all cells, which corresponds to the given; (incomplete) untransformed event vector 'xvec' and returns the; cell values, according to the parameter 'cv'. Parameters:. - xvec - map for the untransformed vector. The key (Int_t) is; the dimension, and the value (Float_t) is the event; coordinate. Note that not all coordinates have to be; specified. - cv - cell values to return. Return:. cell values from all cells that were found. TMVA::PDEFoamCell* FindCell(const vector<Float_t>& ) const; Find cell that contains 'xvec' (in foam coordinates [0,1]). Loop to find ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:19102,Modifiability,variab,variables,19102,"ponding to 'xvec'. void FindCells(const map<Int_t,Float_t>& , TMVA::PDEFoamCell* , vector<TMVA::PDEFoamCell*>& ) const; This is a helper function for std::vector<PDEFoamCell*>; FindCells(...) and a generalisation of PDEFoamCell* FindCell().; It saves in 'cells' all cells, which contain the coordinates; specifies in 'txvec'. Note, that not all coordinates have to be; specified in 'txvec'. Parameters:. - txvec - event vector in foam coordinates [0,1]. The key is; the dimension and the value is the event coordinate. Note,; that not all coordinates have to be specified. - cell - cell to start searching with (usually root cell; fCells[0]). - cells - list of cells that were found. std::vector<TMVA::PDEFoamCell*> FindCells(const std::vector<Float_t> &txvec); Find all cells, that contain txvec. This function can be used,; when the dimension of the foam is greater than the dimension of; txvec. E.g. this is the case for multi-target regression. Parameters:. - txvec - event vector of variables, transformed into foam; coordinates [0,1]. The size of txvec can be smaller than the; dimension of the foam. Return value:. - vector of cells, that fit txvec. std::vector<TMVA::PDEFoamCell*> FindCells(const std::map<Int_t, Float_t> &txvec); Find all cells, that contain the coordinates specified in txvec.; The key in 'txvec' is the dimension, and the corresponding value; is the coordinate. Note, that not all coordinates have to be; specified in txvec. Parameters:. - txvec - map of coordinates (transformed into foam coordinates; [0,1]). Return value:. - vector of cells, that fit txvec. TH1D* Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); Draws 1-dimensional foam (= histogram). Parameters:. - cell_value - the cell value to draw. - nbin - number of bins of result histogram. - kernel - a PDEFoam kernel. TH2D* Project2(Int_t idim1, Int_t idim2, TMVA::ECellValue cell_value = kValue, TMVA::PDEFoamKernelBase* kernel = __null, UInt_t nbin = 50); Project",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:20121,Modifiability,variab,variable,20121,"meters:. - txvec - event vector of variables, transformed into foam; coordinates [0,1]. The size of txvec can be smaller than the; dimension of the foam. Return value:. - vector of cells, that fit txvec. std::vector<TMVA::PDEFoamCell*> FindCells(const std::map<Int_t, Float_t> &txvec); Find all cells, that contain the coordinates specified in txvec.; The key in 'txvec' is the dimension, and the corresponding value; is the coordinate. Note, that not all coordinates have to be; specified in txvec. Parameters:. - txvec - map of coordinates (transformed into foam coordinates; [0,1]). Return value:. - vector of cells, that fit txvec. TH1D* Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); Draws 1-dimensional foam (= histogram). Parameters:. - cell_value - the cell value to draw. - nbin - number of bins of result histogram. - kernel - a PDEFoam kernel. TH2D* Project2(Int_t idim1, Int_t idim2, TMVA::ECellValue cell_value = kValue, TMVA::PDEFoamKernelBase* kernel = __null, UInt_t nbin = 50); Project foam variable idim1 and variable idim2 to histogram. Parameters:. - idim1, idim2 - dimensions to project to. - cell_value - the cell value to draw. - kernel - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetC",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:20140,Modifiability,variab,variable,20140,"meters:. - txvec - event vector of variables, transformed into foam; coordinates [0,1]. The size of txvec can be smaller than the; dimension of the foam. Return value:. - vector of cells, that fit txvec. std::vector<TMVA::PDEFoamCell*> FindCells(const std::map<Int_t, Float_t> &txvec); Find all cells, that contain the coordinates specified in txvec.; The key in 'txvec' is the dimension, and the corresponding value; is the coordinate. Note, that not all coordinates have to be; specified in txvec. Parameters:. - txvec - map of coordinates (transformed into foam coordinates; [0,1]). Return value:. - vector of cells, that fit txvec. TH1D* Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); Draws 1-dimensional foam (= histogram). Parameters:. - cell_value - the cell value to draw. - nbin - number of bins of result histogram. - kernel - a PDEFoam kernel. TH2D* Project2(Int_t idim1, Int_t idim2, TMVA::ECellValue cell_value = kValue, TMVA::PDEFoamKernelBase* kernel = __null, UInt_t nbin = 50); Project foam variable idim1 and variable idim2 to histogram. Parameters:. - idim1, idim2 - dimensions to project to. - cell_value - the cell value to draw. - kernel - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetC",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:24483,Modifiability,variab,variable,24483,"td::vector<Float_t> VarTransform(const vector<Float_t>& invec) const. Float_t VarTransformInvers(Int_t idim, Float_t x) const. std::vector<Float_t> VarTransformInvers(const vector<Float_t>& invec) const. PDEFoamDensityBase* GetDistr() const; get internal density. { assert(fDistr); return fDistr; }. void Initialize(); ---------- Foam creation functions. {}. void Finalize(); function to call after foam is grown. {}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetDensity(TMVA::PDEFoamDensityBase* dens); { fDistr = dens; }. Int_t GetTotDim() const; coverity[ -tainted_data_return ]. {return fDim; }. TString GetFoamName() const; {return fName; }. UInt_t GetNActiveCells() const; {return fNoAct;}. UInt_t GetNInActiveCells() const; {return GetNCells()-GetNActiveCells();}. UInt_t GetNCells() const; {return fNCells;}. PDEFoamCell* GetRootCell() const; {return fCells[0];}. void SetNmin(UInt_t val); Getters and Setters for user cut options. { fNmin=val; }. UInt_t GetNmin(); { return fNmin; }. void SetMaxDepth(UInt_t maxdepth); { fMaxDepth = maxdepth; }. UInt_t GetMaxDepth() const; { return fMaxDepth; }. Double_t GetXmin(Int_t idim) const; {return fXmin[idim];}. Double_t GetXmax(Int_t idim) const; {return fXmax[idim];}. void AddVariableName(const char* s); Getters and Setters for variable names. { AddVariableName(new TObjString(s)); }. void AddVariableName(TObjString* s); { fVariableNames->Add(s); }. TObjString* GetVariableName(Int_t idx); {return dynamic_cast<TObjString*>(fVariableNames->At(idx));}. » Author: S. Jadach, Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:22295,Performance,load,load,22295,"e foam output.; Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t createCanvas = kTRUE, Bool_t colors = kTRUE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - createCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. Example:. The following commands load a mono-target regression foam from; file 'foam.root' and create a ROOT macro 'output.C', which; draws all PDEFoam cells with little boxes. The latter are; filled with colors according to the target value stored in the; cell. Also the cell number is drawn. TFile file(""foam.root"");; TMVA::PDEFoam *foam = (TMVA::PDEFoam*) gDirectory->Get(""MonoTargetRegressionFoam"");; foam->RootPlot2dim(""output.C"",""cell_value,cellnumber"");; gROOT->Macro(""output.C"");. void FillBinarySearchTree(const TMVA::Event* ev); Insert event to internal foam's density estimator; PDEFoamDensityBase. void DeleteBinarySearchTree(); Delete the foam's density estimator, which contains the binary; search tree. Float_t VarTransform(Int_t idim, Float_t x) const. std::vector<Float_t> VarTransform(const vector<Float_t>& invec) const. Float_t VarTransformInvers(Int_t idim, Float_t x) const. std::vector<Float_t> VarTransformInvers(const vector<Float_t>& invec) const. PDEFoamDensityBase* GetDistr() const; get internal density. { assert(fDis",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:13608,Safety,avoid,avoid,13608,"VA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t[] , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Create.; Provides random vector Alpha 0< Alpha(i) < 1. Long_t PeekMax(); Internal subprogram used by Create. It finds cell with maximal; driver integral for the purpose of the division. This function; is overridden by the PDEFoam Class to apply cuts on the number; of events in the cell (fNmin) and the cell tree depth; (GetMaxDepth() > 0) during cell buildup. Int_t Divide(TMVA::PDEFoamCell* ); Internal subrogram used by Create.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:21298,Safety,avoid,avoid,21298," - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); Set cell element i of cell to value. If the cell element i does; not exist, it is created. void OutputGrow(Bool_t finished = false); Overridden function of PDEFoam to avoid native foam output.; Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t createCanvas = kTRUE, Bool_t colors = kTRUE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - createCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. Example:. ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:9980,Testability,log,logic,9980,"public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of acti",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:10523,Testability,log,logger,10523,"textMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoam.html:23298,Testability,assert,assert,23298," regression foam from; file 'foam.root' and create a ROOT macro 'output.C', which; draws all PDEFoam cells with little boxes. The latter are; filled with colors according to the target value stored in the; cell. Also the cell number is drawn. TFile file(""foam.root"");; TMVA::PDEFoam *foam = (TMVA::PDEFoam*) gDirectory->Get(""MonoTargetRegressionFoam"");; foam->RootPlot2dim(""output.C"",""cell_value,cellnumber"");; gROOT->Macro(""output.C"");. void FillBinarySearchTree(const TMVA::Event* ev); Insert event to internal foam's density estimator; PDEFoamDensityBase. void DeleteBinarySearchTree(); Delete the foam's density estimator, which contains the binary; search tree. Float_t VarTransform(Int_t idim, Float_t x) const. std::vector<Float_t> VarTransform(const vector<Float_t>& invec) const. Float_t VarTransformInvers(Int_t idim, Float_t x) const. std::vector<Float_t> VarTransformInvers(const vector<Float_t>& invec) const. PDEFoamDensityBase* GetDistr() const; get internal density. { assert(fDistr); return fDistr; }. void Initialize(); ---------- Foam creation functions. {}. void Finalize(); function to call after foam is grown. {}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetDensity(TMVA::PDEFoamDensityBase* dens); { fDistr = dens; }. Int_t GetTotDim() const; coverity[ -tainted_data_return ]. {return fDim; }. TString GetFoamName() const; {return fName; }. UInt_t GetNActiveCells() const; {return fNoAct;}. UInt_t GetNInActiveCells() const; {return GetNCells()-GetNActiveCells();}. UInt_t GetNCells() const; {return fNCells;}. PDEFoamCell* GetRootCell() const; {return fCells[0];}. void SetNmin(UInt_t val); Getters and Setters for user cut options. { fNmin=val; }. UInt_t GetNmin(); { return fNmin; }. void SetMaxDepth(UInt_t maxdepth); { fMaxDepth = maxdepth; }. UInt_t GetMaxDepth() const; { return fMaxDepth; }. Double_t ",MatchSource.WIKI,root/html604/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoam.html
https://root.cern/root/html604/TMVA__PDEFoamCell.html:1302,Availability,error,error,1302," virtual~PDEFoamCell(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TMVA::PDEFoamCell*, TMVA::PDEFoamCell*, TMVA::PDEFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TMVA::PDEFoamCell*GetDau0() const; TMVA::PDEFoamCell*GetDau1() const; UInt_tGetDepth(); virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); TObject*GetElement() const; voidGetHcub",MatchSource.WIKI,root/html604/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamCell.html
https://root.cern/root/html604/TMVA__PDEFoamCell.html:1386,Availability,error,error,1386,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TMVA::PDEFoamCell*, TMVA::PDEFoamCell*, TMVA::PDEFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TMVA::PDEFoamCell*GetDau0() const; TMVA::PDEFoamCell*GetDau1() const; UInt_tGetDepth(); virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); TObject*GetElement() const; voidGetHcub(TMVA::PDEFoamVect&, TMVA::PDEFoamVect&) const; voidGetHSize(TMVA::PDEFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TMVA::PDEFoamCell*GetPare() const;",MatchSource.WIKI,root/html604/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamCell.html
https://root.cern/root/html604/TMVA__PDEFoamCell.html:7425,Energy Efficiency,allocate,allocated,7425,"ymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; TObject*fElementmay set by the user to save some data in this cell; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamCell(); Default constructor for streamer. PDEFoamCell(Int_t ); User constructor allocating single empty Cell. PDEFoamCell(const TMVA::PDEFoamCell& ); Copy constructor. ~PDEFoamCell(); Destructor. void Fill(Int_t , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TMVA::PDEFoamVect& , TMVA::PDEFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TMVA::PDEFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. UInt_t GetTreeDepth(UInt_t depth = 0); Get depth of cell tree, starting at this cell. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;",MatchSource.WIKI,root/html604/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamCell.html
https://root.cern/root/html604/TMVA__PDEFoamCell.html:9343,Modifiability,variab,variable,9343,"ize parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. UInt_t GetTreeDepth(UInt_t depth = 0); Get depth of cell tree, starting at this cell. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. void SetIntg(Double_t Intg); { fIntegral=Intg;}. void SetDriv(Double_t Driv); linked tree organization. { fDrive =Driv;}. Int_t GetStat() const; { return fStatus;}. void SetStat(Int_t Stat); { fStatus=Stat;}. PDEFoamCell* GetPare() const; { return (PDEFoamCell*) fParent.GetObject(); }. PDEFoamCell* GetDau0() const; { return (PDEFoamCell*) fDaught0.GetObject(); }. PDEFoamCell* GetDau1() const; { return (PDEFoamCell*) fDaught1.GetObject(); }. void SetDau0(TMVA::PDEFoamCell* Daug); { fDaught0 = Daug;}. void SetDau1(TMVA::PDEFoamCell* Daug); { fDaught1 = Daug;}. void SetPare(TMVA::PDEFoamCell* Pare); { fParent = Pare;}. void SetSerial(Int_t Serial); { fSerial=Serial;}. Int_t GetSerial() const; { return fSerial;}. void SetElement(TObject* fobj); getter and setter for user variable. { fElement = fobj; }. TObject* GetElement() const. { return fElement; }. » Author: S. Jadach, Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamCell.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:548,Availability,error,error,548,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:2258,Availability,error,error,2258,"TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidTMVA::PDEFoamDiscriminant::FillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidTMVA::PDEFoamDiscriminant::Finalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>TMVA::PDEFoam::GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamN",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:2342,Availability,error,error,2342,"st char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidTMVA::PDEFoamDiscriminant::FillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidTMVA::PDEFoamDiscriminant::Finalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>TMVA::PDEFoam::GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::G",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:10960,Deployability,integrat,integration,10960,"itsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tTMVA::PDEFoamDiscriminant::fClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number o",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:10960,Integrability,integrat,integration,10960,"itsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tTMVA::PDEFoamDiscriminant::fClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number o",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:11582,Integrability,message,message,11582,"t::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tTMVA::PDEFoamDiscriminant::fClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:13975,Integrability,rout,routine,13975,"bers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. private:. TMVA::SeparationBase*fSepTypeseparation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTree(); Default constructor for streamer, user should not use it. PDEFoamDecisionTree(const TString& , TMVA::SeparationBase* sepType, UInt_t cls); Parameters:. - name - name of the foam. - sepType - separation type used for the cell splitting (will be; deleted in the destructor). - cls - class to consider as signal when calcualting the purity. PDEFoamDecisionTree(const TMVA::PDEFoamDecisionTree& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). ~PDEFoamDecisionTree(); Destructor; deletes fSepType. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to the decision tree logic. The separation; set via the 'sepType' option in the constructor. The optimal division point for eventual future cell division is; determined/recorded. Note that links to parents and initial; volume = 1/2 parent has to be already defined prior to calling; this routine. Note, that according to the decision tree logic, a cell is only; split, if the number of (unweighted) events in each dautghter; cell is greater than fNmin. » Author: Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:11928,Modifiability,variab,variables,11928,"ITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] m",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:12641,Modifiability,variab,variable,12641,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. private:. TMVA::SeparationBase*fSepTypeseparation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTree(); Default constructor for streamer, user should not use it. PDEFoamDecisionTree(const TString& , TMVA::SeparationBase* sepType, UInt_t cls); Parameters:. - name - name of the foam. - sepType - separation type used for the cell splitting (will be; deleted in the destructor). - cls - class to consider as signal when calcualting the purity. PDEFoamDecisionTree(const TMVA::PDEFoamDecisionTree& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). ~PDEFoamDecisionTree(); Destructor; deletes fSepType. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to th",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:12812,Modifiability,variab,variable,12812,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. private:. TMVA::SeparationBase*fSepTypeseparation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTree(); Default constructor for streamer, user should not use it. PDEFoamDecisionTree(const TString& , TMVA::SeparationBase* sepType, UInt_t cls); Parameters:. - name - name of the foam. - sepType - separation type used for the cell splitting (will be; deleted in the destructor). - cls - class to consider as signal when calcualting the purity. PDEFoamDecisionTree(const TMVA::PDEFoamDecisionTree& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). ~PDEFoamDecisionTree(); Destructor; deletes fSepType. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to th",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:12880,Modifiability,variab,variable,12880,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. private:. TMVA::SeparationBase*fSepTypeseparation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTree(); Default constructor for streamer, user should not use it. PDEFoamDecisionTree(const TString& , TMVA::SeparationBase* sepType, UInt_t cls); Parameters:. - name - name of the foam. - sepType - separation type used for the cell splitting (will be; deleted in the destructor). - cls - class to consider as signal when calcualting the purity. PDEFoamDecisionTree(const TMVA::PDEFoamDecisionTree& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). ~PDEFoamDecisionTree(); Destructor; deletes fSepType. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to th",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:10912,Testability,log,logic,10912,"itsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tTMVA::PDEFoamDiscriminant::fClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number o",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:11590,Testability,log,logger,11590,"t::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tTMVA::PDEFoamDiscriminant::fClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:13708,Testability,log,logic,13708,"bers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. private:. TMVA::SeparationBase*fSepTypeseparation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTree(); Default constructor for streamer, user should not use it. PDEFoamDecisionTree(const TString& , TMVA::SeparationBase* sepType, UInt_t cls); Parameters:. - name - name of the foam. - sepType - separation type used for the cell splitting (will be; deleted in the destructor). - cls - class to consider as signal when calcualting the purity. PDEFoamDecisionTree(const TMVA::PDEFoamDecisionTree& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). ~PDEFoamDecisionTree(); Destructor; deletes fSepType. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to the decision tree logic. The separation; set via the 'sepType' option in the constructor. The optimal division point for eventual future cell division is; determined/recorded. Note that links to parents and initial; volume = 1/2 parent has to be already defined prior to calling; this routine. Note, that according to the decision tree logic, a cell is only; split, if the number of (unweighted) events in each dautghter; cell is greater than fNmin. » Author: Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:14026,Testability,log,logic,14026,"bers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. private:. TMVA::SeparationBase*fSepTypeseparation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTree(); Default constructor for streamer, user should not use it. PDEFoamDecisionTree(const TString& , TMVA::SeparationBase* sepType, UInt_t cls); Parameters:. - name - name of the foam. - sepType - separation type used for the cell splitting (will be; deleted in the destructor). - cls - class to consider as signal when calcualting the purity. PDEFoamDecisionTree(const TMVA::PDEFoamDecisionTree& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). ~PDEFoamDecisionTree(); Destructor; deletes fSepType. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to the decision tree logic. The separation; set via the 'sepType' option in the constructor. The optimal division point for eventual future cell division is; determined/recorded. Note that links to parents and initial; volume = 1/2 parent has to be already defined prior to calling; this routine. Note, that according to the decision tree logic, a cell is only; split, if the number of (unweighted) events in each dautghter; cell is greater than fNmin. » Author: Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html:1646,Availability,error,error,1646,"Density(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillHistograms(TMVA::Volume&, vector<TH1D*>&, vector<TH1D*>&, vector<TH1D*>&, vector<TH1D*>&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTreeDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html:1730,Availability,error,error,1730,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillHistograms(TMVA::Volume&, vector<TH1D*>&, vector<TH1D*>&, vector<TH1D*>&, vector<TH1D*>&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual UL",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTreeDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html:7038,Integrability,message,message,7038," const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTreeDensity(); {}. PDEFoamDecisionTreeDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDecisionTreeDensity(const TMVA::PDEFoamDecisionTreeDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is not used in the decision tree like PDEFoam,; instead FillHist() is used. void FillHistograms(TMVA::Volume& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& ); Fill the given histograms with signal and background events,; which are found in the volume. Parameters:. - volume - volume box to search in. - hsig, hbkg, hsig_unw, hbkg_unw - histograms with weighted and; unweighte",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTreeDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html:7046,Testability,log,logger,7046," const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTreeDensity(); {}. PDEFoamDecisionTreeDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDecisionTreeDensity(const TMVA::PDEFoamDecisionTreeDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is not used in the decision tree like PDEFoam,; instead FillHist() is used. void FillHistograms(TMVA::Volume& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& ); Fill the given histograms with signal and background events,; which are found in the volume. Parameters:. - volume - volume box to search in. - hsig, hbkg, hsig_unw, hbkg_unw - histograms with weighted and; unweighte",MatchSource.WIKI,root/html604/TMVA__PDEFoamDecisionTreeDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTreeDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html:1260,Availability,avail,available,1260,"MVA; » TMVA::PDEFoamDensityBase. class TMVA::PDEFoamDensityBase: public TObject. PDEFoamDensityBase. This is an abstract class, which provides an interface for a; PDEFoam density estimator. Derived classes have to implement the; Density(...) function, which returns the density of a certain; quantity at a given phase-space point during the foam build-up. Variants of PDEFoamDensityBase are:. - PDEFoamEventDensity; - PDEFoamDiscriminantDensity; - PDEFoamTargetDensity; - PDEFoamDecisionTreeDensity. Usage:. The user has to instantiate a child class of PDEFoamDensityBase and; set the pointer to the owner, which is a PDEFoam object:. PDEFoamDensityBase *dens = new MyDensity();; pdefoam->SetDensity(dens);. Afterwards the binary search tree should be filled with TMVA; events, by either using. pdefoam->FillBinarySearchTree(event);. or. dens->FillBinarySearchTree(event);. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamDensityBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamDensityBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html
https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html:2310,Availability,error,error,2310,"ityBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, c",MatchSource.WIKI,root/html604/TMVA__PDEFoamDensityBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html
https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html:2394,Availability,error,error,2394,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname)",MatchSource.WIKI,root/html604/TMVA__PDEFoamDensityBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html
https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html:398,Integrability,interface,interface,398,". TMVA::PDEFoamDensityBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDensityBase. class TMVA::PDEFoamDensityBase: public TObject. PDEFoamDensityBase. This is an abstract class, which provides an interface for a; PDEFoam density estimator. Derived classes have to implement the; Density(...) function, which returns the density of a certain; quantity at a given phase-space point during the foam build-up. Variants of PDEFoamDensityBase are:. - PDEFoamEventDensity; - PDEFoamDiscriminantDensity; - PDEFoamTargetDensity; - PDEFoamDecisionTreeDensity. Usage:. The user has to instantiate a child class of PDEFoamDensityBase and; set the pointer to the owner, which is a PDEFoam object:. PDEFoamDensityBase *dens = new MyDensity();; pdefoam->SetDensity(dens);. Afterwards the binary search tree should be filled with TMVA; events, by either using. pdefoam->FillBinarySearchTree(event);. or. dens->FillBinarySearchTree(event);. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamDensityBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """,MatchSource.WIKI,root/html604/TMVA__PDEFoamDensityBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html
https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html:7036,Integrability,message,message,7036," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tGetBoxVolume(); TMVA::MsgLogger&Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*fBstBinary tree to find events within a volume; TMVA::MsgLogger*fLogger! message logger. private:. vector<Double_t>fBoxrange-searching box; Bool_tfBoxHasChangedrange searching box has changed; Double_tfBoxVolumevolume of range searching box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDensityBase(); {}. PDEFoamDensityBase(vector<Double_t> box); User constructor. - box - range-searching box, where box.size() == dimension of; the PDEFoam == periode of the binary search tree. ~PDEFoamDensityBase(); destructor. PDEFoamDensityBase(const TMVA::PDEFoamDensityBase& ); Copy constructor. Creates a deep copy, using the copy constructor of; TMVA::BinarySearchTree. void FillBinarySearchTree(const TMVA::Event* ev); This method inserts the given event 'ev' it into the binary; search tree. Double_t GetBoxVolume(); Returns the volume of range searching box fBox. If the range searching box 'fBox' has changed (fBoxHasChanged is; kTRUE), recalculate the box volume and set fBoxHasChan",MatchSource.WIKI,root/html604/TMVA__PDEFoamDensityBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html
https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html:7044,Testability,log,logger,7044," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tGetBoxVolume(); TMVA::MsgLogger&Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*fBstBinary tree to find events within a volume; TMVA::MsgLogger*fLogger! message logger. private:. vector<Double_t>fBoxrange-searching box; Bool_tfBoxHasChangedrange searching box has changed; Double_tfBoxVolumevolume of range searching box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDensityBase(); {}. PDEFoamDensityBase(vector<Double_t> box); User constructor. - box - range-searching box, where box.size() == dimension of; the PDEFoam == periode of the binary search tree. ~PDEFoamDensityBase(); destructor. PDEFoamDensityBase(const TMVA::PDEFoamDensityBase& ); Copy constructor. Creates a deep copy, using the copy constructor of; TMVA::BinarySearchTree. void FillBinarySearchTree(const TMVA::Event* ev); This method inserts the given event 'ev' it into the binary; search tree. Double_t GetBoxVolume(); Returns the volume of range searching box fBox. If the range searching box 'fBox' has changed (fBoxHasChanged is; kTRUE), recalculate the box volume and set fBoxHasChan",MatchSource.WIKI,root/html604/TMVA__PDEFoamDensityBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDensityBase.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:505,Availability,error,error,505,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voi",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:2066,Availability,error,error,2066,"TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidFinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>TMVA::PDEFoam::GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName()",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:2150,Availability,error,error,2150,"st char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidFinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>TMVA::PDEFoam::GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::GetMaxDepth() const; UInt_tTMVA::PDEFoam::GetNActiveCel",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:12915,Availability,error,error,12915,"ments; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminant(); Default constructor for streamer, user should not use it. PDEFoamDiscriminant(const TString& , UInt_t ); {}. PDEFoamDiscriminant(const TMVA::PDEFoamDiscriminant& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; event weight 'wt' is filled into cell element 0 if the event is; of class fClass, and filled into cell element 1 otherwise. void Finalize(); Calc discriminator and its error for every cell and save it to; the cell. TH2D* Project2(Int_t , Int_t , TMVA::ECellValue , TMVA::PDEFoamKernelBase* , UInt_t ); Project foam variable idim1 and variable idim2 to histogram.; The projection algorithm is modified such that the z axis range; of the returned histogram is [0, 1], as necessary for the; interpretation as a discriminator. This is done by weighting; the cell values (in case of cell_value = kValue) by the cell; volume in all dimensions, excluding 'idim1' and 'idim2'. Parameters:. - idim1, idim2 - dimensions to project to. - cell_value - the cell value to draw. - kernel - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. virtual ~PDEFoamDiscriminant(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $I",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:10361,Deployability,integrat,integration,10361,"ect::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tfClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables i",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:10361,Integrability,integrat,integration,10361,"ect::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tfClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables i",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:10983,Integrability,message,message,10983,"::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tfClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:11329,Modifiability,variab,variables,11329,"ITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] m",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:12042,Modifiability,variab,variable,12042,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminant(); Default constructor for streamer, user should not use it. PDEFoamDiscriminant(const TString& , UInt_t ); {}. PDEFoamDiscriminant(const TMVA::PDEFoamDiscriminant& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; event weight 'wt' is filled into cell element 0 if the event is; of class fClass, and filled into cell element 1 otherwise. void Finalize(); Calc discriminator and its error for every cell and save it to; the cell. TH2D* Project2(Int_t , Int_t , TMVA::ECellValue , TMVA::PDEFoamKernelBase* , UInt_t ); Project foam variable idim1 and variable idi",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:12213,Modifiability,variab,variable,12213,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminant(); Default constructor for streamer, user should not use it. PDEFoamDiscriminant(const TString& , UInt_t ); {}. PDEFoamDiscriminant(const TMVA::PDEFoamDiscriminant& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; event weight 'wt' is filled into cell element 0 if the event is; of class fClass, and filled into cell element 1 otherwise. void Finalize(); Calc discriminator and its error for every cell and save it to; the cell. TH2D* Project2(Int_t , Int_t , TMVA::ECellValue , TMVA::PDEFoamKernelBase* , UInt_t ); Project foam variable idim1 and variable idi",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:12281,Modifiability,variab,variable,12281,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminant(); Default constructor for streamer, user should not use it. PDEFoamDiscriminant(const TString& , UInt_t ); {}. PDEFoamDiscriminant(const TMVA::PDEFoamDiscriminant& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; event weight 'wt' is filled into cell element 0 if the event is; of class fClass, and filled into cell element 1 otherwise. void Finalize(); Calc discriminator and its error for every cell and save it to; the cell. TH2D* Project2(Int_t , Int_t , TMVA::ECellValue , TMVA::PDEFoamKernelBase* , UInt_t ); Project foam variable idim1 and variable idi",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:13062,Modifiability,variab,variable,13062,"of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminant(); Default constructor for streamer, user should not use it. PDEFoamDiscriminant(const TString& , UInt_t ); {}. PDEFoamDiscriminant(const TMVA::PDEFoamDiscriminant& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; event weight 'wt' is filled into cell element 0 if the event is; of class fClass, and filled into cell element 1 otherwise. void Finalize(); Calc discriminator and its error for every cell and save it to; the cell. TH2D* Project2(Int_t , Int_t , TMVA::ECellValue , TMVA::PDEFoamKernelBase* , UInt_t ); Project foam variable idim1 and variable idim2 to histogram.; The projection algorithm is modified such that the z axis range; of the returned histogram is [0, 1], as necessary for the; interpretation as a discriminator. This is done by weighting; the cell values (in case of cell_value = kValue) by the cell; volume in all dimensions, excluding 'idim1' and 'idim2'. Parameters:. - idim1, idim2 - dimensions to project to. - cell_value - the cell value to draw. - kernel - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. virtual ~PDEFoamDiscriminant(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regardin",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:13081,Modifiability,variab,variable,13081,"of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminant(); Default constructor for streamer, user should not use it. PDEFoamDiscriminant(const TString& , UInt_t ); {}. PDEFoamDiscriminant(const TMVA::PDEFoamDiscriminant& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; event weight 'wt' is filled into cell element 0 if the event is; of class fClass, and filled into cell element 1 otherwise. void Finalize(); Calc discriminator and its error for every cell and save it to; the cell. TH2D* Project2(Int_t , Int_t , TMVA::ECellValue , TMVA::PDEFoamKernelBase* , UInt_t ); Project foam variable idim1 and variable idim2 to histogram.; The projection algorithm is modified such that the z axis range; of the returned histogram is [0, 1], as necessary for the; interpretation as a discriminator. This is done by weighting; the cell values (in case of cell_value = kValue) by the cell; volume in all dimensions, excluding 'idim1' and 'idim2'. Parameters:. - idim1, idim2 - dimensions to project to. - cell_value - the cell value to draw. - kernel - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. virtual ~PDEFoamDiscriminant(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regardin",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:10313,Testability,log,logic,10313,"ect::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tfClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables i",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:10991,Testability,log,logger,10991,"::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; UInt_tfClasssignal class; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html:1700,Availability,error,error,1700,"Density(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminantDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html:1784,Availability,error,error,1784,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminantDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html:6985,Integrability,message,message,6985," const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminantDensity(); {}. PDEFoamDiscriminantDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDiscriminantDensity(const TMVA::PDEFoamDiscriminantDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average number density of events of type fClass within the; range-searching volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights) of type fClass, which were; found in the range-searching volume at point ",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminantDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html
https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html:6993,Testability,log,logger,6993," const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminantDensity(); {}. PDEFoamDiscriminantDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDiscriminantDensity(const TMVA::PDEFoamDiscriminantDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average number density of events of type fClass within the; range-searching volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights) of type fClass, which were; found in the range-searching volume at point ",MatchSource.WIKI,root/html604/TMVA__PDEFoamDiscriminantDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminantDensity.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:1964,Availability,error,error,1964,"TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidTMVA::PDEFoam::Finalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>TMVA::PDEFoam::GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:2048,Availability,error,error,2048,"st char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidTMVA::PDEFoam::Finalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>TMVA::PDEFoam::GetCellValue(const map<Int_t,Float_t>& xvec, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const TMVA::PDEFoamCell* cell, TMVA::ECellValue cv); virtual Float_tTMVA::PDEFoam::GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::GetMaxDepth() const; UInt_tTMVA::PDEFoam",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:10250,Deployability,integrat,integration,10250,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:10250,Integrability,integrat,integration,10250,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:10872,Integrability,message,message,10872,"Object::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:11218,Modifiability,variab,variables,11218,"ITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] m",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:11931,Modifiability,variab,variable,11931,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEvent(); Default constructor for streamer, user should not use it. PDEFoamEvent(const TString& ); {}. PDEFoamEvent(const TMVA::PDEFoamEvent& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event weight 'wt' into the PDEFoam. Cell; element 0 is filled with the weight 'wt', and element 1 is; filled with the squared weight. virtual ~PDEFoamEvent(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:12102,Modifiability,variab,variable,12102,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEvent(); Default constructor for streamer, user should not use it. PDEFoamEvent(const TString& ); {}. PDEFoamEvent(const TMVA::PDEFoamEvent& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event weight 'wt' into the PDEFoam. Cell; element 0 is filled with the weight 'wt', and element 1 is; filled with the squared weight. virtual ~PDEFoamEvent(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:12170,Modifiability,variab,variable,12170,"xDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEvent(); Default constructor for streamer, user should not use it. PDEFoamEvent(const TString& ); {}. PDEFoamEvent(const TMVA::PDEFoamEvent& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event weight 'wt' into the PDEFoam. Cell; element 0 is filled with the weight 'wt', and element 1 is; filled with the squared weight. virtual ~PDEFoamEvent(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:10202,Testability,log,logic,10202,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEvent.html:10880,Testability,log,logger,10880,"Object::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEvent.html
https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html:1578,Availability,error,error,1578,"Density(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html604/TMVA__PDEFoamEventDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html
https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html:1662,Availability,error,error,1662,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root/html604/TMVA__PDEFoamEventDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html
https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html:6762,Integrability,message,message,6762,", va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEventDensity(); {}. PDEFoamEventDensity(vector<Double_t> box); User construcor. Parameters:. - box - size of sampling box. PDEFoamEventDensity(const TMVA::PDEFoamEventDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; event density within the range-searching volume (specified by; fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights), which were found in the; range-searching volume at point 'xev', divided by the box; volume. virtual ~PDEFoamEventDensity(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ ",MatchSource.WIKI,root/html604/TMVA__PDEFoamEventDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html
https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html:6770,Testability,log,logger,6770,", va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEventDensity(); {}. PDEFoamEventDensity(vector<Double_t> box); User construcor. Parameters:. - box - size of sampling box. PDEFoamEventDensity(const TMVA::PDEFoamEventDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; event density within the range-searching volume (specified by; fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights), which were found in the; range-searching volume at point 'xev', divided by the box; volume. virtual ~PDEFoamEventDensity(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ ",MatchSource.WIKI,root/html604/TMVA__PDEFoamEventDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamEventDensity.html
https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:780,Availability,avail,available,780,". TMVA::PDEFoamKernelBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamKernelBase. class TMVA::PDEFoamKernelBase: public TObject. PDEFoamKernelBase. This class is the abstract kernel interface for PDEFoam. The; kernel can be used for manipulating (smearing) the cell values of a; PDEFoam, by passing it as an argument to; PDEFoam::GetCellValue(...). Derived classes must implement the Estimate() function to provide a; specific kernel behaviour. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamKernelBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html
https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:1832,Availability,error,error,1832,"Base(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html
https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:1916,Availability,error,error,1916,"AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html
https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:383,Integrability,interface,interface,383,". TMVA::PDEFoamKernelBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamKernelBase. class TMVA::PDEFoamKernelBase: public TObject. PDEFoamKernelBase. This class is the abstract kernel interface for PDEFoam. The; kernel can be used for manipulating (smearing) the cell values of a; PDEFoam, by passing it as an argument to; PDEFoam::GetCellValue(...). Derived classes must implement the Estimate() function to provide a; specific kernel behaviour. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamKernelBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html
https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:6268,Integrability,message,message,6268,"onst char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelBase(); Default constructor for streamer. PDEFoamKernelBase(const TMVA::PDEFoamKernelBase& ); Copy constructor. ~PDEFoamKernelBase(); Destructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); kernel estimator. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html
https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:6276,Testability,log,logger,6276,"onst char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelBase(); Default constructor for streamer. PDEFoamKernelBase(const TMVA::PDEFoamKernelBase& ); Copy constructor. ~PDEFoamKernelBase(); Destructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); kernel estimator. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html
https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:1539,Availability,error,error,1539,"auss(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelGauss.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html
https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:1623,Availability,error,error,1623,"AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelGauss.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html
https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:6371,Integrability,message,message,6371,"Float_tGetAverageNeighborsValue(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); voidTObject::MakeZombie(); Float_tWeightGaus(TMVA::PDEFoam*, TMVA::PDEFoamCell*, vector<Float_t>&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger; Float_tfSigmawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the n",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelGauss.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html
https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:7763,Modifiability,variab,variables,7763,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelGauss.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html
https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:7992,Safety,avoid,avoid,7992,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelGauss.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html
https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:6379,Testability,log,logger,6379,"Float_tGetAverageNeighborsValue(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); voidTObject::MakeZombie(); Float_tWeightGaus(TMVA::PDEFoam*, TMVA::PDEFoamCell*, vector<Float_t>&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger; Float_tfSigmawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the n",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelGauss.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html
https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html:1543,Availability,error,error,1543,"LinN(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelLinN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html
https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html:1627,Availability,error,error,1627,"AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelLinN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html
https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html:6369,Integrability,message,message,6369,"t; Float_tGetAverageNeighborsValue(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); voidTObject::MakeZombie(); Float_tWeightLinNeighbors(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue, Bool_t). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelLinN(); Default constructor for streamer. PDEFoamKernelLinN(const TMVA::PDEFoamKernelLinN& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Linear neighbors kernel estimator. It returns the cell value; 'cv', corresponding to the event vector 'txvec' (in foam; coordinates) linear weighted by the cell values of the neighbor; cells. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t WeightLinNeighbors(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue , Bool_t ); Returns the cell value, corresponding to 'txvec' (foam; coordinates [0,1]), weighted by the neighbor cells via a linear; function. Parameters:; - foam - the foam to search in. - txvec - event vector, transformed into foam coordinates [0,1]. - cv - cell value to be",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelLinN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html
https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html:6377,Testability,log,logger,6377,"t; Float_tGetAverageNeighborsValue(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); voidTObject::MakeZombie(); Float_tWeightLinNeighbors(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue, Bool_t). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelLinN(); Default constructor for streamer. PDEFoamKernelLinN(const TMVA::PDEFoamKernelLinN& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Linear neighbors kernel estimator. It returns the cell value; 'cv', corresponding to the event vector 'txvec' (in foam; coordinates) linear weighted by the cell values of the neighbor; cells. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t WeightLinNeighbors(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue , Bool_t ); Returns the cell value, corresponding to 'txvec' (foam; coordinates [0,1]), weighted by the neighbor cells via a linear; function. Parameters:; - foam - the foam to search in. - txvec - event vector, transformed into foam coordinates [0,1]. - cv - cell value to be",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelLinN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelLinN.html
https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html:1558,Availability,error,error,1558,"vial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelTrivial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html
https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html:1642,Availability,error,error,1642,"AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelTrivial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html
https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html:6233,Integrability,message,message,6233,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelTrivial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html
https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html:6241,Testability,log,logger,6241,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__PDEFoamKernelTrivial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:2498,Availability,error,error,2498,"TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidTMVA::PDEFoamEvent::FillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidTMVA::PDEFoam::Finalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>GetCellValue(const map<Int_t,Float_t>&, TMVA::ECellValue); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::GetMaxDepth() const; UInt_tTMVA::PDEFoam::GetNActiveCells() const; virtual const char*TObject::GetName() const; UInt_tTMVA::PDEFoam::GetNCells() const; UInt_tTMVA::PDEFoam::Ge",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:2582,Availability,error,error,2582,"st char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidTMVA::PDEFoamEvent::FillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidTMVA::PDEFoam::Finalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual vector<Float_t>GetCellValue(const map<Int_t,Float_t>&, TMVA::ECellValue); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::GetMaxDepth() const; UInt_tTMVA::PDEFoam::GetNActiveCells() const; virtual const char*TObject::GetName() const; UInt_tTMVA::PDEFoam::GetNCells() const; UInt_tTMVA::PDEFoam::GetNInActiveCells() const; UInt_tTMVA::PDEFoam::GetNmin(); virtual char*TObject::GetOb",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:11009,Deployability,integrat,integration,11009,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:911,Integrability,depend,depending,911,". TMVA::PDEFoamMultiTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamMultiTarget. class TMVA::PDEFoamMultiTarget: public TMVA::PDEFoamEvent. PDEFoamMultiTarget. This PDEFoam variant is used to estimate multiple targets by; creating an event density foam (PDEFoamEvent), which has dimension:. dimension = number of variables + number targets. This PDEFoam variant stores in every cell the sum of event weights; and the sum of the squared event weights. During evaluation for a; given event, which has only variables and no targets (number of; event variables is smaller than the foam dimension), the targets; are estimated by finding all cells, which correspond to this event; and calculate the Mean (or Mpv, depending on the ETargetSelection); cell center weighted by the event density in the cell. This PDEFoam variant should be booked together with the; PDEFoamEventDensity density estimator, which returns the event; weight density at a given phase space point during the foam; build-up. Function Members (Methods); public:. virtual~PDEFoamMultiTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPr",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:11009,Integrability,integrat,integration,11009,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:11631,Integrability,message,message,11631,"Object::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:517,Modifiability,variab,variables,517,". TMVA::PDEFoamMultiTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamMultiTarget. class TMVA::PDEFoamMultiTarget: public TMVA::PDEFoamEvent. PDEFoamMultiTarget. This PDEFoam variant is used to estimate multiple targets by; creating an event density foam (PDEFoamEvent), which has dimension:. dimension = number of variables + number targets. This PDEFoam variant stores in every cell the sum of event weights; and the sum of the squared event weights. During evaluation for a; given event, which has only variables and no targets (number of; event variables is smaller than the foam dimension), the targets; are estimated by finding all cells, which correspond to this event; and calculate the Mean (or Mpv, depending on the ETargetSelection); cell center weighted by the event density in the cell. This PDEFoam variant should be booked together with the; PDEFoamEventDensity density estimator, which returns the event; weight density at a given phase space point during the foam; build-up. Function Members (Methods); public:. virtual~PDEFoamMultiTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPr",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:708,Modifiability,variab,variables,708,". TMVA::PDEFoamMultiTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamMultiTarget. class TMVA::PDEFoamMultiTarget: public TMVA::PDEFoamEvent. PDEFoamMultiTarget. This PDEFoam variant is used to estimate multiple targets by; creating an event density foam (PDEFoamEvent), which has dimension:. dimension = number of variables + number targets. This PDEFoam variant stores in every cell the sum of event weights; and the sum of the squared event weights. During evaluation for a; given event, which has only variables and no targets (number of; event variables is smaller than the foam dimension), the targets; are estimated by finding all cells, which correspond to this event; and calculate the Mean (or Mpv, depending on the ETargetSelection); cell center weighted by the event density in the cell. This PDEFoam variant should be booked together with the; PDEFoamEventDensity density estimator, which returns the event; weight density at a given phase space point during the foam; build-up. Function Members (Methods); public:. virtual~PDEFoamMultiTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPr",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:751,Modifiability,variab,variables,751,". TMVA::PDEFoamMultiTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamMultiTarget. class TMVA::PDEFoamMultiTarget: public TMVA::PDEFoamEvent. PDEFoamMultiTarget. This PDEFoam variant is used to estimate multiple targets by; creating an event density foam (PDEFoamEvent), which has dimension:. dimension = number of variables + number targets. This PDEFoam variant stores in every cell the sum of event weights; and the sum of the squared event weights. During evaluation for a; given event, which has only variables and no targets (number of; event variables is smaller than the foam dimension), the targets; are estimated by finding all cells, which correspond to this event; and calculate the Mean (or Mpv, depending on the ETargetSelection); cell center weighted by the event density in the cell. This PDEFoam variant should be booked together with the; PDEFoamEventDensity density estimator, which returns the event; weight density at a given phase space point during the foam; build-up. Function Members (Methods); public:. virtual~PDEFoamMultiTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPr",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:11977,Modifiability,variab,variables,11977,"ITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::ETargetSelectionfTargetSelectionthe target selection method; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] ma",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:12757,Modifiability,variab,variable,12757," Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::ETargetSelectionfTargetSelectionthe target selection method; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamMultiTarget(); Default constructor for streamer, user should not use it. PDEFoamMultiTarget(const TString& , TMVA::ETargetSelection ); User constructor. Parameters:. - name - name of PDEFoam object. - ts - target selection method used in; GetCellValue(const std::map<Int_t, Float_t>& xvec, ECellValue); Cadidates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for ",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:12928,Modifiability,variab,variable,12928," Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::ETargetSelectionfTargetSelectionthe target selection method; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamMultiTarget(); Default constructor for streamer, user should not use it. PDEFoamMultiTarget(const TString& , TMVA::ETargetSelection ); User constructor. Parameters:. - name - name of PDEFoam object. - ts - target selection method used in; GetCellValue(const std::map<Int_t, Float_t>& xvec, ECellValue); Cadidates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for ",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:12996,Modifiability,variab,variable,12996," Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::ETargetSelectionfTargetSelectionthe target selection method; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamMultiTarget(); Default constructor for streamer, user should not use it. PDEFoamMultiTarget(const TString& , TMVA::ETargetSelection ); User constructor. Parameters:. - name - name of PDEFoam object. - ts - target selection method used in; GetCellValue(const std::map<Int_t, Float_t>& xvec, ECellValue); Cadidates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for ",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:13607,Modifiability,variab,variable,13607,"or fDim+1 maximum elements; TMVA::ETargetSelectionfTargetSelectionthe target selection method; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamMultiTarget(); Default constructor for streamer, user should not use it. PDEFoamMultiTarget(const TString& , TMVA::ETargetSelection ); User constructor. Parameters:. - name - name of PDEFoam object. - ts - target selection method used in; GetCellValue(const std::map<Int_t, Float_t>& xvec, ECellValue); Cadidates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for every target variable in the; foam), that is the target value which corresponds to the; cell with the largest event density. PDEFoamMultiTarget(const TMVA::PDEFoamMultiTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). std::vector<Float_t> GetCellValue(const map<Int_t,Float_t>& , TMVA::ECellValue ); This function is overridden from PDFEFoam. It returns all; regression targets (in order), given an untransformed event; vector 'xvec'. The key of 'xvec' is the dimension and the value; (Float_t) is the coordinate. Note: number of foam dimensions = number of variables + number; of targets. Parameters:; - xvec - map of event variables (no targets!); - cv - cell value to return (ignored!). Return:; Targets, ordered by missing dimensions in 'xvec'.; The size o",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
