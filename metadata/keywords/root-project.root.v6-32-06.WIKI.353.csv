id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html532/TMath.html:12770,Availability,error,error,12770,"Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Int_t Nint(Float_t x); Round to nearest integer. Rounds half integers to the nearest; even integer. Int_t Nint(Double_t x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, B",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18286,Availability,error,error,18286,"nst Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:20971,Availability,error,error,20971,"convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roo",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:21193,Availability,error,error,21193,"just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:42304,Availability,down,down,42304,"lement value); Binary search in an array defined by its iterators. The values in the iterators range are supposed to be sorted; prior to this call. If match is found, function returns; position of element. If no match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> T * Cross(const T v1[3],const T v2[3], T out[3]); Calculate the Cross Product of two vectors:; out = [v1 x v2]. template <typename T> T * Normal2Plane(const T p1[3],const T p2[3],const T p3[3], T normal[3]); Calculate a normal vector of a plane. Input:; Float_t *p1,*p2,*p3 - 3 3D points belonged the plane to define it. Return:; Pointer to 3D normal vector (normalized). template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y); Function which returns kTRUE if point xp,yp lies inside the; polygon defined by the np points in arrays x and y, kFALSE otherwise.; Note that the polygon may be open or closed. template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:42468,Availability,down,down,42468,"o match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> T * Cross(const T v1[3],const T v2[3], T out[3]); Calculate the Cross Product of two vectors:; out = [v1 x v2]. template <typename T> T * Normal2Plane(const T p1[3],const T p2[3],const T p3[3], T normal[3]); Calculate a normal vector of a plane. Input:; Float_t *p1,*p2,*p3 - 3 3D points belonged the plane to define it. Return:; Pointer to 3D normal vector (normalized). template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y); Function which returns kTRUE if point xp,yp lies inside the; polygon defined by the np points in arrays x and y, kFALSE otherwise.; Note that the polygon may be open or closed. template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the median of the array a where each entry i has weight w[i] .; Both arrays have a length of at least n . The median is a number obtained; from the sorted array a through. median = (a[jl]+a[jh])/2. where (using al",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:49060,Availability,down,down,49060,"is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value). template <typename Iterator, typename Element> Iterator BinarySearch(Iterator first, Iterator last, Element value). void Sort(Index n, const Element* a, Index* index, Bool_t down=kTRUE); Sorting. template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y); IsInside. template <typename T> T * Cross(const T v1[3],const T v2[3], T out[3]); Calculate the Cross Product of two vectors. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. template <typename T> T * Normal2Plane(const T v1[3],const T v2[3],const T v3[3], T normal[3]); Calculate a normal vector of a plane. template <typename T> Double_t Mean(Long64_t n, const T *a, const Double_t *w=0). Statistics over arrays. Mean, Geometric Mean, Median, RMS(sigma). template <typename Iterator> Double_t Mean(Iterator first, Iterator last). template <typename Iterator, typename WeightIterator> Double_t Mean(Iterator first, Iterator last, WeightIterator w). template <typename T> Double_t GeomMean(Long64_t n, const T *a). template <typename Iterator> Double_t GeomMean(Iterator first, Iterator last). templa",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:53081,Availability,down,down,53081,"lement value); Binary search in an array defined by its iterators. The values in the iterators range are supposed to be sorted; prior to this call. If match is found, function returns; position of element. If no match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the median of the array a where each entry i has weight w[i] .; Both arrays have a length of at least n . The median is a number obtained; from the sorted array a through. median = (a[jl]+a[jh])/2. where (using also the sorted index on the array w). sum_i=0,jl w[i] <= sumTot/2; sum_i=0,jh w[i] >= sumTot/2; sumTot = sum_i=0,n w[i]. If w=0, the algorithm defaults to the median definition where it is; a number that divides the sorted sequence into 2 halves.; When n is odd or n > 1000, the median is kth element k = (n + 1) / 2.; when n is even and n < 1000the median is a mean of the elements k = n/2 and k = n/2 + 1. If the weights are supplied ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:53245,Availability,down,down,53245,"o match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the median of the array a where each entry i has weight w[i] .; Both arrays have a length of at least n . The median is a number obtained; from the sorted array a through. median = (a[jl]+a[jh])/2. where (using also the sorted index on the array w). sum_i=0,jl w[i] <= sumTot/2; sum_i=0,jh w[i] >= sumTot/2; sumTot = sum_i=0,n w[i]. If w=0, the algorithm defaults to the median definition where it is; a number that divides the sorted sequence into 2 halves.; When n is odd or n > 1000, the median is kth element k = (n + 1) / 2.; when n is even and n < 1000the median is a mean of the elements k = n/2 and k = n/2 + 1. If the weights are supplied (w not 0) all weights must be >= 0. If work is supplied, it is used to store the sorting index and assumed to be; >= n . If work=0, local storage is used, either on the stack if n < kWorkMax; or on the heap fo",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18502,Deployability,integrat,integrated,18502,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:22903,Deployability,continuous,continuous,22903,"urned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array'",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:29216,Deployability,continuous,continuous,29216,"atural lower and upper limits. Double_t BetaIncomplete(Double_t x, Double_t a, Double_t b); Calculates the incomplete Beta-function. Double_t Binomial(Int_t n, Int_t k); Calculate the binomial coefficient n over k. Double_t BinomialI(Double_t p, Int_t n, Int_t k); Suppose an event occurs with probability _p_ per trial; Then the probability P of its occuring _k_ or more times; in _n_ trials is termed a cumulative binomial probability; the formula is P = sum_from_j=k_to_n(TMath::Binomial(n, j)*; *TMath::Power(p, j)*TMath::Power(1-p, n-j); For _n_ larger than 12 BetaIncomplete is a much better way; to evaluate the sum than would be the straightforward sum calculation; for _n_ smaller than 12 either method is acceptable; (""Numerical Recipes""); --implementation by Anna Kreshuk. Double_t CauchyDist(Double_t x, Double_t t = 0, Double_t s = 1); Computes the density of Cauchy distribution at point x; by default, standard Cauchy distribution is used (t=0, s=1); t is the location parameter; s is the scale parameter; The Cauchy distribution, also called Lorentzian distribution,; is a continuous distribution describing resonance behavior; The mean and standard deviation of the Cauchy distribution are undefined.; The practical meaning of this is that collecting 1,000 data points gives; no more accurate an estimate of the mean and standard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:14418,Energy Efficiency,adapt,adapted,14418,"; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mpv is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mpv=0 and sigma=1 (default values) the exact location of the maximum of the distribution (most proble value) is at; x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for all integer arguments it is correct.; BUT for non-integer values it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note that",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:16512,Energy Efficiency,power,powerful,16512,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18608,Energy Efficiency,adapt,adapted,18608,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:21120,Energy Efficiency,adapt,adapted,21120," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:22505,Energy Efficiency,allocate,allocated,22505,"ubject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:22596,Energy Efficiency,allocate,allocated,22596,"ble_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and F",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:28634,Energy Efficiency,Power,Power,28634,"hird are the function parameters.; Since the Beta distribution is bounded on both sides, it's often; used to represent processes with natural lower and upper limits. Double_t BetaDistI(Double_t x, Double_t p, Double_t q); Computes the distribution function of the Beta distribution.; The first argument is the point, where the function will be; computed, second and third are the function parameters.; Since the Beta distribution is bounded on both sides, it's often; used to represent processes with natural lower and upper limits. Double_t BetaIncomplete(Double_t x, Double_t a, Double_t b); Calculates the incomplete Beta-function. Double_t Binomial(Int_t n, Int_t k); Calculate the binomial coefficient n over k. Double_t BinomialI(Double_t p, Int_t n, Int_t k); Suppose an event occurs with probability _p_ per trial; Then the probability P of its occuring _k_ or more times; in _n_ trials is termed a cumulative binomial probability; the formula is P = sum_from_j=k_to_n(TMath::Binomial(n, j)*; *TMath::Power(p, j)*TMath::Power(1-p, n-j); For _n_ larger than 12 BetaIncomplete is a much better way; to evaluate the sum than would be the straightforward sum calculation; for _n_ smaller than 12 either method is acceptable; (""Numerical Recipes""); --implementation by Anna Kreshuk. Double_t CauchyDist(Double_t x, Double_t t = 0, Double_t s = 1); Computes the density of Cauchy distribution at point x; by default, standard Cauchy distribution is used (t=0, s=1); t is the location parameter; s is the scale parameter; The Cauchy distribution, also called Lorentzian distribution,; is a continuous distribution describing resonance behavior; The mean and standard deviation of the Cauchy distribution are undefined.; The practical meaning of this is that collecting 1,000 data points gives; no more accurate an estimate of the mean and standard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:28653,Energy Efficiency,Power,Power,28653,"hird are the function parameters.; Since the Beta distribution is bounded on both sides, it's often; used to represent processes with natural lower and upper limits. Double_t BetaDistI(Double_t x, Double_t p, Double_t q); Computes the distribution function of the Beta distribution.; The first argument is the point, where the function will be; computed, second and third are the function parameters.; Since the Beta distribution is bounded on both sides, it's often; used to represent processes with natural lower and upper limits. Double_t BetaIncomplete(Double_t x, Double_t a, Double_t b); Calculates the incomplete Beta-function. Double_t Binomial(Int_t n, Int_t k); Calculate the binomial coefficient n over k. Double_t BinomialI(Double_t p, Int_t n, Int_t k); Suppose an event occurs with probability _p_ per trial; Then the probability P of its occuring _k_ or more times; in _n_ trials is termed a cumulative binomial probability; the formula is P = sum_from_j=k_to_n(TMath::Binomial(n, j)*; *TMath::Power(p, j)*TMath::Power(1-p, n-j); For _n_ larger than 12 BetaIncomplete is a much better way; to evaluate the sum than would be the straightforward sum calculation; for _n_ smaller than 12 either method is acceptable; (""Numerical Recipes""); --implementation by Anna Kreshuk. Double_t CauchyDist(Double_t x, Double_t t = 0, Double_t s = 1); Computes the density of Cauchy distribution at point x; by default, standard Cauchy distribution is used (t=0, s=1); t is the location parameter; s is the scale parameter; The Cauchy distribution, also called Lorentzian distribution,; is a continuous distribution describing resonance behavior; The mean and standard deviation of the Cauchy distribution are undefined.; The practical meaning of this is that collecting 1,000 data points gives; no more accurate an estimate of the mean and standard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33717,Energy Efficiency,adapt,adapted,33717,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:38695,Energy Efficiency,Power,Power,38695,"m the Cernlib function dislan(G110); Reference: K.S.Kolbig and B.Schorr, ""A program package for the Landau; distribution"", Computer Phys.Comm., 31(1984), 97-111. Double_t Sin(Double_t x); { return sin(x); }. Double_t Cos(Double_t x); { return cos(x); }. Double_t Tan(Double_t x); { return tan(x); }. Double_t SinH(Double_t x); { return sinh(x); }. Double_t CosH(Double_t x); { return cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimu",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:38758,Energy Efficiency,Power,Power,38758,"S.Kolbig and B.Schorr, ""A program package for the Landau; distribution"", Computer Phys.Comm., 31(1984), 97-111. Double_t Sin(Double_t x); { return sin(x); }. Double_t Cos(Double_t x); { return cos(x); }. Double_t Tan(Double_t x); { return tan(x); }. Double_t SinH(Double_t x); { return sinh(x); }. Double_t CosH(Double_t x); { return cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n,",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:47767,Energy Efficiency,charge,charge,47767," 1.0e7 * K(); }. Double_t KUncertainty(); { return 0.0000024e-23; }. Double_t Sigma(); Stefan-Boltzmann constant. { return 5.6704e-8; }. Double_t SigmaUncertainty(); { return 0.000040e-8; }. Double_t Na(); Avogadro constant (Avogadro's Number). { return 6.02214199e+23; }. Double_t NaUncertainty(); { return 0.00000047e+23; }. Double_t R(); universal gas constant (Na * K); http://scienceworld.wolfram.com/physics/UniversalGasConstant.html. { return K() * Na(); }. Double_t RUncertainty(); { return R()*((KUncertainty()/K()) + (NaUncertainty()/Na())); }. Double_t MWair(); Molecular weight of dry air; 1976 US Standard Atmosphere,; also see http://atmos.nmsu.edu/jsdap/encyclopediawork.html. { return 28.9644; }. Double_t Rgair(); Dry Air Gas Constant (R / MWair); http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm. { return (1000.0 * R()) / MWair(); }. Double_t EulerGamma(); Euler-Mascheroni Constant. { return 0.577215664901532860606512090082402431042; }. Double_t Qe(); Elementary charge. { return 1.602176462e-19; }. Double_t QeUncertainty(); { return 0.000000063e-19; }. T Min(). T Max(). Bool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Comparing floating points. return Abs(af-bf); return kTRUE if absolute difference between af and bf is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t BinarySearch(Long64_",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:296,Integrability,rout,routines,296,". TMath. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  TMath. namespace TMath. TMath. Encapsulate math routines. Function Members (Methods); public:. Short_tAbs(Short_t d); Int_tAbs(Int_t d); Long_tAbs(Long_t d); Long64_tAbs(Long64_t d); Float_tAbs(Float_t d); Double_tAbs(Double_t d); Double_tACos(Double_t x); Double_tACosH(Double_t); Bool_tAreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Bool_tAreEqualRel(Double_t af, Double_t bf, Double_t relPrec); Double_tASin(Double_t x); Double_tASinH(Double_t); Double_tATan(Double_t x); Double_tATan2(Double_t y, Double_t x); Double_tATanH(Double_t); Double_tBesselI(Int_t n, Double_t x); Double_tBesselI0(Double_t x); Double_tBesselI1(Double_t x); Double_tBesselJ0(Double_t x); Double_tBesselJ1(Double_t x); Double_tBesselK(Int_t n, Double_t x); Double_tBesselK0(Double_t x); Double_tBesselK1(Double_t x); Double_tBesselY0(Double_t x); Double_tBesselY1(Double_t x); Double_tBeta(Double_t p, Double_t q); Double_tBetaCf(Double_t x, Double_t a, Double_t b); Double_tBetaDist(Double_t x, Double_t p, Double_t q); Double_tBetaDistI(Double_t x, Double_t p, Double_t q); Double_tBetaIncomplete(Double_t x, Double_t a, Double_t b); Long64_tBinarySearch(Long64_t n, const short* array, short value); Long64_tBinarySearch(Long64_t n, const short** array, short value); Long64_tBinarySearch(Long64_t n, const int* array, int value); Long64_tBinarySearch(Long64_t n, const int** array, int value); Long64_tBinarySearch(Long64_t n, const float* array, float value); Long64_tBinarySearch(Long64_t n, const float** array, float value); Long64_tBinarySearch(Long64_t n, const double* array, double value); Long64_tBinarySearch(Long64_t n, const double** array, double value); Long64_tBinarySearch(Long64_t n, const long* array, long value); Long64_tBinarySearch(Long64_",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:14443,Integrability,rout,routine,14443,"; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mpv is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mpv=0 and sigma=1 (default values) the exact location of the maximum of the distribution (most proble value) is at; x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for all integer arguments it is correct.; BUT for non-integer values it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note that",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18502,Integrability,integrat,integrated,18502,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18642,Integrability,rout,routine,18642,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33738,Integrability,rout,routine,33738,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:39024,Integrability,wrap,wrapper,39024,"_t SinH(Double_t x); { return sinh(x); }. Double_t CosH(Double_t x); { return cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with the maximum element.; If more than one element is maximum returns first found. Iterator LocMax(Iterator first, Iterator last); Return index of array with the maximum element.; If more than one element is maximum re",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:14418,Modifiability,adapt,adapted,14418,"; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mpv is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mpv=0 and sigma=1 (default values) the exact location of the maximum of the distribution (most proble value) is at; x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for all integer arguments it is correct.; BUT for non-integer values it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note that",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18608,Modifiability,adapt,adapted,18608,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:21120,Modifiability,adapt,adapted,21120," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:30471,Modifiability,variab,variable,30471,"andard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() impl",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33043,Modifiability,Variab,Variable,33043,"lace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at wh",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33717,Modifiability,adapt,adapted,33717,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:34106,Modifiability,variab,variable,34106,"e shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distrib",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:34666,Modifiability,variab,variable,34666,"f; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Computes quantiles of the Student's t-distribution; 1st argument is the probability, at which the quantile is computed; 2nd argument - the number of degrees of freedom of the; Student distribution; When the 3rd argument lower_tail i",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:20237,Performance,perform,perform,20237,"a++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24351,Security,Hash,Hash,24351,"pe=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24397,Security,hash,hash,24397,"pe=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24588,Security,hash,hash,24588," Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-S",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24619,Security,hash,hash,24619,"istician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24689,Security,hash,hash,24689,"ackage {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; A",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24752,Security,Hash,Hash,24752,"ackage {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; A",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24761,Security,Hash,Hash,24761,"ackage {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; A",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24773,Security,Hash,Hash,24773,"t to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Dou",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24880,Security,Hash,Hash,24880,"; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK1(Double_t x); Compute the modified Bessel function K_1(x) for positive real x. M.Abramowitz and I.A.St",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24923,Security,Hash,Hash,24923,"; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK1(Double_t x); Compute the modified Bessel function K_1(x) for positive real x. M.Abramowitz and I.A.St",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24976,Security,Hash,Hash,24976,"; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK1(Double_t x); Compute the modified Bessel function K_1(x) for positive real x. M.Abramowitz and I.A.St",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:25147,Security,Hash,Hash,25147,"r2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK1(Double_t x); Compute the modified Bessel function K_1(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK(Int_t n, Double_t x); Com",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:25161,Security,Hash,Hash,25161,"ord.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK1(Double_t x); Compute the modified Bessel function K_1(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK(Int_t n, Double_t x); Compute the Integer Order Modified Bessel function K_n(x); for n",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:16424,Testability,test,test,16424,"e values of par, it is better to call; TMath::Gaus(x,par,sqrt(par),kTRUE). /*. */. Double_t PoissonI(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:16522,Testability,test,test,16522,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:17414,Testability,test,test,17414,"est statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:17546,Testability,test,test,17546,"est statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18003,Testability,test,test,18003,"*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two so",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18427,Testability,test,test,18427,"ether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (i",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:18445,Testability,test,test,18445,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:20523,Testability,test,test,20523,"ase, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubi",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:24782,Testability,test,tested,24782,"t to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Dou",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:30620,Testability,test,testing,30620,"/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Doub",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:31049,Testability,test,test,31049,"na Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now impleme",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:31120,Testability,test,test,31120,"grees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now implementation in ROOT::Math::gamma_pdf. /*; ; */. Double_t LaplaceDist(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the probability density function of Laplace distributi",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:32908,Testability,Log,LogNormal,32908,"3/eda366b.htm; use now implementation in ROOT::Math::gamma_pdf. /*; ; */. Double_t LaplaceDist(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the probability density function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33007,Testability,Log,LogNormal,33007,"3/eda366b.htm; use now implementation in ROOT::Math::gamma_pdf. /*; ; */. Double_t LaplaceDist(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the probability density function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33058,Testability,log,lognormal,33058,"lace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at wh",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:34338,Testability,test,tests,34338,"; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Dou",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:34379,Testability,test,tests,34379,"; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Dou",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:38795,Testability,Log,Log,38795,"for the Landau; distribution"", Computer Phys.Comm., 31(1984), 97-111. Double_t Sin(Double_t x); { return sin(x); }. Double_t Cos(Double_t x); { return cos(x); }. Double_t Tan(Double_t x); { return tan(x); }. Double_t SinH(Double_t x); { return sinh(x); }. Double_t CosH(Double_t x); { return cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:38821,Testability,log,log,38821,"for the Landau; distribution"", Computer Phys.Comm., 31(1984), 97-111. Double_t Sin(Double_t x); { return sin(x); }. Double_t Cos(Double_t x); { return cos(x); }. Double_t Tan(Double_t x); { return tan(x); }. Double_t SinH(Double_t x); { return sinh(x); }. Double_t CosH(Double_t x); { return cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with ",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:45494,Testability,log,log,45494,"sorting index and; assumed to be >= n. If work=0, local storage is used, either on; the stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbar",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:45561,Testability,log,log,45561,"he stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:45583,Testability,log,log,45583,"he stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:45640,Testability,Log,LogE,45640," not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-34; }. Double_t HC(); hc (h * c). { return H() * C(); }. Double_t HCcgs(); { return Hcgs() * C",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:45656,Testability,log,log,45656," not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-34; }. Double_t HC(); hc (h * c). { return H() * C(); }. Double_t HCcgs(); { return Hcgs() * C",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:45683,Testability,log,log,45683," not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-34; }. Double_t HC(); hc (h * c). { return H() * C(); }. Double_t HCcgs(); { return Hcgs() * C",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMath.html:33612,Usability,Simpl,Simple,33612,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html532/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMath.html
https://root.cern/root/html532/TMatrixDEigen.html:1762,Modifiability,Inherit,Inheritance,1762,"-symmetric; cases, and A*V = V*D. Function Members (Methods); public:. TMatrixDEigen(); TMatrixDEigen(const TMatrixD& a); TMatrixDEigen(const TMatrixDEigen& another); virtual~TMatrixDEigen(); static TClass*Class(); const TMatrixDGetEigenValues() const; const TVectorD&GetEigenValuesIm() const; const TVectorD&GetEigenValuesRe() const; const TMatrixD&GetEigenVectors() const; virtual TClass*IsA() const; TMatrixDEigen&operator=(const TMatrixDEigen& source); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidMakeHessenBerg(TMatrixD& v, TVectorD& ortho, TMatrixD& H); static voidMakeSchurr(TMatrixD& v, TVectorD& d, TVectorD& e, TMatrixD& H); static voidSort(TMatrixD& v, TVectorD& d, TVectorD& e). Data Members; public:. enum { kWorkMax; };. protected:. TVectorDfEigenValuesImEigen-values; TVectorDfEigenValuesReEigen-values; TMatrixDfEigenVectorsEigen-vectors of matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMatrixDEigen(const TMatrixD& a); Constructor for eigen-problem of matrix A . TMatrixDEigen(const TMatrixDEigen& another); Copy constructor. void MakeHessenBerg(TMatrixD& v, TVectorD& ortho, TMatrixD& H); Nonsymmetric reduction to Hessenberg form.; This is derived from the Algol procedures orthes and ortran, by Martin and Wilkinson,; Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutines in EISPACK. void MakeSchurr(TMatrixD& v, TVectorD& d, TVectorD& e, TMatrixD& H); Nonsymmetric reduction from Hessenberg to real Schur form.; This is derived from the Algol procedure hqr2, by Martin and Wilkinson,; Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutine in EISPACK. void Sort(TMatrixD& v, TVectorD& d, TVectorD& e); Sort eigenvalues and corresponding vectors in descending order of Re^2+Im^2; of the complex eigenvalues . TMatrixDEigen & operator=(const TMatrixDEigen& s",MatchSource.WIKI,root/html532/TMatrixDEigen.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixDEigen.html
https://root.cern/root/html532/TMatrixDEigen.html:1775,Modifiability,Inherit,Inherited,1775,"-symmetric; cases, and A*V = V*D. Function Members (Methods); public:. TMatrixDEigen(); TMatrixDEigen(const TMatrixD& a); TMatrixDEigen(const TMatrixDEigen& another); virtual~TMatrixDEigen(); static TClass*Class(); const TMatrixDGetEigenValues() const; const TVectorD&GetEigenValuesIm() const; const TVectorD&GetEigenValuesRe() const; const TMatrixD&GetEigenVectors() const; virtual TClass*IsA() const; TMatrixDEigen&operator=(const TMatrixDEigen& source); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidMakeHessenBerg(TMatrixD& v, TVectorD& ortho, TMatrixD& H); static voidMakeSchurr(TMatrixD& v, TVectorD& d, TVectorD& e, TMatrixD& H); static voidSort(TMatrixD& v, TVectorD& d, TVectorD& e). Data Members; public:. enum { kWorkMax; };. protected:. TVectorDfEigenValuesImEigen-values; TVectorDfEigenValuesReEigen-values; TMatrixDfEigenVectorsEigen-vectors of matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMatrixDEigen(const TMatrixD& a); Constructor for eigen-problem of matrix A . TMatrixDEigen(const TMatrixDEigen& another); Copy constructor. void MakeHessenBerg(TMatrixD& v, TVectorD& ortho, TMatrixD& H); Nonsymmetric reduction to Hessenberg form.; This is derived from the Algol procedures orthes and ortran, by Martin and Wilkinson,; Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutines in EISPACK. void MakeSchurr(TMatrixD& v, TVectorD& d, TVectorD& e, TMatrixD& H); Nonsymmetric reduction from Hessenberg to real Schur form.; This is derived from the Algol procedure hqr2, by Martin and Wilkinson,; Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutine in EISPACK. void Sort(TMatrixD& v, TVectorD& d, TVectorD& e); Sort eigenvalues and corresponding vectors in descending order of Re^2+Im^2; of the complex eigenvalues . TMatrixDEigen & operator=(const TMatrixDEigen& s",MatchSource.WIKI,root/html532/TMatrixDEigen.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixDEigen.html
https://root.cern/root/html532/TMatrixDSymEigen.html:1449,Modifiability,Inherit,Inheritance,1449," V is orthogonal. That is, the; diagonal values of D are the eigenvalues, and V*V' = I, where I is; the identity matrix. The columns of V represent the eigenvectors in; the sense that A*V = V*D. Function Members (Methods); public:. TMatrixDSymEigen(); TMatrixDSymEigen(const TMatrixDSym& a); TMatrixDSymEigen(const TMatrixDSymEigen& another); virtual~TMatrixDSymEigen(); static TClass*Class(); const TVectorD&GetEigenValues() const; const TMatrixD&GetEigenVectors() const; virtual TClass*IsA() const; TMatrixDSymEigen&operator=(const TMatrixDSymEigen& source); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidMakeEigenVectors(TMatrixD& v, TVectorD& d, TVectorD& e); static voidMakeTridiagonal(TMatrixD& v, TVectorD& d, TVectorD& e). Data Members; public:. enum { kWorkMax; };. protected:. TVectorDfEigenValuesEigen-values; TMatrixDfEigenVectorsEigen-vectors of matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMatrixDSymEigen(const TMatrixDSym& a); Constructor for eigen-problem of symmetric matrix A . TMatrixDSymEigen(const TMatrixDSymEigen& another); Copy constructor. void MakeTridiagonal(TMatrixD& v, TVectorD& d, TVectorD& e); This is derived from the Algol procedures tred2 by Bowdler, Martin, Reinsch, and; Wilkinson, Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutine in EISPACK. void MakeEigenVectors(TMatrixD& v, TVectorD& d, TVectorD& e); Symmetric tridiagonal QL algorithm.; This is derived from the Algol procedures tql2, by Bowdler, Martin, Reinsch, and; Wilkinson, Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutine in EISPACK. TMatrixDSymEigen & operator=(const TMatrixDSymEigen& source); Assignment operator. TMatrixDSymEigen(); {}. virtual ~TMatrixDSymEigen(); {}. const TMatrixD & GetEigenVectors() const; If matrix A has shape (rowLwb,rowUpb,rowLwb,rowUpb),",MatchSource.WIKI,root/html532/TMatrixDSymEigen.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixDSymEigen.html
https://root.cern/root/html532/TMatrixDSymEigen.html:1462,Modifiability,Inherit,Inherited,1462," V is orthogonal. That is, the; diagonal values of D are the eigenvalues, and V*V' = I, where I is; the identity matrix. The columns of V represent the eigenvectors in; the sense that A*V = V*D. Function Members (Methods); public:. TMatrixDSymEigen(); TMatrixDSymEigen(const TMatrixDSym& a); TMatrixDSymEigen(const TMatrixDSymEigen& another); virtual~TMatrixDSymEigen(); static TClass*Class(); const TVectorD&GetEigenValues() const; const TMatrixD&GetEigenVectors() const; virtual TClass*IsA() const; TMatrixDSymEigen&operator=(const TMatrixDSymEigen& source); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidMakeEigenVectors(TMatrixD& v, TVectorD& d, TVectorD& e); static voidMakeTridiagonal(TMatrixD& v, TVectorD& d, TVectorD& e). Data Members; public:. enum { kWorkMax; };. protected:. TVectorDfEigenValuesEigen-values; TMatrixDfEigenVectorsEigen-vectors of matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMatrixDSymEigen(const TMatrixDSym& a); Constructor for eigen-problem of symmetric matrix A . TMatrixDSymEigen(const TMatrixDSymEigen& another); Copy constructor. void MakeTridiagonal(TMatrixD& v, TVectorD& d, TVectorD& e); This is derived from the Algol procedures tred2 by Bowdler, Martin, Reinsch, and; Wilkinson, Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutine in EISPACK. void MakeEigenVectors(TMatrixD& v, TVectorD& d, TVectorD& e); Symmetric tridiagonal QL algorithm.; This is derived from the Algol procedures tql2, by Bowdler, Martin, Reinsch, and; Wilkinson, Handbook for Auto. Comp., Vol.ii-Linear Algebra, and the corresponding; Fortran subroutine in EISPACK. TMatrixDSymEigen & operator=(const TMatrixDSymEigen& source); Assignment operator. TMatrixDSymEigen(); {}. virtual ~TMatrixDSymEigen(); {}. const TMatrixD & GetEigenVectors() const; If matrix A has shape (rowLwb,rowUpb,rowLwb,rowUpb),",MatchSource.WIKI,root/html532/TMatrixDSymEigen.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixDSymEigen.html
https://root.cern/root/html532/TMatrixTBase_double_.html:822,Availability,avail,available,822,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3983,Availability,down,down,3983,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:7544,Availability,avail,available,7544,"Function(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Double_t>, TMatrixDBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual vo",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:8733,Availability,Error,Error,8733,"on_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TOb",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:8862,Availability,error,error,8862,"(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:8946,Availability,error,error,8946,"; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2031,Deployability,integrat,integrated,2031,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2545,Deployability,install,installation,2545,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2583,Deployability,install,installation,2583,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:1988,Energy Efficiency,efficient,efficient,1988,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2454,Energy Efficiency,adapt,adapted,2454,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3259,Energy Efficiency,adapt,adapted,3259,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3315,Energy Efficiency,efficient,efficiently,3315,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:4342,Energy Efficiency,efficient,efficient,4342,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2031,Integrability,integrat,integrated,2031,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3101,Integrability,rout,routines,3101,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3298,Integrability,rout,routines,3298,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2454,Modifiability,adapt,adapted,2454,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3259,Modifiability,adapt,adapted,3259,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:10562,Modifiability,Inherit,InheritsFrom,10562,"ual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); virtual doubleMax() const; voidTObject::MayNotUse(const char* method) const; virtual doubleMin() const; virtual Int_tNonZeros() const; doubleNorm1() const; virtual TMatrixTBase<double>&NormByDiag(const TVectorT<double>& v, Option_t* option = ""D""); doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(c",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:10628,Modifiability,Inherit,InheritsFrom,10628,"; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); virtual doubleMax() const; voidTObject::MayNotUse(const char* method) const; virtual doubleMin() const; virtual Int_tNonZeros() const; doubleNorm1() const; virtual TMatrixTBase<double>&NormByDiag(const TVectorT<double>& v, Option_t* option = ""D""); doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVe",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:15755,Modifiability,Inherit,Inheritance,15755,"ond, double* data); static voidIndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); voidTObject::MakeZombie(). private:. double*GetElements(). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwblower bound of the col index; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNcolsnumber of columns; Int_tfNelemsnumber of elements in matrix; Int_tfNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index; doublefTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTBase<Element> DoubleLexSort(Int_t n, Int_t* first, Int_t* second, double* data); Lexical sort on array data using indices first and second. void TMatrixTBase<Element> IndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); Lexical sort on array data using indices first and second. TMatrixTBase<Element> &TMatrixTBase<Element> SetMatrixArray(const double* data, Option_t* option = """"); Copy array data to matrix . It is assumed that array is of size >= fNelems; (=)))) fNrows*fNcols; option indicates how the data is stored in the array:; option =; 'F' : column major (Fortran) m[i][j] = array[i+j*fNrows]; else : row major (C) m[i][j] = array[i*fNcols+j] (default). Bool_t TMatrixTBase<Element> IsSymmetric() const; Check whether matrix is symmetric. void TMatrixTBase<Element> GetMatrix2Array(double* data, Option_t* option = """") const; Copy matrix data to array . It is assumed that arr",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:15768,Modifiability,Inherit,Inherited,15768,"ond, double* data); static voidIndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); voidTObject::MakeZombie(). private:. double*GetElements(). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwblower bound of the col index; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNcolsnumber of columns; Int_tfNelemsnumber of elements in matrix; Int_tfNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index; doublefTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTBase<Element> DoubleLexSort(Int_t n, Int_t* first, Int_t* second, double* data); Lexical sort on array data using indices first and second. void TMatrixTBase<Element> IndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); Lexical sort on array data using indices first and second. TMatrixTBase<Element> &TMatrixTBase<Element> SetMatrixArray(const double* data, Option_t* option = """"); Copy array data to matrix . It is assumed that array is of size >= fNelems; (=)))) fNrows*fNcols; option indicates how the data is stored in the array:; option =; 'F' : column major (Fortran) m[i][j] = array[i+j*fNrows]; else : row major (C) m[i][j] = array[i*fNcols+j] (default). Bool_t TMatrixTBase<Element> IsSymmetric() const; Check whether matrix is symmetric. void TMatrixTBase<Element> GetMatrix2Array(double* data, Option_t* option = """") const; Copy matrix data to array . It is assumed that arr",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:3955,Performance,optimiz,optimized,3955,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:851,Safety,avoid,avoiding,851,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:1682,Safety,AVOID,AVOID,1682,"ng. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage ",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:5124,Security,Access,Accessing,5124,"; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK.",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:6625,Security,Validat,Validation,6625,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Double_t>, TMatrixDBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs()",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:10452,Security,Hash,Hash,10452,":GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); virtual doubleMax() const; voidTObject::MayNotUse(const char* method) const; virtual doubleMin() const; virtual Int_tNonZeros() const; doubleNorm1() const; virtual TMatrixTBase<double>&NormByDiag(const TVectorT<do",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:2133,Testability,test,test,2133," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:4688,Testability,test,test,4688,"; from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; st",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:6650,Testability,test,test,6650,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Double_t>, TMatrixDBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs()",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:14169,Testability,Test,TestBit,14169,"ble beta, Double_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual TMatrixTBase<double>&ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); virtual TMatrixTBase<double>&ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); virtual doubleRowNorm() const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual TMatrixTBase<double>&SetColIndexArray(Int_t* data); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual TMatrixTBase<double>&SetMatrixArray(const double* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<double>&SetRowIndexArray(Int_t* data); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleSetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<double>&Sqr(); virtual TMatrixTBase<double>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual TMatrixTBase<double>&UnitMatrix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<double>&Zero().",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:14208,Testability,Test,TestBits,14208,"ble beta, Double_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual TMatrixTBase<double>&ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); virtual TMatrixTBase<double>&ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); virtual doubleRowNorm() const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual TMatrixTBase<double>&SetColIndexArray(Int_t* data); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual TMatrixTBase<double>&SetMatrixArray(const double* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<double>&SetRowIndexArray(Int_t* data); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleSetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<double>&Sqr(); virtual TMatrixTBase<double>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual TMatrixTBase<double>&UnitMatrix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<double>&Zero().",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:21515,Testability,Test,TestBit,21515,"fer& b); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(double newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln).  Last changed: root/matrix:$Id: TMatrixTBase.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:6277,Usability,simpl,simple,6277,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:6950,Usability,simpl,simple,6950,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Double_t>, TMatrixDBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActio",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_double_.html:21368,Usability,Clear,Clear,21368," Randomize(double alpha, double beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& b); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(double newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln).  Last changed: root/matrix:$Id: TMatrixTBase.h 20882 2007-11-19 11",MatchSource.WIKI,root/html532/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:819,Availability,avail,available,819,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3980,Availability,down,down,3980,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:7540,Availability,avail,available,7540,"yFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Float_t>, TMatrixFBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObje",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:8721,Availability,Error,Error,8721,"d(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:8850,Availability,error,error,8850,"ply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:8934,Availability,error,error,8934,"b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*T",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2028,Deployability,integrat,integrated,2028,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2542,Deployability,install,installation,2542,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2580,Deployability,install,installation,2580,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:1985,Energy Efficiency,efficient,efficient,1985,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2451,Energy Efficiency,adapt,adapted,2451,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3256,Energy Efficiency,adapt,adapted,3256,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3312,Energy Efficiency,efficient,efficiently,3312,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:4339,Energy Efficiency,efficient,efficient,4339,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2028,Integrability,integrat,integrated,2028,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3098,Integrability,rout,routines,3098,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3295,Integrability,rout,routines,3295,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2451,Modifiability,adapt,adapted,2451,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3256,Modifiability,adapt,adapted,3256,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:10543,Modifiability,Inherit,InheritsFrom,10543,"; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); virtual floatMax() const; voidTObject::MayNotUse(const char* method) const; virtual floatMin() const; virtual Int_tNonZeros() const; floatNorm1() const; virtual TMatrixTBase<float>&NormByDiag(const TVectorT<float>& v, Option_t* option = ""D""); floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const cha",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:10609,Modifiability,Inherit,InheritsFrom,10609,"const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); virtual floatMax() const; voidTObject::MayNotUse(const char* method) const; virtual floatMin() const; virtual Int_tNonZeros() const; floatNorm1() const; virtual TMatrixTBase<float>&NormByDiag(const TVectorT<float>& v, Option_t* option = ""D""); floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) cons",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:15695,Modifiability,Inherit,Inheritance,15695,"second, float* data); static voidIndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); voidTObject::MakeZombie(). private:. float*GetElements(). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwblower bound of the col index; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNcolsnumber of columns; Int_tfNelemsnumber of elements in matrix; Int_tfNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index; floatfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTBase<Element> DoubleLexSort(Int_t n, Int_t* first, Int_t* second, float* data); Lexical sort on array data using indices first and second. void TMatrixTBase<Element> IndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); Lexical sort on array data using indices first and second. TMatrixTBase<Element> &TMatrixTBase<Element> SetMatrixArray(const float* data, Option_t* option = """"); Copy array data to matrix . It is assumed that array is of size >= fNelems; (=)))) fNrows*fNcols; option indicates how the data is stored in the array:; option =; 'F' : column major (Fortran) m[i][j] = array[i+j*fNrows]; else : row major (C) m[i][j] = array[i*fNcols+j] (default). Bool_t TMatrixTBase<Element> IsSymmetric() const; Check whether matrix is symmetric. void TMatrixTBase<Element> GetMatrix2Array(float* data, Option_t* option = """") const; Copy matrix data to array . It is assumed that array ",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:15708,Modifiability,Inherit,Inherited,15708,"second, float* data); static voidIndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); voidTObject::MakeZombie(). private:. float*GetElements(). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwblower bound of the col index; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNcolsnumber of columns; Int_tfNelemsnumber of elements in matrix; Int_tfNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index; floatfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTBase<Element> DoubleLexSort(Int_t n, Int_t* first, Int_t* second, float* data); Lexical sort on array data using indices first and second. void TMatrixTBase<Element> IndexedLexSort(Int_t n, Int_t* first, Int_t swapFirst, Int_t* second, Int_t swapSecond, Int_t* index); Lexical sort on array data using indices first and second. TMatrixTBase<Element> &TMatrixTBase<Element> SetMatrixArray(const float* data, Option_t* option = """"); Copy array data to matrix . It is assumed that array is of size >= fNelems; (=)))) fNrows*fNcols; option indicates how the data is stored in the array:; option =; 'F' : column major (Fortran) m[i][j] = array[i+j*fNrows]; else : row major (C) m[i][j] = array[i*fNcols+j] (default). Bool_t TMatrixTBase<Element> IsSymmetric() const; Check whether matrix is symmetric. void TMatrixTBase<Element> GetMatrix2Array(float* data, Option_t* option = """") const; Copy matrix data to array . It is assumed that array ",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:3952,Performance,optimiz,optimized,3952,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:848,Safety,avoid,avoiding,848,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:1679,Safety,AVOID,AVOID,1679,"ng. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage ",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:5121,Security,Access,Accessing,5121,"; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK.",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:6622,Security,Validat,Validation,6622,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Float_t>, TMatrixFBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); v",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:10433,Security,Hash,Hash,10433,"bject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); virtual floatMax() const; voidTObject::MayNotUse(const char* method) const; virtual floatMin() const; virtual Int_tNonZeros() const; floatNorm1() const; virtual TMatrixTBase<float>&NormByDiag(const TVectorT<float>& ",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:2130,Testability,test,test,2130," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:4685,Testability,test,test,4685,"; from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; st",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:6647,Testability,test,test,6647,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Float_t>, TMatrixFBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); v",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:14114,Testability,Test,TestBit,14114,"e(float alpha, float beta, Double_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual TMatrixTBase<float>&ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); virtual TMatrixTBase<float>&ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); virtual floatRowNorm() const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual TMatrixTBase<float>&SetColIndexArray(Int_t* data); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual TMatrixTBase<float>&SetMatrixArray(const float* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<float>&SetRowIndexArray(Int_t* data); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatSetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<float>&Sqr(); virtual TMatrixTBase<float>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual TMatrixTBase<float>&UnitMatrix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<float>&Zero().",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:14153,Testability,Test,TestBits,14153,"e(float alpha, float beta, Double_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual TMatrixTBase<float>&ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); virtual TMatrixTBase<float>&ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); virtual floatRowNorm() const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual TMatrixTBase<float>&SetColIndexArray(Int_t* data); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual TMatrixTBase<float>&SetMatrixArray(const float* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<float>&SetRowIndexArray(Int_t* data); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatSetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<float>&Sqr(); virtual TMatrixTBase<float>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual TMatrixTBase<float>&UnitMatrix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<float>&Zero().",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:21440,Testability,Test,TestBit,21440,"ffer& b); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(float newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln).  Last changed: root/matrix:$Id: TMatrixTBase.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:6274,Usability,simpl,simple,6274,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:6947,Usability,simpl,simple,6947,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Float_t>, TMatrixFBase. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<flo",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTBase_float_.html:21293,Usability,Clear,Clear,21293,"nt> Randomize(float alpha, float beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& b); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(float newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln).  Last changed: root/matrix:$Id: TMatrixTBase.h 20882 2007-11-19 11:",MatchSource.WIKI,root/html532/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html
https://root.cern/root/html532/TMatrixTColumn_const_double_.html:1904,Modifiability,Inherit,Inheritance,1904,"rseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTColumn_const<Double_t>, TMatrixDColumn_const. Function Members (Methods); public:. TMatrixTColumn_const<double>(); TMatrixTColumn_const<double>(const TMatrixTColumn_const<double>& trc); TMatrixTColumn_const<double>(const TMatrixT<double>& matrix, Int_t col); TMatrixTColumn_const<double>(const TMatrixTSym<double>& matrix, Int_t col); virtual~TMatrixTColumn_const<double>(); static TClass*Class(); Int_tGetColIndex() const; Int_tGetInc() const; const TMatrixTBase<double>*GetMatrix() const; const double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTColumn_const<double>&operator=(const TMatrixTColumn_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColIndeffective column index; Int_tfIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<double>*fMatrixthe matrix I am a column of; const double*fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTColumn_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetColIndex() const; { return fColInd; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTColumn_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_const_double_.html
https://root.cern/root/html532/TMatrixTColumn_const_double_.html:1917,Modifiability,Inherit,Inherited,1917,"rseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTColumn_const<Double_t>, TMatrixDColumn_const. Function Members (Methods); public:. TMatrixTColumn_const<double>(); TMatrixTColumn_const<double>(const TMatrixTColumn_const<double>& trc); TMatrixTColumn_const<double>(const TMatrixT<double>& matrix, Int_t col); TMatrixTColumn_const<double>(const TMatrixTSym<double>& matrix, Int_t col); virtual~TMatrixTColumn_const<double>(); static TClass*Class(); Int_tGetColIndex() const; Int_tGetInc() const; const TMatrixTBase<double>*GetMatrix() const; const double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTColumn_const<double>&operator=(const TMatrixTColumn_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColIndeffective column index; Int_tfIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<double>*fMatrixthe matrix I am a column of; const double*fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTColumn_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetColIndex() const; { return fColInd; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTColumn_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_const_double_.html
https://root.cern/root/html532/TMatrixTColumn_const_float_.html:1884,Modifiability,Inherit,Inheritance,1884,"_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixFColumn_const, TMatrixTColumn_const<Float_t>. Function Members (Methods); public:. TMatrixTColumn_const<float>(); TMatrixTColumn_const<float>(const TMatrixTColumn_const<float>& trc); TMatrixTColumn_const<float>(const TMatrixT<float>& matrix, Int_t col); TMatrixTColumn_const<float>(const TMatrixTSym<float>& matrix, Int_t col); virtual~TMatrixTColumn_const<float>(); static TClass*Class(); Int_tGetColIndex() const; Int_tGetInc() const; const TMatrixTBase<float>*GetMatrix() const; const float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTColumn_const<float>&operator=(const TMatrixTColumn_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColIndeffective column index; Int_tfIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<float>*fMatrixthe matrix I am a column of; const float*fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTColumn_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetColIndex() const; { return fColInd; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTColumn_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_const_float_.html
https://root.cern/root/html532/TMatrixTColumn_const_float_.html:1897,Modifiability,Inherit,Inherited,1897,"_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixFColumn_const, TMatrixTColumn_const<Float_t>. Function Members (Methods); public:. TMatrixTColumn_const<float>(); TMatrixTColumn_const<float>(const TMatrixTColumn_const<float>& trc); TMatrixTColumn_const<float>(const TMatrixT<float>& matrix, Int_t col); TMatrixTColumn_const<float>(const TMatrixTSym<float>& matrix, Int_t col); virtual~TMatrixTColumn_const<float>(); static TClass*Class(); Int_tGetColIndex() const; Int_tGetInc() const; const TMatrixTBase<float>*GetMatrix() const; const float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTColumn_const<float>&operator=(const TMatrixTColumn_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColIndeffective column index; Int_tfIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<float>*fMatrixthe matrix I am a column of; const float*fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTColumn_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetColIndex() const; { return fColInd; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTColumn_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_const_float_.html
https://root.cern/root/html532/TMatrixTColumn_double_.html:2392,Modifiability,Inherit,Inheritance,2392,"nst; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTColumn_const<double>& c); voidoperator+=(double val); voidoperator+=(const TMatrixTColumn_const<double>& c); voidoperator=(double val); voidoperator=(const TMatrixTColumn_const<double>& c); TMatrixTColumn<double>&operator=(const TMatrixTColumn<double>& c); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTColumn_const<double>::fColIndeffective column index; Int_tTMatrixTColumn_const<double>::fIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<double>*TMatrixTColumn_const<double>::fMatrixthe matrix I am a column of; const double*TMatrixTColumn_const<double>::fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTColumn_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_double_.html
https://root.cern/root/html532/TMatrixTColumn_double_.html:2405,Modifiability,Inherit,Inherited,2405,"nst; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTColumn_const<double>& c); voidoperator+=(double val); voidoperator+=(const TMatrixTColumn_const<double>& c); voidoperator=(double val); voidoperator=(const TMatrixTColumn_const<double>& c); TMatrixTColumn<double>&operator=(const TMatrixTColumn<double>& c); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTColumn_const<double>::fColIndeffective column index; Int_tTMatrixTColumn_const<double>::fIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<double>*TMatrixTColumn_const<double>::fMatrixthe matrix I am a column of; const double*TMatrixTColumn_const<double>::fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTColumn_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_double_.html
https://root.cern/root/html532/TMatrixTColumn_float_.html:2355,Modifiability,Inherit,Inheritance,2355,"ual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTColumn_const<float>& c); voidoperator+=(float val); voidoperator+=(const TMatrixTColumn_const<float>& c); voidoperator=(float val); voidoperator=(const TMatrixTColumn_const<float>& c); TMatrixTColumn<float>&operator=(const TMatrixTColumn<float>& c); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTColumn_const<float>::fColIndeffective column index; Int_tTMatrixTColumn_const<float>::fIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<float>*TMatrixTColumn_const<float>::fMatrixthe matrix I am a column of; const float*TMatrixTColumn_const<float>::fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTColumn_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_float_.html
https://root.cern/root/html532/TMatrixTColumn_float_.html:2368,Modifiability,Inherit,Inherited,2368,"ual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTColumn_const<float>& c); voidoperator+=(float val); voidoperator+=(const TMatrixTColumn_const<float>& c); voidoperator=(float val); voidoperator=(const TMatrixTColumn_const<float>& c); TMatrixTColumn<float>&operator=(const TMatrixTColumn<float>& c); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTColumn_const<float>::fColIndeffective column index; Int_tTMatrixTColumn_const<float>::fIncif ptr = @a[i,col], then ptr+inc = @a[i+1,col]; TMatrixTBase<float>*TMatrixTColumn_const<float>::fMatrixthe matrix I am a column of; const float*TMatrixTColumn_const<float>::fPtrpointer to the a[0,col] column. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTColumn_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTColumn_float_.html
https://root.cern/root/html532/TMatrixTCramerInv.html:402,Energy Efficiency,adapt,adapted,402,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html532/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTCramerInv.html
https://root.cern/root/html532/TMatrixTCramerInv.html:367,Integrability,rout,routines,367,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html532/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTCramerInv.html
https://root.cern/root/html532/TMatrixTCramerInv.html:415,Integrability,rout,routines,415,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html532/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTCramerInv.html
https://root.cern/root/html532/TMatrixTCramerInv.html:402,Modifiability,adapt,adapted,402,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html532/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTCramerInv.html
https://root.cern/root/html532/TMatrixTDiag_const_double_.html:1860,Modifiability,Inherit,Inheritance,1860,"ixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTDiag_const<Double_t>, TMatrixDDiag_const. Function Members (Methods); public:. TMatrixTDiag_const<double>(); TMatrixTDiag_const<double>(const TMatrixT<double>& matrix); TMatrixTDiag_const<double>(const TMatrixTSym<double>& matrix); TMatrixTDiag_const<double>(const TMatrixTDiag_const<double>& trc); virtual~TMatrixTDiag_const<double>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNdiags() const; const double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTDiag_const<double>&operator=(const TMatrixTDiag_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<double>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols); const double*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTDiag_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTDiag_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_const_double_.html
https://root.cern/root/html532/TMatrixTDiag_const_double_.html:1873,Modifiability,Inherit,Inherited,1873,"ixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTDiag_const<Double_t>, TMatrixDDiag_const. Function Members (Methods); public:. TMatrixTDiag_const<double>(); TMatrixTDiag_const<double>(const TMatrixT<double>& matrix); TMatrixTDiag_const<double>(const TMatrixTSym<double>& matrix); TMatrixTDiag_const<double>(const TMatrixTDiag_const<double>& trc); virtual~TMatrixTDiag_const<double>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNdiags() const; const double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTDiag_const<double>&operator=(const TMatrixTDiag_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<double>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols); const double*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTDiag_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTDiag_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_const_double_.html
https://root.cern/root/html532/TMatrixTDiag_const_float_.html:1840,Modifiability,Inherit,Inheritance,1840,"ixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTDiag_const<Float_t>, TMatrixFDiag_const. Function Members (Methods); public:. TMatrixTDiag_const<float>(); TMatrixTDiag_const<float>(const TMatrixT<float>& matrix); TMatrixTDiag_const<float>(const TMatrixTSym<float>& matrix); TMatrixTDiag_const<float>(const TMatrixTDiag_const<float>& trc); virtual~TMatrixTDiag_const<float>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNdiags() const; const float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTDiag_const<float>&operator=(const TMatrixTDiag_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<float>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols); const float*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTDiag_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTDiag_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_const_float_.html
https://root.cern/root/html532/TMatrixTDiag_const_float_.html:1853,Modifiability,Inherit,Inherited,1853,"ixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTDiag_const<Float_t>, TMatrixFDiag_const. Function Members (Methods); public:. TMatrixTDiag_const<float>(); TMatrixTDiag_const<float>(const TMatrixT<float>& matrix); TMatrixTDiag_const<float>(const TMatrixTSym<float>& matrix); TMatrixTDiag_const<float>(const TMatrixTDiag_const<float>& trc); virtual~TMatrixTDiag_const<float>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNdiags() const; const float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTDiag_const<float>&operator=(const TMatrixTDiag_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<float>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols); const float*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTDiag_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTDiag_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_const_float_.html
https://root.cern/root/html532/TMatrixTDiag_double_.html:2326,Modifiability,Inherit,Inheritance,2326,"ass*IsA() const; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTDiag_const<double>& d); voidoperator+=(double val); voidoperator+=(const TMatrixTDiag_const<double>& d); voidoperator=(double val); voidoperator=(const TMatrixTDiag_const<double>& d); TMatrixTDiag<double>&operator=(const TMatrixTDiag<double>& d); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTDiag_const<double>::fIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<double>*TMatrixTDiag_const<double>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTDiag_const<double>::fNdiagnumber of diag elems, min(nrows,ncols); const double*TMatrixTDiag_const<double>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTDiag_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_double_.html
https://root.cern/root/html532/TMatrixTDiag_double_.html:2339,Modifiability,Inherit,Inherited,2339,"ass*IsA() const; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTDiag_const<double>& d); voidoperator+=(double val); voidoperator+=(const TMatrixTDiag_const<double>& d); voidoperator=(double val); voidoperator=(const TMatrixTDiag_const<double>& d); TMatrixTDiag<double>&operator=(const TMatrixTDiag<double>& d); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTDiag_const<double>::fIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<double>*TMatrixTDiag_const<double>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTDiag_const<double>::fNdiagnumber of diag elems, min(nrows,ncols); const double*TMatrixTDiag_const<double>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTDiag_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_double_.html
https://root.cern/root/html532/TMatrixTDiag_float_.html:2289,Modifiability,Inherit,Inheritance,2289," const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTDiag_const<float>& d); voidoperator+=(float val); voidoperator+=(const TMatrixTDiag_const<float>& d); voidoperator=(float val); voidoperator=(const TMatrixTDiag_const<float>& d); TMatrixTDiag<float>&operator=(const TMatrixTDiag<float>& d); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTDiag_const<float>::fIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<float>*TMatrixTDiag_const<float>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTDiag_const<float>::fNdiagnumber of diag elems, min(nrows,ncols); const float*TMatrixTDiag_const<float>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTDiag_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_float_.html
https://root.cern/root/html532/TMatrixTDiag_float_.html:2302,Modifiability,Inherit,Inherited,2302," const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTDiag_const<float>& d); voidoperator+=(float val); voidoperator+=(const TMatrixTDiag_const<float>& d); voidoperator=(float val); voidoperator=(const TMatrixTDiag_const<float>& d); TMatrixTDiag<float>&operator=(const TMatrixTDiag<float>& d); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTDiag_const<float>::fIncif ptr=@a[i,i], then ptr+inc = @a[i+1,i+1]; TMatrixTBase<float>*TMatrixTDiag_const<float>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTDiag_const<float>::fNdiagnumber of diag elems, min(nrows,ncols); const float*TMatrixTDiag_const<float>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTDiag_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTDiag_float_.html
https://root.cern/root/html532/TMatrixTFlat_const_double_.html:1725,Modifiability,Inherit,Inheritance,1725,"here:. Different matrix views without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTFlat_const<Double_t>, TMatrixDFlat_const. Function Members (Methods); public:. TMatrixTFlat_const<double>(); TMatrixTFlat_const<double>(const TMatrixT<double>& matrix); TMatrixTFlat_const<double>(const TMatrixTSym<double>& matrix); TMatrixTFlat_const<double>(const TMatrixTFlat_const<double>& trc); virtual~TMatrixTFlat_const<double>(); static TClass*Class(); const TMatrixTBase<double>*GetMatrix() const; const double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTFlat_const<double>&operator=(const TMatrixTFlat_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<double>*fMatrixthe matrix I am the diagonal of; Int_tfNelems; const double*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTFlat_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTFlat_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_const_double_.html
https://root.cern/root/html532/TMatrixTFlat_const_double_.html:1738,Modifiability,Inherit,Inherited,1738,"here:. Different matrix views without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTFlat_const<Double_t>, TMatrixDFlat_const. Function Members (Methods); public:. TMatrixTFlat_const<double>(); TMatrixTFlat_const<double>(const TMatrixT<double>& matrix); TMatrixTFlat_const<double>(const TMatrixTSym<double>& matrix); TMatrixTFlat_const<double>(const TMatrixTFlat_const<double>& trc); virtual~TMatrixTFlat_const<double>(); static TClass*Class(); const TMatrixTBase<double>*GetMatrix() const; const double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTFlat_const<double>&operator=(const TMatrixTFlat_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<double>*fMatrixthe matrix I am the diagonal of; Int_tfNelems; const double*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTFlat_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTFlat_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_const_double_.html
https://root.cern/root/html532/TMatrixTFlat_const_float_.html:1705,Modifiability,Inherit,Inheritance,1705,"asses are defined here:. Different matrix views without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixFFlat_const, TMatrixTFlat_const<Float_t>. Function Members (Methods); public:. TMatrixTFlat_const<float>(); TMatrixTFlat_const<float>(const TMatrixT<float>& matrix); TMatrixTFlat_const<float>(const TMatrixTSym<float>& matrix); TMatrixTFlat_const<float>(const TMatrixTFlat_const<float>& trc); virtual~TMatrixTFlat_const<float>(); static TClass*Class(); const TMatrixTBase<float>*GetMatrix() const; const float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTFlat_const<float>&operator=(const TMatrixTFlat_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<float>*fMatrixthe matrix I am the diagonal of; Int_tfNelems; const float*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTFlat_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTFlat_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_const_float_.html
https://root.cern/root/html532/TMatrixTFlat_const_float_.html:1718,Modifiability,Inherit,Inherited,1718,"asses are defined here:. Different matrix views without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixFFlat_const, TMatrixTFlat_const<Float_t>. Function Members (Methods); public:. TMatrixTFlat_const<float>(); TMatrixTFlat_const<float>(const TMatrixT<float>& matrix); TMatrixTFlat_const<float>(const TMatrixTSym<float>& matrix); TMatrixTFlat_const<float>(const TMatrixTFlat_const<float>& trc); virtual~TMatrixTFlat_const<float>(); static TClass*Class(); const TMatrixTBase<float>*GetMatrix() const; const float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTFlat_const<float>&operator=(const TMatrixTFlat_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<float>*fMatrixthe matrix I am the diagonal of; Int_tfNelems; const float*fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTFlat_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTFlat_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_const_float_.html
https://root.cern/root/html532/TMatrixTFlat_double_.html:2107,Modifiability,Inherit,Inheritance,2107,"*Class(); const TMatrixTBase<double>*TMatrixTFlat_const<double>::GetMatrix() const; double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTFlat_const<double>& f); voidoperator+=(double val); voidoperator+=(const TMatrixTFlat_const<double>& f); voidoperator=(double val); voidoperator=(const TMatrixTFlat_const<double>& f); TMatrixTFlat<double>&operator=(const TMatrixTFlat<double>& f); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<double>*TMatrixTFlat_const<double>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTFlat_const<double>::fNelems; const double*TMatrixTFlat_const<double>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTFlat_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_double_.html
https://root.cern/root/html532/TMatrixTFlat_double_.html:2120,Modifiability,Inherit,Inherited,2120,"*Class(); const TMatrixTBase<double>*TMatrixTFlat_const<double>::GetMatrix() const; double*GetPtr() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTFlat_const<double>& f); voidoperator+=(double val); voidoperator+=(const TMatrixTFlat_const<double>& f); voidoperator=(double val); voidoperator=(const TMatrixTFlat_const<double>& f); TMatrixTFlat<double>&operator=(const TMatrixTFlat<double>& f); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<double>*TMatrixTFlat_const<double>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTFlat_const<double>::fNelems; const double*TMatrixTFlat_const<double>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTFlat_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_double_.html
https://root.cern/root/html532/TMatrixTFlat_float_.html:2073,Modifiability,Inherit,Inheritance,2073,"oat>(); static TClass*Class(); const TMatrixTBase<float>*TMatrixTFlat_const<float>::GetMatrix() const; float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTFlat_const<float>& f); voidoperator+=(float val); voidoperator+=(const TMatrixTFlat_const<float>& f); voidoperator=(float val); voidoperator=(const TMatrixTFlat_const<float>& f); TMatrixTFlat<float>&operator=(const TMatrixTFlat<float>& f); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<float>*TMatrixTFlat_const<float>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTFlat_const<float>::fNelems; const float*TMatrixTFlat_const<float>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTFlat_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_float_.html
https://root.cern/root/html532/TMatrixTFlat_float_.html:2086,Modifiability,Inherit,Inherited,2086,"oat>(); static TClass*Class(); const TMatrixTBase<float>*TMatrixTFlat_const<float>::GetMatrix() const; float*GetPtr() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTFlat_const<float>& f); voidoperator+=(float val); voidoperator+=(const TMatrixTFlat_const<float>& f); voidoperator=(float val); voidoperator=(const TMatrixTFlat_const<float>& f); TMatrixTFlat<float>&operator=(const TMatrixTFlat<float>& f); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TMatrixTBase<float>*TMatrixTFlat_const<float>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTFlat_const<float>::fNelems; const float*TMatrixTFlat_const<float>::fPtrpointer to the a[0,0]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTFlat_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTFlat_float_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:663,Availability,avail,available,663,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Double_t>, TMatrixDLazy. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:1512,Availability,Error,Error,1512," virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:1641,Availability,error,error,1641," virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:1725,Availability,error,error,1725," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:2701,Modifiability,Inherit,InheritsFrom,2701,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:2767,Modifiability,Inherit,InheritsFrom,2767,"t_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pa",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:5625,Modifiability,Inherit,Inheritance,5625,"set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTLazy<double>&). private:. virtual voidFillIn(TMatrixT<double>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwb; Int_tfColUpb; Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTLazy<double>& ); { }. void FillIn(TMatrixT<double>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fColUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:5638,Modifiability,Inherit,Inherited,5638,"set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTLazy<double>&). private:. virtual voidFillIn(TMatrixT<double>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwb; Int_tfColUpb; Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTLazy<double>& ); { }. void FillIn(TMatrixT<double>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fColUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:2591,Security,Hash,Hash,2591,"(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:4666,Testability,Test,TestBit,4666,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:4705,Testability,Test,TestBits,4705,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_double_.html:972,Usability,Clear,Clear,972," virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html532/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_double_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:659,Availability,avail,available,659,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Float_t>, TMatrixFLazy. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:1507,Availability,Error,Error,1507," virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:1636,Availability,error,error,1636," virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:1720,Availability,error,error,1720," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:2696,Modifiability,Inherit,InheritsFrom,2696,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:2762,Modifiability,Inherit,InheritsFrom,2762,"t_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pa",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:5618,Modifiability,Inherit,Inheritance,5618,"l_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTLazy<float>&). private:. virtual voidFillIn(TMatrixT<float>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwb; Int_tfColUpb; Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTLazy<float>& ); { }. void FillIn(TMatrixT<float>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fColUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:5631,Modifiability,Inherit,Inherited,5631,"l_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTLazy<float>&). private:. virtual voidFillIn(TMatrixT<float>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwb; Int_tfColUpb; Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTLazy<float>& ); { }. void FillIn(TMatrixT<float>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fColUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:2586,Security,Hash,Hash,2586,"(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:4661,Testability,Test,TestBit,4661,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:4700,Testability,Test,TestBits,4700,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTLazy_float_.html:967,Usability,Clear,Clear,967," virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html532/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTLazy_float_.html
https://root.cern/root/html532/TMatrixTRow_const_double_.html:1852,Modifiability,Inherit,Inheritance,1852,"atrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixDRow_const, TMatrixTRow_const<Double_t>. Function Members (Methods); public:. TMatrixTRow_const<double>(); TMatrixTRow_const<double>(const TMatrixTRow_const<double>& trc); TMatrixTRow_const<double>(const TMatrixT<double>& matrix, Int_t row); TMatrixTRow_const<double>(const TMatrixTSym<double>& matrix, Int_t row); virtual~TMatrixTRow_const<double>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<double>*GetMatrix() const; const double*GetPtr() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTRow_const<double>&operator=(const TMatrixTRow_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<double>*fMatrixthe matrix I am a row of; const double*fPtrpointer to the a[row,0]; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTRow_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTRow_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_const_double_.html
https://root.cern/root/html532/TMatrixTRow_const_double_.html:1865,Modifiability,Inherit,Inherited,1865,"atrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixDRow_const, TMatrixTRow_const<Double_t>. Function Members (Methods); public:. TMatrixTRow_const<double>(); TMatrixTRow_const<double>(const TMatrixTRow_const<double>& trc); TMatrixTRow_const<double>(const TMatrixT<double>& matrix, Int_t row); TMatrixTRow_const<double>(const TMatrixTSym<double>& matrix, Int_t row); virtual~TMatrixTRow_const<double>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<double>*GetMatrix() const; const double*GetPtr() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; TMatrixTRow_const<double>&operator=(const TMatrixTRow_const<double>& trc); const double&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<double>*fMatrixthe matrix I am a row of; const double*fPtrpointer to the a[row,0]; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTRow_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTRow_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_const_double_.html
https://root.cern/root/html532/TMatrixTRow_const_float_.html:1832,Modifiability,Inherit,Inheritance,1832,"atrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTRow_const<Float_t>, TMatrixFRow_const. Function Members (Methods); public:. TMatrixTRow_const<float>(); TMatrixTRow_const<float>(const TMatrixTRow_const<float>& trc); TMatrixTRow_const<float>(const TMatrixT<float>& matrix, Int_t row); TMatrixTRow_const<float>(const TMatrixTSym<float>& matrix, Int_t row); virtual~TMatrixTRow_const<float>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<float>*GetMatrix() const; const float*GetPtr() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTRow_const<float>&operator=(const TMatrixTRow_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<float>*fMatrixthe matrix I am a row of; const float*fPtrpointer to the a[row,0]; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTRow_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTRow_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_const_float_.html
https://root.cern/root/html532/TMatrixTRow_const_float_.html:1845,Modifiability,Inherit,Inherited,1845,"atrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTRow_const<Float_t>, TMatrixFRow_const. Function Members (Methods); public:. TMatrixTRow_const<float>(); TMatrixTRow_const<float>(const TMatrixTRow_const<float>& trc); TMatrixTRow_const<float>(const TMatrixT<float>& matrix, Int_t row); TMatrixTRow_const<float>(const TMatrixTSym<float>& matrix, Int_t row); virtual~TMatrixTRow_const<float>(); static TClass*Class(); Int_tGetInc() const; const TMatrixTBase<float>*GetMatrix() const; const float*GetPtr() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; TMatrixTRow_const<float>&operator=(const TMatrixTRow_const<float>& trc); const float&operator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<float>*fMatrixthe matrix I am a row of; const float*fPtrpointer to the a[row,0]; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTRow_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. Int_t GetInc() const; { return fInc; }. const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTRow_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_const_float_.html
https://root.cern/root/html532/TMatrixTRow_double_.html:2307,Modifiability,Inherit,Inheritance,2307,"owIndex() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTRow_const<double>& r); voidoperator+=(double val); voidoperator+=(const TMatrixTRow_const<double>& r); voidoperator=(double val); voidoperator=(const TMatrixTRow_const<double>& r); TMatrixTRow<double>&operator=(const TMatrixTRow<double>& r); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTRow_const<double>::fIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<double>*TMatrixTRow_const<double>::fMatrixthe matrix I am a row of; const double*TMatrixTRow_const<double>::fPtrpointer to the a[row,0]; Int_tTMatrixTRow_const<double>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTRow_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_double_.html
https://root.cern/root/html532/TMatrixTRow_double_.html:2320,Modifiability,Inherit,Inherited,2320,"owIndex() const; virtual TClass*IsA() const; const double&operator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTRow_const<double>& r); voidoperator+=(double val); voidoperator+=(const TMatrixTRow_const<double>& r); voidoperator=(double val); voidoperator=(const TMatrixTRow_const<double>& r); TMatrixTRow<double>&operator=(const TMatrixTRow<double>& r); voidoperator=(const TVectorT<double>& vec); const double&operator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTRow_const<double>::fIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<double>*TMatrixTRow_const<double>::fMatrixthe matrix I am a row of; const double*TMatrixTRow_const<double>::fPtrpointer to the a[row,0]; Int_tTMatrixTRow_const<double>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTRow_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_double_.html
https://root.cern/root/html532/TMatrixTRow_float_.html:2270,Modifiability,Inherit,Inheritance,2270,"_const<float>::GetRowIndex() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTRow_const<float>& r); voidoperator+=(float val); voidoperator+=(const TMatrixTRow_const<float>& r); voidoperator=(float val); voidoperator=(const TMatrixTRow_const<float>& r); TMatrixTRow<float>&operator=(const TMatrixTRow<float>& r); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTRow_const<float>::fIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<float>*TMatrixTRow_const<float>::fMatrixthe matrix I am a row of; const float*TMatrixTRow_const<float>::fPtrpointer to the a[row,0]; Int_tTMatrixTRow_const<float>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTRow_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_float_.html
https://root.cern/root/html532/TMatrixTRow_float_.html:2283,Modifiability,Inherit,Inherited,2283,"_const<float>::GetRowIndex() const; virtual TClass*IsA() const; const float&operator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTRow_const<float>& r); voidoperator+=(float val); voidoperator+=(const TMatrixTRow_const<float>& r); voidoperator=(float val); voidoperator=(const TMatrixTRow_const<float>& r); TMatrixTRow<float>&operator=(const TMatrixTRow<float>& r); voidoperator=(const TVectorT<float>& vec); const float&operator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tTMatrixTRow_const<float>::fIncif ptr = @a[row,i], then ptr+inc = @a[row,i+1]; TMatrixTBase<float>*TMatrixTRow_const<float>::fMatrixthe matrix I am a row of; const float*TMatrixTRow_const<float>::fPtrpointer to the a[row,0]; Int_tTMatrixTRow_const<float>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element * GetPtr() const; { return fPtr; }. const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html532/TMatrixTRow_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTRow_float_.html
https://root.cern/root/html532/TMatrixTSparseDiag_const_double_.html:1786,Modifiability,Inherit,Inheritance,1786,"Column_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSparseDiag_const<Double_t>, TMatrixDSparseDiag_const. Function Members (Methods); public:. TMatrixTSparseDiag_const<double>(); TMatrixTSparseDiag_const<double>(const TMatrixTSparse<double>& matrix); TMatrixTSparseDiag_const<double>(const TMatrixTSparseDiag_const<double>& trc); virtual~TMatrixTSparseDiag_const<double>(); static TClass*Class(); const double*GetDataPtr() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNdiags() const; virtual TClass*IsA() const; doubleoperator()(Int_t i) const; TMatrixTSparseDiag_const<double>&operator=(const TMatrixTSparseDiag_const<double>& trc); doubleoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const double*fDataPtrdata pointer; TMatrixTBase<double>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseDiag_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }. const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_const_double_.html
https://root.cern/root/html532/TMatrixTSparseDiag_const_double_.html:1799,Modifiability,Inherit,Inherited,1799,"Column_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSparseDiag_const<Double_t>, TMatrixDSparseDiag_const. Function Members (Methods); public:. TMatrixTSparseDiag_const<double>(); TMatrixTSparseDiag_const<double>(const TMatrixTSparse<double>& matrix); TMatrixTSparseDiag_const<double>(const TMatrixTSparseDiag_const<double>& trc); virtual~TMatrixTSparseDiag_const<double>(); static TClass*Class(); const double*GetDataPtr() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNdiags() const; virtual TClass*IsA() const; doubleoperator()(Int_t i) const; TMatrixTSparseDiag_const<double>&operator=(const TMatrixTSparseDiag_const<double>& trc); doubleoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const double*fDataPtrdata pointer; TMatrixTBase<double>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseDiag_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }. const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_const_double_.html
https://root.cern/root/html532/TMatrixTSparseDiag_const_float_.html:1768,Modifiability,Inherit,Inheritance,1768,"ixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSparseDiag_const<Float_t>, TMatrixFSparseDiag_const. Function Members (Methods); public:. TMatrixTSparseDiag_const<float>(); TMatrixTSparseDiag_const<float>(const TMatrixTSparse<float>& matrix); TMatrixTSparseDiag_const<float>(const TMatrixTSparseDiag_const<float>& trc); virtual~TMatrixTSparseDiag_const<float>(); static TClass*Class(); const float*GetDataPtr() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNdiags() const; virtual TClass*IsA() const; floatoperator()(Int_t i) const; TMatrixTSparseDiag_const<float>&operator=(const TMatrixTSparseDiag_const<float>& trc); floatoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const float*fDataPtrdata pointer; TMatrixTBase<float>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseDiag_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }. const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_const_float_.html
https://root.cern/root/html532/TMatrixTSparseDiag_const_float_.html:1781,Modifiability,Inherit,Inherited,1781,"ixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSparseDiag_const<Float_t>, TMatrixFSparseDiag_const. Function Members (Methods); public:. TMatrixTSparseDiag_const<float>(); TMatrixTSparseDiag_const<float>(const TMatrixTSparse<float>& matrix); TMatrixTSparseDiag_const<float>(const TMatrixTSparseDiag_const<float>& trc); virtual~TMatrixTSparseDiag_const<float>(); static TClass*Class(); const float*GetDataPtr() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNdiags() const; virtual TClass*IsA() const; floatoperator()(Int_t i) const; TMatrixTSparseDiag_const<float>&operator=(const TMatrixTSparseDiag_const<float>& trc); floatoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const float*fDataPtrdata pointer; TMatrixTBase<float>*fMatrixthe matrix I am the diagonal of; Int_tfNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseDiag_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Int_t GetNdiags() const; { return fNdiag; }. const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_const_float_.html
https://root.cern/root/html532/TMatrixTSparseDiag_double_.html:2262,Modifiability,Inherit,Inheritance,2262,"seDiag_const<double>::GetNdiags() const; virtual TClass*IsA() const; doubleoperator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTSparseDiag_const<double>& d); voidoperator+=(double val); voidoperator+=(const TMatrixTSparseDiag_const<double>& d); voidoperator=(double val); voidoperator=(const TMatrixTSparseDiag_const<double>& d); TMatrixTSparseDiag<double>&operator=(const TMatrixTSparseDiag<double>& d); voidoperator=(const TVectorT<double>& vec); doubleoperator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const double*TMatrixTSparseDiag_const<double>::fDataPtrdata pointer; TMatrixTBase<double>*TMatrixTSparseDiag_const<double>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTSparseDiag_const<double>::fNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_double_.html
https://root.cern/root/html532/TMatrixTSparseDiag_double_.html:2275,Modifiability,Inherit,Inherited,2275,"seDiag_const<double>::GetNdiags() const; virtual TClass*IsA() const; doubleoperator()(Int_t i) const; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTSparseDiag_const<double>& d); voidoperator+=(double val); voidoperator+=(const TMatrixTSparseDiag_const<double>& d); voidoperator=(double val); voidoperator=(const TMatrixTSparseDiag_const<double>& d); TMatrixTSparseDiag<double>&operator=(const TMatrixTSparseDiag<double>& d); voidoperator=(const TVectorT<double>& vec); doubleoperator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const double*TMatrixTSparseDiag_const<double>::fDataPtrdata pointer; TMatrixTBase<double>*TMatrixTSparseDiag_const<double>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTSparseDiag_const<double>::fNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_double_.html
https://root.cern/root/html532/TMatrixTSparseDiag_float_.html:2229,Modifiability,Inherit,Inheritance,2229,"; Int_tTMatrixTSparseDiag_const<float>::GetNdiags() const; virtual TClass*IsA() const; floatoperator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTSparseDiag_const<float>& d); voidoperator+=(float val); voidoperator+=(const TMatrixTSparseDiag_const<float>& d); voidoperator=(float val); voidoperator=(const TMatrixTSparseDiag_const<float>& d); TMatrixTSparseDiag<float>&operator=(const TMatrixTSparseDiag<float>& d); voidoperator=(const TVectorT<float>& vec); floatoperator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const float*TMatrixTSparseDiag_const<float>::fDataPtrdata pointer; TMatrixTBase<float>*TMatrixTSparseDiag_const<float>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTSparseDiag_const<float>::fNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_float_.html
https://root.cern/root/html532/TMatrixTSparseDiag_float_.html:2242,Modifiability,Inherit,Inherited,2242,"; Int_tTMatrixTSparseDiag_const<float>::GetNdiags() const; virtual TClass*IsA() const; floatoperator()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTSparseDiag_const<float>& d); voidoperator+=(float val); voidoperator+=(const TMatrixTSparseDiag_const<float>& d); voidoperator=(float val); voidoperator=(const TMatrixTSparseDiag_const<float>& d); TMatrixTSparseDiag<float>&operator=(const TMatrixTSparseDiag<float>& d); voidoperator=(const TVectorT<float>& vec); floatoperator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const float*TMatrixTSparseDiag_const<float>::fDataPtrdata pointer; TMatrixTBase<float>*TMatrixTSparseDiag_const<float>::fMatrixthe matrix I am the diagonal of; Int_tTMatrixTSparseDiag_const<float>::fNdiagnumber of diag elems, min(nrows,ncols). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html532/TMatrixTSparseDiag_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseDiag_float_.html
https://root.cern/root/html532/TMatrixTSparseRow_const_double_.html:1883,Modifiability,Inherit,Inheritance,1883,"SparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSparseRow_const<Double_t>, TMatrixDSparseRow_const. Function Members (Methods); public:. TMatrixTSparseRow_const<double>(); TMatrixTSparseRow_const<double>(const TMatrixTSparseRow_const<double>& trc); TMatrixTSparseRow_const<double>(const TMatrixTSparse<double>& matrix, Int_t row); virtual~TMatrixTSparseRow_const<double>(); static TClass*Class(); const Int_t*GetColPtr() const; const double*GetDataPtr() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNindex() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; doubleoperator()(Int_t i) const; TMatrixTSparseRow_const<double>&operator=(const TMatrixTSparseRow_const<double>& trc); doubleoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*fColPtrcolumn index pointer; const double*fDataPtrdata pointer; TMatrixTBase<double>*fMatrixthe matrix I am a row of; Int_tfNindexindex range; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseRow_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. const Element * GetDataPtr() const; { return fDataPtr; }. const Int_t * GetColPtr() const; { return fColPtr; }. Int_t GetNindex() const; { return fNindex; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseRow_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_const_double_.html
https://root.cern/root/html532/TMatrixTSparseRow_const_double_.html:1896,Modifiability,Inherit,Inherited,1896,"SparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSparseRow_const<Double_t>, TMatrixDSparseRow_const. Function Members (Methods); public:. TMatrixTSparseRow_const<double>(); TMatrixTSparseRow_const<double>(const TMatrixTSparseRow_const<double>& trc); TMatrixTSparseRow_const<double>(const TMatrixTSparse<double>& matrix, Int_t row); virtual~TMatrixTSparseRow_const<double>(); static TClass*Class(); const Int_t*GetColPtr() const; const double*GetDataPtr() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNindex() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; doubleoperator()(Int_t i) const; TMatrixTSparseRow_const<double>&operator=(const TMatrixTSparseRow_const<double>& trc); doubleoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*fColPtrcolumn index pointer; const double*fDataPtrdata pointer; TMatrixTBase<double>*fMatrixthe matrix I am a row of; Int_tfNindexindex range; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseRow_const<double>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. const Element * GetDataPtr() const; { return fDataPtr; }. const Int_t * GetColPtr() const; { return fColPtr; }. Int_t GetNindex() const; { return fNindex; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseRow_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_const_double_.html
https://root.cern/root/html532/TMatrixTSparseRow_const_float_.html:1865,Modifiability,Inherit,Inheritance,1865,"g_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixFSparseRow_const, TMatrixTSparseRow_const<Float_t>. Function Members (Methods); public:. TMatrixTSparseRow_const<float>(); TMatrixTSparseRow_const<float>(const TMatrixTSparseRow_const<float>& trc); TMatrixTSparseRow_const<float>(const TMatrixTSparse<float>& matrix, Int_t row); virtual~TMatrixTSparseRow_const<float>(); static TClass*Class(); const Int_t*GetColPtr() const; const float*GetDataPtr() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNindex() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; floatoperator()(Int_t i) const; TMatrixTSparseRow_const<float>&operator=(const TMatrixTSparseRow_const<float>& trc); floatoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*fColPtrcolumn index pointer; const float*fDataPtrdata pointer; TMatrixTBase<float>*fMatrixthe matrix I am a row of; Int_tfNindexindex range; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseRow_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. const Element * GetDataPtr() const; { return fDataPtr; }. const Int_t * GetColPtr() const; { return fColPtr; }. Int_t GetNindex() const; { return fNindex; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseRow_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_const_float_.html
https://root.cern/root/html532/TMatrixTSparseRow_const_float_.html:1878,Modifiability,Inherit,Inherited,1878,"g_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixFSparseRow_const, TMatrixTSparseRow_const<Float_t>. Function Members (Methods); public:. TMatrixTSparseRow_const<float>(); TMatrixTSparseRow_const<float>(const TMatrixTSparseRow_const<float>& trc); TMatrixTSparseRow_const<float>(const TMatrixTSparse<float>& matrix, Int_t row); virtual~TMatrixTSparseRow_const<float>(); static TClass*Class(); const Int_t*GetColPtr() const; const float*GetDataPtr() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNindex() const; Int_tGetRowIndex() const; virtual TClass*IsA() const; floatoperator()(Int_t i) const; TMatrixTSparseRow_const<float>&operator=(const TMatrixTSparseRow_const<float>& trc); floatoperator[](Int_t i) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*fColPtrcolumn index pointer; const float*fDataPtrdata pointer; TMatrixTBase<float>*fMatrixthe matrix I am a row of; Int_tfNindexindex range; Int_tfRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TMatrixTSparseRow_const<float>& trc); {return *this;}. const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. Int_t GetRowIndex() const; { return fRowInd; }. const Element & operator()(Int_t i) const. const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. const Element * GetDataPtr() const; { return fDataPtr; }. const Int_t * GetColPtr() const; { return fColPtr; }. Int_t GetNindex() const; { return fNindex; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSparseRow_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_const_float_.html
https://root.cern/root/html532/TMatrixTSparseRow_double_.html:2482,Modifiability,Inherit,Inheritance,2482,t; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTSparseRow_const<double>& r); voidoperator+=(double val); voidoperator+=(const TMatrixTSparseRow_const<double>& r); voidoperator=(double val); voidoperator=(const TMatrixTSparseRow_const<double>& r); TMatrixTSparseRow<double>&operator=(const TMatrixTSparseRow<double>& r); voidoperator=(const TVectorT<double>& vec); doubleoperator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*TMatrixTSparseRow_const<double>::fColPtrcolumn index pointer; const double*TMatrixTSparseRow_const<double>::fDataPtrdata pointer; TMatrixTBase<double>*TMatrixTSparseRow_const<double>::fMatrixthe matrix I am a row of; Int_tTMatrixTSparseRow_const<double>::fNindexindex range; Int_tTMatrixTSparseRow_const<double>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r,MatchSource.WIKI,root/html532/TMatrixTSparseRow_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_double_.html
https://root.cern/root/html532/TMatrixTSparseRow_double_.html:2495,Modifiability,Inherit,Inherited,2495,t; double&operator()(Int_t i); voidoperator*=(double val); voidoperator*=(const TMatrixTSparseRow_const<double>& r); voidoperator+=(double val); voidoperator+=(const TMatrixTSparseRow_const<double>& r); voidoperator=(double val); voidoperator=(const TMatrixTSparseRow_const<double>& r); TMatrixTSparseRow<double>&operator=(const TMatrixTSparseRow<double>& r); voidoperator=(const TVectorT<double>& vec); doubleoperator[](Int_t i) const; double&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*TMatrixTSparseRow_const<double>::fColPtrcolumn index pointer; const double*TMatrixTSparseRow_const<double>::fDataPtrdata pointer; TMatrixTBase<double>*TMatrixTSparseRow_const<double>::fMatrixthe matrix I am a row of; Int_tTMatrixTSparseRow_const<double>::fNindexindex range; Int_tTMatrixTSparseRow_const<double>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r,MatchSource.WIKI,root/html532/TMatrixTSparseRow_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_double_.html
https://root.cern/root/html532/TMatrixTSparseRow_float_.html:2445,Modifiability,Inherit,Inheritance,2445,tor()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTSparseRow_const<float>& r); voidoperator+=(float val); voidoperator+=(const TMatrixTSparseRow_const<float>& r); voidoperator=(float val); voidoperator=(const TMatrixTSparseRow_const<float>& r); TMatrixTSparseRow<float>&operator=(const TMatrixTSparseRow<float>& r); voidoperator=(const TVectorT<float>& vec); floatoperator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*TMatrixTSparseRow_const<float>::fColPtrcolumn index pointer; const float*TMatrixTSparseRow_const<float>::fDataPtrdata pointer; TMatrixTBase<float>*TMatrixTSparseRow_const<float>::fMatrixthe matrix I am a row of; Int_tTMatrixTSparseRow_const<float>::fNindexindex range; Int_tTMatrixTSparseRow_const<float>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r,MatchSource.WIKI,root/html532/TMatrixTSparseRow_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_float_.html
https://root.cern/root/html532/TMatrixTSparseRow_float_.html:2458,Modifiability,Inherit,Inherited,2458,tor()(Int_t i) const; float&operator()(Int_t i); voidoperator*=(float val); voidoperator*=(const TMatrixTSparseRow_const<float>& r); voidoperator+=(float val); voidoperator+=(const TMatrixTSparseRow_const<float>& r); voidoperator=(float val); voidoperator=(const TMatrixTSparseRow_const<float>& r); TMatrixTSparseRow<float>&operator=(const TMatrixTSparseRow<float>& r); voidoperator=(const TVectorT<float>& vec); floatoperator[](Int_t i) const; float&operator[](Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const Int_t*TMatrixTSparseRow_const<float>::fColPtrcolumn index pointer; const float*TMatrixTSparseRow_const<float>::fDataPtrdata pointer; TMatrixTBase<float>*TMatrixTSparseRow_const<float>::fMatrixthe matrix I am a row of; Int_tTMatrixTSparseRow_const<float>::fNindexindex range; Int_tTMatrixTSparseRow_const<float>::fRowIndeffective row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i) const. Element & operator()(Int_t i). const Element & operator[](Int_t i) const; { return (*(const TMatrixTRow<Element> *)this)(i); }. Element & operator[](Int_t i); { return (*( TMatrixTRow<Element> *)this)(i); }. void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). const Element * GetDataPtr() const; { return fDataPtr; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions r,MatchSource.WIKI,root/html532/TMatrixTSparseRow_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparseRow_float_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:5120,Availability,Error,Error,5120,"TMatrixTBase<double>&TMatrixTBase<double>::Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*Get",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:5249,Availability,error,error,5249," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:5333,Availability,error,error,5333,"oidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:17068,Energy Efficiency,Allocate,Allocate,17068,"Menu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<double>::fColLwblower bound of the col index; double*fElements[fNelems]; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Cre",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:17181,Energy Efficiency,Allocate,Allocate,17181,"Menu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<double>::fColLwblower bound of the col index; double*fElements[fNelems]; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Cre",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:17938,Energy Efficiency,allocate,allocated,17938,"lon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:18164,Energy Efficiency,allocate,allocated,18164,"_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:18390,Energy Efficiency,allocate,allocated,18390,"). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:18614,Energy Efficiency,allocate,allocated,18614,"nt_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy m",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:18832,Energy Efficiency,allocate,allocated,18832,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:19060,Energy Efficiency,allocate,allocated,19060,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:19282,Energy Efficiency,allocate,allocated,19282,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source t",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:19504,Energy Efficiency,allocate,allocated,19504,"lement> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b;",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:20548,Energy Efficiency,allocate,allocated,20548,"ubtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:20789,Energy Efficiency,allocate,allocated,20789,"Nelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:2198,Integrability,rout,routine,2198,"+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixTSparse<Double_t>, TMatrixDSparse. Function Members (Methods); public:. TMatrixTSparse<double>(); TMatrixTSparse<double>(const TMatrixTSparse<double>& another); TMatrixTSparse<double>(const TMatrixT<double>& another); TMatrixTSparse<double>(Int_t nrows, Int_t ncols); TMatrixTSparse<double>(TMatrixTSparse<double>::EMatrixCreatorsOp1 op, const TMatrixTSparse<double>& prototype); TM",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:22002,Integrability,depend,depends,22002,"zeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<double>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:2320,Modifiability,flexible,flexible,2320,"e matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixTSparse<Double_t>, TMatrixDSparse. Function Members (Methods); public:. TMatrixTSparse<double>(); TMatrixTSparse<double>(const TMatrixTSparse<double>& another); TMatrixTSparse<double>(const TMatrixT<double>& another); TMatrixTSparse<double>(Int_t nrows, Int_t ncols); TMatrixTSparse<double>(TMatrixTSparse<double>::EMatrixCreatorsOp1 op, const TMatrixTSparse<double>& prototype); TMatrixTSparse<double>(const TMatrixTSparse<double>& a, TMatrixTSparse<double>::EMatrixCreatorsOp2 op, const TMatrixTSparse<double>& b); TMatrixTSparse<double>(const TMatrixTSparse<double>& a, TMatrixTSparse<double>::EMatrixCreatorsOp2 op, const TMatrixT<do",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:7238,Modifiability,Inherit,InheritsFrom,7238,"e<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixTSparse<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual doubleTMatrixTBase<double>::Min() const; voidMult(const TMatrixTSparse<double>& a, const TMatrixTSparse<double>& b); virtual Int_tNo",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:7304,Modifiability,Inherit,InheritsFrom,7304,"ows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixTSparse<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual doubleTMatrixTBase<double>::Min() const; voidMult(const TMatrixTSparse<double>& a, const TMatrixTSparse<double>& b); virtual Int_tNonZeros() const; doubleTMatrixTBase<double>::Norm1() const; virtual",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:16962,Modifiability,Inherit,Inheritance,16962,"};; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<double>::fColLwblower bound of the col index; double*fElements[fNelems]; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Elemen",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:16975,Modifiability,Inherit,Inherited,16975,"};; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<double>::fColLwblower bound of the col index; double*fElements[fNelems]; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Elemen",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:1566,Performance,perform,performance,1566,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is sm",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:840,Security,access,access,840,". TMatrixTSparse<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSparse<double>. class TMatrixTSparse<double>: public TMatrixTBase<double>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); wher",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:7128,Security,Hash,Hash,7128,"rray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixTSparse<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual doubleTMatrixTBase",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:12863,Testability,Test,TestBit,12863,"Sparse<double>&SetSparseIndexAB(const TMatrixTSparse<double>& a, const TMatrixTSparse<double>& b); TMatrixTSparse<double>&SetSparseIndexAB(const TMatrixT<double>& a, const TMatrixTSparse<double>& b); TMatrixTSparse<double>&SetSparseIndexAB(const TMatrixTSparse<double>& a, const TMatrixT<double>& b); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleTMatrixTBase<double>::SetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&TMatrixTBase<double>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqr(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleTMatrixTBase<double>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSparse<double>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMatrixTSparse<double>&Transpose(const TMatrixTSparse<double>& source); virtual TMatrixTBase<double>&UnitMatrix(); TMatrixTSparse<double>&Use(TMatrixTSparse<double>& a); const TMatrixTSparse<double>&Use(const TMatrixTSparse<double>& a) const; TMatrixTSparse<double>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData); const TMatrixTSparse<double>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const double* pData) const; TMatrixTSparse<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData); const TMatrixTSparse<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const double* pData) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(con",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:12902,Testability,Test,TestBits,12902,"MatrixTSparse<double>& a, const TMatrixTSparse<double>& b); TMatrixTSparse<double>&SetSparseIndexAB(const TMatrixT<double>& a, const TMatrixTSparse<double>& b); TMatrixTSparse<double>&SetSparseIndexAB(const TMatrixTSparse<double>& a, const TMatrixT<double>& b); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleTMatrixTBase<double>::SetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&TMatrixTBase<double>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqr(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleTMatrixTBase<double>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSparse<double>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMatrixTSparse<double>&Transpose(const TMatrixTSparse<double>& source); virtual TMatrixTBase<double>&UnitMatrix(); TMatrixTSparse<double>&Use(TMatrixTSparse<double>& a); const TMatrixTSparse<double>&Use(const TMatrixTSparse<double>& a) const; TMatrixTSparse<double>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData); const TMatrixTSparse<double>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const double* pData) const; TMatrixTSparse<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData); const TMatrixTSparse<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const double* pData) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_double_.html:26955,Usability,Clear,Clear,26955,"ultB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0); Elementary constructors. void AMultB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr=0). void AMultB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). void APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data); { memmove(fRowIndex,data,(this->fNrows+1)*sizeof(Int_t)); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* data); { memmove(fColIndex,data,this->fNelems*sizeof(Int_t)); return *this; }. TMatrixTSparse<Element> & SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b). TMatrixTBase<Element> & SetMatrixArray(const double* data, Option_t* = """"); { memcpy(fElements,data,this->fNelems*sizeof(Element)); return *this; }. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). void Clear(Option_t* = """"). TMatrixTSparse<Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData). Bool_t IsSymmetric() const; { return (*this == TMatrixTSparse<Element>(kTransposed,*this)); }. void Mult(const TMatrixTSparse<double>& a, const TMatrixTSparse<double>& b); { AMultB(a,b,0); }. Int_t NonZeros() const; { return this->fNelems; }. TMatrixTBase<Element> & NormByDiag(const TVectorT<double>& , Option_t* ); { MayNotUse(""NormByDiag""); return *this; }. const TMatrixTSparseRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTSparseRow_const<Element>(*this,rown); }. TMatrixTSparseRow <Element> operator[](Int_t rown); { return TMatrixTSparseRow <Element>(*this,rown); }. TMatrixTSparse<Element> & operator-=(Element val). TMatrixTSparse<Element> & operator+=(Element val). TMatrixTSparse<Element> & operator*=(Element val). TMatrixTSparse<Element> & operator+=(const TMatrixTSparse<Eleme",MatchSource.WIKI,root/html532/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:5076,Availability,Error,Error,5076," virtual TMatrixTBase<float>&TMatrixTBase<float>::Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrix",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:5205,Availability,error,error,5205,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNo",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:5289,Availability,error,error,5289,"tual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:16853,Energy Efficiency,Allocate,Allocate,16853,"kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<float>::fColLwblower bound of the col index; float*fElements[fNelems]; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Creat",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:16966,Energy Efficiency,Allocate,Allocate,16966,"kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<float>::fColLwblower bound of the col index; float*fElements[fNelems]; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Creat",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:17721,Energy Efficiency,allocate,allocated,17721,"silon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:17947,Energy Efficiency,allocate,allocated,17947,"nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:18173,Energy Efficiency,allocate,allocated,18173,"at). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:18397,Energy Efficiency,allocate,allocated,18397,"Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy ma",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:18615,Energy Efficiency,allocate,allocated,18615,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/co",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:18843,Energy Efficiency,allocate,allocated,18843,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(I",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:19065,Energy Efficiency,allocate,allocated,19065,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to s",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:19287,Energy Efficiency,allocate,allocated,19287,"lement> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:20328,Energy Efficiency,allocate,allocated,20328,"x subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:20569,Energy Efficiency,allocate,allocated,20569," fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:2194,Integrability,rout,routine,2194,"+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixFSparse, TMatrixTSparse<Float_t>. Function Members (Methods); public:. TMatrixTSparse<float>(); TMatrixTSparse<float>(const TMatrixTSparse<float>& another); TMatrixTSparse<float>(const TMatrixT<float>& another); TMatrixTSparse<float>(Int_t nrows, Int_t ncols); TMatrixTSparse<float>(TMatrixTSparse<float>::EMatrixCreatorsOp1 op, const TMatrixTSparse<float>& prototype); TMatrixTSpar",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:21780,Integrability,depend,depends,21780,"onzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<float>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The n",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:2316,Modifiability,flexible,flexible,2316,"e matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixFSparse, TMatrixTSparse<Float_t>. Function Members (Methods); public:. TMatrixTSparse<float>(); TMatrixTSparse<float>(const TMatrixTSparse<float>& another); TMatrixTSparse<float>(const TMatrixT<float>& another); TMatrixTSparse<float>(Int_t nrows, Int_t ncols); TMatrixTSparse<float>(TMatrixTSparse<float>::EMatrixCreatorsOp1 op, const TMatrixTSparse<float>& prototype); TMatrixTSparse<float>(const TMatrixTSparse<float>& a, TMatrixTSparse<float>::EMatrixCreatorsOp2 op, const TMatrixTSparse<float>& b); TMatrixTSparse<float>(const TMatrixTSparse<float>& a, TMatrixTSparse<float>::EMatrixCreatorsOp2 op, const TMatrixT<float>& b); TMatrix",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:7178,Modifiability,Inherit,InheritsFrom,7178,"atrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixTSparse<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMatrixTBase<float>::Min() const; voidMult(const TMatrixTSparse<float>& a, const TMatrixTSparse<float>& b); virtual Int_tNonZeros() con",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:7244,Modifiability,Inherit,InheritsFrom,7244,"::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixTSparse<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMatrixTBase<float>::Min() const; voidMult(const TMatrixTSparse<float>& a, const TMatrixTSparse<float>& b); virtual Int_tNonZeros() const; floatTMatrixTBase<float>::Norm1() const; virtual TMatrixTBase<",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:16747,Modifiability,Inherit,Inheritance,16747," kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<float>::fColLwblower bound of the col index; float*fElements[fNelems]; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element>",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:16760,Modifiability,Inherit,Inherited,16760," kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fColIndex[fNelems] column index; Int_tTMatrixTBase<float>::fColLwblower bound of the col index; float*fElements[fNelems]; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_t*fRowIndex[fNrowIndex] row index; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element>",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:1562,Performance,perform,performance,1562,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is sm",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:836,Security,access,access,836,". TMatrixTSparse<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSparse<float>. class TMatrixTSparse<float>: public TMatrixTBase<float>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:7068,Security,Hash,Hash,7068,"GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixTSparse<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMatrixTBase<float>::",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:12701,Testability,Test,TestBit,12701,"at>& another); TMatrixTSparse<float>&SetSparseIndexAB(const TMatrixTSparse<float>& a, const TMatrixTSparse<float>& b); TMatrixTSparse<float>&SetSparseIndexAB(const TMatrixT<float>& a, const TMatrixTSparse<float>& b); TMatrixTSparse<float>&SetSparseIndexAB(const TMatrixTSparse<float>& a, const TMatrixT<float>& b); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatTMatrixTBase<float>::SetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&TMatrixTBase<float>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqr(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatTMatrixTBase<float>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSparse<float>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMatrixTSparse<float>&Transpose(const TMatrixTSparse<float>& source); virtual TMatrixTBase<float>&UnitMatrix(); TMatrixTSparse<float>&Use(TMatrixTSparse<float>& a); const TMatrixTSparse<float>&Use(const TMatrixTSparse<float>& a) const; TMatrixTSparse<float>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData); const TMatrixTSparse<float>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const float* pData) const; TMatrixTSparse<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData); const TMatrixTSparse<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const float* pData) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:12740,Testability,Test,TestBits,12740,"tSparseIndexAB(const TMatrixTSparse<float>& a, const TMatrixTSparse<float>& b); TMatrixTSparse<float>&SetSparseIndexAB(const TMatrixT<float>& a, const TMatrixTSparse<float>& b); TMatrixTSparse<float>&SetSparseIndexAB(const TMatrixTSparse<float>& a, const TMatrixT<float>& b); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatTMatrixTBase<float>::SetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&TMatrixTBase<float>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqr(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatTMatrixTBase<float>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSparse<float>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMatrixTSparse<float>&Transpose(const TMatrixTSparse<float>& source); virtual TMatrixTBase<float>&UnitMatrix(); TMatrixTSparse<float>&Use(TMatrixTSparse<float>& a); const TMatrixTSparse<float>&Use(const TMatrixTSparse<float>& a) const; TMatrixTSparse<float>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData); const TMatrixTSparse<float>&Use(Int_t nrows, Int_t ncols, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const float* pData) const; TMatrixTSparse<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData); const TMatrixTSparse<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, const Int_t* pRowIndex, const Int_t* pColIndex, const float* pData) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSparse_float_.html:26722,Usability,Clear,Clear,26722,"MultB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0); Elementary constructors. void AMultB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr=0). void AMultB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). void APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data); { memmove(fRowIndex,data,(this->fNrows+1)*sizeof(Int_t)); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* data); { memmove(fColIndex,data,this->fNelems*sizeof(Int_t)); return *this; }. TMatrixTSparse<Element> & SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b). TMatrixTBase<Element> & SetMatrixArray(const float* data, Option_t* = """"); { memcpy(fElements,data,this->fNelems*sizeof(Element)); return *this; }. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). void Clear(Option_t* = """"). TMatrixTSparse<Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData). Bool_t IsSymmetric() const; { return (*this == TMatrixTSparse<Element>(kTransposed,*this)); }. void Mult(const TMatrixTSparse<float>& a, const TMatrixTSparse<float>& b); { AMultB(a,b,0); }. Int_t NonZeros() const; { return this->fNelems; }. TMatrixTBase<Element> & NormByDiag(const TVectorT<float>& , Option_t* ); { MayNotUse(""NormByDiag""); return *this; }. const TMatrixTSparseRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTSparseRow_const<Element>(*this,rown); }. TMatrixTSparseRow <Element> operator[](Int_t rown); { return TMatrixTSparseRow <Element>(*this,rown); }. TMatrixTSparse<Element> & operator-=(Element val). TMatrixTSparse<Element> & operator+=(Element val). TMatrixTSparse<Element> & operator*=(Element val). TMatrixTSparse<Element> & operator+=(const TMatrixTSparse<Element> ",MatchSource.WIKI,root/html532/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html
https://root.cern/root/html532/TMatrixTSub_const_double_.html:1798,Modifiability,Inherit,Inheritance,1798,"iews without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixDSub_const, TMatrixTSub_const<Double_t>. Function Members (Methods); public:. TMatrixTSub_const<double>(); TMatrixTSub_const<double>(const TMatrixTSub_const<double>&); TMatrixTSub_const<double>(const TMatrixT<double>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); TMatrixTSub_const<double>(const TMatrixTSym<double>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TMatrixTSub_const<double>(); static TClass*Class(); Int_tGetColOff() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNcols() const; Int_tGetNrows() const; Int_tGetRowOff() const; virtual TClass*IsA() const; const double&operator()(Int_t rown, Int_t coln) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColOff; TMatrixTBase<double>*fMatrixthe matrix I am a submatrix of; Int_tfNcolsSub; Int_tfNrowsSub; Int_tfRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i). Int_t GetRowOff() const; { return fRowOff; }. Int_t GetColOff() const; { return fColOff; }. Int_t GetNrows() const; { return fNrowsSub; }. Int_t GetNcols() const; { return fNcolsSub; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_const_double_.html
https://root.cern/root/html532/TMatrixTSub_const_double_.html:1811,Modifiability,Inherit,Inherited,1811,"iews without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixDSub_const, TMatrixTSub_const<Double_t>. Function Members (Methods); public:. TMatrixTSub_const<double>(); TMatrixTSub_const<double>(const TMatrixTSub_const<double>&); TMatrixTSub_const<double>(const TMatrixT<double>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); TMatrixTSub_const<double>(const TMatrixTSym<double>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TMatrixTSub_const<double>(); static TClass*Class(); Int_tGetColOff() const; const TMatrixTBase<double>*GetMatrix() const; Int_tGetNcols() const; Int_tGetNrows() const; Int_tGetRowOff() const; virtual TClass*IsA() const; const double&operator()(Int_t rown, Int_t coln) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColOff; TMatrixTBase<double>*fMatrixthe matrix I am a submatrix of; Int_tfNcolsSub; Int_tfNrowsSub; Int_tfRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i). Int_t GetRowOff() const; { return fRowOff; }. Int_t GetColOff() const; { return fColOff; }. Int_t GetNrows() const; { return fNrowsSub; }. Int_t GetNcols() const; { return fNcolsSub; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_const_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_const_double_.html
https://root.cern/root/html532/TMatrixTSub_const_float_.html:1783,Modifiability,Inherit,Inheritance,1783,"ent matrix views without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSub_const<Float_t>, TMatrixFSub_const. Function Members (Methods); public:. TMatrixTSub_const<float>(); TMatrixTSub_const<float>(const TMatrixTSub_const<float>&); TMatrixTSub_const<float>(const TMatrixT<float>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); TMatrixTSub_const<float>(const TMatrixTSym<float>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TMatrixTSub_const<float>(); static TClass*Class(); Int_tGetColOff() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNcols() const; Int_tGetNrows() const; Int_tGetRowOff() const; virtual TClass*IsA() const; const float&operator()(Int_t rown, Int_t coln) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColOff; TMatrixTBase<float>*fMatrixthe matrix I am a submatrix of; Int_tfNcolsSub; Int_tfNrowsSub; Int_tfRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i). Int_t GetRowOff() const; { return fRowOff; }. Int_t GetColOff() const; { return fColOff; }. Int_t GetNrows() const; { return fNrowsSub; }. Int_t GetNcols() const; { return fNcolsSub; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_const_float_.html
https://root.cern/root/html532/TMatrixTSub_const_float_.html:1796,Modifiability,Inherit,Inherited,1796,"ent matrix views without copying data elements :; TMatrixTRow_const TMatrixTRow; TMatrixTColumn_const TMatrixTColumn; TMatrixTDiag_const TMatrixTDiag; TMatrixTFlat_const TMatrixTFlat; TMatrixTSub_const TMatrixTSub; TMatrixTSparseRow_const TMatrixTSparseRow; TMatrixTSparseDiag_const TMatrixTSparseDiag. TElementActionT; TElementPosActionT. This class is also known as (typedefs to this class)TMatrixTSub_const<Float_t>, TMatrixFSub_const. Function Members (Methods); public:. TMatrixTSub_const<float>(); TMatrixTSub_const<float>(const TMatrixTSub_const<float>&); TMatrixTSub_const<float>(const TMatrixT<float>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); TMatrixTSub_const<float>(const TMatrixTSym<float>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TMatrixTSub_const<float>(); static TClass*Class(); Int_tGetColOff() const; const TMatrixTBase<float>*GetMatrix() const; Int_tGetNcols() const; Int_tGetNrows() const; Int_tGetRowOff() const; virtual TClass*IsA() const; const float&operator()(Int_t rown, Int_t coln) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_tfColOff; TMatrixTBase<float>*fMatrixthe matrix I am a submatrix of; Int_tfNcolsSub; Int_tfNrowsSub; Int_tfRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TMatrixTBase<Element> * GetMatrix() const; { return fMatrix; }. const Element & operator()(Int_t i). Int_t GetRowOff() const; { return fRowOff; }. Int_t GetColOff() const; { return fColOff; }. Int_t GetNrows() const; { return fNrowsSub; }. Int_t GetNcols() const; { return fNcolsSub; }.  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_const_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_const_float_.html
https://root.cern/root/html532/TMatrixTSub_double_.html:2585,Modifiability,Inherit,Inheritance,2585,"tor*=(double val); voidoperator*=(const TMatrixTSub_const<double>& s); voidoperator*=(const TMatrixT<double>& m); voidoperator*=(const TMatrixTSym<double>& m); voidoperator+=(double val); voidoperator+=(const TMatrixTSub_const<double>& s); voidoperator+=(const TMatrixTBase<double>& m); voidoperator=(double val); voidoperator=(const TMatrixTSub_const<double>& s); TMatrixTSub<double>&operator=(const TMatrixTSub<double>& s); voidoperator=(const TMatrixTBase<double>& m); voidRank1Update(const TVectorT<double>& vec, double alpha = 1.0); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { kWorkMax; };. protected:. Int_tTMatrixTSub_const<double>::fColOff; TMatrixTBase<double>*TMatrixTSub_const<double>::fMatrixthe matrix I am a submatrix of; Int_tTMatrixTSub_const<double>::fNcolsSub; Int_tTMatrixTSub_const<double>::fNrowsSub; Int_tTMatrixTSub_const<double>::fRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i). void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). void operator+=(Element val). void operator*=(Element val). void operator*=(const TMatrixTColumn_const<Element> &c). void Rank1Update(const TVectorT<double>& vec, double alpha = 1.0).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_double_.html
https://root.cern/root/html532/TMatrixTSub_double_.html:2598,Modifiability,Inherit,Inherited,2598,"tor*=(double val); voidoperator*=(const TMatrixTSub_const<double>& s); voidoperator*=(const TMatrixT<double>& m); voidoperator*=(const TMatrixTSym<double>& m); voidoperator+=(double val); voidoperator+=(const TMatrixTSub_const<double>& s); voidoperator+=(const TMatrixTBase<double>& m); voidoperator=(double val); voidoperator=(const TMatrixTSub_const<double>& s); TMatrixTSub<double>&operator=(const TMatrixTSub<double>& s); voidoperator=(const TMatrixTBase<double>& m); voidRank1Update(const TVectorT<double>& vec, double alpha = 1.0); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { kWorkMax; };. protected:. Int_tTMatrixTSub_const<double>::fColOff; TMatrixTBase<double>*TMatrixTSub_const<double>::fMatrixthe matrix I am a submatrix of; Int_tTMatrixTSub_const<double>::fNcolsSub; Int_tTMatrixTSub_const<double>::fNrowsSub; Int_tTMatrixTSub_const<double>::fRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i). void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). void operator+=(Element val). void operator*=(Element val). void operator*=(const TMatrixTColumn_const<Element> &c). void Rank1Update(const TVectorT<double>& vec, double alpha = 1.0).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_double_.html
https://root.cern/root/html532/TMatrixTSub_float_.html:2545,Modifiability,Inherit,Inheritance,2545,"Int_t coln); voidoperator*=(float val); voidoperator*=(const TMatrixTSub_const<float>& s); voidoperator*=(const TMatrixT<float>& m); voidoperator*=(const TMatrixTSym<float>& m); voidoperator+=(float val); voidoperator+=(const TMatrixTSub_const<float>& s); voidoperator+=(const TMatrixTBase<float>& m); voidoperator=(float val); voidoperator=(const TMatrixTSub_const<float>& s); TMatrixTSub<float>&operator=(const TMatrixTSub<float>& s); voidoperator=(const TMatrixTBase<float>& m); voidRank1Update(const TVectorT<float>& vec, float alpha = 1.0); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { kWorkMax; };. protected:. Int_tTMatrixTSub_const<float>::fColOff; TMatrixTBase<float>*TMatrixTSub_const<float>::fMatrixthe matrix I am a submatrix of; Int_tTMatrixTSub_const<float>::fNcolsSub; Int_tTMatrixTSub_const<float>::fNrowsSub; Int_tTMatrixTSub_const<float>::fRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i). void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). void operator+=(Element val). void operator*=(Element val). void operator*=(const TMatrixTColumn_const<Element> &c). void Rank1Update(const TVectorT<float>& vec, float alpha = 1.0).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_float_.html
https://root.cern/root/html532/TMatrixTSub_float_.html:2558,Modifiability,Inherit,Inherited,2558,"Int_t coln); voidoperator*=(float val); voidoperator*=(const TMatrixTSub_const<float>& s); voidoperator*=(const TMatrixT<float>& m); voidoperator*=(const TMatrixTSym<float>& m); voidoperator+=(float val); voidoperator+=(const TMatrixTSub_const<float>& s); voidoperator+=(const TMatrixTBase<float>& m); voidoperator=(float val); voidoperator=(const TMatrixTSub_const<float>& s); TMatrixTSub<float>&operator=(const TMatrixTSub<float>& s); voidoperator=(const TMatrixTBase<float>& m); voidRank1Update(const TVectorT<float>& vec, float alpha = 1.0); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { kWorkMax; };. protected:. Int_tTMatrixTSub_const<float>::fColOff; TMatrixTBase<float>*TMatrixTSub_const<float>::fMatrixthe matrix I am a submatrix of; Int_tTMatrixTSub_const<float>::fNcolsSub; Int_tTMatrixTSub_const<float>::fNrowsSub; Int_tTMatrixTSub_const<float>::fRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TElementActionT& operator=(const TElementActionT<Element> &); {return *this;}. TElementPosActionT<Element>& operator=(const TElementPosActionT<Element> &); {return *this;}. TMatrixTRow_const<Element>& operator=(const TMatrixTRow_const<Element>& trc). const Element & operator()(Int_t i). void operator=(Element val). void operator+=(Element val). void operator*=(Element val). void operator+=(const TMatrixTRow_const<Element> &r). void operator*=(const TMatrixTRow_const<Element> &r). void operator+=(Element val). void operator*=(Element val). void operator*=(const TMatrixTColumn_const<Element> &c). void Rank1Update(const TVectorT<float>& vec, float alpha = 1.0).  Last changed: root/matrix:$Id: TMatrixTUtils.h 36047 2010-10-04 06:43:15Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSub_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSub_float_.html
https://root.cern/root/html532/TMatrixTSymCramerInv.html:414,Energy Efficiency,adapt,adapted,414,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html532/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymCramerInv.html
https://root.cern/root/html532/TMatrixTSymCramerInv.html:379,Integrability,rout,routines,379,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html532/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymCramerInv.html
https://root.cern/root/html532/TMatrixTSymCramerInv.html:427,Integrability,rout,routines,427,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html532/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymCramerInv.html
https://root.cern/root/html532/TMatrixTSymCramerInv.html:414,Modifiability,adapt,adapted,414,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html532/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymCramerInv.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:678,Availability,avail,available,678,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Double_t>, TMatrixDSymLazy. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:1530,Availability,Error,Error,1530," virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:1659,Availability,error,error,1659," virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:1743,Availability,error,error,1743," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:2671,Modifiability,Inherit,InheritsFrom,2671,"l voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:2737,Modifiability,Inherit,InheritsFrom,2737,"error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pa",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:5573,Modifiability,Inherit,Inheritance,5573,"e(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTSymLazy<double>&). private:. virtual voidFillIn(TMatrixTSym<double>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTSymLazy<double>& ); { }. void FillIn(TMatrixTSym<double>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:5586,Modifiability,Inherit,Inherited,5586,"e(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTSymLazy<double>&). private:. virtual voidFillIn(TMatrixTSym<double>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTSymLazy<double>& ); { }. void FillIn(TMatrixTSym<double>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:2561,Security,Hash,Hash,2561,"har* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:4636,Testability,Test,TestBit,4636,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:4675,Testability,Test,TestBits,4675,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_double_.html:990,Usability,Clear,Clear,990," virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html532/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_double_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:674,Availability,avail,available,674,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFSymLazy, TMatrixTSymLazy<Float_t>. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:1525,Availability,Error,Error,1525," virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:1654,Availability,error,error,1654," virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:1738,Availability,error,error,1738," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:2666,Modifiability,Inherit,InheritsFrom,2666,"l voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:2732,Modifiability,Inherit,InheritsFrom,2732,"error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pa",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:5566,Modifiability,Inherit,Inheritance,5566,"itive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTSymLazy<float>&). private:. virtual voidFillIn(TMatrixTSym<float>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTSymLazy<float>& ); { }. void FillIn(TMatrixTSym<float>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:5579,Modifiability,Inherit,Inherited,5579,"itive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TMatrixTSymLazy<float>&). private:. virtual voidFillIn(TMatrixTSym<float>& m) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfRowLwb; Int_tfRowUpb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMatrixTSymLazy<float>& ); { }. void FillIn(TMatrixTSym<float>& m) const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fRowUpb; }.  Last changed: root/matrix:$Id: TMatrixTLazy.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:2556,Security,Hash,Hash,2556,"har* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:4631,Testability,Test,TestBit,4631,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:4670,Testability,Test,TestBits,4670,"nHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSymLazy_float_.html:985,Usability,Clear,Clear,985," virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html532/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSymLazy_float_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:2776,Availability,Error,Error,2776,"nst TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual cons",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:2905,Availability,error,error,2905,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:2989,Availability,error,error,2989,"Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTM",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:492,Deployability,update,updated,492,". TMatrixTSym<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSym<double>. class TMatrixTSym<double>: public TMatrixTBase<double>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . This class is also known as (typedefs to this class)TMatrixTSym<Double_t>, TMatrixDSym. Function Members (Methods); public:. TMatrixTSym<double>(); TMatrixTSym<double>(Int_t nrows); TMatrixTSym<double>(const TMatrixTSym<double>& another); TMatrixTSym<double>(const TMatrixTSymLazy<double>& lazy_constructor); TMatrixTSym<double>(Int_t row_lwb, Int_t row_upb); TMatrixTSym<double>(TMatrixTSym<double>::EMatrixCreatorsOp1 op, const TMatrixTSym<double>& prototype); TMatrixTSym<double>(TMatrixTSym<double>::EMatrixCreatorsOp1 op, const TMatrixT<double>& prototype); TMatrixTSym<double>(Int_t nrows, const double* data, Option_t* option = """"); TMatrixTSym<double>(const TMatrixTSym<double>& a, TMatrixTSym<double>::EMatrixCreatorsOp2 op, const TMatrixTSym<double>& b); TMatrixTSym<double>(Int_t row_lwb, Int_t row_upb, const double* data, Option_t* option = """"); virtual~TMatrixTSym<double>(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(con",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:13959,Energy Efficiency,Allocate,Allocate,13959,"_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, double*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:14061,Energy Efficiency,Allocate,Allocate,14061,"_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, double*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:18142,Energy Efficiency,efficient,efficient,18142," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:18482,Energy Efficiency,efficient,efficient,18482,"<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:18874,Energy Efficiency,efficient,efficient,18874,"= 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:15143,Integrability,depend,depends,15143,"ound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starti",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:15574,Integrability,depend,depends,15574," Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const double* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set siz",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:18206,Integrability,rout,routine,18206," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:18546,Integrability,rout,routine,18546,"<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:18938,Integrability,rout,routine,18938,"= 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:5059,Modifiability,Inherit,InheritsFrom,5059,"(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixTSym<double>&GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; TMatrixTSym<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); TMatrixTSym<double>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixTSym<double>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual doubleTMatri",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:5125,Modifiability,Inherit,InheritsFrom,5125," virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixTSym<double>&GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; TMatrixTSym<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); TMatrixTSym<double>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixTSym<double>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual doubleTMatrixTBase<double>::Min() const; voidMinus(const TMatrixTSym<double>& ",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:13349,Modifiability,Inherit,Inheritance,13349,"atusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<double>::fColLwblower bound of the col index; doublefDataStack[25]! data container; double*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, double*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:13362,Modifiability,Inherit,Inherited,13362,"atusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<double>::fColLwblower bound of the col index; doublefDataStack[25]! data container; double*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, double*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:17858,Performance,Perform,Perform,17858,"to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:4949,Security,Hash,Hash,4949,"e<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixTSym<double>&GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; TMatrixTSym<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); TMatrixTSym<double>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixTSym<double>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtu",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:17472,Security,access,access,17472,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficien",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:10466,Testability,Test,TestBit,10466,"Array(Int_t*); TMatrixTSym<double>&SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleTMatrixTBase<double>::SetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); TMatrixTSym<double>&Similarity(const TMatrixT<double>& n); TMatrixTSym<double>&Similarity(const TMatrixTSym<double>& n); doubleSimilarity(const TVectorT<double>& v) const; TMatrixTSym<double>&SimilarityT(const TMatrixT<double>& n); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqr(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleTMatrixTBase<double>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSym<double>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<double>& a); voidTMult(const TMatrixTSym<double>& a); TMatrixTSym<double>&Transpose(const TMatrixTSym<double>& source); virtual TMatrixTBase<double>&TMatrixTBase<double>::UnitMatrix(); TMatrixTSym<double>&Use(TMatrixTSym<double>& a); const TMatrixTSym<double>&Use(const TMatrixTSym<double>& a) const; TMatrixTSym<double>&Use(Int_t nrows, double* data); const TMatrixTSym<double>&Use(Int_t nrows, const double* data) const; TMatrixTSym<double>&Use(Int_t row_lwb, Int_t row_upb, double* data); const TMatrixTSym<double>&Use(Int_t row_lwb, Int_t row_upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<double>&TMatrixT",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:10505,Testability,Test,TestBits,10505,"ixTSym<double>&SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleTMatrixTBase<double>::SetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); TMatrixTSym<double>&Similarity(const TMatrixT<double>& n); TMatrixTSym<double>&Similarity(const TMatrixTSym<double>& n); doubleSimilarity(const TVectorT<double>& v) const; TMatrixTSym<double>&SimilarityT(const TMatrixT<double>& n); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqr(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleTMatrixTBase<double>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSym<double>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<double>& a); voidTMult(const TMatrixTSym<double>& a); TMatrixTSym<double>&Transpose(const TMatrixTSym<double>& source); virtual TMatrixTBase<double>&TMatrixTBase<double>::UnitMatrix(); TMatrixTSym<double>&Use(TMatrixTSym<double>& a); const TMatrixTSym<double>&Use(const TMatrixTSym<double>& a) const; TMatrixTSym<double>&Use(Int_t nrows, double* data); const TMatrixTSym<double>&Use(Int_t nrows, const double* data) const; TMatrixTSym<double>&Use(Int_t row_lwb, Int_t row_upb, double* data); const TMatrixTSym<double>&Use(Int_t row_lwb, Int_t row_upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::Zero().",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_double_.html:22519,Usability,Clear,Clear,22519,"ement> Use(Int_t nrows, const double* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<double>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<double>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<double>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }.  Last changed: root/matrix:$Id: TMatrixTSym.h 34744 2010-08-07 06:16:36Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:2792,Availability,Error,Error,2792,"Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const floa",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:2921,Availability,error,error,2921,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:3005,Availability,error,error,3005,"bject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:488,Deployability,update,updated,488,". TMatrixTSym<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TMatrixTSym<float>. class TMatrixTSym<float>: public TMatrixTBase<float>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . This class is also known as (typedefs to this class)TMatrixTSym<Float_t>, TMatrixFSym. Function Members (Methods); public:. TMatrixTSym<float>(); TMatrixTSym<float>(Int_t nrows); TMatrixTSym<float>(const TMatrixTSym<float>& another); TMatrixTSym<float>(const TMatrixTSymLazy<float>& lazy_constructor); TMatrixTSym<float>(const TMatrixTSym<double>& another); TMatrixTSym<float>(Int_t row_lwb, Int_t row_upb); TMatrixTSym<float>(TMatrixTSym<float>::EMatrixCreatorsOp1 op, const TMatrixTSym<float>& prototype); TMatrixTSym<float>(TMatrixTSym<float>::EMatrixCreatorsOp1 op, const TMatrixT<float>& prototype); TMatrixTSym<float>(Int_t nrows, const float* data, Option_t* option = """"); TMatrixTSym<float>(const TMatrixTSym<float>& a, TMatrixTSym<float>::EMatrixCreatorsOp2 op, const TMatrixTSym<float>& b); TMatrixTSym<float>(Int_t row_lwb, Int_t row_upb, const float* data, Option_t* option = """"); virtual~TMatrixTSym<float>(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TOb",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:13813,Energy Efficiency,Allocate,Allocate,13813,"rix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, float*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& targ",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:13915,Energy Efficiency,Allocate,Allocate,13915,"rix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, float*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& targ",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:17983,Energy Efficiency,efficient,efficient,17983,"st. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:18323,Energy Efficiency,efficient,efficient,18323,"Sym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Eleme",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:18713,Energy Efficiency,efficient,efficient,18713,"a = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(float val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the s",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:14991,Integrability,depend,depends,14991,"lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting ",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:15421,Integrability,depend,depends,15421,"a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const float* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size o",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:18047,Integrability,rout,routine,18047,"st. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:18387,Integrability,rout,routine,18387,"Sym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Eleme",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:18777,Integrability,rout,routine,18777,"a = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(float val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the s",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:5055,Modifiability,Inherit,InheritsFrom,5055,"bjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixTSym<float>&GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; TMatrixTSym<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); TMatrixTSym<float>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixTSym<float>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMatrixTBase<float",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:5121,Modifiability,Inherit,InheritsFrom,5121,"ctStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixTSym<float>&GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; TMatrixTSym<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); TMatrixTSym<float>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixTSym<float>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMatrixTBase<float>::Min() const; voidMinus(const TMatrixTSym<float>& a, const TMatr",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:13206,Modifiability,Inherit,Inheritance,13206,"::EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<float>::fColLwblower bound of the col index; floatfDataStack[25]! data container; float*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, float*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:13219,Modifiability,Inherit,Inherited,13219,"::EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<float>::fColLwblower bound of the col index; floatfDataStack[25]! data container; float*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSym<Element> Delete_m(Int_t size, float*& ); delete data pointer m, if it was assigned on the heap. Element* TMatrixTSym<Element> New_m(Int_t size); return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixTSym<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixTSym<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:17699,Performance,Perform,Perform,17699,"ix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than a",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:4945,Security,Hash,Hash,4945,"TMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixTSym<float>&GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; TMatrixTSym<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); TMatrixTSym<float>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixTSym<float>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatT",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:17316,Security,access,access,17316,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient t",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:10361,Testability,Test,TestBit,10361,"Base<float>&SetRowIndexArray(Int_t*); TMatrixTSym<float>&SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatTMatrixTBase<float>::SetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); TMatrixTSym<float>&Similarity(const TMatrixT<float>& n); TMatrixTSym<float>&Similarity(const TMatrixTSym<float>& n); floatSimilarity(const TVectorT<float>& v) const; TMatrixTSym<float>&SimilarityT(const TMatrixT<float>& n); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqr(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatTMatrixTBase<float>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSym<float>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<float>& a); voidTMult(const TMatrixTSym<float>& a); TMatrixTSym<float>&Transpose(const TMatrixTSym<float>& source); virtual TMatrixTBase<float>&TMatrixTBase<float>::UnitMatrix(); TMatrixTSym<float>&Use(TMatrixTSym<float>& a); const TMatrixTSym<float>&Use(const TMatrixTSym<float>& a) const; TMatrixTSym<float>&Use(Int_t nrows, float* data); const TMatrixTSym<float>&Use(Int_t nrows, const float* data) const; TMatrixTSym<float>&Use(Int_t row_lwb, Int_t row_upb, float* data); const TMatrixTSym<float>&Use(Int_t row_lwb, Int_t row_upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::Zero()",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:10400,Testability,Test,TestBits,10400,"Base<float>&SetRowIndexArray(Int_t*); TMatrixTSym<float>&SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatTMatrixTBase<float>::SetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); TMatrixTSym<float>&Similarity(const TMatrixT<float>& n); TMatrixTSym<float>&Similarity(const TMatrixTSym<float>& n); floatSimilarity(const TVectorT<float>& v) const; TMatrixTSym<float>&SimilarityT(const TMatrixT<float>& n); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqr(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatTMatrixTBase<float>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixTSym<float>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<float>& a); voidTMult(const TMatrixTSym<float>& a); TMatrixTSym<float>&Transpose(const TMatrixTSym<float>& source); virtual TMatrixTBase<float>&TMatrixTBase<float>::UnitMatrix(); TMatrixTSym<float>&Use(TMatrixTSym<float>& a); const TMatrixTSym<float>&Use(const TMatrixTSym<float>& a) const; TMatrixTSym<float>&Use(Int_t nrows, float* data); const TMatrixTSym<float>&Use(Int_t nrows, const float* data) const; TMatrixTSym<float>&Use(Int_t row_lwb, Int_t row_upb, float* data); const TMatrixTSym<float>&Use(Int_t row_lwb, Int_t row_upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::Zero().",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixTSym_float_.html:22347,Usability,Clear,Clear,22347,"ym<Element> Use(Int_t nrows, const float* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<float>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<float>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<float>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }.  Last changed: root/matrix:$Id: TMatrixTSym.h 34744 2010-08-07 06:16:36Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html
https://root.cern/root/html532/TMatrixT_double_.html:3002,Availability,Error,Error,3002,"nst TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual cons",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:3131,Availability,error,error,3131,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:3215,Availability,error,error,3215,"Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTM",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:15863,Energy Efficiency,Allocate,Allocate,15863,"atrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TM",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:15965,Energy Efficiency,Allocate,Allocate,15965,"atrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TM",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:19845,Energy Efficiency,Power,Power,19845,"e<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v,",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:17390,Integrability,rout,routine,17390,"lement> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A general and B symmetric.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A symmetric and B symmetric.; (Actually copied for the moment routine for B general); Create a matrix C such that C = A * B. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_l",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:18612,Integrability,depend,depends,18612," = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, th",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:5165,Modifiability,Inherit,InheritsFrom,5165,"ixTBase<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixT<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); TMatrixT<double>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixT<double>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTMatrixTBase<double>::IsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virt",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:5231,Modifiability,Inherit,InheritsFrom,5231,":GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixT<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); TMatrixT<double>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixT<double>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTMatrixTBase<double>::IsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::MakeValid(); virtual doubleTMatrixTBase<double>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual doubleTMatrixTBase<double>::Min() const; voidMinus(const TMatr",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:15265,Modifiability,Inherit,Inheritance,15265,"atusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<double>::fColLwblower bound of the col index; doublefDataStack[25]! data container; double*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:15278,Modifiability,Inherit,Inherited,15278,"atusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<double>::fColLwblower bound of the col index; doublefDataStack[25]! data container; double*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<double>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<double>::fNcolsnumber of columns; Int_tTMatrixTBase<double>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<double>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<double>::fNrowsnumber of rows; Int_tTMatrixTBase<double>::fRowLwblower bound of the row index; doubleTMatrixTBase<double>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:20346,Performance,Perform,Perform,20346,"t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:20535,Performance,Perform,Perform,20535,"are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSparse<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTLazy<Eleme",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:5055,Security,Hash,Hash,5055,"atrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<double>::GetRowLwb() const; Int_tTMatrixTBase<double>::GetRowUpb() const; TMatrixT<double>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<double>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; doubleTMatrixTBase<double>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<double>::Invalidate(); TMatrixT<double>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixT<double>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<double>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTMatrixTBase<double>::IsSymmetric() const; Bool_tTMatrixTBase<double>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<double>::Ma",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:12084,Testability,Test,TestBit,12084,"tatic voidTObject::SetDtorOnly(void* obj); virtual TMatrixTBase<double>&TMatrixTBase<double>::SetMatrixArray(const double* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<double>&SetRowIndexArray(Int_t*); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleTMatrixTBase<double>::SetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&TMatrixTBase<double>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); doubleSimilarity(const TVectorT<double>& v) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqr(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleTMatrixTBase<double>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixT<double>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<double>& a, const TMatrixT<double>& b); voidTMult(const TMatrixT<double>& a, const TMatrixTSym<double>& b); voidTMult(const TMatrixTSym<double>& a, const TMatrixT<double>& b); voidTMult(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); TMatrixT<double>&Transpose(const TMatrixT<double>& source); virtual TMatrixTBase<double>&TMatrixTBase<double>::UnitMatrix(); TMatrixT<double>&Use(TMatrixT<double>& a); const TMatrixT<double>&Use(const TMatrixT<double>& a) const; TMatrixT<double>&Use(Int_t nrows, Int_t ncols, double* data); const TMatrixT<double>&Use(Int_t nrows, Int_t ncols, const double* data) const; TMatrixT<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); const TMatrixT<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* metho",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:12123,Testability,Test,TestBits,12123,"j); virtual TMatrixTBase<double>&TMatrixTBase<double>::SetMatrixArray(const double* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<double>&SetRowIndexArray(Int_t*); virtual TMatrixTBase<double>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); doubleTMatrixTBase<double>::SetTol(double newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<double>&TMatrixTBase<double>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); doubleSimilarity(const TVectorT<double>& v) const; virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqr(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleTMatrixTBase<double>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixT<double>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<double>& a, const TMatrixT<double>& b); voidTMult(const TMatrixT<double>& a, const TMatrixTSym<double>& b); voidTMult(const TMatrixTSym<double>& a, const TMatrixT<double>& b); voidTMult(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); TMatrixT<double>&Transpose(const TMatrixT<double>& source); virtual TMatrixTBase<double>&TMatrixTBase<double>::UnitMatrix(); TMatrixT<double>&Use(TMatrixT<double>& a); const TMatrixT<double>&Use(const TMatrixT<double>& a) const; TMatrixT<double>&Use(Int_t nrows, Int_t ncols, double* data); const TMatrixT<double>&Use(Int_t nrows, Int_t ncols, const double* data) const; TMatrixT<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); const TMatrixT<double>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual In",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_double_.html:26492,Usability,Clear,Clear,26492,"rixT<Element> &TMatrixT<Element> Use(const TMatrixT<double>& a) const. template <class Element> inline TMatrixT<Element> TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixT<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixT<Element> operator()(Int_t rown, Int_t coln). void Plus(const TMatrixT <Element> &a,const TMatrixT <Element> &b); Elementary constructors. void Minus(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b); { Mult(a,b); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). TMatrixT <Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }.  Last changed: root/matrix:$Id: TMatrixT.h 39086 2011-05-04 09:36:17Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_double_.html
https://root.cern/root/html532/TMatrixT_float_.html:3006,Availability,Error,Error,3006,"Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const floa",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:3135,Availability,error,error,3135,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:3219,Availability,error,error,3219,"bject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:15653,Energy Efficiency,Allocate,Allocate,15653,"nts in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TM",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:15755,Energy Efficiency,Allocate,Allocate,15755,"nts in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TM",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:19632,Energy Efficiency,Power,Power,19632,"se<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:17180,Integrability,rout,routine,17180,"lement> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A general and B symmetric.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A symmetric and B symmetric.; (Actually copied for the moment routine for B general); Create a matrix C such that C = A * B. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lw",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:18400,Integrability,depend,depends,18400,"j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, the",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:5151,Modifiability,Inherit,InheritsFrom,5151,"nt_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixT<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); TMatrixT<float>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixT<float>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTMatrixTBase<float>::IsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMa",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:5217,Modifiability,Inherit,InheritsFrom,5217,"float>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixT<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); TMatrixT<float>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixT<float>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTMatrixTBase<float>::IsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid(); virtual floatTMatrixTBase<float>::Max() const; voidTObject::MayNotUse(const char* method) const; virtual floatTMatrixTBase<float>::Min() const; voidMinus(const TMatrixT<float>& a,",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:15058,Modifiability,Inherit,Inheritance,15058,"::EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<float>::fColLwblower bound of the col index; floatfDataStack[25]! data container; float*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,co",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:15071,Modifiability,Inherit,Inherited,15071,"::EMatrixStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTMatrixTBase<float>::fColLwblower bound of the col index; floatfDataStack[25]! data container; float*fElements[fNelems] elements themselves; Bool_tTMatrixTBase<float>::fIsOwner!default kTRUE, when Use array kFALSE; Int_tTMatrixTBase<float>::fNcolsnumber of columns; Int_tTMatrixTBase<float>::fNelemsnumber of elements in matrix; Int_tTMatrixTBase<float>::fNrowIndexlength of row index array (= fNrows+1) wich is only used for sparse matrices; Int_tTMatrixTBase<float>::fNrowsnumber of rows; Int_tTMatrixTBase<float>::fRowLwblower bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,co",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:20130,Performance,Perform,Perform,20130,"nt_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment opera",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:20316,Performance,Perform,Perform,20316," ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSparse<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTLazy<Element>",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:5041,Security,Hash,Hash,5041,"float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Int_t*GetRowIndexArray() const; virtual Int_t*GetRowIndexArray(); Int_tTMatrixTBase<float>::GetRowLwb() const; Int_tTMatrixTBase<float>::GetRowUpb() const; TMatrixT<float>GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const; virtual TMatrixTBase<float>&GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; floatTMatrixTBase<float>::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); virtual voidTObject::Inspect() constMENU ; voidTMatrixTBase<float>::Invalidate(); TMatrixT<float>&Invert(Double_t* det = 0); voidTObject::InvertBit(UInt_t f); TMatrixT<float>&InvertFast(Double_t* det = 0); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTMatrixTBase<float>::IsOwner() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTMatrixTBase<float>::IsSymmetric() const; Bool_tTMatrixTBase<float>::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTMatrixTBase<float>::MakeValid();",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:11921,Testability,Test,TestBit,11921,"option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual TMatrixTBase<float>&TMatrixTBase<float>::SetMatrixArray(const float* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<float>&SetRowIndexArray(Int_t*); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatTMatrixTBase<float>::SetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&TMatrixTBase<float>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); floatSimilarity(const TVectorT<float>& v) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqr(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatTMatrixTBase<float>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixT<float>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<float>& a, const TMatrixT<float>& b); voidTMult(const TMatrixT<float>& a, const TMatrixTSym<float>& b); voidTMult(const TMatrixTSym<float>& a, const TMatrixT<float>& b); voidTMult(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); TMatrixT<float>&Transpose(const TMatrixT<float>& source); virtual TMatrixTBase<float>&TMatrixTBase<float>::UnitMatrix(); TMatrixT<float>&Use(TMatrixT<float>& a); const TMatrixT<float>&Use(const TMatrixT<float>& a) const; TMatrixT<float>&Use(Int_t nrows, Int_t ncols, float* data); const TMatrixT<float>&Use(Int_t nrows, Int_t ncols, const float* data) const; TMatrixT<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); const TMatrixT<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:11960,Testability,Test,TestBits,11960,"SetDtorOnly(void* obj); virtual TMatrixTBase<float>&TMatrixTBase<float>::SetMatrixArray(const float* data, Option_t* option = """"); static voidTObject::SetObjectStat(Bool_t stat); virtual TMatrixTBase<float>&SetRowIndexArray(Int_t*); virtual TMatrixTBase<float>&SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); floatTMatrixTBase<float>::SetTol(float newTol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual TMatrixTBase<float>&TMatrixTBase<float>::Shift(Int_t row_shift, Int_t col_shift); virtual voidShowMembers(TMemberInspector& insp); floatSimilarity(const TVectorT<float>& v) const; virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqr(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual floatTMatrixTBase<float>::Sum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TMatrixT<float>&T(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMult(const TMatrixT<float>& a, const TMatrixT<float>& b); voidTMult(const TMatrixT<float>& a, const TMatrixTSym<float>& b); voidTMult(const TMatrixTSym<float>& a, const TMatrixT<float>& b); voidTMult(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); TMatrixT<float>&Transpose(const TMatrixT<float>& source); virtual TMatrixTBase<float>&TMatrixTBase<float>::UnitMatrix(); TMatrixT<float>&Use(TMatrixT<float>& a); const TMatrixT<float>&Use(const TMatrixT<float>& a) const; TMatrixT<float>&Use(Int_t nrows, Int_t ncols, float* data); const TMatrixT<float>&Use(Int_t nrows, Int_t ncols, const float* data) const; TMatrixT<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); const TMatrixT<float>&Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const ",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMatrixT_float_.html:26265,Usability,Clear,Clear,26265,"atrixT<Element> &TMatrixT<Element> Use(const TMatrixT<float>& a) const. template <class Element> inline TMatrixT<Element> TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixT<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixT<Element> operator()(Int_t rown, Int_t coln). void Plus(const TMatrixT <Element> &a,const TMatrixT <Element> &b); Elementary constructors. void Minus(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b); { Mult(a,b); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). TMatrixT <Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }.  Last changed: root/matrix:$Id: TMatrixT.h 39086 2011-05-04 09:36:17Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html
https://root.cern/root/html532/TMCParticle.html:1534,Availability,Error,Error,1534," Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); virtual~TMCParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEnergy() const; Int_tGetFirstChild() const; virtual const char*TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetOb",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:1663,Availability,error,error,1663,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEnergy() const; Int_tGetFirstChild() const; virtual const char*TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetP",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:1747,Availability,error,error,1747,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEnergy() const; Int_tGetFirstChild() const; virtual const char*TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParent() const; Float_tGetPx() const; Float_tGetPy() const; Float_tGetPz() const; Flo",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:530,Energy Efficiency,energy,energy,530," TMCParticle(); TMCParticle(const TMCParticle&); TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); virtual~TMCParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(con",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:5052,Energy Efficiency,energy,energy,5052,"erator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMCParticle&operator=(const TMCParticle&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEnergy(Float_t energy); virtual voidSetFirstChild(Int_t first); virtual voidSetKF(Int_t kF); virtual voidSetKS(Int_t kS); virtual voidSetLastChild(Int_t last); virtual voidSetLifetime(Float_t lifetime); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMass(Float_t mass); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(Int_t parent); virtual voidSetPx(Float_t px); virtual voidSetPy(Float_t py); virtual voidSetPz(Float_t pz); virtual voidSetTime(Float_t time); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVx(Float_t vx); virtual voidSetVy(Float_t vy); virtual voidSetVz(Float_t vz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:7977,Energy Efficiency,energy,energy,7977,"tfEnergyEnergy [GeV] ( LUJETS P[4] ); Int_tfFirstChildid of first child ( LUJETS K[4] ); Int_tfKFKF flavour code ( LUJETS K[2] ); Int_tfKSstatus of particle ( LUJETS K[1] ); Int_tfLastChildid of last child ( LUJETS K[5] ); Float_tfLifetimeproper lifetime [mm/c] ( LUJETS V[5] ); Float_tfMassMass [Gev/c^2] ( LUJETS P[5] ); Int_tfParentparrent's id ( LUJETS K[3] ); Float_tfPxX momenta [GeV/c] ( LUJETS P[1] ); Float_tfPyY momenta [GeV/c] ( LUJETS P[2] ); Float_tfPzZ momenta [GeV/c] ( LUJETS P[3] ); Float_tfTimetime of procuction [mm/c]( LUJETS V[4] ); Float_tfVxX vertex [mm] ( LUJETS V[1] ); Float_tfVyY vertex [mm] ( LUJETS V[2] ); Float_tfVzZ vertex [mm] ( LUJETS V[3] ). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Fl",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:9077,Energy Efficiency,energy,energy,9077,"tation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Float_t px); {fPx=px;}. void SetPy(Float_t py); {fPy=py;}. void SetPz(Float_t pz); {fPz=pz;}. void SetEnergy(Float_t energy); {fEnergy=energy;}. void SetMass(Float_t mass); {fMass=mass;}. void SetVx(Float_t vx); {fVx=vx;}. void SetVy(Float_t vy); {fVy=vy;}. void SetVz(Float_t vz); {fVz=vz;}. void SetTime(Float_t time); {fTime=time;}. void SetLifetime(Float_t lifetime); {fLifetime=lifetime;}.  Author: Piotr Golonka 17/09/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/pythia6:$Id: TMCParticle.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:9095,Energy Efficiency,energy,energy,9095,"tation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Float_t px); {fPx=px;}. void SetPy(Float_t py); {fPy=py;}. void SetPz(Float_t pz); {fPz=pz;}. void SetEnergy(Float_t energy); {fEnergy=energy;}. void SetMass(Float_t mass); {fMass=mass;}. void SetVx(Float_t vx); {fVx=vx;}. void SetVy(Float_t vy); {fVy=vy;}. void SetVz(Float_t vz); {fVz=vz;}. void SetTime(Float_t time); {fTime=time;}. void SetLifetime(Float_t lifetime); {fLifetime=lifetime;}.  Author: Piotr Golonka 17/09/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/pythia6:$Id: TMCParticle.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:3112,Modifiability,Inherit,InheritsFrom,3112,"GetEnergy() const; Int_tGetFirstChild() const; virtual const char*TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParent() const; Float_tGetPx() const; Float_tGetPy() const; Float_tGetPz() const; Float_tGetTime() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Float_tGetVx() const; Float_tGetVy() const; Float_tGetVz() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option) const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](si",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:3178,Modifiability,Inherit,InheritsFrom,3178,"TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParent() const; Float_tGetPx() const; Float_tGetPy() const; Float_tGetPz() const; Float_tGetTime() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Float_tGetVx() const; Float_tGetVy() const; Float_tGetVz() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option) const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMCPa",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:7652,Modifiability,Inherit,Inheritance,7652,"xtMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. private:. Float_tfEnergyEnergy [GeV] ( LUJETS P[4] ); Int_tfFirstChildid of first child ( LUJETS K[4] ); Int_tfKFKF flavour code ( LUJETS K[2] ); Int_tfKSstatus of particle ( LUJETS K[1] ); Int_tfLastChildid of last child ( LUJETS K[5] ); Float_tfLifetimeproper lifetime [mm/c] ( LUJETS V[5] ); Float_tfMassMass [Gev/c^2] ( LUJETS P[5] ); Int_tfParentparrent's id ( LUJETS K[3] ); Float_tfPxX momenta [GeV/c] ( LUJETS P[1] ); Float_tfPyY momenta [GeV/c] ( LUJETS P[2] ); Float_tfPzZ momenta [GeV/c] ( LUJETS P[3] ); Float_tfTimetime of procuction [mm/c]( LUJETS V[4] ); Float_tfVxX vertex [mm] ( LUJETS V[1] ); Float_tfVyY vertex [mm] ( LUJETS V[2] ); Float_tfVzZ vertex [mm] ( LUJETS V[3] ). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. ",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:7665,Modifiability,Inherit,Inherited,7665,"xtMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. private:. Float_tfEnergyEnergy [GeV] ( LUJETS P[4] ); Int_tfFirstChildid of first child ( LUJETS K[4] ); Int_tfKFKF flavour code ( LUJETS K[2] ); Int_tfKSstatus of particle ( LUJETS K[1] ); Int_tfLastChildid of last child ( LUJETS K[5] ); Float_tfLifetimeproper lifetime [mm/c] ( LUJETS V[5] ); Float_tfMassMass [Gev/c^2] ( LUJETS P[5] ); Int_tfParentparrent's id ( LUJETS K[3] ); Float_tfPxX momenta [GeV/c] ( LUJETS P[1] ); Float_tfPyY momenta [GeV/c] ( LUJETS P[2] ); Float_tfPzZ momenta [GeV/c] ( LUJETS P[3] ); Float_tfTimetime of procuction [mm/c]( LUJETS V[4] ); Float_tfVxX vertex [mm] ( LUJETS V[1] ); Float_tfVyY vertex [mm] ( LUJETS V[2] ); Float_tfVzZ vertex [mm] ( LUJETS V[3] ). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. ",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:3002,Security,Hash,Hash,3002,"TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEnergy() const; Int_tGetFirstChild() const; virtual const char*TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParent() const; Float_tGetPx() const; Float_tGetPy() const; Float_tGetPz() const; Float_tGetTime() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Float_tGetVx() const; Float_tGetVy() const; Float_tGetVz() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option) const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:6040,Testability,Test,TestBit,6040,"e); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEnergy(Float_t energy); virtual voidSetFirstChild(Int_t first); virtual voidSetKF(Int_t kF); virtual voidSetKS(Int_t kS); virtual voidSetLastChild(Int_t last); virtual voidSetLifetime(Float_t lifetime); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMass(Float_t mass); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(Int_t parent); virtual voidSetPx(Float_t px); virtual voidSetPy(Float_t py); virtual voidSetPz(Float_t pz); virtual voidSetTime(Float_t time); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVx(Float_t vx); virtual voidSetVy(Float_t vy); virtual voidSetVz(Float_t vz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:6079,Testability,Test,TestBits,6079,"e); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEnergy(Float_t energy); virtual voidSetFirstChild(Int_t first); virtual voidSetKF(Int_t kF); virtual voidSetKS(Int_t kS); virtual voidSetLastChild(Int_t last); virtual voidSetLifetime(Float_t lifetime); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMass(Float_t mass); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(Int_t parent); virtual voidSetPx(Float_t px); virtual voidSetPy(Float_t py); virtual voidSetPz(Float_t pz); virtual voidSetTime(Float_t time); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVx(Float_t vx); virtual voidSetVy(Float_t vy); virtual voidSetVz(Float_t vz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCParticle.html:887,Usability,Clear,Clear,887," TMCParticle(); TMCParticle(const TMCParticle&); TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); virtual~TMCParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(con",MatchSource.WIKI,root/html532/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCParticle.html
https://root.cern/root/html532/TMCVerbose.html:1552,Availability,Error,Error,1552,"onst TMCVerbose&); virtual~TMCVerbose(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:1681,Availability,error,error,1681,"idAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:1765,Availability,error,error,1765,"dBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:2759,Modifiability,Inherit,InheritsFrom,2759,"error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitGeometry(); virtual voidInitMC(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp);",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:2825,Modifiability,Inherit,InheritsFrom,2825,"x, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitGeometry(); virtual voidInitMC(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator n",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:5906,Modifiability,Inherit,Inheritance,5906,"nst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidPrintBanner() const; voidPrintStepHeader() const; voidPrintTrackInfo() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfLevelverbose level; Int_tfStepNumbercurrent step number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMCVerbose(Int_t level); Standard constructor. TMCVerbose(); Default constructor. ~TMCVerbose(); Destructor. void PrintBanner() const; Prints banner for track information. void PrintTrackInfo() const; Prints track information. void PrintStepHeader() const; Prints the header for stepping information. void InitMC(); Initialize MC info. void RunMC(Int_t nofEvents); MC run info. void FinishRun(); Finish MC run info. void ConstructGeometry(); Construct geometry info. void ConstructOpGeometry(); Construct geometry for optical physics info. void InitGeometry(); Initialize geometry info. void AddParticles(); Add particles info. void AddIons(); Add ions info. void GeneratePrimaries(); Generate primaries info. void BeginEvent(); Begin event info. void BeginPrimary(); Begin of a primary track info. void PreTrack(); Begin of each track info. void Stepping(); Stepping info. void PostTrack(); Finish of each track info. void FinishPrimary(); Finish o",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:5919,Modifiability,Inherit,Inherited,5919,"nst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidPrintBanner() const; voidPrintStepHeader() const; voidPrintTrackInfo() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfLevelverbose level; Int_tfStepNumbercurrent step number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMCVerbose(Int_t level); Standard constructor. TMCVerbose(); Default constructor. ~TMCVerbose(); Destructor. void PrintBanner() const; Prints banner for track information. void PrintTrackInfo() const; Prints track information. void PrintStepHeader() const; Prints the header for stepping information. void InitMC(); Initialize MC info. void RunMC(Int_t nofEvents); MC run info. void FinishRun(); Finish MC run info. void ConstructGeometry(); Construct geometry info. void ConstructOpGeometry(); Construct geometry for optical physics info. void InitGeometry(); Initialize geometry info. void AddParticles(); Add particles info. void AddIons(); Add ions info. void GeneratePrimaries(); Generate primaries info. void BeginEvent(); Begin event info. void BeginPrimary(); Begin of a primary track info. void PreTrack(); Begin of each track info. void Stepping(); Stepping info. void PostTrack(); Finish of each track info. void FinishPrimary(); Finish o",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:2649,Security,Hash,Hash,2649,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitGeometry(); virtual voidInitMC(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator dele",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:4951,Testability,Test,TestBit,4951,"r* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMCVerbose&operator=(const TMCVerbose&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPostTrack(); virtual voidPreTrack(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidRunMC(Int_t nofEvents); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLevel(Int_t level); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStepping(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:4990,Testability,Test,TestBits,4990,"r* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMCVerbose&operator=(const TMCVerbose&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPostTrack(); virtual voidPreTrack(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidRunMC(Int_t nofEvents); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLevel(Int_t level); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStepping(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMCVerbose.html:944,Usability,Clear,Clear,944," TMCVerbose(); TMCVerbose(Int_t level); TMCVerbose(const TMCVerbose&); virtual~TMCVerbose(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObje",MatchSource.WIKI,root/html532/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMCVerbose.html
https://root.cern/root/html532/TMD5.html:508,Availability,avail,available,508,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4126,Availability,error,error,4126,"Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's mo",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4405,Availability,error,error,4405,"ple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatical",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4639,Availability,error,error,4639,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4946,Availability,error,error,4946,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:766,Deployability,Update,Update,766,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2518,Deployability,Update,Update,2518,"ar* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() block",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2558,Deployability,Update,Update,2558,"ar* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() block",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:3562,Deployability,Update,Update,3562,"ation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case t",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:3146,Energy Efficiency,allocate,allocated,3146,"ious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:292,Integrability,message,message-digest,292,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:701,Integrability,message,message,701,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:1869,Integrability,message,message,1869," array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the;",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:1909,Integrability,message,message,1909," array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the;",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2699,Integrability,message,message-digest,2699," UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII re",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2742,Integrability,message,message,2742," UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII re",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2845,Integrability,message,message-digest,2845,"t[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 oth",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2888,Integrability,message,message,2888,"t[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 oth",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:3020,Integrability,message,message,3020,"ers; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). T",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:3631,Integrability,rout,routine,3631,"ation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case t",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:1986,Modifiability,Inherit,Inheritance,1986,"~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const;",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:1999,Modifiability,Inherit,Inherited,1999,"~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const;",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2313,Safety,avoid,avoids,2313,"ar* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:2457,Safety,avoid,avoids,2457,"eamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algori",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4708,Safety,safe,safely,4708,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:5026,Safety,safe,safely,5026,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:532,Security,Secur,Security,532,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:3503,Security,hash,hash,3503,"essary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const c",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:3920,Security,checksum,checksum,3920,"the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argum",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4220,Security,checksum,checksum,4220,"Int_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4498,Security,checksum,checksum,4498,"an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:4876,Security,checksum,checksum,4876,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }.  Author: Fons Rademakers 29/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMD5.html:567,Testability,test,tested,567,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html532/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMD5.html
https://root.cern/root/html532/TMehrotraSolver.html:2312,Availability,Error,Error,2312,"* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetO",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:2441,Availability,error,error,2441,"taBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::H",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:2525,Availability,error,error,2525," virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:8457,Energy Efficiency,Monitor,Monitor,8457," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator.  Author: Eddy Offermann May 2004  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:8799,Energy Efficiency,monitor,monitor,8799," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator.  Author: Eddy Offermann May 2004  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:3605,Modifiability,Inherit,InheritsFrom,3605,"l voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:3671,Modifiability,Inherit,InheritsFrom,3671,"; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMehrotraSolver&operato",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:8008,Modifiability,Inherit,Inheritance,8008,"ble_tTQpSolverBase::fGamma_fparameters associated with the step length heuristic; Int_tTQpSolverBase::fMaxitmaximum number of iterations allowed; Double_t*TQpSolverBase::fMu_history[fMaxit] history of values of mu obtained on all iterations to date; Double_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator.  Author: Eddy Offermann May 2004  Copyright (C) 1995-2000, Rene Br",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:8021,Modifiability,Inherit,Inherited,8021,"ble_tTQpSolverBase::fGamma_fparameters associated with the step length heuristic; Int_tTQpSolverBase::fMaxitmaximum number of iterations allowed; Double_t*TQpSolverBase::fMu_history[fMaxit] history of values of mu obtained on all iterations to date; Double_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator.  Author: Eddy Offermann May 2004  Copyright (C) 1995-2000, Rene Br",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:8774,Performance,optimiz,optimization,8774," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator.  Author: Eddy Offermann May 2004  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:397,Safety,predict,predictor-corrector,397,". TMehrotraSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  QUADP;  TMehrotraSolver. class TMehrotraSolver: public TQpSolverBase. TMehrotraSolver. Derived class of TQpSolverBase implementing the original Mehrotra; predictor-corrector algorithm. Function Members (Methods); public:. TMehrotraSolver(); TMehrotraSolver(const TMehrotraSolver& another); TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); virtual~TMehrotraSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """");",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:3495,Security,Hash,Hash,3495,", TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:6052,Testability,Test,TestBit,6052,"; static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMehrotraSolver&operator=(const TMehrotraSolver& source); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTQpSolverBase::SetArTol(Double_t ar); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTQpSolverBase::SetMuTol(Double_t m); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tSolve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); virtual voidTQpSolverBase::Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTQpSolverBase::SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:6091,Testability,Test,TestBits,6091,"; static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMehrotraSolver&operator=(const TMehrotraSolver& source); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTQpSolverBase::SetArTol(Double_t ar); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTQpSolverBase::SetMuTol(Double_t m); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tSolve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); virtual voidTQpSolverBase::Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTQpSolverBase::SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMehrotraSolver.html:875,Usability,Clear,Clear,875," TMehrotraSolver(); TMehrotraSolver(const TMehrotraSolver& another); TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); virtual~TMehrotraSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """");",MatchSource.WIKI,root/html532/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html
https://root.cern/root/html532/TMemberInspector.html:684,Availability,avail,available,684,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void G",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberInspector.html:2320,Availability,error,error,2320,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp).  Author: Fons Rademakers 15/07/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberInspector.html:2326,Integrability,message,message,2326,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp).  Author: Fons Rademakers 15/07/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberInspector.html:1581,Modifiability,Inherit,Inheritance,1581,"ss, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj,",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberInspector.html:1594,Modifiability,Inherit,Inherited,1594,"ss, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj,",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberInspector.html:2302,Safety,avoid,avoid,2302,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp).  Author: Fons Rademakers 15/07/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberInspector.html:335,Security,access,accessing,335,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void G",MatchSource.WIKI,root/html532/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberInspector.html
https://root.cern/root/html532/TMemberStreamer.html:877,Modifiability,Inherit,Inheritance,877,". TMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TMemberStreamer. class TMemberStreamer. TMemberStreamer is used to stream a data member. The address passed to operator() will be the address of the data; member. Function Members (Methods); public:. TMemberStreamer(MemberStreamerFunc_t pointer); TMemberStreamer(const TMemberStreamer& rhs); virtual~TMemberStreamer(); virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* pmember, Int_t size = 0); TMemberStreamer&operator=(const TMemberStreamer&); virtual voidSetOnFileClass(const TClass* cl). protected:. TMemberStreamer(). Data Members; private:. TClassReffOnFileClass; MemberStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberStreamer(); {}. TMemberStreamer(MemberStreamerFunc_t pointer); {}. TMemberStreamer(const TMemberStreamer& rhs); {}. virtual ~TMemberStreamer(); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. void operator()(TBuffer& b, void* pmember, Int_t size = 0); The address passed to operator() will be the address of the data member.; If the data member is a variable size array, 'size' is the number of elements; to read/write.  Author: Victor Perev and Philippe Canal 08/05/02  Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *;  Last changed: root/base:$Id: TMemberStreamer.h 25450 2008-09-18 21:13:42Z pcanal $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberStreamer.html
https://root.cern/root/html532/TMemberStreamer.html:890,Modifiability,Inherit,Inherited,890,". TMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TMemberStreamer. class TMemberStreamer. TMemberStreamer is used to stream a data member. The address passed to operator() will be the address of the data; member. Function Members (Methods); public:. TMemberStreamer(MemberStreamerFunc_t pointer); TMemberStreamer(const TMemberStreamer& rhs); virtual~TMemberStreamer(); virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* pmember, Int_t size = 0); TMemberStreamer&operator=(const TMemberStreamer&); virtual voidSetOnFileClass(const TClass* cl). protected:. TMemberStreamer(). Data Members; private:. TClassReffOnFileClass; MemberStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberStreamer(); {}. TMemberStreamer(MemberStreamerFunc_t pointer); {}. TMemberStreamer(const TMemberStreamer& rhs); {}. virtual ~TMemberStreamer(); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. void operator()(TBuffer& b, void* pmember, Int_t size = 0); The address passed to operator() will be the address of the data member.; If the data member is a variable size array, 'size' is the number of elements; to read/write.  Author: Victor Perev and Philippe Canal 08/05/02  Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *;  Last changed: root/base:$Id: TMemberStreamer.h 25450 2008-09-18 21:13:42Z pcanal $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberStreamer.html
https://root.cern/root/html532/TMemberStreamer.html:1415,Modifiability,variab,variable,1415,". TMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TMemberStreamer. class TMemberStreamer. TMemberStreamer is used to stream a data member. The address passed to operator() will be the address of the data; member. Function Members (Methods); public:. TMemberStreamer(MemberStreamerFunc_t pointer); TMemberStreamer(const TMemberStreamer& rhs); virtual~TMemberStreamer(); virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* pmember, Int_t size = 0); TMemberStreamer&operator=(const TMemberStreamer&); virtual voidSetOnFileClass(const TClass* cl). protected:. TMemberStreamer(). Data Members; private:. TClassReffOnFileClass; MemberStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberStreamer(); {}. TMemberStreamer(MemberStreamerFunc_t pointer); {}. TMemberStreamer(const TMemberStreamer& rhs); {}. virtual ~TMemberStreamer(); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. void operator()(TBuffer& b, void* pmember, Int_t size = 0); The address passed to operator() will be the address of the data member.; If the data member is a variable size array, 'size' is the number of elements; to read/write.  Author: Victor Perev and Philippe Canal 08/05/02  Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *;  Last changed: root/base:$Id: TMemberStreamer.h 25450 2008-09-18 21:13:42Z pcanal $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemberStreamer.html
https://root.cern/root/html532/TMemFile.html:3187,Availability,Error,Error,3187,"Int_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:3316,Availability,error,error,3316,"e); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenH",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:3400,Availability,error,error,3400," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetB",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:11065,Availability,Recover,Recover,11065,"size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tTFile::ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:23935,Availability,alive,alive,23935," Libraries. Function documentation; TMemFile(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const char* name, char* buffer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const TMemFile& orig); Copying the content of the TMemFile into another TMemFile. ~TMemFile(); Close and clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:24079,Availability,alive,alive,24079,"ual Constructor. See the TFile constructor for details. TMemFile(const char* name, char* buffer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const TMemFile& orig); Copying the content of the TMemFile into another TMemFile. ~TMemFile(); Close and clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void ResetErrno() const; ResetErrno; simply calls TSystem::ResetErrno(). Long64_t MemRead(Int_t fd, void* buf, Long64_t len) const.  Aut",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:8198,Modifiability,Inherit,InheritsFrom,8198,"t, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Long64_tTFile::GetRelOffset() const; virtual Long64_tTDirectoryFile::GetSeekDir() const; virtual Long64_tTFile::GetSeekFree() const; virtual Long64_tTFile::GetSeekInfo() const; virtual Long64_tTDirectoryFile::GetSeekKeys() const; virtual Long64_tTDirectoryFile::GetSeekParent() const; virtual Long64_tGetSize() const; const TList*TFile::GetStreamerInfoCache(); virtual TList*TFile::GetStreamerInfoList(); virtual const char*TNamed::GetTitle() const; static TFile::EFileTypeTFile::GetType(const char* name, Option_t* option = """", TString* prefix = 0); virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; Int_tTFile::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; static voidTFile::IncrementFileCounter(); virtual voidTFile::IncrementProcessIDs(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTFile::IsArchive() const; Bool_tTFile::IsBinary() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTDirectory::IsFolder() const; virtual Bool_tTDirectoryFile::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTFile::IsOpen() const; Bool_tTFile::IsRaw() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectoryFile::IsWritable() const; Bool_tTObject::IsZombie() const; virtual voidTFile::ls(Option_t* option = """") const; virtual voidTFile::MakeFree(Long64_t first, Long64_t last); virtual voidTFile::MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new"")MENU ; virtual voidTFile::Map()MENU ; virtual Bool_tTFile::Matches(const char* name); voidTObject::MayNotUse(const char* method) const; ",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:8264,Modifiability,Inherit,InheritsFrom,8264,"ong64_tTFile::GetRelOffset() const; virtual Long64_tTDirectoryFile::GetSeekDir() const; virtual Long64_tTFile::GetSeekFree() const; virtual Long64_tTFile::GetSeekInfo() const; virtual Long64_tTDirectoryFile::GetSeekKeys() const; virtual Long64_tTDirectoryFile::GetSeekParent() const; virtual Long64_tGetSize() const; const TList*TFile::GetStreamerInfoCache(); virtual TList*TFile::GetStreamerInfoList(); virtual const char*TNamed::GetTitle() const; static TFile::EFileTypeTFile::GetType(const char* name, Option_t* option = """", TString* prefix = 0); virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; Int_tTFile::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; static voidTFile::IncrementFileCounter(); virtual voidTFile::IncrementProcessIDs(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTFile::IsArchive() const; Bool_tTFile::IsBinary() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTDirectory::IsFolder() const; virtual Bool_tTDirectoryFile::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTFile::IsOpen() const; Bool_tTFile::IsRaw() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectoryFile::IsWritable() const; Bool_tTObject::IsZombie() const; virtual voidTFile::ls(Option_t* option = """") const; virtual voidTFile::MakeFree(Long64_t first, Long64_t last); virtual voidTFile::MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new"")MENU ; virtual voidTFile::Map()MENU ; virtual Bool_tTFile::Matches(const char* name); voidTObject::MayNotUse(const char* method) const; virtual TDirectory*TDirectoryFile::mkdir(const char* name, const c",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:22838,Modifiability,Inherit,Inheritance,22838,"ut stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TMemFile::TMemBlockfBlockListColletion of memory blocks of size fBlockSize; Long64_tfBlockOffsetSeek offset within the block; TMemFile::TMemBlock*fBlockSeekPointer to the block we seeked to.; Long64_tfSizeTotal file size (sum of the size of the chunks); Long64_tfSysOffsetSeek offset in file; static Long64_tfgDefaultBlockSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemFile(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const char* name, char* buffer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const TMemFile& orig); Copying the content of the TMemFile into another TMemFile. ~TMemFile(); Close and clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe ",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:22851,Modifiability,Inherit,Inherited,22851,"ut stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TMemFile::TMemBlockfBlockListColletion of memory blocks of size fBlockSize; Long64_tfBlockOffsetSeek offset within the block; TMemFile::TMemBlock*fBlockSeekPointer to the block we seeked to.; Long64_tfSizeTotal file size (sum of the size of the chunks); Long64_tfSysOffsetSeek offset in file; static Long64_tfgDefaultBlockSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemFile(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const char* name, char* buffer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const TMemFile& orig); Copying the content of the TMemFile into another TMemFile. ~TMemFile(); Close and clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe ",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:12017,Performance,cache,cacheDir,12017,", const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:12144,Performance,cache,cache,12144,"TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:12202,Performance,cache,cache,12202,"ption_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:18439,Performance,cache,cache,18439,,MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:18511,Performance,cache,cache,18511,,MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:19119,Performance,Cache,Cached,19119,"SizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be ",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:20185,Performance,cache,cache,20185,"e!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:20468,Performance,cache,cache,20468,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:21848,Performance,cache,cache,21848,"StringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:21878,Performance,cache,cached,21878,"StringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:21959,Performance,CACHE,CACHEREAD,21959,"StringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:24746,Performance,Perform,Perform,24746,"-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void ResetErrno() const; ResetErrno; simply calls TSystem::ResetErrno(). Long64_t MemRead(Int_t fd, void* buf, Long64_t len) const.  Author: Philippe Canal, May 2011  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TMemFile.h 41423 2011-10-17 17:30:33Z pcanal $  Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:11065,Safety,Recover,Recover,11065,"size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tTFile::ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:13159,Safety,timeout,timeout,13159,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:8004,Security,Hash,Hash,8004,"h() const; virtual const char*TDirectory::GetPathStatic() const; static Int_tTFile::GetReadaheadSize(); virtual Int_tTFile::GetReadCalls() const; Int_tTFile::GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Long64_tTFile::GetRelOffset() const; virtual Long64_tTDirectoryFile::GetSeekDir() const; virtual Long64_tTFile::GetSeekFree() const; virtual Long64_tTFile::GetSeekInfo() const; virtual Long64_tTDirectoryFile::GetSeekKeys() const; virtual Long64_tTDirectoryFile::GetSeekParent() const; virtual Long64_tGetSize() const; const TList*TFile::GetStreamerInfoCache(); virtual TList*TFile::GetStreamerInfoList(); virtual const char*TNamed::GetTitle() const; static TFile::EFileTypeTFile::GetType(const char* name, Option_t* option = """", TString* prefix = 0); virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; Int_tTFile::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; static voidTFile::IncrementFileCounter(); virtual voidTFile::IncrementProcessIDs(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTFile::IsArchive() const; Bool_tTFile::IsBinary() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTDirectory::IsFolder() const; virtual Bool_tTDirectoryFile::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTFile::IsOpen() const; Bool_tTFile::IsRaw() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectoryFile::IsWritable() const; Bool_tTObject::IsZombie() const; virtual voidTFile::ls(Option_t* option = """") const; virtual voidTFile::MakeFree(Long64_t first, Long64_t last); virtual voidTFile::MakeProject(const char*",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:14107,Testability,Test,TestBit,14107,"ged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTFile::UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTFile::Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); virtual Int_tTFile::Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; virtual Bool_tTFile::WriteBuffer(const char* buf, Int_t len); virtual voidTDirectoryFile::WriteDirHeader(); virtual voidTFile::WriteFree(); virtual voidTFile::WriteHeader(); virtual voidTDirectoryFile::WriteKeys(); Int_tTDirectory::WriteObject(const void* obj, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* optio",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:14146,Testability,Test,TestBits,14146,"t(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTFile::UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTFile::Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); virtual Int_tTFile::Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; virtual Bool_tTFile::WriteBuffer(const char* buf, Int_t len); virtual voidTDirectoryFile::WriteDirHeader(); virtual voidTFile::WriteFree(); virtual voidTFile::WriteHeader(); virtual voidTDirectoryFile::WriteKeys(); Int_tTDirectory::WriteObject(const void* obj, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual Int_tTDirectoryFile::WriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* option = """", Int_t bufsize = 0); virtual USho",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:1572,Usability,Clear,Clear,1572,"fer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual~TMemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidTFile::Close(Option_t* option = """")MENU ; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTFile::Copy(TObject&) const; virtual voidCopyTo(TBuffer& tobuf) const; virtual Long64_tCopyTo(void* to, Long64_t maxsize) const; virtual Bool_tTFile::Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tTFile::Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const c",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemFile.html:24913,Usability,simpl,simply,24913,"-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void ResetErrno() const; ResetErrno; simply calls TSystem::ResetErrno(). Long64_t MemRead(Int_t fd, void* buf, Long64_t len) const.  Author: Philippe Canal, May 2011  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TMemFile.h 41423 2011-10-17 17:30:33Z pcanal $  Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemFile.html
https://root.cern/root/html532/TMemStat.html:4489,Availability,Error,Error,4489,,MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:4618,Availability,error,error,4618,"virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:4702,Availability,error,error,4702,"oidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:3043,Deployability,update,updated,3043,"m.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. TMemStat(const TMemStat&); TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidC",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:3063,Deployability,update,update,3063,"t.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. TMemStat(const TMemStat&); TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTO",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:7400,Deployability,update,update,7400,"tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMemStat&operator=(const TMemStat&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:9079,Deployability,update,update,9079," const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveis object attached to MemStat. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); Supported options:; ""gnubuiltin"" - if declared, then MemStat will use gcc build-in function,; otherwise glibc backtrace will be used. Note: Currently MemStat uses a hard-coded output file name (for writing) = ""memstat.root"";. ~TMemStat(); destructor. void Close(); close the TMemStat manager. void Disable(); Disable memory statistics. void Enable(); Enable memory statistics. void Show(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); Show results. TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000).  Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/memstat:$Id: TMemStat.h 36382 2010-10-20 12:27:40Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:395,Energy Efficiency,allocate,allocated,395,". TMemStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  MEMSTAT;  TMemStat. class TMemStat: public TObject. TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMem",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:1713,Integrability,depend,depending,1713,"ot > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of ",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:787,Modifiability,variab,variable,787,". TMemStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  MEMSTAT;  TMemStat. class TMemStat: public TObject. TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMem",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:5582,Modifiability,Inherit,InheritsFrom,5582,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:5648,Modifiability,Inherit,InheritsFrom,5648,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMemStat&operator=(cons",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:8517,Modifiability,Inherit,Inheritance,8517,"); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveis object attached to MemStat. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); Supported options:; ""gnubuiltin"" - if declared, then MemStat will use gcc build-in function,; otherwise glibc backtrace will be used. Note: Currently MemStat uses a hard-coded output file name (for writing) = ""memstat.root"";. ~TMemStat(); destructor. void Close(); close the TMemStat manager. void Disable(); Disable memory statistics. void Enable(); Enable memory statistics. void Show(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); Show results. TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000).  Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/memstat:$Id: TMemStat.h 36382 2010-10-20 12:27:40Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:8530,Modifiability,Inherit,Inherited,8530,"); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveis object attached to MemStat. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); Supported options:; ""gnubuiltin"" - if declared, then MemStat will use gcc build-in function,; otherwise glibc backtrace will be used. Note: Currently MemStat uses a hard-coded output file name (for writing) = ""memstat.root"";. ~TMemStat(); destructor. void Close(); close the TMemStat manager. void Disable(); Disable memory statistics. void Enable(); Enable memory statistics. void Show(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); Show results. TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000).  Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/memstat:$Id: TMemStat.h 36382 2010-10-20 12:27:40Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:5472,Security,Hash,Hash,5472,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:7671,Testability,Test,TestBit,7671,"rtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveis object attached to MemStat. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); Supported options:; ""gnubuiltin"" - if d",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:7710,Testability,Test,TestBits,7710,"rtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveis object attached to MemStat. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); Supported options:; ""gnubuiltin"" - if d",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:2798,Usability,Simpl,Simply,2798,"for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. TMemStat(const TMemStat&); TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObjec",MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStat.html:3884,Usability,Clear,Clear,3884,,MatchSource.WIKI,root/html532/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStat.html
https://root.cern/root/html532/TMemStatShow.html:1232,Availability,Error,Error,1232," TMemStatShow(); TMemStatShow(const TMemStatShow&); virtual~TMemStatShow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:1511,Availability,error,error,1511,"idTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) co",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:1595,Availability,error,error,1595,"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:4506,Deployability,update,update,4506,"t; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMemStatShow&operator=(const TMemStatShow&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); static voidSetAddressRange(Long64_t nbytes = 0, Long64_t first = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetEntryRange(Long64_t nentries = 0, Long64_t first = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:7249,Deployability,update,update,7249,"cess; static TObjArray*fgBtidlistlist of back trace ids; static TCanvas*fgC1pointer to canvas showing allocs/deallocs vs time; static TCanvas*fgC2pointer to canvas with leaks in decreasing order; static TCanvas*fgC3pointer to canvas showing the main leaks; static Long64_tfgEntryFirstfirst entry to process; static Long64_tfgEntryNnumber of entries to process; static TH1D*fgHhistogram with allocations - frees; static TH1D*fgHallochistogram with allocations; static TH1I*fgHdiffhistogram with diff of entry number between alloc/free; static TH1I*fgHentryhistogram with entry numbers in the TObjArray; static TH1D*fgHfreehistogram with frees; static TH1I*fgHleakshistogram with leaks; static TTree*fgTTMemStat Tree; static TGToolTip*fgTip1pointer to tool tip for canvas 1; static TGToolTip*fgTip2pointer to tool tip for canvas 2; static Double_t*fgV1pointer to V1 array of TTree::Draw (pos); static Double_t*fgV2pointer to V2 array of TTree::Draw (nbytes); static Double_t*fgV3pointer to V3 array of TTree::Draw (time); static Double_t*fgV4pointer to V4 array of TTree::Draw (btid). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStatShow(); {;}. virtual ~TMemStatShow(); {;}. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected). void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected). void FillBTString(Int_t bin, Int_t mode, TString& btstring). void SetAddressRange(Long64_t nbytes = 0, Long64_t first = 0). void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0). void Show(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*"").  Author: Rene Brun 21/09/2010  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/treeviewer:$Id: TMemStatShow.h 37300 2010-12-05 17:25:20Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:2542,Modifiability,Inherit,InheritsFrom,2542,"ute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:2608,Modifiability,Inherit,InheritsFrom,2608," voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMemStatShow&operator=(",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:6777,Modifiability,Inherit,Inheritance,6777,"cess; static TObjArray*fgBtidlistlist of back trace ids; static TCanvas*fgC1pointer to canvas showing allocs/deallocs vs time; static TCanvas*fgC2pointer to canvas with leaks in decreasing order; static TCanvas*fgC3pointer to canvas showing the main leaks; static Long64_tfgEntryFirstfirst entry to process; static Long64_tfgEntryNnumber of entries to process; static TH1D*fgHhistogram with allocations - frees; static TH1D*fgHallochistogram with allocations; static TH1I*fgHdiffhistogram with diff of entry number between alloc/free; static TH1I*fgHentryhistogram with entry numbers in the TObjArray; static TH1D*fgHfreehistogram with frees; static TH1I*fgHleakshistogram with leaks; static TTree*fgTTMemStat Tree; static TGToolTip*fgTip1pointer to tool tip for canvas 1; static TGToolTip*fgTip2pointer to tool tip for canvas 2; static Double_t*fgV1pointer to V1 array of TTree::Draw (pos); static Double_t*fgV2pointer to V2 array of TTree::Draw (nbytes); static Double_t*fgV3pointer to V3 array of TTree::Draw (time); static Double_t*fgV4pointer to V4 array of TTree::Draw (btid). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStatShow(); {;}. virtual ~TMemStatShow(); {;}. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected). void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected). void FillBTString(Int_t bin, Int_t mode, TString& btstring). void SetAddressRange(Long64_t nbytes = 0, Long64_t first = 0). void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0). void Show(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*"").  Author: Rene Brun 21/09/2010  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/treeviewer:$Id: TMemStatShow.h 37300 2010-12-05 17:25:20Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:6790,Modifiability,Inherit,Inherited,6790,"cess; static TObjArray*fgBtidlistlist of back trace ids; static TCanvas*fgC1pointer to canvas showing allocs/deallocs vs time; static TCanvas*fgC2pointer to canvas with leaks in decreasing order; static TCanvas*fgC3pointer to canvas showing the main leaks; static Long64_tfgEntryFirstfirst entry to process; static Long64_tfgEntryNnumber of entries to process; static TH1D*fgHhistogram with allocations - frees; static TH1D*fgHallochistogram with allocations; static TH1I*fgHdiffhistogram with diff of entry number between alloc/free; static TH1I*fgHentryhistogram with entry numbers in the TObjArray; static TH1D*fgHfreehistogram with frees; static TH1I*fgHleakshistogram with leaks; static TTree*fgTTMemStat Tree; static TGToolTip*fgTip1pointer to tool tip for canvas 1; static TGToolTip*fgTip2pointer to tool tip for canvas 2; static Double_t*fgV1pointer to V1 array of TTree::Draw (pos); static Double_t*fgV2pointer to V2 array of TTree::Draw (nbytes); static Double_t*fgV3pointer to V3 array of TTree::Draw (time); static Double_t*fgV4pointer to V4 array of TTree::Draw (btid). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStatShow(); {;}. virtual ~TMemStatShow(); {;}. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected). void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected). void FillBTString(Int_t bin, Int_t mode, TString& btstring). void SetAddressRange(Long64_t nbytes = 0, Long64_t first = 0). void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0). void Show(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*"").  Author: Rene Brun 21/09/2010  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/treeviewer:$Id: TMemStatShow.h 37300 2010-12-05 17:25:20Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:2432,Security,Hash,Hash,2432," virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:4777,Testability,Test,TestBit,4777,"oidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); static voidSetAddressRange(Long64_t nbytes = 0, Long64_t first = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetEntryRange(Long64_t nentries = 0, Long64_t first = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static Long64_tfgAddressFirstfirst address to process; static Long64_tfgAddressNnumber of addresses in bytes to process; static TObjArray*fgBtidlistlist of back trace ids; static TCanvas*fgC1pointer to canvas showing allocs/deallocs vs time; static TCanvas*fgC2po",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:4816,Testability,Test,TestBits,4816,"oidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); static voidSetAddressRange(Long64_t nbytes = 0, Long64_t first = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetEntryRange(Long64_t nentries = 0, Long64_t first = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.1, Int_t nbigleaks = 20, const char* fname = ""*""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static Long64_tfgAddressFirstfirst address to process; static Long64_tfgAddressNnumber of addresses in bytes to process; static TObjArray*fgBtidlistlist of back trace ids; static TCanvas*fgC1pointer to canvas showing allocs/deallocs vs time; static TCanvas*fgC2po",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMemStatShow.html:692,Usability,Clear,Clear,692," TMemStatShow(); TMemStatShow(const TMemStatShow&); virtual~TMemStatShow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_",MatchSource.WIKI,root/html532/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMemStatShow.html
https://root.cern/root/html532/TMergerInfo.html:1579,Availability,Error,Error,1579,"TSlave* t, Int_t port, Int_t forHowManyWorkers); virtual~TMergerInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*Get",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:1708,Availability,error,error,1708,"idAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:1792,Availability,error,error,1792,"ppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_t",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:482,Integrability,message,messages,482,". TMergerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  PROOF;  PROOF;  TMergerInfo. class TMergerInfo: public TObject. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the worker servers, it keeps track of how many workers are; running, it keeps track of the workers running status, it broadcasts; messages to all workers, it collects results, etc. Function Members (Methods); public:. TMergerInfo(TSlave* t, Int_t port, Int_t forHowManyWorkers); virtual~TMergerInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) c",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:2804,Modifiability,Inherit,InheritsFrom,2804,"l voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](si",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:2870,Modifiability,Inherit,InheritsFrom,2870,"ual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtu",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:6094,Modifiability,Inherit,Inheritance,6094,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMergerInfo(const TMergerInfo&); TMergerInfo&operator=(const TMergerInfo&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveMerger state; Int_tfMergedObjectsTotal number of objects it must accept from other workers; Int_tfMergedWorkersCurrent number of already merged workers; TSlave*fMergerSlave that acts as merger; Int_tfPortPort number, on which it accepts outputs from other workers; TList*fWorkersList of already assigned workers; Int_tfWorkersToMergeNumber of workers that are merged on this merger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofInterruptHandler& operator=(const TMergerInfo& ). TMergerInfo(const TMergerInfo& ). TMergerInfo(TSlave* t, Int_t port, Int_t forHowManyWorkers); { }. virtual ~TMergerInfo(). void AddWorker(TSlave* sl). TList * GetWorkers(); { return fWorkers; }. TSlave * GetMerger(); { return fMerger; }. Int_t GetPort(); { return fPort; }. Int_t GetWorkersToMerge(); { return fWorkersToMerge; }. Int_t GetMergedWorkers(); { return fMergedWorkers; }. Int_t GetMergedObjects(); { return fMergedObjects; }. void SetMergedWorker(). void AddMergedObjects(Int_t objects); { fMergedObjects += objects; }. Bool_t AreAllWorkersAssigned(). Bool_t AreAllWorkersMerged(). void Deactivate(); { fIsActive = kFALSE; }. Bool_t IsActive(); { return fIsActive; }.  Author: Fons Rademakers 13/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProof.h 39178 2011-05-13 10:30:30Z ganis $  Last generated: 2011-11-03 20:20; This",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:6107,Modifiability,Inherit,Inherited,6107,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMergerInfo(const TMergerInfo&); TMergerInfo&operator=(const TMergerInfo&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIsActiveMerger state; Int_tfMergedObjectsTotal number of objects it must accept from other workers; Int_tfMergedWorkersCurrent number of already merged workers; TSlave*fMergerSlave that acts as merger; Int_tfPortPort number, on which it accepts outputs from other workers; TList*fWorkersList of already assigned workers; Int_tfWorkersToMergeNumber of workers that are merged on this merger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofInterruptHandler& operator=(const TMergerInfo& ). TMergerInfo(const TMergerInfo& ). TMergerInfo(TSlave* t, Int_t port, Int_t forHowManyWorkers); { }. virtual ~TMergerInfo(). void AddWorker(TSlave* sl). TList * GetWorkers(); { return fWorkers; }. TSlave * GetMerger(); { return fMerger; }. Int_t GetPort(); { return fPort; }. Int_t GetWorkersToMerge(); { return fWorkersToMerge; }. Int_t GetMergedWorkers(); { return fMergedWorkers; }. Int_t GetMergedObjects(); { return fMergedObjects; }. void SetMergedWorker(). void AddMergedObjects(Int_t objects); { fMergedObjects += objects; }. Bool_t AreAllWorkersAssigned(). Bool_t AreAllWorkersMerged(). void Deactivate(); { fIsActive = kFALSE; }. Bool_t IsActive(); { return fIsActive; }.  Author: Fons Rademakers 13/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProof.h 39178 2011-05-13 10:30:30Z ganis $  Last generated: 2011-11-03 20:20; This",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:2694,Security,Hash,Hash,2694,"ams, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:4810,Testability,Test,TestBit,4810,"Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMergedWorker(); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:4849,Testability,Test,TestBits,4849,"Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMergedWorker(); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMergerInfo.html:1021,Usability,Clear,Clear,1021," TMergerInfo(TSlave* t, Int_t port, Int_t forHowManyWorkers); virtual~TMergerInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) c",MatchSource.WIKI,root/html532/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMergerInfo.html
https://root.cern/root/html532/TMessage.html:2673,Availability,Error,Error,2673,"lassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetD",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:2802,Availability,error,error,2802," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObj",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:2886,Availability,error,error,2886,"l TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtu",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23981,Availability,error,error,23981,"at was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 ",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:24229,Availability,error,error,24229,"(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects ca",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:297,Integrability,Message,Message,297,". TMessage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TMessage. class TMessage: public TBufferFile. TMessage. Message buffer class used for serializing objects and sending them; over a network. This class inherits from TBuffer the basic I/O; serializer. Function Members (Methods); public:. TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); virtual~TMessage(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTBufferFile::ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tTBufferFile::ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) cons",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21170,Integrability,message,message,21170,"ading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only i",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21282,Integrability,message,message,21282,"ading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only i",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21371,Integrability,message,message,21371,"ading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only i",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21916,Integrability,message,message,21916,"ReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteI",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21948,Integrability,message,message,21948,"buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writin",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21979,Integrability,Message,MessageTypes,21979,"buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writin",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22014,Integrability,message,message,22014,":fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was re",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22062,Integrability,message,message,22062,":fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was re",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22158,Integrability,message,message,22158,"e message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22310,Integrability,message,message,22310,"r*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message leng",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22382,Integrability,message,message,22382,"r*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message leng",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22558,Integrability,message,message,22558," WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kM",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:22985,Integrability,message,message,22985,"OOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the mess",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23101,Integrability,message,message,23101,"are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise re",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23241,Integrability,message,message,23241,"g process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwi",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23324,Integrability,message,message,23324,"ed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support fo",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23363,Integrability,message,message,23363,"ed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support fo",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23491,Integrability,message,message,23491," reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSock",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23561,Integrability,message,message,23561,". ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to st",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23844,Integrability,message,message,23844,"ction returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. USh",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23857,Integrability,message,message,23857,"VirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is alre",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:23934,Integrability,message,message,23934,"VirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is alre",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:24024,Integrability,message,message,24024,"at was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 ",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:24136,Integrability,message,message,24136,"amerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompre",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:24149,Integrability,message,message,24149,"he StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() co",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:24303,Integrability,message,message,24303,"t again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects cannot be copied or assigned. void operator=(const TMessag",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:24916,Integrability,message,message,24916,"e compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects cannot be copied or assigned. void operator=(const TMessage& ). Bool_t TestBitNumber(UInt_t bitnumber) const; used by friend TSocket. { return fBitsPIDs.TestBitNumber(bitnumber); }. TClass * GetClass() const; { return fClass;}. void Reset(). UInt_t What() const; { return fWhat; }. void EnableSchemaEvolution(Bool_t enable = kTRUE); { fEvolution = enable; }. Bool_t UsesSchemaEvolution() const; { return fEvolution; }. char * CompBuffer() const; { return fBufComp; }. Int_t CompLength() const; { return (Int_t)(fBufCompCur - fBufComp); }.  Author: Fons Rademakers 19/12/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: ",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:392,Modifiability,inherit,inherits,392,". TMessage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TMessage. class TMessage: public TBufferFile. TMessage. Message buffer class used for serializing objects and sending them; over a network. This class inherits from TBuffer the basic I/O; serializer. Function Members (Methods); public:. TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); virtual~TMessage(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTBufferFile::ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tTBufferFile::ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) cons",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:4866,Modifiability,Inherit,InheritsFrom,4866,":GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:4932,Modifiability,Inherit,InheritsFrom,4932,"able* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTOb",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:20944,Modifiability,extend,extending,20944,"MaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of me",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21678,Modifiability,Inherit,Inheritance,21678,"write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disab",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:21691,Modifiability,Inherit,Inherited,21691,"write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disab",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:20091,Performance,cache,cache,20091,"amedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fB",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:4687,Security,Hash,Hash,4687,"atic Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virt",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:14141,Testability,Test,TestBit,14141,"SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); virtual voidTBufferFile::SetStreamerElementNumber(Int_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetWhat(UInt_t what); voidTBuffer::SetWriteMode(); virtual voidTBufferFile::SetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp); virtual voidTBufferFile::SkipObjectAny(); virtual voidTBufferFile::SkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTBufferFile::StreamObject(TObject* obj); virtual voidTBufferFile::StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tUncompress(); virtual voidTObject::UseCurrentStyle(); Bool_tUsesSchemaEvolution() const; static Bool_tUsesSchemaEvolutionForAll(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; UInt_tWhat() const; virtual voidTBufferFile::WriteArray(const Bool_t* b, Int_t n); virtual voidTBufferFile::WriteArray(const Char_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const UChar_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const Short_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const UShort_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const Int_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const UInt_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const Long_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Long64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong64_t* ll, Int_t n); virt",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:14180,Testability,Test,TestBits,14180,"func = 0); virtual voidTBufferFile::SetStreamerElementNumber(Int_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetWhat(UInt_t what); voidTBuffer::SetWriteMode(); virtual voidTBufferFile::SetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp); virtual voidTBufferFile::SkipObjectAny(); virtual voidTBufferFile::SkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTBufferFile::StreamObject(TObject* obj); virtual voidTBufferFile::StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tUncompress(); virtual voidTObject::UseCurrentStyle(); Bool_tUsesSchemaEvolution() const; static Bool_tUsesSchemaEvolutionForAll(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; UInt_tWhat() const; virtual voidTBufferFile::WriteArray(const Bool_t* b, Int_t n); virtual voidTBufferFile::WriteArray(const Char_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const UChar_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const Short_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const UShort_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const Int_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const UInt_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const Long_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Long64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong64_t* ll, Int_t n); virtual voidTBufferFile::WriteArray(const Fl",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:25296,Testability,Test,TestBitNumber,25296,"mpress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects cannot be copied or assigned. void operator=(const TMessage& ). Bool_t TestBitNumber(UInt_t bitnumber) const; used by friend TSocket. { return fBitsPIDs.TestBitNumber(bitnumber); }. TClass * GetClass() const; { return fClass;}. void Reset(). UInt_t What() const; { return fWhat; }. void EnableSchemaEvolution(Bool_t enable = kTRUE); { fEvolution = enable; }. Bool_t UsesSchemaEvolution() const; { return fEvolution; }. char * CompBuffer() const; { return fBufComp; }. Int_t CompLength() const; { return (Int_t)(fBufCompCur - fBufComp); }.  Author: Fons Rademakers 19/12/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/net:$Id: TMessage.h 41637 2011-10-28 15:34:35Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:25378,Testability,Test,TestBitNumber,25378,"mpress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects cannot be copied or assigned. void operator=(const TMessage& ). Bool_t TestBitNumber(UInt_t bitnumber) const; used by friend TSocket. { return fBitsPIDs.TestBitNumber(bitnumber); }. TClass * GetClass() const; { return fClass;}. void Reset(). UInt_t What() const; { return fWhat; }. void EnableSchemaEvolution(Bool_t enable = kTRUE); { fEvolution = enable; }. Bool_t UsesSchemaEvolution() const; { return fEvolution; }. char * CompBuffer() const; { return fBufComp; }. Int_t CompLength() const; { return (Int_t)(fBufCompCur - fBufComp); }.  Author: Fons Rademakers 19/12/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/net:$Id: TMessage.h 41637 2011-10-28 15:34:35Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessage.html:1860,Usability,Clear,Clear,1860,"ionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TOb",MatchSource.WIKI,root/html532/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessage.html
https://root.cern/root/html532/TMessageHandler.html:853,Availability,Error,Errors,853,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:4145,Availability,Error,Error,4145,"(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat();",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:4274,Availability,error,error,4274,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGet",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:4358,Availability,error,error,4358,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTotalMessageCount() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tHandleD",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:682,Deployability,install,install,682,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:346,Integrability,message,messages,346,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:450,Integrability,message,messages,450,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:570,Integrability,message,message,570,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:623,Integrability,message,message,623,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:665,Integrability,message,message,665,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:704,Integrability,message,message,704,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:734,Integrability,message,message,734,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:829,Integrability,message,message,829,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:875,Integrability,message,message,875,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:924,Integrability,message,message,924,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:970,Integrability,message,message,970,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:6442,Integrability,Message,Message,6442,"_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidNotified()SIGNAL ; virtual Bool_tNotify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidRemoved()SIGNAL ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:9674,Integrability,message,message,9674,"lot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:9722,Integrability,message,message,9722,"lot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:9760,Integrability,message,messages,9760,"lot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10065,Integrability,message,message,10065,"lot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10214,Integrability,message,messages,10214,"lot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10514,Integrability,message,message,10514,"idObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10570,Integrability,message,message,10570,"idObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10658,Integrability,message,message,10658,"s for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fo",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10720,Integrability,message,message,10720,"s for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fo",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10759,Integrability,message,message,10759,"o for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last gene",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10790,Integrability,message,messages,10790,"o for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last gene",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10871,Integrability,message,message,10871,"to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10954,Integrability,message,messages,10954,"ect; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:11020,Integrability,message,message,11020,"id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:11216,Integrability,message,message,11216,"id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:11260,Integrability,message,message,11260,"id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:11293,Integrability,message,messages,11293,"id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }.  Author: Rene Brun 11/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMessageHandler.h 22415 2008-03-01 11:00:27Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:5776,Modifiability,Inherit,InheritsFrom,5776," char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTotalMessageCount() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tHandleDerived() const; virtual voidHandleMessage(Int_t id, const TObject* obj); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidNotified()SIGNAL ; virtual Bool_tNotify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); stati",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:5842,Modifiability,Inherit,InheritsFrom,5842,"Signals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTotalMessageCount() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tHandleDerived() const; virtual voidHandleMessage(Int_t id, const TObject* obj); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidNotified()SIGNAL ; virtual Bool_tNotify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTO",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10365,Modifiability,Inherit,Inheritance,10365,"tatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:10378,Modifiability,Inherit,Inherited,10378,"tatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. virtual ~TMessageHandler(). Int_t GetSize",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:609,Security,access,access,609,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:5578,Security,Hash,Hash,5578,"ct::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTotalMessageCount() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tHandleDerived() const; virtual voidHandleMessage(Int_t id, const TObject* obj); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidNotified()SIGNAL ; virtual Bool_tNotify(); virtual Int_tTQObject::NumberOfConnections() const;",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:819,Testability,log,logged,819,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:865,Testability,log,logged,865,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:914,Testability,log,logged,914,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:960,Testability,log,logged,960,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:8348,Testability,Test,TestBit,8348,"ovedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidRemoved()SIGNAL ; voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:8387,Testability,Test,TestBits,8387,"ovedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidRemoved()SIGNAL ; voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMessageHandler.html:1693,Usability,Clear,Clear,1693," TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html532/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMessageHandler.html
https://root.cern/root/html532/TMethod.html:1456,Availability,Error,Error,1456," TMethod(const TMethod& org); TMethod(MethodInfo_t* info = 0, TClass* cl = 0); virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObj",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:1585,Availability,error,error,1585,"d(const TMethod& org); TMethod(MethodInfo_t* info = 0, TClass* cl = 0); virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClass() const; virtual const char*GetCommentString(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:1669,Availability,error,error,1669,"hod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClass() const; virtual const char*GetCommentString(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:6969,Deployability,TOGGLE,TOGGLE,6969,"har* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. virtual voidCreateSignature(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MethodInfo_t*TFunction::fInfopointer to CINT function info; TStringTFunction::fMangledNameMangled name as determined by CINT.; TList*TFunction::fMethodArgslist of function arguments; TStringTNamed::fNameobject identifier; TStringTFunction::fSignaturestring containing function signature; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to the class; TStringfGetterstate getter in case this is a *TOGGLE method; TMethodCall*fGetterMethodmethodcall for state getter in case this is a *TOGGLE method; EMenuItemKindfMenuItemtype of menuitem in context menu; TMethodCall*fSetterMethodmethodcall for state setter in case this is a *TOGGLE method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethod(MethodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last a",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:7056,Deployability,TOGGLE,TOGGLE,7056,"har* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. virtual voidCreateSignature(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MethodInfo_t*TFunction::fInfopointer to CINT function info; TStringTFunction::fMangledNameMangled name as determined by CINT.; TList*TFunction::fMethodArgslist of function arguments; TStringTNamed::fNameobject identifier; TStringTFunction::fSignaturestring containing function signature; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to the class; TStringfGetterstate getter in case this is a *TOGGLE method; TMethodCall*fGetterMethodmethodcall for state getter in case this is a *TOGGLE method; EMenuItemKindfMenuItemtype of menuitem in context menu; TMethodCall*fSetterMethodmethodcall for state setter in case this is a *TOGGLE method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethod(MethodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last a",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:7199,Deployability,TOGGLE,TOGGLE,7199,"har* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. virtual voidCreateSignature(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MethodInfo_t*TFunction::fInfopointer to CINT function info; TStringTFunction::fMangledNameMangled name as determined by CINT.; TList*TFunction::fMethodArgslist of function arguments; TStringTNamed::fNameobject identifier; TStringTFunction::fSignaturestring containing function signature; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to the class; TStringfGetterstate getter in case this is a *TOGGLE method; TMethodCall*fGetterMethodmethodcall for state getter in case this is a *TOGGLE method; EMenuItemKindfMenuItemtype of menuitem in context menu; TMethodCall*fSetterMethodmethodcall for state setter in case this is a *TOGGLE method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethod(MethodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last a",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:8416,Deployability,TOGGLE,TOGGLE,8416,"hodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 are data fields in the same class.; (""pointers"" to data members). TMethodCall * GetterMethod(); Return call environment for the getter method in case this is a; *TOGGLE method (for the context menu). TMethodCall * SetterMethod(); Return call environment for this method in case this is a; *TOGGLE method which takes a single boolean or integer argument. TList * GetListOfMethodArgs(); Returns methodarg list and additionally updates fDataMember in TMethod by; calling FindDataMember();. TClass * GetClass() const; { return fClass; }. EMenuItemKind IsMenuItem() const; { return fMenuItem; }. const char * Getter() const; { return fGetter; }. void SetMenuItem(EMenuItemKind menuItem); {fMenuItem=menuItem;}.  Author: Rene Brun 09/02/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TMethod.h 24077 2008-05-31 19:39:09Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:8544,Deployability,TOGGLE,TOGGLE,8544,"hodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 are data fields in the same class.; (""pointers"" to data members). TMethodCall * GetterMethod(); Return call environment for the getter method in case this is a; *TOGGLE method (for the context menu). TMethodCall * SetterMethod(); Return call environment for this method in case this is a; *TOGGLE method which takes a single boolean or integer argument. TList * GetListOfMethodArgs(); Returns methodarg list and additionally updates fDataMember in TMethod by; calling FindDataMember();. TClass * GetClass() const; { return fClass; }. EMenuItemKind IsMenuItem() const; { return fMenuItem; }. const char * Getter() const; { return fGetter; }. void SetMenuItem(EMenuItemKind menuItem); {fMenuItem=menuItem;}.  Author: Rene Brun 09/02/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TMethod.h 24077 2008-05-31 19:39:09Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:8679,Deployability,update,updates,8679,"hodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 are data fields in the same class.; (""pointers"" to data members). TMethodCall * GetterMethod(); Return call environment for the getter method in case this is a; *TOGGLE method (for the context menu). TMethodCall * SetterMethod(); Return call environment for this method in case this is a; *TOGGLE method which takes a single boolean or integer argument. TList * GetListOfMethodArgs(); Returns methodarg list and additionally updates fDataMember in TMethod by; calling FindDataMember();. TClass * GetClass() const; { return fClass; }. EMenuItemKind IsMenuItem() const; { return fMenuItem; }. const char * Getter() const; { return fGetter; }. void SetMenuItem(EMenuItemKind menuItem); {fMenuItem=menuItem;}.  Author: Rene Brun 09/02/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TMethod.h 24077 2008-05-31 19:39:09Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:3369,Integrability,Interface,InterfaceMethod,3369," TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TFunction::GetPrototype() const; const char*TFunction::GetReturnTypeName() const; const char*TFunction::GetSignature(); virtual const char*Getter() const; virtual TMethodCall*GetterMethod(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; void*TFunction::InterfaceMethod() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; EMenuItemKindIsMenuItem() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethod&operator=(const TMethod& rhs); virtual vo",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:3206,Modifiability,Inherit,InheritsFrom,3206," type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TFunction::GetPrototype() const; const char*TFunction::GetReturnTypeName() const; const char*TFunction::GetSignature(); virtual const char*Getter() const; virtual TMethodCall*GetterMethod(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; void*TFunction::InterfaceMethod() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; EMenuItemKindIsMenuItem() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:3272,Modifiability,Inherit,InheritsFrom,3272,"onst; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TFunction::GetPrototype() const; const char*TFunction::GetReturnTypeName() const; const char*TFunction::GetSignature(); virtual const char*Getter() const; virtual TMethodCall*GetterMethod(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; void*TFunction::InterfaceMethod() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; EMenuItemKindIsMenuItem() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); vo",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:7228,Modifiability,Inherit,Inheritance,7228,"Map; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MethodInfo_t*TFunction::fInfopointer to CINT function info; TStringTFunction::fMangledNameMangled name as determined by CINT.; TList*TFunction::fMethodArgslist of function arguments; TStringTNamed::fNameobject identifier; TStringTFunction::fSignaturestring containing function signature; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to the class; TStringfGetterstate getter in case this is a *TOGGLE method; TMethodCall*fGetterMethodmethodcall for state getter in case this is a *TOGGLE method; EMenuItemKindfMenuItemtype of menuitem in context menu; TMethodCall*fSetterMethodmethodcall for state setter in case this is a *TOGGLE method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethod(MethodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 ",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:7241,Modifiability,Inherit,Inherited,7241,"Map; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MethodInfo_t*TFunction::fInfopointer to CINT function info; TStringTFunction::fMangledNameMangled name as determined by CINT.; TList*TFunction::fMethodArgslist of function arguments; TStringTNamed::fNameobject identifier; TStringTFunction::fSignaturestring containing function signature; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to the class; TStringfGetterstate getter in case this is a *TOGGLE method; TMethodCall*fGetterMethodmethodcall for state getter in case this is a *TOGGLE method; EMenuItemKindfMenuItemtype of menuitem in context menu; TMethodCall*fSetterMethodmethodcall for state setter in case this is a *TOGGLE method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethod(MethodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 ",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:3096,Security,Hash,Hash,3096,"atic TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TFunction::GetPrototype() const; const char*TFunction::GetReturnTypeName() const; const char*TFunction::GetSignature(); virtual const char*Getter() const; virtual TMethodCall*GetterMethod(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; void*TFunction::InterfaceMethod() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; EMenuItemKindIsMenuItem() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static void",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:5628,Testability,Test,TestBit,5628,"idTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethod&operator=(const TMethod& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tTFunction::Property() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetMenuItem(EMenuItemKind menuItem); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual TMethodCall*SetterMethod(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:5667,Testability,Test,TestBits,5667,"idTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethod&operator=(const TMethod& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tTFunction::Property() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetMenuItem(EMenuItemKind menuItem); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual TMethodCall*SetterMethod(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethod.html:921,Usability,Clear,Clear,921," TMethod(const TMethod& org); TMethod(MethodInfo_t* info = 0, TClass* cl = 0); virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObj",MatchSource.WIKI,root/html532/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethod.html
https://root.cern/root/html532/TMethodArg.html:1477,Availability,Error,Error,1477," TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:1606,Availability,error,error,1606,"MethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:1690,Availability,error,error,1690,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:2942,Modifiability,Inherit,InheritsFrom,2942,"st; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:3008,Modifiability,Inherit,InheritsFrom,3008," TDataMember*GetDataMember() const; const char*GetDefault() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pain",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:6427,Modifiability,Inherit,Inheritance,6427,"const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMethodArg(const TMethodArg&); TMethodArg&operator=(const TMethodArg&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TDataMember*fDataMemberTDataMember pointed by this arg,to get values and options from.; MethodArgInfo_t*fInfopointer to CINT method argument info; TFunction*fMethodpointer to the method or global function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to spec",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:6440,Modifiability,Inherit,Inherited,6440,"const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMethodArg(const TMethodArg&); TMethodArg&operator=(const TMethodArg&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TDataMember*fDataMemberTDataMember pointed by this arg,to get values and options from.; MethodArgInfo_t*fInfopointer to CINT method argument info; TFunction*fMethodpointer to the method or global function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to spec",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:2832,Security,Hash,Hash,2832,"t) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:5155,Testability,Test,TestBit,5155,"const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:5194,Testability,Test,TestBits,5194,"const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:934,Usability,Clear,Clear,934," TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodArg.html:7812,Usability,learn,learn,7812,"udes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }.  Author: Rene Brun 04/02/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TMethodArg.h 25986 2008-10-28 08:39:44Z brun $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodArg.html
https://root.cern/root/html532/TMethodBrowsable.html:3076,Availability,Error,Error,3076,,MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:3205,Availability,error,error,3205,"hodBrowsable(const TMethodBrowsable&); virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObje",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:3289,Availability,error,error,3289,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:10579,Integrability,Wrap,Wrapper,10579,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:10688,Integrability,depend,depending,10688,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:10756,Integrability,Wrap,Wrapper,10756,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:10865,Integrability,depend,depending,10865,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:435,Modifiability,extend,extend,435,". TMethodBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:4745,Modifiability,Inherit,InheritsFrom,4745," const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; static Bool_tIsMethodBrowsable(const TMethod* m); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:4811,Modifiability,Inherit,InheritsFrom,4811,"Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; static Bool_tIsMethodBrowsable(const TMethod* m); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:8827,Modifiability,Inherit,Inheritance,8827,"* b, const TVirtualBranchBrowsable* parent, TClass*& contained); static list<MethodCreateListOfBrowsables_t>&TVirtualBranchBrowsable::GetRegisteredGenerators(); voidTObject::MakeZombie(); static voidTVirtualBranchBrowsable::RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); voidTVirtualBranchBrowsable::SetType(TClass* type); voidTVirtualBranchBrowsable::SetTypeIsPointer(Bool_t set = kTRUE); static voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and ret",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:8840,Modifiability,Inherit,Inherited,8840,"* b, const TVirtualBranchBrowsable* parent, TClass*& contained); static list<MethodCreateListOfBrowsables_t>&TVirtualBranchBrowsable::GetRegisteredGenerators(); voidTObject::MakeZombie(); static voidTVirtualBranchBrowsable::RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); voidTVirtualBranchBrowsable::SetType(TClass* type); voidTVirtualBranchBrowsable::SetTypeIsPointer(Bool_t set = kTRUE); static voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and ret",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:1162,Performance,cache,cached,1162,"ROOT;  TREE;  TREE;  TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:1223,Performance,cache,cached,1223,"ROOT;  TREE;  TREE;  TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const ",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:4635,Security,Hash,Hash,4635,"Object*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; static Bool_tIsMethodBrowsable(const TMethod* m); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject:",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:10400,Security,access,access,10400,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $  Last generated: 2011-11-03 20:20; This page h",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:10430,Security,access,access,10430,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $  Last generated: 2011-11-03 20:20; This page h",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:7060,Testability,Test,TestBit,7060,"oid* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRegister(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTVirtualBranchBrowsable::TypeIsPointer() const; static voidUnregister(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:7099,Testability,Test,TestBits,7099,"oid* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRegister(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTVirtualBranchBrowsable::TypeIsPointer() const; static voidUnregister(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:1410,Usability,simpl,simple,1410,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const TMethodBrowsable&); virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Brow",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:2533,Usability,Clear,Clear,2533,,MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodBrowsable.html:9084,Usability,simpl,simple,9084,"tualBranchBrowsable::RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); voidTVirtualBranchBrowsable::SetType(TClass* type); voidTVirtualBranchBrowsable::SetTypeIsPointer(Bool_t set = kTRUE); static voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being brows",MatchSource.WIKI,root/html532/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html
https://root.cern/root/html532/TMethodCall.html:1771,Availability,Error,Error,1771,"l(); TMethodCall(const TMethodCall& org); TMethodCall(const char* function, const char* params); TMethodCall(TClass* cl, const char* method, const char* params); virtual~TMethodCall(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCallDtorOnly(Bool_t set = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(); voidExecute(void* object); voidExecute(const char* params); voidExecute(Long_t& retLong); voidExecute(Double_t& retDouble); voidExecute(void* object, const char* params); voidExecute(void* object, Long_t& retLong); voidExecute(void* object, Double_t& retDouble); voidExecute(void* object, char** retText); voidExecute(const char* params, Long_t& retLong); voidExecute(const char* params, Double_t& retDouble); voidExecute(void* object, const char* params, Long_t& retLong); voidExecute(void* object, const char* params, Double_t& retDouble); voidExecute(void* object, const char* params, char** retText); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTO",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:7937,Energy Efficiency,efficient,efficient,7937,"kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TClass*fClasspointer to the class info; Bool_tfDtorOnlycall only dtor and not delete when calling ~xxx; CallFunc_t*fFuncCINT method invocation environment; TFunction*fMetPtrpointer to the method or function info; TStringfMethodmethod name; Long_tfOffsetoffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Exe",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:8262,Energy Efficiency,efficient,efficient,8262,"ffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than ca",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:8891,Energy Efficiency,efficient,efficient,8891," two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execut",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:9261,Energy Efficiency,efficient,efficient,9261,"calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpr",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:9842,Energy Efficiency,efficient,efficient,9842,"his two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* obj",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:10224,Energy Efficiency,efficient,efficient,10224," method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* par",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:334,Integrability,interface,interface,334,". TMethodCall. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TMethodCall. class TMethodCall: public TObject. TMethodCall. Method or function calling interface. Objects of this class contain; the (CINT) environment to call a global function or a method for an; object of a specific class with the desired arguments. This class is; espicially useful when a method has to be called more times for; different objects and/or with different arguments. If a function or; method needs to be called only once one better uses; TInterpreter::Execute(). Function Members (Methods); public:. TMethodCall(); TMethodCall(const TMethodCall& org); TMethodCall(const char* function, const char* params); TMethodCall(TClass* cl, const char* method, const char* params); virtual~TMethodCall(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCallDtorOnly(Bool_t set = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(); voidExecute(void* object); voidExecute(const char* params); voidExecute(Long_t& retLong); voidExecute(Double_t& retDouble); voidExecute(void* object, const char* ",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:3428,Modifiability,Inherit,InheritsFrom,3428,"retText); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TFunction*GetMethod(); const char*GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetParams() const; const char*GetProto() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInit(const char* function, const char* params); voidInit(TClass* cl, const char* method, const char* params); voidInitWithPrototype(const char* function, const char* proto); voidInitWithPrototype(TClass* cl, const char* method, const char* proto); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator d",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:3494,Modifiability,Inherit,InheritsFrom,3494," Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TFunction*GetMethod(); const char*GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetParams() const; const char*GetProto() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInit(const char* function, const char* params); voidInit(TClass* cl, const char* method, const char* params); voidInitWithPrototype(const char* function, const char* proto); voidInitWithPrototype(TClass* cl, const char* method, const char* proto); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:7462,Modifiability,Inherit,Inheritance,7462,"nt* = 0); virtual voidExecute(TMethod*, TObjArray*, int* = 0); voidInitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo). Data Members; public:. enum EReturnType { kLong; kDouble; kString; kOther; kNone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TClass*fClasspointer to the class info; Bool_tfDtorOnlycall only dtor and not delete when calling ~xxx; CallFunc_t*fFuncCINT method invocation environment; TFunction*fMetPtrpointer to the method or function info; TStringfMethodmethod name; Long_tfOffsetoffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. ",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:7475,Modifiability,Inherit,Inherited,7475,"nt* = 0); virtual voidExecute(TMethod*, TObjArray*, int* = 0); voidInitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo). Data Members; public:. enum EReturnType { kLong; kDouble; kString; kOther; kNone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TClass*fClasspointer to the class info; Bool_tfDtorOnlycall only dtor and not delete when calling ~xxx; CallFunc_t*fFuncCINT method invocation environment; TFunction*fMetPtrpointer to the method or function info; TStringfMethodmethod name; Long_tfOffsetoffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. ",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:10618,Performance,cache,cached,10618,"lize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(void* object, char** retText); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, char** retText); Execute the method for the specified object and argument values. void SetParamPtrs(voi",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:3318,Security,Hash,Hash,3318,"cute(void* object, const char* params, Double_t& retDouble); voidExecute(void* object, const char* params, char** retText); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TFunction*GetMethod(); const char*GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetParams() const; const char*GetProto() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInit(const char* function, const char* params); voidInit(TClass* cl, const char* method, const char* params); voidInitWithPrototype(const char* function, const char* proto); voidInitWithPrototype(TClass* cl, const char* method, const char* proto); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, ",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:5930,Testability,Test,TestBit,5930,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethodCall&operator=(const TMethodCall& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetParam(); TMethodCall::EReturnTypeReturnType(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetParam(Long_t l); voidSetParam(Double_t d); voidSetParam(Long64_t ll); voidSetParam(ULong64_t ull); voidSetParamPtrs(void* paramArr, Int_t nparam = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:5969,Testability,Test,TestBits,5969,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethodCall&operator=(const TMethodCall& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetParam(); TMethodCall::EReturnTypeReturnType(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetParam(Long_t l); voidSetParam(Double_t d); voidSetParam(Long64_t ll); voidSetParam(ULong64_t ull); voidSetParamPtrs(void* paramArr, Int_t nparam = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:1240,Usability,Clear,Clear,1240," TMethodCall(); TMethodCall(const TMethodCall& org); TMethodCall(const char* function, const char* params); TMethodCall(TClass* cl, const char* method, const char* params); virtual~TMethodCall(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCallDtorOnly(Bool_t set = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(); voidExecute(void* object); voidExecute(const char* params); voidExecute(Long_t& retLong); voidExecute(Double_t& retDouble); voidExecute(void* object, const char* ",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMethodCall.html:10390,Usability,usab,usable,10390,"lementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(vo",MatchSource.WIKI,root/html532/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMethodCall.html
https://root.cern/root/html532/TMinuit.html:3439,Availability,down,down,3439,"lected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4111,Availability,error,error,4111,"mit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakn",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4176,Availability,error,error,4176,"mit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakn",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4223,Availability,error,errors,4223,"mit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakn",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4798,Availability,error,error,4798,"value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:6445,Availability,error,errors,6445,"imits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels s",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:6562,Availability,error,error,6562,"n the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:6594,Availability,error,errors,6594,"n the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:6811,Availability,error,errors,6811,"ause the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carri",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:6949,Availability,error,error,6949,"if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given po",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:6988,Availability,error,error,6988," to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by t",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7034,Availability,error,errors,7034," to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by t",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7109,Availability,Error,Errors,7109,"r can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7170,Availability,reliab,reliability,7170,"/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indic",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7195,Availability,error,error,7195,"/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indic",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7387,Availability,error,error,7387,"F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7707,Availability,Reliab,Reliability,7707,"ore common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7729,Availability,error,error,7729,"ore common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:7819,Availability,error,errors,7819,". Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlat",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8066,Availability,error,errors,8066,"retation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which ha",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8162,Availability,error,error,8162,"MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so h",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8211,Availability,reliab,reliable,8211,"MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so h",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8281,Availability,ERROR,ERROR,8281,"h as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliab",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8348,Availability,ERROR,ERROR,8348,"h as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliab",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8527,Availability,error,errors,8527,"ort DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them,",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8729,Availability,error,error,8729,"liability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8746,Availability,Failure,Failure,8746," carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far aw",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9134,Availability,error,errors,9134," there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9331,Availability,error,errors,9331,"are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; tha",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9406,Availability,error,errors,9406,"ed but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data poi",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9471,Availability,error,errors,9471,"lieves the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other pr",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9564,Availability,error,errors,9564,"lieves the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other pr",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10146,Availability,recover,recovers,10146,"s been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10566,Availability,error,error,10566,"of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of e",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10871,Availability,error,errors,10871,"hat it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This conce",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:11297,Availability,error,error,11297,"nimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the sec",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:11813,Availability,error,errors,11813,"undoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:11913,Availability,error,errors,11913,"undoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:11961,Availability,error,errors,11961,", but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:12037,Availability,error,errors,12037," are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in extern",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:12346,Availability,error,error,12346," of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:12471,Availability,error,error,12471," of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:12780,Availability,error,error,12780,"errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; e",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:12844,Availability,error,error,12844,"errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; e",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:13132,Availability,error,error,13132,"g that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:13239,Availability,error,errors,13239,"rts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:13382,Availability,error,error,13382," exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:13637,Availability,error,errors,13637,"ransformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*T",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:13729,Availability,error,error,13729,"mits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual In",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:13827,Availability,error,error,13827,"mits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual In",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:14126,Availability,error,errors,14126,"to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virt",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:14163,Availability,error,errors,14163,"to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virt",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:15432,Availability,Error,Error,15432," virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGe",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:15651,Availability,error,error,15651,"ect*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParamete",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:15735,Availability,error,error,15735,"; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; virtual TObjec",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:19217,Availability,toler,toler,19217,"l voidmncuve(); virtual voidmnderi(); virtual voidmndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); virtual voidmneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); virtual voidmnemat(Double_t* emat, Int_t ndim); virtual voidmnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); virtual voidmneval(Double_t anext, Double_t& fnext, Int_t& ierev); virtual voidmnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); virtual voidmnexin(Double_t* pint); virtual voidmnfixp(Int_t iint, Int_t& ierr); virtual voidmnfree(Int_t k); virtual voidmngrad(); virtual voidmnhelp(TString comd); virtual voidmnhelp(const char* command = """"); virtual voidmnhes1(); virtual voidmnhess(); virtual voidmnimpr(); virtual voidmninex(Double_t* pint); virtual voidmninit(Int_t i1, Int_t i2, Int_t i3); virtual voidmnlims(); virtual voidmnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); virtual voidmnmatu(Int_t kode); virtual voidmnmigr(); virtual voidmnmnos(); virtual voidmnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); virtual voidmnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); virtual voidmnpars(TString& crdbuf, Int_t& icondn); virtual voidmnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); virtual voidmnpint(Double_t& pexti, Int_t i, Double_t& pinti); virtual voidmnplot(Double_t* xpt, Double_t* ypt, char* chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); virtual voidmnpout(Int_t iuext, TString& chnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; virtual voidmnprin(Int_t inkode, Double_t fval); virtual voidmnpsdf(); virtual voidmnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); virtual voidmnrn15(Double_t& val, Int_t& inseed); virtual voidmnrset(Int_t iopt); virtual voidmnsave(); virtual v",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:24669,Availability,error,errors,24669,"Minimum value found for FCN; Double_tfApsi; Double_tfBigedmBig EDM = 123456; Double_t*fBlim[fMaxpar2] Upper limits for parameters; Double_t*fCOMDplist[fMaxpar] array used in mncomd; Double_t*fCONTgcc[fMaxpar] array used in mncont; Double_t*fCONTw[fMaxpar] array used in mncont; TStringfCfrom; char*fChpt!Character to be plotted at the X,Y contour positions; TStringfCovmes[4]; TString*fCpnam[fMaxpar2] Array of parameters names; TStringfCstatu; TStringfCtitl; TStringfCundef; TStringfCvrsn; TStringfCword; Double_tfDcovarRelative change in covariance matrix; Double_t*fDgrd[fMaxpar] Uncertainties; Double_t*fDirin[fMaxpar] (Internal) step sizes for current step; Double_t*fDirins[fMaxpar] (Internal) step sizes for current step for fixed params; Double_tfEDMEstimated vertical distance to the minimum; Int_tfEmptyInitialization flag (1 = Minuit initialized); Double_tfEpsi; Double_tfEpsma2sqrt(fEpsmac); Double_tfEpsmacmachine precision for floating points:; Double_t*fErn[fMaxpar] Negative Minos errors if calculated; Double_t*fErp[fMaxpar] Positive Minos errors if calculated; voidfFCN!; Double_t*fFIXPyy[fMaxpar] array used in mnfixp; Double_tfFval3; Double_t*fG2[fMaxpar] ; Double_t*fG2s[fMaxpar] ; Double_t*fGRADgf[fMaxpar] array used in mngrad; Double_t*fGin[fMaxpar2] ; Double_t*fGlobcc[fMaxpar] Global Correlation Coefficients; Bool_tfGraphicsModetrue if graphics mode on (default); Double_t*fGrd[fMaxpar] First derivatives; Double_t*fGrds[fMaxpar] ; Double_t*fGstep[fMaxpar] Step sizes; Double_t*fGsteps[fMaxpar] ; Double_t*fHESSyy[fMaxpar] array used in mnhess; Double_t*fIMPRdsav[fMaxpar] array used in mnimpr; Double_t*fIMPRy[fMaxpar] array used in mnimpr; Int_tfISW[7]Array of switches; Int_tfIcirc[2]; Int_tfIcomndNumber of commands; Int_tfIdbg[11]Array of internal debug switches; Int_t*fIpfix[fMaxpar] List of fixed parameters; Int_tfIstkrd[10]; Int_tfIstkwr[10]; Int_tfIstrat; Int_tfIsysrdstandardInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; I",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:24729,Availability,error,errors,24729,"ig EDM = 123456; Double_t*fBlim[fMaxpar2] Upper limits for parameters; Double_t*fCOMDplist[fMaxpar] array used in mncomd; Double_t*fCONTgcc[fMaxpar] array used in mncont; Double_t*fCONTw[fMaxpar] array used in mncont; TStringfCfrom; char*fChpt!Character to be plotted at the X,Y contour positions; TStringfCovmes[4]; TString*fCpnam[fMaxpar2] Array of parameters names; TStringfCstatu; TStringfCtitl; TStringfCundef; TStringfCvrsn; TStringfCword; Double_tfDcovarRelative change in covariance matrix; Double_t*fDgrd[fMaxpar] Uncertainties; Double_t*fDirin[fMaxpar] (Internal) step sizes for current step; Double_t*fDirins[fMaxpar] (Internal) step sizes for current step for fixed params; Double_tfEDMEstimated vertical distance to the minimum; Int_tfEmptyInitialization flag (1 = Minuit initialized); Double_tfEpsi; Double_tfEpsma2sqrt(fEpsmac); Double_tfEpsmacmachine precision for floating points:; Double_t*fErn[fMaxpar] Negative Minos errors if calculated; Double_t*fErp[fMaxpar] Positive Minos errors if calculated; voidfFCN!; Double_t*fFIXPyy[fMaxpar] array used in mnfixp; Double_tfFval3; Double_t*fG2[fMaxpar] ; Double_t*fG2s[fMaxpar] ; Double_t*fGRADgf[fMaxpar] array used in mngrad; Double_t*fGin[fMaxpar2] ; Double_t*fGlobcc[fMaxpar] Global Correlation Coefficients; Bool_tfGraphicsModetrue if graphics mode on (default); Double_t*fGrd[fMaxpar] First derivatives; Double_t*fGrds[fMaxpar] ; Double_t*fGstep[fMaxpar] Step sizes; Double_t*fGsteps[fMaxpar] ; Double_t*fHESSyy[fMaxpar] array used in mnhess; Double_t*fIMPRdsav[fMaxpar] array used in mnimpr; Double_t*fIMPRy[fMaxpar] array used in mnimpr; Int_tfISW[7]Array of switches; Int_tfIcirc[2]; Int_tfIcomndNumber of commands; Int_tfIdbg[11]Array of internal debug switches; Int_t*fIpfix[fMaxpar] List of fixed parameters; Int_tfIstkrd[10]; Int_tfIstkwr[10]; Int_tfIstrat; Int_tfIsysrdstandardInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; Int_tfKe2cr; Bool_tfLimsettrue if a parameter is up against l",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:28344,Availability,error,errors,28344,"er of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant..); Int_tfNwrmes[2]; TObject*fObjectFitPointer to object being fitted; TStringfOrigin[100]; Double_t*fP[fMaxpar1] ; Double_t*fPARSplist[fMaxpar] array used in mnpars; Double_t*fPSDFs[fMaxpar] array used in mnpsdf; Double_t*fPbar[fMaxpar] ; TObject*fPlotPointer to TGraph object created by mncont; Double_t*fPrho[fMaxpar] Minimum point of parabola; Double_t*fPstar[fMaxpar2] ; Double_t*fPstst[fMaxpar] ; Double_t*fSEEKxbest[fMaxpar] array used in mnseek; Double_t*fSEEKxmid[fMaxpar] array used in mnseek; Double_t*fSIMPy[fMaxpar] array used in mnsimp; Int_tfStatusStatus flag for the last called Minuit function; Double_t*fU[fMaxpar2] External (visible to user in FCN) value of parameters; Double_tfUndefiUndefined number = -54321; Double_tfUpFCN+-UP defines errors (for chisquare fits UP=1); Double_tfUpdflt; Double_t*fVERTpp[fMaxpar] array used in mnvert; Double_t*fVERTq[fMaxpar] array used in mnvert; Double_t*fVERTs[fMaxpar] array used in mnvert; Double_t*fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tfVlimhi; Double_tfVlimlo; Double_t*fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringfWarmes[100]; Double_t*fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*fWord7[fMaxpar] ; Double_t*fX[fMaxpar] Internal parameters values; Double_tfXdircr; Double_tfXmidcr; Double_t*fXpt[fMaxcpt] X array of points for contours; Double_t*fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tfYdircr; Double_tfYmidcr; Double_t*fYpt[fMaxcpt] Y array of points for contours. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Memb",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:28574,Availability,error,error,28574,"er of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant..); Int_tfNwrmes[2]; TObject*fObjectFitPointer to object being fitted; TStringfOrigin[100]; Double_t*fP[fMaxpar1] ; Double_t*fPARSplist[fMaxpar] array used in mnpars; Double_t*fPSDFs[fMaxpar] array used in mnpsdf; Double_t*fPbar[fMaxpar] ; TObject*fPlotPointer to TGraph object created by mncont; Double_t*fPrho[fMaxpar] Minimum point of parabola; Double_t*fPstar[fMaxpar2] ; Double_t*fPstst[fMaxpar] ; Double_t*fSEEKxbest[fMaxpar] array used in mnseek; Double_t*fSEEKxmid[fMaxpar] array used in mnseek; Double_t*fSIMPy[fMaxpar] array used in mnsimp; Int_tfStatusStatus flag for the last called Minuit function; Double_t*fU[fMaxpar2] External (visible to user in FCN) value of parameters; Double_tfUndefiUndefined number = -54321; Double_tfUpFCN+-UP defines errors (for chisquare fits UP=1); Double_tfUpdflt; Double_t*fVERTpp[fMaxpar] array used in mnvert; Double_t*fVERTq[fMaxpar] array used in mnvert; Double_t*fVERTs[fMaxpar] array used in mnvert; Double_t*fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tfVlimhi; Double_tfVlimlo; Double_t*fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringfWarmes[100]; Double_t*fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*fWord7[fMaxpar] ; Double_t*fX[fMaxpar] Internal parameters values; Double_tfXdircr; Double_tfXmidcr; Double_t*fXpt[fMaxcpt] X array of points for contours; Double_t*fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tfYdircr; Double_tfYmidcr; Double_t*fYpt[fMaxcpt] Y array of points for contours. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Memb",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:28817,Availability,error,error,28817,"er of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant..); Int_tfNwrmes[2]; TObject*fObjectFitPointer to object being fitted; TStringfOrigin[100]; Double_t*fP[fMaxpar1] ; Double_t*fPARSplist[fMaxpar] array used in mnpars; Double_t*fPSDFs[fMaxpar] array used in mnpsdf; Double_t*fPbar[fMaxpar] ; TObject*fPlotPointer to TGraph object created by mncont; Double_t*fPrho[fMaxpar] Minimum point of parabola; Double_t*fPstar[fMaxpar2] ; Double_t*fPstst[fMaxpar] ; Double_t*fSEEKxbest[fMaxpar] array used in mnseek; Double_t*fSEEKxmid[fMaxpar] array used in mnseek; Double_t*fSIMPy[fMaxpar] array used in mnsimp; Int_tfStatusStatus flag for the last called Minuit function; Double_t*fU[fMaxpar2] External (visible to user in FCN) value of parameters; Double_tfUndefiUndefined number = -54321; Double_tfUpFCN+-UP defines errors (for chisquare fits UP=1); Double_tfUpdflt; Double_t*fVERTpp[fMaxpar] array used in mnvert; Double_t*fVERTq[fMaxpar] array used in mnvert; Double_t*fVERTs[fMaxpar] array used in mnvert; Double_t*fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tfVlimhi; Double_tfVlimlo; Double_t*fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringfWarmes[100]; Double_t*fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*fWord7[fMaxpar] ; Double_t*fX[fMaxpar] Internal parameters values; Double_tfXdircr; Double_tfXmidcr; Double_t*fXpt[fMaxcpt] X array of points for contours; Double_t*fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tfYdircr; Double_tfYmidcr; Double_t*fYpt[fMaxcpt] Y array of points for contours. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Memb",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:30392,Availability,avail,available,30392,"amed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:30518,Availability,avail,available,30518,"tion; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF paramet",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:31245,Availability,error,errors,31245," as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:33668,Availability,error,error,33668," who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:34101,Availability,error,error,34101," any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet (also suppresse all warnings); = 0 normal; = 1 verbose. void mnamin(); Initialize AMIN*-*-*-*-; *-* ===============; *-*C Called from many places. Initializes the value of AMIN by; *-*C calling the user function. Prints out the function value and; *-*C parameter values if Print Flag value is high enough.; *. void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); -*-*Compute reasonable histogram intervals; *-* ==============",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:37348,Availability,error,errors,37348,"rmally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* ================================================; *-* Find NPTU points along a contour where the function; *-* FMIN (X(KE1),X(KE2)) = AMIN+UP; *-* where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:38107,Availability,error,errors,38107,"where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-* are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; *-* only KE1CR is varied. From MNCONT, both are varied.; *-* Crossing point is at; *-* (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); -; *. void mncuve(); -*-*-*Makes sure that the current point is a local minimum; *-* ====================================================; *-* Makes sure that the current point is a local; *-* minimum and that the error matrix exists,; *-* or at least something good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transfor",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:38127,Availability,error,error,38127,"where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-* are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; *-* only KE1CR is varied. From MNCONT, both are varied.; *-* Crossing point is at; *-* (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); -; *. void mncuve(); -*-*-*Makes sure that the current point is a local minimum; *-* ====================================================; *-* Makes sure that the current point is a local; *-* minimum and that the error matrix exists,; *-* or at least something good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transfor",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:38814,Availability,error,error,38814,"mat input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-* are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; *-* only KE1CR is varied. From MNCONT, both are varied.; *-* Crossing point is at; *-* (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); -; *. void mncuve(); -*-*-*Makes sure that the current point is a local minimum; *-* ====================================================; *-* Makes sure that the current point is a local; *-* minimum and that the error matrix exists,; *-* or at least something good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transforming the user-; *-* supplied derivatives to internal coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:39873,Availability,error,error,39873,"ng good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transforming the user-; *-* supplied derivatives to internal coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable paramet",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40192,Availability,error,errors,40192,"coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); In",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40360,Availability,error,errors,40360,"lues; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40415,Availability,error,error,40415,"lues; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40427,Availability,error,error,40427,"lues; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40448,Availability,Error,Errors,40448," *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by setting up a call to a function; -; *-* recognized MINUIT commands:; *-* obsolete commands:; *-* IERFLG is now (94.5) defined the same as ICO",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40531,Availability,error,error,40531," *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by setting up a call to a function; -; *-* recognized MINUIT commands:; *-* obsolete commands:; *-* IERFLG is now (94.5) defined the same as ICO",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:45727,Availability,toler,toler,45727,"MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local f",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:46033,Availability,TOLER,TOLER,46033," to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:46050,Availability,toler,tolerance,46050," to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:46989,Availability,error,error,46989,"ion STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFL",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:47065,Availability,error,error,47065,"ion STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFL",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:47300,Availability,error,error,47300,"; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-*",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:48490,Availability,error,error,48490,"========================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-* parses the string CRDBUF and calls MNPARM; -; *-* output conditions:; *-* ICONDN = 0 all OK; *-* ICONDN = 1 error, attempt to define parameter is ignored; *-* ICONDN = 2 end of parameter definitions; *. void mnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); To fit a parabola to npar2p points*-; *-* ==================================; *-* npar2p no. of points; *-* parx2p(i) x value of point i; *-* pary2p(i) y value of point i; -; *-* coef2p(1...3) coefficients of the fitted parabola; *-* y=coef2p(1) + coef2p(2)*x + coef2p(3)*x**2; *-* sdev2p= variance; *-* method : chi**2 = min equation solved explicitly; *. void mnpint(Double_t& pexti, Int_t i, Double_t& pinti); Calculates the internal parameter value PINTI*-; *-* =============================================; *-* corresponding to the external value PEXTI for parameter I.; *. void mnplot(Double_t* xpt, Double_t* ypt, char* chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); Plots po",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51099,Availability,error,errors,51099,"hnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; -*Provides the user with information concerning the current status; *-* ================================================================; *-* of parameter number IUEXT. Namely, it returns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated dis",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51254,Availability,error,errors,51254,"rns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Not",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51284,Availability,error,errors,51284,"rns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Not",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51335,Availability,error,errors,51335,"rns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Not",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51394,Availability,error,errors,51394,"d (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* ======================",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51408,Availability,error,errors,51408,"d (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* ======================",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:52383,Availability,error,errors,52383,"W[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:52502,Availability,error,errors,52502,"W[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56728,Availability,error,errors,56728,"id mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}.  Author: Rene Brun, Frederick James 12/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TMinuit.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56887,Availability,avail,available,56887,"id mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}.  Author: Rene Brun, Frederick James 12/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TMinuit.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:436,Deployability,patch,patch,436,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:33995,Deployability,Release,Release,33995,"ample of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet (also suppresse all warnings); = 0 normal; = 1 verbose. void mnamin(); Initialize AMIN*-*-*-*-; *-* ===============; *-*C Called from many places. Initializes the value of AMIN by; *-*C calling the user function. Prints out the function value and; *-*C parameter values if Print Flag value is high enough.; *. void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, D",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:34017,Deployability,release,release,34017,"ample of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet (also suppresse all warnings); = 0 normal; = 1 verbose. void mnamin(); Initialize AMIN*-*-*-*-; *-* ===============; *-*C Called from many places. Initializes the value of AMIN by; *-*C calling the user function. Prints out the function value and; *-*C parameter values if Print Flag value is high enough.; *. void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, D",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:48032,Deployability,update,updates,48032,"ng basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-* parses the string CRDBUF and calls MNPARM; -; *-* output conditions:; *-* ICONDN = 0 all OK; *-* ICONDN = 1 error, attempt to define parameter is ignored; *-* ICONDN = 2 end of parameter definitions; *. void mnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); To fit a parabola to npar2p points*-; *-* ==================================; *-* npar2p no. of points; *-* parx2p(i) x value",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:817,Integrability,depend,depending,817,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:2249,Integrability,depend,depend,2249,"mber functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice line",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:2474,Integrability,depend,depending,2474,"sses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does r",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:5179,Integrability,depend,depends,5179,"ameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zer",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:8684,Integrability,message,messages,8684,"liability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9273,Integrability,message,message,9273,"are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; tha",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10453,Integrability,depend,dependence,10453,"s; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:11408,Integrability,depend,dependence,11408," the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root o",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:31580,Integrability,rout,routine,31580,"cution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the para",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40171,Integrability,rout,routine,40171,"coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); In",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:43455,Integrability,interface,interface,43455,"es one or more fixed parameter(s) to variable status*-*-; *-* ==========================================================; *-* Restores one or more fixed parameter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* ============================================; -; *-* COMD ='*' or """" prints a global help for all commands; *-* COMD =Command_name: print detailed help for one command.; *-* Note that at least 3 characters must be given for the command; *-* name.; -; *-* Author: Rene Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ================================",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:43513,Integrability,rout,routine,43513,"meter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* ============================================; -; *-* COMD ='*' or """" prints a global help for all commands; *-* COMD =Command_name: print detailed help for one command.; *-* Note that at least 3 characters must be given for the command; *-* name.; -; *-* Author: Rene Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local m",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:45147,Integrability,rout,routines,45147,"s, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMB",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:45206,Integrability,rout,routine,45206,"s, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMB",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56169,Integrability,message,messages,56169,"t all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() co",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56247,Integrability,message,message,56247,"t all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() co",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56300,Integrability,message,message,56300,"te covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(In",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56373,Integrability,rout,routine,56373,"achine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fO",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56405,Integrability,message,message,56405,"achine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fO",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56485,Integrability,message,message,56485,"d returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}.  Author: Rene Brun, Frederick James 12/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Radema",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:56599,Integrability,message,messages,56599,"Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}.  Author: Rene Brun, Frederick James 12/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TMinuit.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:652,Modifiability,variab,variables,652,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:1519,Modifiability,flexible,flexible,1519,"nt implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisq",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:1926,Modifiability,variab,variables,1926,"mber of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. F",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:2272,Modifiability,variab,variable,2272,"mber functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice line",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:2852,Modifiability,variab,variable,2852,"ed object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4532,Modifiability,variab,variable,4532,"troduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the exis",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:5028,Modifiability,variab,variable-metric,5028,"also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:9101,Modifiability,parameteriz,parameterized,9101," there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10406,Modifiability,parameteriz,parameterization,10406,"s; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10691,Modifiability,parameteriz,parameterization,10691,"of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of e",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:11784,Modifiability,variab,variables,11784," inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired l",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:17054,Modifiability,Inherit,InheritsFrom,17054,"virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; virtual TObject*GetPlot() const; Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tMigrad(); virtual voidmnamin(); virtual voidmnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); virtual voidmncalf(Double_t* pvec, Double_t& ycalf); virtual voidmncler(); virtual voidmncntr(Int_t ke1, Int_t ke2, Int_t& ierrf); virtual voidmncomd(const char* crdbin, Int_t& icondn); virtual voidmncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); virtual voidmncrck(TString crdbuf, Int_t maxc",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:17120,Modifiability,Inherit,InheritsFrom,17120,"GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; virtual TObject*GetPlot() const; Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tMigrad(); virtual voidmnamin(); virtual voidmnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); virtual voidmncalf(Double_t* pvec, Double_t& ycalf); virtual voidmncler(); virtual voidmncntr(Int_t ke1, Int_t ke2, Int_t& ierrf); virtual voidmncomd(const char* crdbin, Int_t& icondn); virtual voidmncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); virtual voidmncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:27074,Modifiability,variab,variable,27074,"dInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; Int_tfKe2cr; Bool_tfLimsettrue if a parameter is up against limits (for MINOS); Bool_tfLnewmntrue if the previous process has unexpectedly improved FCN; Bool_tfLnolimtrue if there are no limits on any parameters (not yet used); Bool_tfLpheadtrue if a heading should be put out for the next parameter definition; Bool_tfLreportrue if exceptional conditions are put out (default=false); Bool_tfLwarntrue if warning messges are to be put out (default=true); Double_t*fMATUvline[fMaxpar] array used in mnmatu; Double_t*fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*fMIGRgs[fMaxpar] array used in mnmigr; Double_t*fMIGRstep[fMaxpar] array used in mnmigr; Double_t*fMIGRvg[fMaxpar] array used in mnmigr; Double_t*fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*fMNOTw[fMaxpar] array used in mnmnot; Double_t*fMNOTxdev[fMaxpar] array used in mnmnot; Int_tfMaxIterationsMaximum number of iterations; Int_tfMaxcpt; Int_tfMaxextMaximum number of external parameters; Int_tfMaxintMaximum number of internal parameters; Int_tfMaxparMaximum number of parameters; Int_tfMaxpar1fMaxpar*(fMaxpar+1); Int_tfMaxpar2fMaxpar*fMaxpar; Int_tfMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; Int_tfNblockNumber of Minuit data blocks; Int_tfNewpag; Int_t*fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tfNfcnNumber of calls to FCN; Int_tfNfcnfr; Int_tfNfcnlc; Int_tfNfcnmxMaximum number of calls to FCN; Int_tfNfcwar[20]; Int_t*fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tfNpaglnNumber of lines per page; Int_tfNpagwdPage width; Int_tfNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tfNpfixNumber of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:27296,Modifiability,variab,variable,27296,"dInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; Int_tfKe2cr; Bool_tfLimsettrue if a parameter is up against limits (for MINOS); Bool_tfLnewmntrue if the previous process has unexpectedly improved FCN; Bool_tfLnolimtrue if there are no limits on any parameters (not yet used); Bool_tfLpheadtrue if a heading should be put out for the next parameter definition; Bool_tfLreportrue if exceptional conditions are put out (default=false); Bool_tfLwarntrue if warning messges are to be put out (default=true); Double_t*fMATUvline[fMaxpar] array used in mnmatu; Double_t*fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*fMIGRgs[fMaxpar] array used in mnmigr; Double_t*fMIGRstep[fMaxpar] array used in mnmigr; Double_t*fMIGRvg[fMaxpar] array used in mnmigr; Double_t*fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*fMNOTw[fMaxpar] array used in mnmnot; Double_t*fMNOTxdev[fMaxpar] array used in mnmnot; Int_tfMaxIterationsMaximum number of iterations; Int_tfMaxcpt; Int_tfMaxextMaximum number of external parameters; Int_tfMaxintMaximum number of internal parameters; Int_tfMaxparMaximum number of parameters; Int_tfMaxpar1fMaxpar*(fMaxpar+1); Int_tfMaxpar2fMaxpar*fMaxpar; Int_tfMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; Int_tfNblockNumber of Minuit data blocks; Int_tfNewpag; Int_t*fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tfNfcnNumber of calls to FCN; Int_tfNfcnfr; Int_tfNfcnlc; Int_tfNfcnmxMaximum number of calls to FCN; Int_tfNfcwar[20]; Int_t*fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tfNpaglnNumber of lines per page; Int_tfNpagwdPage width; Int_tfNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tfNpfixNumber of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:29433,Modifiability,Inherit,Inheritance,29433,"[fMaxpar] array used in mnvert; Double_t*fVERTs[fMaxpar] array used in mnvert; Double_t*fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tfVlimhi; Double_tfVlimlo; Double_t*fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringfWarmes[100]; Double_t*fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*fWord7[fMaxpar] ; Double_t*fX[fMaxpar] Internal parameters values; Double_tfXdircr; Double_tfXmidcr; Double_t*fXpt[fMaxcpt] X array of points for contours; Double_t*fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tfYdircr; Double_tfYmidcr; Double_t*fYpt[fMaxcpt] Y array of points for contours. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/m",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:29446,Modifiability,Inherit,Inherited,29446,"[fMaxpar] array used in mnvert; Double_t*fVERTs[fMaxpar] array used in mnvert; Double_t*fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tfVlimhi; Double_tfVlimlo; Double_t*fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringfWarmes[100]; Double_t*fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*fWord7[fMaxpar] ; Double_t*fX[fMaxpar] Internal parameters values; Double_tfXdircr; Double_tfXmidcr; Double_t*fXpt[fMaxcpt] X array of points for contours; Double_t*fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tfYdircr; Double_tfYmidcr; Double_t*fYpt[fMaxcpt] Y array of points for contours. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/m",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:31290,Modifiability,variab,variable,31290," as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:32277,Modifiability,variab,variable,32277," if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log li",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:32326,Modifiability,variab,variable,32326," if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log li",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:35946,Modifiability,variab,variables,35946,"ble_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); -*-*Compute reasonable histogram intervals; *-* ======================================; *-* Function TO DETERMINE REASONABLE HISTOGRAM INTERVALS; *-* GIVEN ABSOLUTE UPPER AND LOWER BOUNDS A1 AND A2; *-* AND DESIRED MAXIMUM NUMBER OF BINS NAA; *-* PROGRAM MAKES REASONABLE BINNING FROM BL TO BH OF WIDTH BWID; *-* F. JAMES, AUGUST, 1974 , stolen for Minuit, 1988; *. void mncalf(Double_t* pvec, Double_t& ycalf); Transform FCN to find further minima; *-* ====================================; *-* Called only from MNIMPR. Transforms the function FCN; *-* by dividing out the quadratic part in order to find further; *-* minima. Calculates ycalf = (f-fmin)/(x-xmin)*v*(x-xmin); *. void mncler(); -*-*-*Resets the parameter list to UNDEFINED; *-* ======================================; *-* Called from MINUIT and by option from MNEXCM; *. void mncntr(Int_t ke1, Int_t ke2, Int_t& ierrf); Print function contours in two variables, on line printer; *-* =========================================================; -; *-* input arguments: parx, pary, devs, ngrid; *. void mncomd(const char* crdbin, Int_t& icondn); -*Reads a command string and executes; *-* ===================================; *-* Called by user. 'Reads' a command string and executes.; *-* Equivalent to MNEXCM except that the command is given as a; *-* character string.; -; *-* ICONDN = 0: command executed normally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* =============",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:37186,Modifiability,variab,variable,37186,"====================; -; *-* input arguments: parx, pary, devs, ngrid; *. void mncomd(const char* crdbin, Int_t& icondn); -*Reads a command string and executes; *-* ===================================; *-* Called by user. 'Reads' a command string and executes.; *-* Equivalent to MNEXCM except that the command is given as a; *-* character string.; -; *-* ICONDN = 0: command executed normally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* ================================================; *-* Find NPTU points along a contour where the function; *-* FMIN (X(KE1),X(KE2)) = AMIN+UP; *-* where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric f",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:37393,Modifiability,variab,variable,37393,"rmally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* ================================================; *-* Find NPTU points along a contour where the function; *-* FMIN (X(KE1),X(KE2)) = AMIN+UP; *-* where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:40843,Modifiability,variab,variable,40843,"t_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by setting up a call to a function; -; *-* recognized MINUIT commands:; *-* obsolete commands:; *-* IERFLG is now (94.5) defined the same as ICONDN in MNCOMD; *-* = 0: command executed normally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not conver",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:42484,Modifiability,variab,variable,42484,"k, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *-* see also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for the possible list; *-* of all Minuit commands; -; *. void mnexin(Double_t* pint); -*-*Transforms the external parameter values U to internal values; *-* =============================================================; *-* Transforms the external parameter values U to internal; *-* values in the dense array PINT.; *. void mnfixp(Int_t iint, Int_t& ierr); -*-*-*-*Removes parameter IINT from the internal parameter list; *-* =======================================================; *-* and arranges the rest of the list to fill the hole.; *. void mnfree(Int_t k); Restores one or more fixed parameter(s) to variable status*-*-; *-* ==========================================================; *-* Restores one or more fixed parameter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* =======",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:42616,Modifiability,variab,variable,42616,"k, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *-* see also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for the possible list; *-* of all Minuit commands; -; *. void mnexin(Double_t* pint); -*-*Transforms the external parameter values U to internal values; *-* =============================================================; *-* Transforms the external parameter values U to internal; *-* values in the dense array PINT.; *. void mnfixp(Int_t iint, Int_t& ierr); -*-*-*-*Removes parameter IINT from the internal parameter list; *-* =======================================================; *-* and arranges the rest of the list to fill the hole.; *. void mnfree(Int_t k); Restores one or more fixed parameter(s) to variable status*-*-; *-* ==========================================================; *-* Restores one or more fixed parameter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* =======",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:49810,Modifiability,Plug-in,Plug-in,49810,"no. of points; *-* parx2p(i) x value of point i; *-* pary2p(i) y value of point i; -; *-* coef2p(1...3) coefficients of the fitted parabola; *-* y=coef2p(1) + coef2p(2)*x + coef2p(3)*x**2; *-* sdev2p= variance; *-* method : chi**2 = min equation solved explicitly; *. void mnpint(Double_t& pexti, Int_t i, Double_t& pinti); Calculates the internal parameter value PINTI*-; *-* =============================================; *-* corresponding to the external value PEXTI for parameter I.; *. void mnplot(Double_t* xpt, Double_t* ypt, char* chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); Plots points in array xypt onto one page with labelled axes*-; *-* ===========================================================; *-* NXYPT is the number of points to be plotted; *-* XPT(I) = x-coord. of ith point; *-* YPT(I) = y-coord. of ith point; *-* CHPT(I) = character to be plotted at this position; *-* the input point arrays XPT, YPT, CHPT are destroyed.; -; -; *-* If fGraphicsmode is true (default), a TGraph object is produced; *-* via the Plug-in handler. To get the plot, you can do:; *-* TGraph *gr = (TGraph*)gMinuit->GetPlot();; *-* gr->Draw(""al"");; -; *. void mnpout(Int_t iuext, TString& chnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; -*Provides the user with information concerning the current status; *-* ================================================================; *-* of parameter number IUEXT. Namely, it returns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly t",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:50564,Modifiability,variab,variable,50564,"xes*-; *-* ===========================================================; *-* NXYPT is the number of points to be plotted; *-* XPT(I) = x-coord. of ith point; *-* YPT(I) = y-coord. of ith point; *-* CHPT(I) = character to be plotted at this position; *-* the input point arrays XPT, YPT, CHPT are destroyed.; -; -; *-* If fGraphicsmode is true (default), a TGraph object is produced; *-* via the Plug-in handler. To get the plot, you can do:; *-* TGraph *gr = (TGraph*)gMinuit->GetPlot();; *-* gr->Draw(""al"");; -; *. void mnpout(Int_t iuext, TString& chnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; -*Provides the user with information concerning the current status; *-* ================================================================; *-* of parameter number IUEXT. Namely, it returns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:52048,Modifiability,portab,portable,52048,"m, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:54988,Modifiability,variab,variable,54988,"================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symm",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4771,Performance,perform,perform,4771,"value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:4785,Performance,perform,perform,4785,"value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:32813,Performance,perform,performs,32813,"int). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the numb",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:33380,Performance,Perform,Perform,33380,"); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:45739,Performance,Perform,Perform,45739,"MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local f",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:46677,Performance,Perform,Performs,46677,"T; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-call",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:46767,Performance,Perform,Performs,46767,"T; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-call",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:46972,Performance,Perform,Performs,46972,"ion STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFL",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:47048,Performance,Perform,Performs,47048,"ion STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFL",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:47283,Performance,Perform,Performs,47283,"; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-*",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:53246,Performance,Perform,Performs,53246,"; Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ==================",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:54400,Performance,Perform,Performs,54400,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To fin",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:55592,Performance,optimiz,optimizer,55592,"nt_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:3335,Safety,avoid,avoided,3335,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. U",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:10146,Safety,recover,recovers,10146,"s been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:55562,Safety,safe,safely,55562,"nt_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:16944,Security,Hash,Hash,16944,"bject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; virtual TObject*GetPlot() const; Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tMigrad(); virtual voidmnamin(); virtual voidmnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); virtual voidmncalf(Double_t* pvec, Double_t& ycalf); virtual voidmncler(); virtual voidmncntr(Int_t ke1, Int_t ke2, Int_t& ierrf); virtual voidmncomd(const char* crdbin, Int_t& icondn); virtual voidmncont(Int_t ke1, I",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:22706,Testability,Test,TestBit,22706,"operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRelease(Int_t parNo); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetErrorDef(Double_t up); virtual voidSetFCN(void* fcn); virtual voidSetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); virtual voidSetGraphicsMode(Bool_t mode = kTRUE); virtual voidSetMaxIterations(Int_t maxiter = 500); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObjectFit(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetPrintLevel(Int_t printLevel = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:22745,Testability,Test,TestBits,22745,"operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRelease(Int_t parNo); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetErrorDef(Double_t up); virtual voidSetFCN(void* fcn); virtual voidSetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); virtual voidSetGraphicsMode(Bool_t mode = kTRUE); virtual voidSetMaxIterations(Int_t maxiter = 500); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObjectFit(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetPrintLevel(Int_t printLevel = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:33296,Testability,log,log,33296,"sation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, I",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:45441,Testability,log,logical,45441,"alculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size o",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:976,Usability,simpl,simply,976,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:2303,Usability,simpl,simple,2303,"sses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does r",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:14612,Usability,Clear,Clear,14612,,MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:44850,Usability,simpl,simplex,44850,"ne Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =======================================",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:51928,Usability,simpl,simplex,51928,"nkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for ",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:54299,Usability,simpl,simplex,54299,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To fin",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuit.html:54434,Usability,simpl,simplex,54434,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To fin",MatchSource.WIKI,root/html532/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuit.html
https://root.cern/root/html532/TMinuitMinimizer.html:1283,Availability,Error,ErrorDef,1283," TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:1322,Availability,Error,Errors,1322," TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:3990,Availability,Toler,Tolerance,3990,"rovidesError() const; virtual boolScan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); voidROOT::Math::Minimizer::SetDefaultOptions(); voidROOT::Math::Minimizer::SetErrorDef(double up); virtual boolSetFixedVariable(unsigned int, const string&, double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGradFunction& func); virtual boolSetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double, double); virtual boolROOT::Math::Minimizer::SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); voidROOT::Math::Minimizer::SetMaxFunctionCalls(unsigned int maxfcn); voidROOT::Math::Minimizer::SetMaxIterations(unsigned int maxiter); voidROOT::Math::Minimizer::SetOptions(const ROOT::Math::MinimizerOptions& opt); voidROOT::Math::Minimizer::SetPrecision(double prec); voidROOT::Math::Minimizer::SetPrintLevel(int level); voidROOT::Math::Minimizer::SetStrategy(int strategyLevel); voidROOT::Math::Minimizer::SetTolerance(double tol); virtual boolROOT::Math::Minimizer::SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidROOT::Math::Minimizer::SetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSuppressMinuitWarnings(bool nowarn = true); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const.",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:5111,Availability,error,errors,5111,"oidStreamerNVirtual(TBuffer& b); voidSuppressMinuitWarnings(bool nowarn = true); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer(const TMinuitMinimizer&); TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minim",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8547,Availability,error,errors,8547,"d FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= appro",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8755,Availability,error,errors,8755,"; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMino",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8806,Availability,error,error,8806,"ble. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:10660,Availability,error,error,10660,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Auth",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:10674,Availability,error,errors,10674,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Auth",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:10857,Availability,error,errors,10857,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Auth",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11299,Availability,error,error,11299," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11309,Availability,error,error,11309," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11356,Availability,Error,Errors,11356," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11379,Availability,error,errors,11379," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11618,Availability,error,errors,11618," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8496,Deployability,update,update,8496,"d FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= appro",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:9961,Deployability,release,released,9961,"of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:9994,Deployability,release,release,9994,"of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:10062,Deployability,release,release,10062,"of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7443,Energy Efficiency,Adapt,Adapt,7443," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7635,Energy Efficiency,Adapt,Adapt,7635,"ion(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void Re",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:387,Integrability,interface,interface,387,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:6848,Integrability,interface,interface,6848,"uit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigne",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7192,Integrability,interface,interface,7192," type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7276,Integrability,interface,interface,7276,"n manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. i",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7467,Integrability,interface,interface,7467," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7660,Integrability,interface,interface,7660,"ion(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void Re",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:460,Modifiability,plug-in,plug-in,460,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:478,Modifiability,plug-in,plug-in,478,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:5626,Modifiability,Inherit,Inheritance,5626,"::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void In",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:5639,Modifiability,Inherit,Inherited,5639,"::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void In",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:6255,Modifiability,plug-in,plug-in,6255,"inuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7443,Modifiability,Adapt,Adapt,7443," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7635,Modifiability,Adapt,Adapt,7635,"ion(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void Re",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7834,Modifiability,variab,variable,7834," function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); g",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:7965,Modifiability,variab,variable,7965,"by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8050,Modifiability,variab,variable,8050,"d SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8136,Modifiability,variab,variable,8136,"y passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFr",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8196,Modifiability,Variab,VariableName,8196,"unction derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance ma",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8246,Modifiability,variab,variable,8246,"unction derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance ma",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8265,Modifiability,Variab,VariableIndex,8265,"e not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of c",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8313,Modifiability,variab,variable,8313,"e not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of c",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:10521,Modifiability,variab,variable,10521,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Auth",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11198,Modifiability,variab,variables,11198," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11532,Modifiability,variab,variable,11532," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:11590,Modifiability,variab,variables,11590," parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:8346,Performance,perform,perform,8346,"on of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the f",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:9785,Performance,Perform,Perform,9785,"rieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Mi",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:10880,Performance,perform,perform,10880,"eter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TMinuitMinimizer.h 40564 2011-08-11 16:28:02Z moneta $  Last generated: 2011-11-03 20:20; This page has been automatically gene",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:9364,Safety,avoid,avoid,9364,"riable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj);",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:5128,Security,validat,validated,5128,"oidStreamerNVirtual(TBuffer& b); voidSuppressMinuitWarnings(bool nowarn = true); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer(const TMinuitMinimizer&); TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minim",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:599,Usability,Simpl,Simplex,599,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:639,Usability,Simpl,Simplex,639,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:931,Usability,Clear,Clear,931," TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:5978,Usability,Simpl,Simplex,5978,"solute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:6335,Usability,Simpl,Simplex,6335,"inuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMinuitMinimizer.html:6379,Usability,Simpl,Simplex,6379,"inuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root/html532/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html
https://root.cern/root/html532/TMixture.html:1347,Availability,Error,Error,1347," TMixture(); TMixture(const TMixture&); TMixture(const char* name, const char* title, Int_t nmixt); virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virt",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:1476,Availability,error,error,1476,"l~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjec",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:1560,Availability,error,error,1560,"ject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTMaterial::GetR",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:2946,Modifiability,Inherit,InheritsFrom,2946,"irtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTMaterial::GetRadLength() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Float_t*GetWmixt() const; virtual Float_tTMaterial::GetZ() const; Float_t*GetZmixt() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operato",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:3012,Modifiability,Inherit,InheritsFrom,3012,"ect::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTMaterial::GetRadLength() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Float_t*GetWmixt() const; virtual Float_tTMaterial::GetZ() const; Float_t*GetZmixt() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:7002,Modifiability,Inherit,Inheritance,7002,"t va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTMaterial::fAA of Material; Float_t*fAmixt[fNmixt] Array of A of mixtures; Float_tTMaterial::fDensityMaterial density in gr/cm3; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Float_tTMaterial::fInterLengthMaterial interaction length; TStringTNamed::fNameobject identifier; Int_tfNmixtNumber of elements in mixture; Int_tTMaterial::fNumberMaterial matrix number; Float_tTMaterial::fRadLengthMaterial radiation length; TStringTNamed::fTitleobject title; Float_t*fWmixt[fNmixt] Array of relative weights; Float_tTMaterial::fZZ of Material; Float_t*fZmixt[fNmixt] Array of Z of mixtures. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMixture(); Mixture default constructor. TMixture(const char* name, const char* title, Int_t nmixt); Mixture normal constructor. Defines mixture OR COMPOUND as composed by; the basic nmixt materials defined later by DefineElement. If nmixt > 0 then Wmixt contains the PROPORTION BY WEIGHTS; of each basic material in the mixture. If nmixt < 0 then Wmixt contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, Wmixt is changed to relative weights. nb : the radiation length is computed according; the EGS manual slac-210 uc-32 June-78; formula 2-6-8 (37). ~TMixture(); Mixture default destructor. void DefineElement(Int_t n, Float_t a, Float_t z, Float_t w); Define one mixture element. void Streamer(TBuffer& b); Stream a class object. TMixture(). Int_t GetNmixt() const; {return fNmixt;}. Float_t * GetAmixt() const; {return fAmixt;}. Float_t * GetZmixt() const; {return fZmixt;}. Float_t * GetWmixt() const;",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:7015,Modifiability,Inherit,Inherited,7015,"t va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTMaterial::fAA of Material; Float_t*fAmixt[fNmixt] Array of A of mixtures; Float_tTMaterial::fDensityMaterial density in gr/cm3; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Float_tTMaterial::fInterLengthMaterial interaction length; TStringTNamed::fNameobject identifier; Int_tfNmixtNumber of elements in mixture; Int_tTMaterial::fNumberMaterial matrix number; Float_tTMaterial::fRadLengthMaterial radiation length; TStringTNamed::fTitleobject title; Float_t*fWmixt[fNmixt] Array of relative weights; Float_tTMaterial::fZZ of Material; Float_t*fZmixt[fNmixt] Array of Z of mixtures. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMixture(); Mixture default constructor. TMixture(const char* name, const char* title, Int_t nmixt); Mixture normal constructor. Defines mixture OR COMPOUND as composed by; the basic nmixt materials defined later by DefineElement. If nmixt > 0 then Wmixt contains the PROPORTION BY WEIGHTS; of each basic material in the mixture. If nmixt < 0 then Wmixt contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, Wmixt is changed to relative weights. nb : the radiation length is computed according; the EGS manual slac-210 uc-32 June-78; formula 2-6-8 (37). ~TMixture(); Mixture default destructor. void DefineElement(Int_t n, Float_t a, Float_t z, Float_t w); Define one mixture element. void Streamer(TBuffer& b); Stream a class object. TMixture(). Int_t GetNmixt() const; {return fNmixt;}. Float_t * GetAmixt() const; {return fAmixt;}. Float_t * GetZmixt() const; {return fZmixt;}. Float_t * GetWmixt() const;",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:298,Safety,detect,detector,298,". TMixture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TMixture. class TMixture: public TMaterial. Manages a detector mixture. See class TGeometry. Function Members (Methods); public:. TMixture(); TMixture(const TMixture&); TMixture(const char* name, const char* title, Int_t nmixt); virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virt",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:2836,Security,Hash,Hash,2836,"TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTMaterial::GetRadLength() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Float_t*GetWmixt() const; virtual Float_tTMaterial::GetZ() const; Float_t*GetZmixt() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:5567,Testability,Test,TestBit,5567,"z); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMixture&operator=(const TMixture&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:5606,Testability,Test,TestBits,5606,"z); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMixture&operator=(const TMixture&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMixture.html:735,Usability,Clear,Clear,735," TMixture(); TMixture(const TMixture&); TMixture(const char* name, const char* title, Int_t nmixt); virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virt",MatchSource.WIKI,root/html532/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMixture.html
https://root.cern/root/html532/TMLPAnalyzer.html:1866,Availability,Error,Error,1866,"st char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:1995,Availability,error,error,1995,"e = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:2079,Availability,error,error,2079,"TObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inheri",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:8474,Deployability,continuous,continuous,8474,"sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfi",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:8942,Deployability,continuous,continuous,8942," the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerce",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:433,Modifiability,variab,variables,433,". TMLPAnalyzer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MLP;  TMLPAnalyzer. class TMLPAnalyzer: public TObject. TMLPAnalyzer. This utility class contains a set of tests usefull when developing; a neural network.; It allows you to check for unneeded variables, and to control; the network structure. Function Members (Methods); public:. TMLPAnalyzer(TMultiLayerPerceptron& net); TMLPAnalyzer(TMultiLayerPerceptron* net); TMLPAnalyzer(const TMLPAnalyzer&); virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:3010,Modifiability,Inherit,InheritsFrom,3010,"oidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:3076,Modifiability,Inherit,InheritsFrom,3076,"or = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMLPAnalyzer&operator=(",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:6058,Modifiability,Inherit,Inheritance,6058,"; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; const char*GetInputNeuronTitle(Int_t in); Int_tGetLayers(); TStringGetNeuronFormula(Int_t idx); Int_tGetNeurons(Int_t layer); const char*GetOutputNeuronTitle(Int_t out); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TTree*fAnalysisTree; TTree*fIOTree; TMultiLayerPerceptron*fNetwork. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:6071,Modifiability,Inherit,Inherited,6071,"; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; const char*GetInputNeuronTitle(Int_t in); Int_tGetLayers(); TStringGetNeuronFormula(Int_t idx); Int_tGetNeurons(Int_t layer); const char*GetOutputNeuronTitle(Int_t out); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TTree*fAnalysisTree; TTree*fIOTree; TMultiLayerPerceptron*fNetwork. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:6205,Modifiability,layers,layers,6205,"sgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; const char*GetInputNeuronTitle(Int_t in); Int_tGetLayers(); TStringGetNeuronFormula(Int_t idx); Int_tGetNeurons(Int_t layer); const char*GetOutputNeuronTitle(Int_t out); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TTree*fAnalysisTree; TTree*fIOTree; TMultiLayerPerceptron*fNetwork. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates th",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:7549,Modifiability,variab,variable,7549," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:7845,Performance,optimiz,optimizing,7845," analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each outpu",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:7628,Safety,risk,risk,7628," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:2900,Security,Hash,Hash,2900,"* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:347,Testability,test,tests,347,". TMLPAnalyzer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MLP;  TMLPAnalyzer. class TMLPAnalyzer: public TObject. TMLPAnalyzer. This utility class contains a set of tests usefull when developing; a neural network.; It allows you to check for unneeded variables, and to control; the network structure. Function Members (Methods); public:. TMLPAnalyzer(TMultiLayerPerceptron& net); TMLPAnalyzer(TMultiLayerPerceptron* net); TMLPAnalyzer(const TMLPAnalyzer&); virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:5020,Testability,Test,TestBit,5020,"ble() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMLPAnalyzer&operator=(const TMLPAnalyzer&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:5059,Testability,Test,TestBits,5059,"ble() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMLPAnalyzer&operator=(const TMLPAnalyzer&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:6909,Testability,test,test,6909,"kSingleKey; kOverwrite; kWriteDelete; };. private:. TTree*fAnalysisTree; TTree*fIOTree; TMultiLayerPerceptron*fNetwork. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:7050,Testability,test,test,7050,"ce; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:8110,Testability,test,test,8110,"ation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProf",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:8351,Testability,test,test,8351,". That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP o",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:8820,Testability,test,test,8820,"you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The ret",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:9331,Testability,test,test,9331,"fference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}.  Author: Christophe.Delaere@cern.ch 25/04/04  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;  Last changed: root/mlp:$Id: TMLPAnalyzer.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:19; Th",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:9709,Testability,test,test,9709,"s mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}.  Author: Christophe.Delaere@cern.ch 25/04/04  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;  Last changed: root/mlp:$Id: TMLPAnalyzer.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:926,Usability,Clear,Clear,926," TMLPAnalyzer(TMultiLayerPerceptron& net); TMLPAnalyzer(TMultiLayerPerceptron* net); TMLPAnalyzer(const TMLPAnalyzer&); virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TMLPAnalyzer.html:7523,Usability,learn,learn,7523," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html532/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html
https://root.cern/root/html532/TModuleDocInfo.html:1929,Availability,Error,Error,1929," TModuleDocInfo(const char* name, TModuleDocInfo* super, const char* doc = """"); virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:2058,Availability,error,error,2058," const char* doc = """"); virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash(",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:2142,Availability,error,error,2142,"char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; vi",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:3166,Modifiability,Inherit,InheritsFrom,3166,"t::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:3232,Modifiability,Inherit,InheritsFrom,3232,"ect::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp);",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:6524,Modifiability,Inherit,Inheritance,6524,"bject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TListfClasses; Bool_tfSelectedselected for doc output; THashListfSubmodules contained in this module; TModuleDocInfo*fSupermodule containing this module. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetSelected(Bool_t sel = kTRUE); { fSelected = sel; }. Bool_t IsSelected() const; { return fSelected; }. TModuleDocInfo(const char* name, TModuleDocInfo* super, const char* doc = """"). virtual ~TModuleDocInfo(); {}. void SetDoc(const char* doc); { SetTitle(doc); }. const char* GetDoc() const; { return GetTitle(); }. void AddClass(TClassDocInfo* cl); { fClasses.Add(cl); }. TList* GetClasses(); { return &fClasses; }. TModuleDocInfo* GetSuper() const; { return fSuper; }. THashList& GetSub(); { return fSub; }.  Author: Nenad Buncic 18/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/html:$Id: TDocInfo.h 23937 2008-05-20 16:44:59Z axel $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:6537,Modifiability,Inherit,Inherited,6537,"bject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TListfClasses; Bool_tfSelectedselected for doc output; THashListfSubmodules contained in this module; TModuleDocInfo*fSupermodule containing this module. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetSelected(Bool_t sel = kTRUE); { fSelected = sel; }. Bool_t IsSelected() const; { return fSelected; }. TModuleDocInfo(const char* name, TModuleDocInfo* super, const char* doc = """"). virtual ~TModuleDocInfo(); {}. void SetDoc(const char* doc); { SetTitle(doc); }. const char* GetDoc() const; { return GetTitle(); }. void AddClass(TClassDocInfo* cl); { fClasses.Add(cl); }. TList* GetClasses(); { return &fClasses; }. TModuleDocInfo* GetSuper() const; { return fSuper; }. THashList& GetSub(); { return fSub; }.  Author: Nenad Buncic 18/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/html:$Id: TDocInfo.h 23937 2008-05-20 16:44:59Z axel $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:3056,Security,Hash,Hash,3056,"error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp);",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:5484,Testability,Test,TestBit,5484,"tatic voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDoc(const char* doc); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetSelected(Bool_t sel = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:5523,Testability,Test,TestBits,5523,"tatic voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDoc(const char* doc); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetSelected(Bool_t sel = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TModuleDocInfo.html:1386,Usability,Clear,Clear,1386," TModuleDocInfo(const char* name, TModuleDocInfo* super, const char* doc = """"); virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject",MatchSource.WIKI,root/html532/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html
https://root.cern/root/html532/TMonaLisaText.html:550,Availability,down,downloaded,550,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:682,Availability,down,download,682,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:1905,Availability,Error,Error,1905," TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:2034,Availability,error,error,2034,"ext&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetText() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfm",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:2118,Availability,error,error,2118,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetText() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual ",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:332,Energy Efficiency,Monitor,Monitoring,332,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:405,Energy Efficiency,monitor,monitoring,405,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:783,Energy Efficiency,monitor,monitoring,783,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:310,Integrability,interface,interface,310,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:3070,Modifiability,Inherit,InheritsFrom,3070,"Method* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetText() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:3136,Modifiability,Inherit,InheritsFrom,3136,"TObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetText() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonaLisaText&operator=(c",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:6174,Modifiability,Inherit,Inheritance,6174," name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue& operator=(const TMonaLisaText& ). TMonaLisaText(const char* name, const char* text); { }. virtual ~TMonaLisaText(); { }. const char * GetText() const; { return GetTitle(); }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:6187,Modifiability,Inherit,Inherited,6187," name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue& operator=(const TMonaLisaText& ). TMonaLisaText(const char* name, const char* text); { }. virtual ~TMonaLisaText(); { }. const char * GetText() const; { return GetTitle(); }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:756,Performance,optimiz,optimized,756,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:2960,Security,Hash,Hash,2960,"ual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetText() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:5298,Testability,Test,TestBit,5298,"hod, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonaLisaText&operator=(const TMonaLisaText&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:5337,Testability,Test,TestBits,5337,"hod, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonaLisaText&operator=(const TMonaLisaText&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaText.html:1362,Usability,Clear,Clear,1362," TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root/html532/TMonaLisaText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html
https://root.cern/root/html532/TMonaLisaValue.html:553,Availability,down,downloaded,553,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:685,Availability,down,download,685,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:1871,Availability,Error,Error,1871," TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:2000,Availability,error,error,2000," TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:2084,Availability,error,error,2084,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_t*GetValuePtr(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* clas",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:335,Energy Efficiency,Monitor,Monitoring,335,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:408,Energy Efficiency,monitor,monitoring,408,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:786,Energy Efficiency,monitor,monitoring,786,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:6230,Energy Efficiency,monitor,monitor,6230,"Int_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMonaLisaValue(const TMonaLisaValue&); TMonaLisaValue&operator=(const TMonaLisaValue&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue(const TMonaLisaValue& ). TMonaLisaValue& operator=(const TMonaLisaValue& ). TMonaLisaValue(const char* name, Double_t value); { }. virtual ~TMonaLisaValue(); { }. Double_t GetValue() const; { return fValue; }. Double_t * GetValuePtr(); { return &fValue; }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:313,Integrability,interface,interface,313,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:3058,Modifiability,Inherit,InheritsFrom,3058,"ray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_t*GetValuePtr(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:3124,Modifiability,Inherit,InheritsFrom,3124,"Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_t*GetValuePtr(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pain",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:6259,Modifiability,Inherit,Inheritance,6259,"Int_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMonaLisaValue(const TMonaLisaValue&); TMonaLisaValue&operator=(const TMonaLisaValue&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue(const TMonaLisaValue& ). TMonaLisaValue& operator=(const TMonaLisaValue& ). TMonaLisaValue(const char* name, Double_t value); { }. virtual ~TMonaLisaValue(); { }. Double_t GetValue() const; { return fValue; }. Double_t * GetValuePtr(); { return &fValue; }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:6272,Modifiability,Inherit,Inherited,6272,"Int_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMonaLisaValue(const TMonaLisaValue&); TMonaLisaValue&operator=(const TMonaLisaValue&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue(const TMonaLisaValue& ). TMonaLisaValue& operator=(const TMonaLisaValue& ). TMonaLisaValue(const char* name, Double_t value); { }. virtual ~TMonaLisaValue(); { }. Double_t GetValue() const; { return fValue; }. Double_t * GetValuePtr(); { return &fValue; }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:759,Performance,optimiz,optimized,759,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:2948,Security,Hash,Hash,2948,"te(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_t*GetValuePtr(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:5239,Testability,Test,TestBit,5239,"Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:5278,Testability,Test,TestBits,5278,"Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaValue.html:1328,Usability,Clear,Clear,1328," TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html532/TMonaLisaValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html
https://root.cern/root/html532/TMonaLisaWriter.html:598,Availability,down,downloaded,598,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:730,Availability,down,download,730,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:2959,Availability,Error,Error,2959,,MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:3088,Availability,error,error,3088," 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ApMon*GetApMon() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:3172,Availability,error,error,3172,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ApMon*GetApMon() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9629,Availability,down,downloaded,9629,"imetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. Th",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9761,Availability,down,download,9761,",MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session I",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:12269,Deployability,update,updates,12269,"l method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime();; gMonitoringWriter->SendInfoStatus(""Submitted"");. On each node executing a subtask, you can set the status of this subtask:; gMonitoringWriter->SendProcessingStatus(""Started"");; During the processing of your analysis you can send progress updates:; gMonitoringWriter->SendProcessProgress(100,1000000); <= 100 events, 1MB processed. gMonitoringWriter-SendProcessingStatus(""Finished"");; delete gMonitoringWriter; gMonitoringWriter=0;. Example of use for any Generic Monitoring information:; TList *valuelist = new TList();; valuelist->SetOwner(kTRUE);; // append a text object; TMonaLisaText *valtext = new TMonaLisaText(""decaychannel"",""K->eeg"");; valuelist->Add(valtext);; // append a double value; TMonaLisaValue* valdouble = new TMonaLisaValue(""n-gamma"",5);; valuelist->Add(valdouble);; Bool_t success = SendParameters(valuelist);; delete valuelist;. option:; ""global"": gMonitoringWriter is initialized with this instance. ~TMonaLisaWriter(); Cleanup. Bool_t SendInfoStatus(const char* status); Sends a <status> text to MonaLisa following the process scheme:; <site> --> <jobid> --> 'status' = <status>; Used to set a global status for a groupjob, e.g.; a master-job or the general status ",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:380,Energy Efficiency,Monitor,Monitoring,380,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:453,Energy Efficiency,monitor,monitoring,453,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:829,Energy Efficiency,monitor,monitoring,829,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:1951,Energy Efficiency,monitor,monitoring,1951,"ctly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtua",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:8773,Energy Efficiency,Monitor,MonitoredTFileInfo,8773,"ntag, const char* monid, const char* monsubid, const char* option); TMonaLisaWriter&operator=(const TMonaLisaWriter&); Bool_tSendFileCheckpoint(TFile* file). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9478,Energy Efficiency,monitor,monitoring,9478,"name! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is ",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9861,Energy Efficiency,monitor,monitoring,9861,"ter which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:10014,Energy Efficiency,Monitor,Monitoring,10014,"s. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:10337,Energy Efficiency,monitor,monitoring,10337,"it(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual no",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:10708,Energy Efficiency,monitor,monitoring,10708,"_Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the proc",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:10842,Energy Efficiency,monitor,monitoring,10842,"ion is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus0",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:11188,Energy Efficiency,monitor,monitoring,11188,"<nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime();; gMonitoringWriter->SendInfoStatus(""Submitted"");. On each node executing a subtask, you ",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:11741,Energy Efficiency,Monitor,Monitoring,11741,"ion ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime();; gMonitoringWriter->SendInfoStatus(""Submitted"");. On each node executing a subtask, you can set the status of this subtask:; gMonitoringWriter->SendProcessingStatus(""Started"");; During the processing of your analysis you can send progress updates:; gMonitoringWriter->SendProcessProgress(100,1000000); <= 100 events, 1MB processed. gMonitoringWriter-SendProcessingStatus(""Finished"");; delete gMonitoringWriter; gMonitoringWriter=0;. Example of use for any Generic Monitoring information:; TList *valuelist = new TList();; valuelist->SetOwner(kTRUE);; // append a text object; TMonaLisaText *valtext = new TMonaLisaText(""decaychannel"",""K->eeg"");; valuelist->Add(valtext);; // append a double value; TMonaLisaValue* valdouble = new TMonaLis",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:12494,Energy Efficiency,Monitor,Monitoring,12494,"id> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime();; gMonitoringWriter->SendInfoStatus(""Submitted"");. On each node executing a subtask, you can set the status of this subtask:; gMonitoringWriter->SendProcessingStatus(""Started"");; During the processing of your analysis you can send progress updates:; gMonitoringWriter->SendProcessProgress(100,1000000); <= 100 events, 1MB processed. gMonitoringWriter-SendProcessingStatus(""Finished"");; delete gMonitoringWriter; gMonitoringWriter=0;. Example of use for any Generic Monitoring information:; TList *valuelist = new TList();; valuelist->SetOwner(kTRUE);; // append a text object; TMonaLisaText *valtext = new TMonaLisaText(""decaychannel"",""K->eeg"");; valuelist->Add(valtext);; // append a double value; TMonaLisaValue* valdouble = new TMonaLisaValue(""n-gamma"",5);; valuelist->Add(valdouble);; Bool_t success = SendParameters(valuelist);; delete valuelist;. option:; ""global"": gMonitoringWriter is initialized with this instance. ~TMonaLisaWriter(); Cleanup. Bool_t SendInfoStatus(const char* status); Sends a <status> text to MonaLisa following the process scheme:; <site> --> <jobid> --> 'status' = <status>; Used to set a global status for a groupjob, e.g.; a master-job or the general status of PROOF processing. Bool_t SendInfoUser(const char* user = 0); Sends the <user> text to MonaLisa following the process scheme:; <site> --> <jobid> --> 'user' = <user>. Bool_t SendInfoDescription(const char* jobtag); Sends the description <jobtag> following the processing scheme:; <site> --> <jobid> --> 'jobname' = <jobtag>. Bool_t SendInfoTime(); Sends the current time to MonaLisa following the processing scheme; <site> --> <jobid> --> 'time' = >u",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:358,Integrability,interface,interface,358,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:4120,Modifiability,Inherit,InheritsFrom,4120,"te(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ApMon*GetApMon() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:4186,Modifiability,Inherit,InheritsFrom,4186,"voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ApMon*GetApMon() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pain",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9081,Modifiability,Inherit,Inheritance,9081,"te; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9094,Modifiability,Inherit,Inherited,9094,"te; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:10525,Modifiability,variab,variables,10525,"ing the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environme",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:10958,Modifiability,variab,variable,10958,"onality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname""",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:11529,Modifiability,variab,variable,11529," - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime();; gMonitoringWriter->SendInfoStatus(""Submitted"");. On each node executing a subtask, you can set the status of this subtask:; gMonitoringWriter->SendProcessingStatus(""Started"");; During the processing of your analysis you can send progress updates:; gMonitoringWriter->SendProcessProgress(100,1000000); <= 100 events, 1MB processed. gMonitoringWriter-SendProcessingStatus(""Finished"");; delete gMonitoringWriter; gMonitoringWriter=0;. Example of use for any Generic Monitoring information:; TList *valuelist = new TList();; valuelist->SetOw",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:802,Performance,optimiz,optimized,802,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:1101,Performance,throughput,throughput,1101,"ource. Sections:; class description; function members; data members; class charts. ROOT;  NET;  MONALISA;  TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """,MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:1542,Performance,latency,latency,1542,"rver using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newnam",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:1873,Performance,perform,performance,1873,"ng, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TO",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:1939,Performance,perform,performance,1939,"ctly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtua",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:8420,Performance,throughput,throughputs,8420,"ntag, const char* monid, const char* monsubid, const char* option); TMonaLisaWriter&operator=(const TMonaLisaWriter&); Bool_tSendFileCheckpoint(TFile* file). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:9835,Performance,optimiz,optimized,9835,"ter which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:11030,Performance,load,loaded,11030,"formation in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime(",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:4010,Security,Hash,Hash,4010,"virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ApMon*GetApMon() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:8413,Security,access,access,8413,"ntag, const char* monid, const char* monsubid, const char* option); TMonaLisaWriter&operator=(const TMonaLisaWriter&); Bool_tSendFileCheckpoint(TFile* file). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:6517,Testability,log,loglevel,6517,"t char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tSendFileCloseEvent(TFile* file); virtual Bool_tSendFileOpenProgress(TFile* file, TList* openphases, const char* openphasename, Bool_t forcesend = kFALSE); virtual Bool_tSendFileReadProgress(TFile* file); virtual Bool_tSendFileWriteProgress(TFile* file); virtual Bool_tSendInfoDescription(const char* jobtag); virtual Bool_tSendInfoStatus(const char* status); virtual Bool_tSendInfoTime(); virtual Bool_tSendInfoUser(const char* user = 0); virtual Bool_tSendParameters(TList* valuelist, const char* identifier = 0); virtual Bool_tSendProcessingProgress(Double_t nevent, Double_t nbytes, Bool_t force = kFALSE); virtual Bool_tSendProcessingStatus(const char* status, Bool_t restarttimer = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLogLevel(const char* loglevel = ""WARNING""); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t onoff); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:7062,Testability,Test,TestBit,7062,"t char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tSendFileCloseEvent(TFile* file); virtual Bool_tSendFileOpenProgress(TFile* file, TList* openphases, const char* openphasename, Bool_t forcesend = kFALSE); virtual Bool_tSendFileReadProgress(TFile* file); virtual Bool_tSendFileWriteProgress(TFile* file); virtual Bool_tSendInfoDescription(const char* jobtag); virtual Bool_tSendInfoStatus(const char* status); virtual Bool_tSendInfoTime(); virtual Bool_tSendInfoUser(const char* user = 0); virtual Bool_tSendParameters(TList* valuelist, const char* identifier = 0); virtual Bool_tSendProcessingProgress(Double_t nevent, Double_t nbytes, Bool_t force = kFALSE); virtual Bool_tSendProcessingStatus(const char* status, Bool_t restarttimer = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLogLevel(const char* loglevel = ""WARNING""); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t onoff); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:7101,Testability,Test,TestBits,7101,"t char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tSendFileCloseEvent(TFile* file); virtual Bool_tSendFileOpenProgress(TFile* file, TList* openphases, const char* openphasename, Bool_t forcesend = kFALSE); virtual Bool_tSendFileReadProgress(TFile* file); virtual Bool_tSendFileWriteProgress(TFile* file); virtual Bool_tSendInfoDescription(const char* jobtag); virtual Bool_tSendInfoStatus(const char* status); virtual Bool_tSendInfoTime(); virtual Bool_tSendInfoUser(const char* user = 0); virtual Bool_tSendParameters(TList* valuelist, const char* identifier = 0); virtual Bool_tSendProcessingProgress(Double_t nevent, Double_t nbytes, Bool_t force = kFALSE); virtual Bool_tSendProcessingStatus(const char* status, Bool_t restarttimer = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLogLevel(const char* loglevel = ""WARNING""); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t onoff); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:14975,Testability,log,loglevel,14975,"'time' = >unixtimestamp<. Bool_t SendProcessingStatus(const char* status, Bool_t restarttimer = kFALSE); Send the procesing status 'status' to MonaLisa following the; processing scheme:; <site> --> <jobid> --> 'status' = <status>; Used, to set the processing status of individual subtaks e.g. the; status of a batch (sub-)job or the status of a PROOF slave; participating in query <jobid>. Bool_t SendProcessingProgress(Double_t nevent, Double_t nbytes, Bool_t force = kFALSE); Send the procesing progress to MonaLisa. Bool_t SendFileOpenProgress(TFile* file, TList* openphases, const char* openphasename, Bool_t forcesend = kFALSE); Send the fileopen progress to MonaLisa.; If openphases=0 it means that the information is to be stored; in a temp space, since there is not yet an object where to attach it to.; This is typical in the static Open calls.; The temp openphases are put into a list as soon as one is specified. If thisopenphasename=0 it means that the stored phases (temp and object); have to be cleared. Bool_t SendFileCloseEvent(TFile* file). Bool_t SendFileReadProgress(TFile* file). Bool_t SendFileWriteProgress(TFile* file). Bool_t SendFileCheckpoint(TFile* file). Bool_t SendParameters(TList* valuelist, const char* identifier = 0); Send the parameters to MonaLisa. void SetLogLevel(const char* loglevel = ""WARNING""); Set MonaLisa log level. void Print(Option_t* option = """") const; Print info about MonaLisa object. TMonaLisaValue& operator=(const TMonaLisaWriter& ). TMonaLisaWriter(const TMonaLisaWriter& ). ApMon * GetApMon() const; { return fApmon; }. void Verbose(Bool_t onoff); { fVerbose = onoff; }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:15011,Testability,log,log,15011,"'time' = >unixtimestamp<. Bool_t SendProcessingStatus(const char* status, Bool_t restarttimer = kFALSE); Send the procesing status 'status' to MonaLisa following the; processing scheme:; <site> --> <jobid> --> 'status' = <status>; Used, to set the processing status of individual subtaks e.g. the; status of a batch (sub-)job or the status of a PROOF slave; participating in query <jobid>. Bool_t SendProcessingProgress(Double_t nevent, Double_t nbytes, Bool_t force = kFALSE); Send the procesing progress to MonaLisa. Bool_t SendFileOpenProgress(TFile* file, TList* openphases, const char* openphasename, Bool_t forcesend = kFALSE); Send the fileopen progress to MonaLisa.; If openphases=0 it means that the information is to be stored; in a temp space, since there is not yet an object where to attach it to.; This is typical in the static Open calls.; The temp openphases are put into a list as soon as one is specified. If thisopenphasename=0 it means that the stored phases (temp and object); have to be cleared. Bool_t SendFileCloseEvent(TFile* file). Bool_t SendFileReadProgress(TFile* file). Bool_t SendFileWriteProgress(TFile* file). Bool_t SendFileCheckpoint(TFile* file). Bool_t SendParameters(TList* valuelist, const char* identifier = 0); Send the parameters to MonaLisa. void SetLogLevel(const char* loglevel = ""WARNING""); Set MonaLisa log level. void Print(Option_t* option = """") const; Print info about MonaLisa object. TMonaLisaValue& operator=(const TMonaLisaWriter& ). TMonaLisaWriter(const TMonaLisaWriter& ). ApMon * GetApMon() const; { return fApmon; }. void Verbose(Bool_t onoff); { fVerbose = onoff; }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:2416,Usability,Clear,Clear,2416,,MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonaLisaWriter.html:14670,Usability,clear,cleared,14670,"cheme; <site> --> <jobid> --> 'time' = >unixtimestamp<. Bool_t SendProcessingStatus(const char* status, Bool_t restarttimer = kFALSE); Send the procesing status 'status' to MonaLisa following the; processing scheme:; <site> --> <jobid> --> 'status' = <status>; Used, to set the processing status of individual subtaks e.g. the; status of a batch (sub-)job or the status of a PROOF slave; participating in query <jobid>. Bool_t SendProcessingProgress(Double_t nevent, Double_t nbytes, Bool_t force = kFALSE); Send the procesing progress to MonaLisa. Bool_t SendFileOpenProgress(TFile* file, TList* openphases, const char* openphasename, Bool_t forcesend = kFALSE); Send the fileopen progress to MonaLisa.; If openphases=0 it means that the information is to be stored; in a temp space, since there is not yet an object where to attach it to.; This is typical in the static Open calls.; The temp openphases are put into a list as soon as one is specified. If thisopenphasename=0 it means that the stored phases (temp and object); have to be cleared. Bool_t SendFileCloseEvent(TFile* file). Bool_t SendFileReadProgress(TFile* file). Bool_t SendFileWriteProgress(TFile* file). Bool_t SendFileCheckpoint(TFile* file). Bool_t SendParameters(TList* valuelist, const char* identifier = 0); Send the parameters to MonaLisa. void SetLogLevel(const char* loglevel = ""WARNING""); Set MonaLisa log level. void Print(Option_t* option = """") const; Print info about MonaLisa object. TMonaLisaValue& operator=(const TMonaLisaWriter& ). TMonaLisaWriter(const TMonaLisaWriter& ). ApMon * GetApMon() const; { return fApmon; }. void Verbose(Bool_t onoff); { fVerbose = onoff; }.  Author: Andreas Peters 5/10/2005  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root/html532/TMonaLisaWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonaLisaWriter.html
https://root.cern/root/html532/TMonitor.html:3917,Availability,Error,Error,3917,"(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const;",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:4046,Availability,error,error,4046,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:4130,Availability,error,error,4130,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTi",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10746,Availability,mask,mask,10746,"ll signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to s",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11667,Availability,error,error,11667,"write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12057,Availability,error,error,12057," readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send som",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12288,Availability,error,error,12288,"ivated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check i",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:321,Energy Efficiency,monitor,monitors,321,". TMonitor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TMonitor. class TMonitor: public TObject, public TQObject. TMonitor. This class monitors activity on a number of network sockets.; The actual monitoring is done by TSystem::DispatchOneEvent().; Typical usage: create a TMonitor object. Register a number of; TSocket objects and call TMonitor::Select(). Select() returns the; socket object which has data waiting. TSocket objects can be added,; removed, (temporary) enabled or disabled. Function Members (Methods); public:. TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual~TMonitor(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(TSocket* sock); virtual voidActivateAll(); virtual voidAdd(TSocket* sock, Int_t interest = kRead); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidT",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:383,Energy Efficiency,monitor,monitoring,383,". TMonitor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TMonitor. class TMonitor: public TObject, public TQObject. TMonitor. This class monitors activity on a number of network sockets.; The actual monitoring is done by TSystem::DispatchOneEvent().; Typical usage: create a TMonitor object. Register a number of; TSocket objects and call TMonitor::Select(). Select() returns the; socket object which has data waiting. TSocket objects can be added,; removed, (temporary) enabled or disabled. Function Members (Methods); public:. TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual~TMonitor(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(TSocket* sock); virtual voidActivateAll(); virtual voidAdd(TSocket* sock, Int_t interest = kRead); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidT",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:9781,Energy Efficiency,monitor,monitor,9781," voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). private:. virtual void*GetSender(); voidSetReady(TSocket* sock). Data Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to mo",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:9912,Energy Efficiency,monitor,monitoring,9912," voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). private:. virtual void*GetSender(); voidSetReady(TSocket* sock). Data Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to mo",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10153,Energy Efficiency,monitor,monitor,10153," Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. voi",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10193,Energy Efficiency,monitor,monitoring,10193,"ts { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10314,Energy Efficiency,monitor,monitor,10314,"lidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivat",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10360,Energy Efficiency,monitor,monitored,10360,"kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. v",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10438,Energy Efficiency,monitor,monitor,10438," kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket *",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10496,Energy Efficiency,monitor,monitor,10496,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10563,Energy Efficiency,monitor,monitor,10563,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10637,Energy Efficiency,monitor,monitor,10637,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10881,Energy Efficiency,monitor,monitor,10881," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10948,Energy Efficiency,monitor,monitor,10948," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11022,Energy Efficiency,monitor,monitor,11022," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11114,Energy Efficiency,monitor,monitor,11114,"on documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TLis",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11169,Energy Efficiency,monitor,monitor,11169,"e a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:13601,Energy Efficiency,monitor,monitor,13601,"e also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }.  Author: Fons Rademakers 09/01/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/net:$Id: TMonitor.h 31598 2009-12-07 15:21:47Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:13827,Energy Efficiency,monitor,monitor,13827,"e also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }.  Author: Fons Rademakers 09/01/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/net:$Id: TMonitor.h 31598 2009-12-07 15:21:47Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:6157,Integrability,Message,Message,6157,"QObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(TSocket* s) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12557,Integrability,rout,routine,12557," with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will ",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:5438,Modifiability,Inherit,InheritsFrom,5438,"const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(TSocket* s) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::op",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:5504,Modifiability,Inherit,InheritsFrom,5504,"Option() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(TSocket* s) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10032,Modifiability,Inherit,Inheritance,10032,"private:. virtual void*GetSender(); voidSetReady(TSocket* sock). Data Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readines",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:10045,Modifiability,Inherit,Inherited,10045,"private:. virtual void*GetSender(); voidSetReady(TSocket* sock). Data Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readines",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:4430,Safety,timeout,timeout,4430,"t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:7460,Safety,timeout,timeout,7460,"::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:7521,Safety,timeout,timeout,7521,"::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11698,Safety,timeout,timeout,11698,"rest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) con",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11783,Safety,timeout,timeout,11783,"the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, r",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:11826,Safety,timeout,timeout,11826," add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12126,Safety,timeout,timeout,12126,"l(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12220,Safety,timeout,timeout,12220,"e-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12701,Safety,timeout,timeout,12701,"r to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12770,Safety,timeout,timeout,12770,"e to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used b",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12857,Safety,timeout,timeout,12857,"e to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used b",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:12880,Safety,timeout,timeout,12880," (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * Ge",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:13074,Safety,timeout,timeout,13074," wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }.  Author: Fons Rademakers 09/01/97  Copyright (C) 1995-2000, Rene Brun and F",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:13316,Safety,Avoid,Avoids,13316,"ts with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }.  Author: Fons Rademakers 09/01/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/net:$Id: TMonitor.h 31598 2009-12-07 15:21:47Z rdm $  Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:5240,Security,Hash,Hash,5240," char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(TSocket* s) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObjec",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:8080,Testability,Test,TestBit,8080,"::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:8119,Testability,Test,TestBits,8119,"::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMonitor.html:1400,Usability,Clear,Clear,1400," TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual~TMonitor(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(TSocket* sock); virtual voidActivateAll(); virtual voidAdd(TSocket* sock, Int_t interest = kRead); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidT",MatchSource.WIKI,root/html532/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMonitor.html
https://root.cern/root/html532/TMultiDimFit.html:1086,Availability,reliab,reliably,1086," Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:1808,Availability,error,errors,1808," which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C. The Method. Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by. . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow). where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization. (1). such that. (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; . So what TMultiDimFit does, ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:2514,Availability,error,error,2514,"dent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C. The Method. Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by. . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow). where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization. (1). such that. (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; . So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-kno",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:3084,Availability,error,error,3084,"wo excellents; text for more information. And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C. The Method. Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by. . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow). where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization. (1). such that. (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; . So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only i",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:8787,Availability,Error,Errors,8787,"ltiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction). In case isn't defined, an alternative method of; performing this second test is used: The ; function. is accepted if (refer also to equation(13)). (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user). >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting. as shown below. Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation(4) can be written as. (15). where. (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate. (17). The model ; can therefore be written as. The original model ; is therefore identical with; this if. (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the regi",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:9464,Availability,error,errors,9464," difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting. as shown below. Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation(4) can be written as. (15). where. (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate. (17). The model ; can therefore be written as. The original model ; is therefore identical with; this if. (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5]. Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. Define ; are the 5 dependent; quantities that define a trac",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:11962,Availability,error,error,11962,"ponent Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent. Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Comput",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:12104,Availability,error,error,12104,"ng themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F.James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H.Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Da",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:12702,Availability,Error,Error,12702,"testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F.James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H.Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H.Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981. */. Function Members (Methods); public:. TMultiDimFit(); TMultiDimFit(const TMultiDimFit&); TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); virtual~TMultiDimFit(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddRow(const Double_t* x, Double_t D, Double_t E = 0); virtual voidAddTestRow",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:14464,Availability,Error,Error,14464,"nsion, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); virtual~TMultiDimFit(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddRow(const Double_t* x, Double_t D, Double_t E = 0); virtual voidAddTestRow(const Double_t* x, Double_t D, Double_t E = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """")MENU ; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* = ""d""); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(const Double_t* x, const Double_t* coeff = 0) const; virtual Double_tEvalError(const Double_t* x, const Double_t* coeff = 0) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindParameterization(Option_t* option = """")MENU ; virtual voidFit(Option_t* option = """")MENU ; Double_tGetChi2() const; const TVectorD*GetCoefficients() const; const TMatrixD*GetCorrelationMatrix() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tG",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:14746,Availability,error,error,14746,"e_t E = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """")MENU ; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* = ""d""); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(const Double_t* x, const Double_t* coeff = 0) const; virtual Double_tEvalError(const Double_t* x, const Double_t* coeff = 0) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindParameterization(Option_t* option = """")MENU ; virtual voidFit(Option_t* option = """")MENU ; Double_tGetChi2() const; const TVectorD*GetCoefficients() const; const TMatrixD*GetCorrelationMatrix() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetError() const; Int_t*GetFunctionCodes() const; const TMatrixD*GetFunctions() const; virtual TList*GetHistograms() const; virtual const char*TObject::GetIconName() const; Double_tGetMaxAngle() const; Int_tGetMaxFunctions() const; Int_t*GetMaxPowers() const; Double_tGetMaxQuantity(",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:14830,Availability,error,error,14830,"e(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """")MENU ; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* = ""d""); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(const Double_t* x, const Double_t* coeff = 0) const; virtual Double_tEvalError(const Double_t* x, const Double_t* coeff = 0) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindParameterization(Option_t* option = """")MENU ; virtual voidFit(Option_t* option = """")MENU ; Double_tGetChi2() const; const TVectorD*GetCoefficients() const; const TMatrixD*GetCorrelationMatrix() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetError() const; Int_t*GetFunctionCodes() const; const TMatrixD*GetFunctions() const; virtual TList*GetHistograms() const; virtual const char*TObject::GetIconName() const; Double_tGetMaxAngle() const; Int_tGetMaxFunctions() const; Int_t*GetMaxPowers() const; Double_tGetMaxQuantity() const; Int_tGetMaxStudy() const; Int_tGetMaxTerms() const; const TVectorD*GetMaxVa",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:19644,Availability,error,error,19644," sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:23162,Availability,error,error,23162,,MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:24257,Availability,error,error,24257,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:24707,Availability,Error,Error,24707,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:25623,Availability,error,error,25623,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:25905,Availability,error,error,25905," Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:25966,Availability,error,error,25966," Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:26231,Availability,error,error,26231,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:26420,Availability,error,error,26420," Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameter",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:26481,Availability,error,error,26481," Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameter",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:27027,Availability,error,error,27027,"value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); C",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:28922,Availability,error,errors,28922,"on. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <filename> with .C appended if argument doesn't; end in .cxx or .C. The contains the implementation of the; function:. Double_t <funcname>(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the static variables:. Int_t gNVariables; Int_t gNCoefficients; Double_t gDMean; Double_t gXMean[]; Double_t gXMin[]; Double_t gXMax[]; Double_t gCoefficient[]; Int_t gPower[]. are initialized. The only ROOT header file needed is Rtypes.h. See TMultiDimFit::MakeRealCode for a list of options. void MakeCoefficientErrors(); PRIVATE METHOD:; Compute the errors on the coefficients. For this to be done, the; curvature matrix of the non-orthogonal functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:34285,Availability,error,error,34285,". See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 1e-3); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. Double_t GetMaxAngle() const; { return fMaxAngle; }. Int_t GetMaxFunctions() const; { return fMaxFunctions; }. Int_t* GetMaxPowers() const; { return fMaxPowers; }. Double_t GetMaxQuantity() const; { return fMaxQuantity; }. Int_",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:34321,Availability,error,error,34321,". See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 1e-3); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. Double_t GetMaxAngle() const; { return fMaxAngle; }. Int_t GetMaxFunctions() const; { return fMaxFunctions; }. Int_t* GetMaxPowers() const; { return fMaxPowers; }. Double_t GetMaxQuantity() const; { return fMaxQuantity; }. Int_",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:540,Energy Efficiency,energy,energy,540,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:595,Energy Efficiency,charge,charged,595,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:3245,Energy Efficiency,power,powers,3245,"uantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by. . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow). where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization. (1). such that. (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; . So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:3850,Energy Efficiency,power,power,3850,"(or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen.",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:3993,Energy Efficiency,power,power,3993," Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; fi",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:4112,Energy Efficiency,power,power,4112,"d when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:4134,Energy Efficiency,power,power,4134,"d when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:4397,Energy Efficiency,power,power,4397,"ways when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt). So we are let to consider an matrix ; , an; element ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:4509,Energy Efficiency,power,power,4509,"lways possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt). So we are let to consider an matrix ; , an; element of which is given by.  with. (3). where labels the rows in the training sample and labels; ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:4689,Energy Efficiency,reduce,reduce,4689,"axTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt). So we are let to consider an matrix ; , an; element of which is given by.  with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:4786,Energy Efficiency,reduce,reduce,4786,"axTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt). So we are let to consider an matrix ; , an; element of which is given by.  with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which ",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:8699,Energy Efficiency,reduce,reduced,8699,"tly to the reduction of , if the angle. between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction). In case isn't defined, an alternative method of; performing this second test is used: The ; function. is accepted if (refer also to equation(13)). (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user). >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting. as shown below. Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation(4) can be written as. (15). where. (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate. (17). The model ; can therefore be written as. The original model ; is therefore identical with; this if. (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize t",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:12374,Energy Efficiency,reduce,reduced,12374," from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F.James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H.Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H.Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981. */. Function Members (Methods); public:. TMultiDimFit(); TMultiDimFit(co",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:12493,Energy Efficiency,reduce,reduced,12493," from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F.James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H.Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H.Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981. */. Function Members (Methods); public:. TMultiDimFit(); TMultiDimFit(co",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:19509,Energy Efficiency,power,powers,19509,"oid*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t opt",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:19900,Energy Efficiency,power,powers,19900," sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:20787,Energy Efficiency,power,powers,20787,"oidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tEvalControl(const Int_t* powers) const; virtual Double_tEvalFactor(Int_t p, Double_t x) const; virtual voidMakeCandidates(); virtual voidMakeCoefficientErrors(); virtual voidMakeCoefficients(); virtual voidMakeCorrelation(); virtual Double_tMakeGramSchmidt(Int_t function); virtual voidMakeNormalized(); virtual voidMakeParameterization(); virtual voidMakeRealCode(const char* filename, const char* classname, Option_t* option = """"); voidTObject::MakeZombie(); virtual Bool_tSelect(const Int_t* iv); virtual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. enum EMDFPolyType { kMonomials; kChebyshev; kLegendre; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrix",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:22557,Energy Efficiency,power,powers,22557,"tual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. enum EMDFPolyType { kMonomials; kChebyshev; kLegendre; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:22608,Energy Efficiency,power,powers,22608,"tual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. enum EMDFPolyType { kMonomials; kChebyshev; kLegendre; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:23830,Energy Efficiency,power,powers,23830,,MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:27189,Energy Efficiency,power,powers,27189,"lly, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
https://root.cern/root/html532/TMultiDimFit.html:27269,Energy Efficiency,power,powers,27269,"lly, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for",MatchSource.WIKI,root/html532/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html
