quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Availability,error,error,"eananigans.jl/issues/new/choose); ; * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative; practices. We ask that new contributors read that guide before submitting a pull request. ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull r",MatchSource.DOCS,CONTRIBUTING.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md
Deployability,configurat,configuration," use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any bugs/problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on; existing issues or by opening a new issue. This is to make sure no one else; is working on the same issue and so we can help and guide you in case there; is anything you need to know beforehand. We also hang out on the #oceananigans channel on Julia Slack, which is a great; place to discuss anything Oceananigans-related, especially contributions! To; join the Julia Slack, go to [https://julialang.org/slack/](https://julialang.org/slack/).; ",MatchSource.DOCS,CONTRIBUTING.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md
Integrability,message,message,"# Contributors Guide. Thank you for considering contributing to Oceananigans! . Feel free to ask us questions and chat with us at any time about any topic at all; by . * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new/choose); ; * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative; practices. We ask that new contributors read that guide before submitting a pull request. ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceanan",MatchSource.DOCS,CONTRIBUTING.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md
Modifiability,variab,variable,"ull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work",MatchSource.DOCS,CONTRIBUTING.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md
Security,access,access,"ceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators hav",MatchSource.DOCS,CONTRIBUTING.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md
Usability,guid,guide,"# Contributors Guide. Thank you for considering contributing to Oceananigans! . Feel free to ask us questions and chat with us at any time about any topic at all; by . * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new/choose); ; * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative; practices. We ask that new contributors read that guide before submitting a pull request. ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceanan",MatchSource.DOCS,CONTRIBUTING.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md
Availability,down,downloads,"ontributor's%20Guide-blueviolet?style=flat-square"">; </a>; <a href=""https://doi.org/10.21105/joss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Deployability,release,releases,"ps://www.repostatus.org/#active"">; <img alt=""Repo status"" src=""https://www.repostatus.org/badges/latest/active.svg?style=flat-square"" />; </a>; <a href=""https://mit-license.org"">; <img alt=""MIT license"" src=""https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square"">; </a>; <a href=""https://github.com/CliMA/Oceananigans.jl/discussions"">; <img alt=""Ask us anything"" src=""https://img.shields.io/badge/Ask%20us-anything-1abc9c.svg?style=flat-square"">; </a>; <a href=""https://github.com/SciML/ColPrac"">; <img alt=""ColPrac: Contributor's Guide on Collaborative Practices for Community Packages"" src=""https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet?style=flat-square"">; </a>; <a href=""https://doi.org/10.21105/joss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Energy Efficiency,power,power,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png); ",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Integrability,interface,interface,"2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Laun",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Modifiability,flexible,flexible,"gans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#perf",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Performance,perform,performance-benchmarks,"mg alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* ðŸ„ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128Â² finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = Recti",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Security,access,accessing,"s models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live dangerously.; ; If you've got a question or something, anything! to talk about, don't hesitate to [start a new discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new?).; * The [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) contains practical tips for [getting started with Julia](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans), [accessing and using GPUs](https://github.com/CliMA/Oceananigans.jl/wiki/Accessing-GPUs-and-using-Oceananigans-on-GPUs), and [productive workflows when using Oceananigans](https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments).; * The `#oceananigans` channel on the [Julia Slack](https://julialang.org/slack/), which accesses ""institutional knowledge"" stored in the minds of the amazing Oceananigans community.; * [Issues](https://github.com/CliMA/Oceananigans.jl/issues) and [pull requests](https://github.com/CliMA/Oceananigans.jl/pulls) also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better ðŸŒˆ. ## Citing. If you use Oceananigans.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Oceananigans.jl by name. ```bibtex; @article{OceananigansJOSS,; doi = {10.21105/joss.02018},; ur",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Testability,log,logo,"<a href=""https://mit-license.org"">; <img alt=""MIT license"" src=""https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square"">; </a>; <a href=""https://github.com/CliMA/Oceananigans.jl/discussions"">; <img alt=""Ask us anything"" src=""https://img.shields.io/badge/Ask%20us-anything-1abc9c.svg?style=flat-square"">; </a>; <a href=""https://github.com/SciML/ColPrac"">; <img alt=""ColPrac: Contributor's Guide on Collaborative Practices for Community Packages"" src=""https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet?style=flat-square"">; </a>; <a href=""https://doi.org/10.21105/joss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Usability,simpl,simple,"2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Laun",MatchSource.DOCS,README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md
Availability,down,down,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,benchmark/README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md
Deployability,toggle,toggle,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,benchmark/README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md
Performance,perform,performance,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,benchmark/README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md
Testability,benchmark,benchmarks,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,benchmark/README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md
Deployability,configurat,configurations,"cale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Juliaâ€™s native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boun",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Energy Efficiency,efficient,efficient,"ore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, including the incompressible; Navier-Stokes equations, with spectral methods. # Acknowledgements. Our work is supported by the generosity of Eric and Wendy Schmidt by; recommendation of the Schmidt Futures program, and by the National Science; Foundation under grant AGS-6939393. # References; ",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Integrability,interface,interface,"arch yet simple enough; for students and first-time programmers. ``Oceananigans.jl`` is being developed; as part of the Climate Modeling Alliance project for the simulation of; small-scale ocean physics at high-resolution that affect the evolution of; Earthâ€™s climate. ``Oceananigans.jl`` is designed for high-resolution simulations in idealized; geometries and supports direct numerical simulation, large eddy simulation,; arbitrary numbers of active and passive tracers, and linear and nonlinear; equations of state for seawater. Under the hood, ``Oceananigans.jl`` employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Juliaâ€™s native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` wil",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Modifiability,flexible,flexible,"le: 'Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs'; tags:; - fluid; - ocean; - climate; - Julia; - gpu; authors:; - name: Ali Ramadhan; orcid: 0000-0003-1102-1520; affiliation: 1; - name: Gregory LeClaire Wagner; orcid: 0000-0001-5317-2445; affiliation: 1; - name: Chris Hill; affiliation: 1; - name: Jean-Michel Campin; affiliation: 1; - name: Valentin Churavy; affiliation: 1; - name: Tim Besard; affiliation: 2; - name: Andre Souza; affiliation: 1; - name: Alan Edelman; affiliation: 1; - name: Raffaele Ferrari; affiliation: 1; - name: John Marshall; affiliation: 1; affiliations:; - name: Massachusetts Institute of Technology; index: 1; - name: Julia Computing, Inc.; index: 2; date: 11 August 2020; bibliography: paper.bib; ---. # Summary. ``Oceananigans.jl`` is a fast and friendly software package for the numerical; simulation of incompressible, stratified, rotating fluid flows on CPUs and GPUs.; ``Oceananigans.jl`` is fast and flexible enough for research yet simple enough; for students and first-time programmers. ``Oceananigans.jl`` is being developed; as part of the Climate Modeling Alliance project for the simulation of; small-scale ocean physics at high-resolution that affect the evolution of; Earthâ€™s climate. ``Oceananigans.jl`` is designed for high-resolution simulations in idealized; geometries and supports direct numerical simulation, large eddy simulation,; arbitrary numbers of active and passive tracers, and linear and nonlinear; equations of state for seawater. Under the hood, ``Oceananigans.jl`` employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; boun",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Performance,perform,performance,"employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Juliaâ€™s native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points ass",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Testability,benchmark,benchmarks,"oclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Juliaâ€™s native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future de",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Usability,simpl,simple,"le: 'Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs'; tags:; - fluid; - ocean; - climate; - Julia; - gpu; authors:; - name: Ali Ramadhan; orcid: 0000-0003-1102-1520; affiliation: 1; - name: Gregory LeClaire Wagner; orcid: 0000-0001-5317-2445; affiliation: 1; - name: Chris Hill; affiliation: 1; - name: Jean-Michel Campin; affiliation: 1; - name: Valentin Churavy; affiliation: 1; - name: Tim Besard; affiliation: 2; - name: Andre Souza; affiliation: 1; - name: Alan Edelman; affiliation: 1; - name: Raffaele Ferrari; affiliation: 1; - name: John Marshall; affiliation: 1; affiliations:; - name: Massachusetts Institute of Technology; index: 1; - name: Julia Computing, Inc.; index: 2; date: 11 August 2020; bibliography: paper.bib; ---. # Summary. ``Oceananigans.jl`` is a fast and friendly software package for the numerical; simulation of incompressible, stratified, rotating fluid flows on CPUs and GPUs.; ``Oceananigans.jl`` is fast and flexible enough for research yet simple enough; for students and first-time programmers. ``Oceananigans.jl`` is being developed; as part of the Climate Modeling Alliance project for the simulation of; small-scale ocean physics at high-resolution that affect the evolution of; Earthâ€™s climate. ``Oceananigans.jl`` is designed for high-resolution simulations in idealized; geometries and supports direct numerical simulation, large eddy simulation,; arbitrary numbers of active and passive tracers, and linear and nonlinear; equations of state for seawater. Under the hood, ``Oceananigans.jl`` employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; boun",MatchSource.DOCS,paper/paper.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md
Availability,error,error,"s guide; helps you make a contribution. Feel free to ask us questions and chat with us at any time about any topic at all; by:. * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new). * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit c",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Deployability,configurat,configuration," readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on existing issues or ; by opening a new issue. This is to make sure no one else is working on the same issue and so ; we can help and guide you in case there is anything you need to know beforehand. ## Ground Rules. * Each pull request should consist of a logical collection of changes. You can; include multiple bug fixes in a single pull request, but they should be related.; For unrelated changes, please submit multiple pull requests. * Do not commit changes to files that are irrelevant to your feature or bugfix; (eg: `.gitignore`). * Be willing to accept criticism and work on improving your code; we don't want; to break other users' code, so care must be taken not to introduce bugs. We; discuss pull requests and kee",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Integrability,message,message,"# Contributors Guide. Thank you for considering contributions to Oceananigans! We hope this guide; helps you make a contribution. Feel free to ask us questions and chat with us at any time about any topic at all; by:. * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new). * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/workin",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Modifiability,variab,variable,"quest](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always,put,spaces.after.commas,or.periods. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try an",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Security,access,access,"ceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always,put,spaces.after.commas,or.periods. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collab",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Testability,log,logical,"keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on existing issues or ; by opening a new issue. This is to make sure no one else is working on the same issue and so ; we can help and guide you in case there is anything you need to know beforehand. ## Ground Rules. * Each pull request should consist of a logical collection of changes. You can; include multiple bug fixes in a single pull request, but they should be related.; For unrelated changes, please submit multiple pull requests. * Do not commit changes to files that are irrelevant to your feature or bugfix; (eg: `.gitignore`). * Be willing to accept criticism and work on improving your code; we don't want; to break other users' code, so care must be taken not to introduce bugs. We; discuss pull requests and keep working on them until we believe we've done a; good job. * Be aware that the pull request review process is not immediate, and is; generally proportional to the size of the pull request. ## Reporting a bug. The easiest way to get involved is to report issues you encounter when using; Oceananigans or by requesting something you think is missing. * Head over to the [issues](https://github.com/CLiMA/Oceananigans.jl/issues) page. * Search to see if your issue already exists or has even been solved previously. * If you ind",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Usability,guid,guide,"# Contributors Guide. Thank you for considering contributions to Oceananigans! We hope this guide; helps you make a contribution. Feel free to ask us questions and chat with us at any time about any topic at all; by:. * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new). * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/workin",MatchSource.DOCS,docs/src/contributing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md
Integrability,interface,interfaces,"bounded grid of cells; that divide up a cube with dimensions ``1 \times 1 \times 1``:. ```jldoctest fields; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (4, 5, 4),; halo = (1, 1, 1),; x = (0, 1),; y = (0, 1),; z = [0, 0.1, 0.3, 0.6, 1]). # output; 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0) regularly spaced with Î”x=0.25; â”œâ”€â”€ Periodic y âˆˆ [0.0, 1.0) regularly spaced with Î”y=0.2; â””â”€â”€ Bounded z âˆˆ [0.0, 1.0] variably spaced with min(Î”z)=0.1, max(Î”z)=0.4; ```. The cubic domain is divided into a ""primary mesh"" of ``4 \times 5 \times 4 = 80`` cells,; which are evenly spaced in ``x, y`` but variably spaced in ``z``.; Now, in addition to the primary mesh, the grid defines also a set of ""staggered"" grids whose cells are; shifted by half a cell width relative to the primary mesh.; In other words, the staggered grid cells have a ""location"" in each direction -- either `Center`,; and therefore co-located with the primary mesh, or `Face` and located over the interfaces of the; primary mesh.; For example, the primary or `Center` cell spacings in ``z`` are. ```jldoctest fields; zspacings(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.1; 0.19999999999999998; 0.3; 0.4; ```. corresponding to cell interfaces located at `z = [0, 0.1, 0.3, 0.6, 1]`.; But then for the grid which is staggered in `z` relative to the primary mesh,. ```jldoctest fields; zspacings(grid, Face()). # output; 5-element view(OffsetArray(::Vector{Float64}, -1:5), 1:5) with eltype Float64:; 0.1; 0.15000000000000002; 0.24999999999999994; 0.3500000000000001; 0.3999999999999999; ```. The cells for the vertically staggered grid have different spacings than the primary mesh.; That's because the _edges_ of the vertically-staggered mesh coincide with the _nodes_ (the cell centers); of the primary mesh. The nodes of the primary mesh are. ```jldoctest fi",MatchSource.DOCS,docs/src/fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md
Modifiability,variab,variably,"ns`, may be computed from an `operand` ; or expression involving other fields, and may cover only a portion of the total; `indices` spanned by the grid. ## Staggered grids and field locations. Oceananigans ocean-flavored fluids simulations rely fundamentally on; ""staggered grid"" numerical methods. Recall that [grids](@ref grids_tutorial) represent a physical domain divided into finite volumes.; For example, let's consider a horizontally-periodic, vertically-bounded grid of cells; that divide up a cube with dimensions ``1 \times 1 \times 1``:. ```jldoctest fields; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (4, 5, 4),; halo = (1, 1, 1),; x = (0, 1),; y = (0, 1),; z = [0, 0.1, 0.3, 0.6, 1]). # output; 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0) regularly spaced with Î”x=0.25; â”œâ”€â”€ Periodic y âˆˆ [0.0, 1.0) regularly spaced with Î”y=0.2; â””â”€â”€ Bounded z âˆˆ [0.0, 1.0] variably spaced with min(Î”z)=0.1, max(Î”z)=0.4; ```. The cubic domain is divided into a ""primary mesh"" of ``4 \times 5 \times 4 = 80`` cells,; which are evenly spaced in ``x, y`` but variably spaced in ``z``.; Now, in addition to the primary mesh, the grid defines also a set of ""staggered"" grids whose cells are; shifted by half a cell width relative to the primary mesh.; In other words, the staggered grid cells have a ""location"" in each direction -- either `Center`,; and therefore co-located with the primary mesh, or `Face` and located over the interfaces of the; primary mesh.; For example, the primary or `Center` cell spacings in ``z`` are. ```jldoctest fields; zspacings(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.1; 0.19999999999999998; 0.3; 0.4; ```. corresponding to cell interfaces located at `z = [0, 0.1, 0.3, 0.6, 1]`.; But then for the grid which is staggered in `z` relative to the primary mesh,. ```jldoctest fields; zspacings(gri",MatchSource.DOCS,docs/src/fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md
Security,access,accessed,"5; 0.75 0.75 0.75 0.75 0.75 0.75 0.75; 1.25 1.25 1.25 1.25 1.25 1.25 1.25; 1.75 1.75 1.75 1.75 1.75 1.75 1.75; 0.25 0.25 0.25 0.25 0.25 0.25 0.25; ```. The way the halo regions are filled depends on `c.boundary_conditions`:. ```julia; c.boundary_conditions. # output; Oceananigans.FieldBoundaryConditions, with boundary conditions; â”œâ”€â”€ west: PeriodicBoundaryCondition; â”œâ”€â”€ east: PeriodicBoundaryCondition; â”œâ”€â”€ south: PeriodicBoundaryCondition; â”œâ”€â”€ north: PeriodicBoundaryCondition; â”œâ”€â”€ bottom: FluxBoundaryCondition: Nothing; â”œâ”€â”€ top: FluxBoundaryCondition: Nothing; â””â”€â”€ immersed: FluxBoundaryCondition: Nothing; ```. Specifically for `c` above, `x` and `y` are `Periodic` while `z` has been assigned; the default ""no-flux"" boundary conditions for a `Field` with `Center` location in; a `Bounded` direction.; For no-flux boundary conditions, the halo regions of `c` are filled so that derivatives evaluated; on the boundary return 0.; To view only the interior cells of `c` we use the function `interior`,. ```jldoctest fields; interior(c, :, :, 1). # output; 4Ã—5 view(::Array{Float64, 3}, 2:5, 2:6, 2) with eltype Float64:; 0.25 0.25 0.25 0.25 0.25; 0.75 0.75 0.75 0.75 0.75; 1.25 1.25 1.25 1.25 1.25; 1.75 1.75 1.75 1.75 1.75; ```. Note that the indices of `c` (and the indices of `c.data`) are ""offset"" so that index `1`; corresponds to the first interior cell.; As a result,. ```jldoctest fields; c[1:4, 1:5, 1] == interior(c, :, :, 1). # output; true; ```. and more generally. ```jldoctest fields; typeof(c.data). # output; OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}; ```. Thus, for example, the `x`-indices of `c.data` vary from `1 - Hx` to `Nx + Hx` -- in this; case, from `0` to `5`.; The underlying array can be accessed with `parent(c)`.; But note that the ""parent"" array does not have offset indices, so. ```jldoctest fields; @show parent(c)[1:2, 2, 2]; @show c.data[1:2, 1, 1]; nothing. # output; (parent(c))[1:2, 2, 2] = [1.75, 0.25]; c.data[1:2, 1, 1] = [0.25, 0.75]; ```; ",MatchSource.DOCS,docs/src/fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md
Usability,simpl,simple,"label=""Cell interfaces""). ylims!(ax, -1, 1); xlims!(ax, -0.1, 1.1); hideydecorations!(ax); hidexdecorations!(ax, ticklabels=false, label=false); hidespines!(ax). Legend(fig[0, 1], ax, nbanks=2, framevisible=false). current_figure(); ```. ## Setting `Field`s. `Field`s are full of 0's when they are created, which is not very exciting.; The situation can be improved using [`set!`](@ref) to change the values of a field.; For example,. ```jldoctest fields; set!(c, 42). # output; 4Ã—5Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 6Ã—7Ã—6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5Ã—0:6Ã—0:5; â””â”€â”€ max=42.0, min=42.0, mean=42.0; ```. Now `c` is filled with `42`s (for this simple case, we could also have used `c .= 42`).; Let's confirm that:. ```jldoctest fields; c[1, 1, 1]. # output; 42.0; ```. Looks good. And. ```jldoctest fields; c[1:4, 1:5, 1]. # output; 4Ã—5 Matrix{Float64}:; 42.0 42.0 42.0 42.0 42.0; 42.0 42.0 42.0 42.0 42.0; 42.0 42.0 42.0 42.0 42.0; 42.0 42.0 42.0 42.0 42.0; ```. Note that indexing into `c` is the same as indexing into `c.data`. ```jldoctest fields; c[:, :, :] == c.data; ; # output; true; ```. We can also `set!` with arrays,. ```@setup fields; using Random; Random.seed!(123); ```. ```@example fields; random_stuff = rand(size(c)...); set!(c, random_stuff). heatmap(view(c, :, :, 1)); ```. or even use functions to set,. ```jldoctest fields; fun_stuff(x, y, z) = 2x; set!(c, fun_stuff). # output. 4Ã—5Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic,",MatchSource.DOCS,docs/src/fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md
Energy Efficiency,meter,meters,"d layer"" has a relatively constant; temperature and keeps deepening as the surface is cooled. The video shows the temperature field and the domain is sliced in half. [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ## [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a; resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of; 0.1 N/mÂ² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a ""mixed; layer"" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz; instabilities as the mechanical mixing sets in. The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line; plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy; (middle right), and the horizontally averaged buoyancy flux (or temperature flux). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ## [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux; that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m; horizontally periodic domain. A pretty strong wind stress of 0.1 N/mÂ² is applied in the x direction which mechanically; mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/mÂ² whi",MatchSource.DOCS,docs/src/gallery.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md
Modifiability,layers,layers,"ow the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy; (middle right), and the horizontally averaged buoyancy flux (or temperature flux). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ## [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux; that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m; horizontally periodic domain. A pretty strong wind stress of 0.1 N/mÂ² is applied in the x direction which mechanically; mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/mÂ² which cools the; surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective; process that keeps mixing the upper layer of the ocean. This leads to a ""mixed layer"" of constant temperature near the; surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in. The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the; horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right),; and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show; the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed; by internal waves. [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ",MatchSource.DOCS,docs/src/gallery.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md
Usability,clear,clear,"# Gallery. Collection of cool movies!. ## [Deep convection](https://www.youtube.com/watch?v=kpUrxnKKMjI). An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in; a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m; at a rate of 800 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the; ocean interior, initiating a convective process that penetrates deep into the ocean. This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in; the Labrador Sea. The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling; disk is clear. [![Watch deep convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/surface_temp_3d_00130_halfsize.png)](https://www.youtube.com/watch?v=kpUrxnKKMjI). ## [Free convection](https://www.youtube.com/watch?v=yq4op9h3xcU). An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in; a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/mÂ² which cools; the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a; convective process that keeps mixing the upper layer of the ocean. This ""mixed layer"" has a relatively constant; temperature and keeps deepening as the surface is cooled. The video shows the temperature field and the domain is sliced in half. [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ## [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). An idealized simulation of a strong wind stress acti",MatchSource.DOCS,docs/src/gallery.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md
Availability,avail,available,"``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3Ã—0Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 20.0) regularly spaced with Î”x=2.0; â”œâ”€â”€ Flat y; â””â”€â”€ Bounded z âˆˆ [0.0, 10.0] variably spaced with min(Î”z)=1.0, max(Î”z)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (or ""kwarg"" for short) that specifies the ``y``-domains may be omitted, and `size` has only two elements rather than 3 as in the first example.; In the stretched cell interfaces specified by `z_interfaces`, the number of; vertical cell interfaces is `Nz + 1 = length(z_interfaces) = 5`, where `Nz = 4` is the number; of cells in the vertical. A bit later in this tutorial, we'll give examples that illustrate how to build a grid thats [`Distributed`](@ref) across _multiple_ CPUs and GPUs. ## Grid types: squares, shells, and mountains. The shape of the physical domain determines what ",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Energy Efficiency,energy,energy,"# [Grids](@id grids_tutorial). ```@meta; DocTestSetup = quote; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); set_theme!(Theme(fontsize=24)); end; ```. Oceananigans simulates the dynamics of ocean-flavored fluids by solving equations that conserve momentum, mass, and energy on a grid of finite volumes or ""cells"".; The first decision we make when setting up a simulation is: on what _grid_ are we going to run our simulation?; The ""grid"" captures the. 1. The geometry of the physical domain;; 2. The way that domain is divided into a mesh of finite volumes;; 3. The machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and; 4. The precision of floating point numbers (double precision or single precision). We start by making a simple grid that divides a three-dimensional rectangular domain -- ""a box"" -- into evenly-spaced cells,. ```jldoctest grids; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16Ã—8Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Integrability,interface,interfaces,"0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3Ã—0Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 20.0) regularly spaced with Î”x=2.0; â”œâ”€â”€ Flat y; â””â”€â”€ Bounded z âˆˆ [0.0, 10.0] variably spaced with min(Î”z)=1.0, max(Î”z)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Modifiability,variab,variably-spaced,"0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3Ã—0Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 20.0) regularly spaced with Î”x=2.0; â”œâ”€â”€ Flat y; â””â”€â”€ Bounded z âˆˆ [0.0, 10.0] variably spaced with min(Î”z)=1.0, max(Î”z)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Performance,perform,performing,"; end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90áµ’N; Î»f = latitude_faces.(1:Nx); Ny = findfirst(Î»f .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; Ï† = Ï†nodes(grid, Center()); Î”x = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Î”y = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Î”x ./ 1e3, Ï†). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Î”y ./ 1e3, Ï†). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `RectilinearGrid`. To build a grid whose fields are represented with single-precision floating point values,; we specify the `float_type` argument along with the (optional) `architecture` argument,. ```jldoctest grids; architecture = CPU(); float_type = Float32. grid = RectilinearGrid(architecture, float_type,; topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16Ã—8Ã—4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. !!! warn ""Using single precision""; Single precision should be used with care.; Users interested in performing single-precision simulations should get in touch via; [Discussions](https://github.com/CliMA/Oceananigans.jl/discussions),; and should subject their work to extensive testing and validation. For more examples see [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid); and [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid).; ",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Security,validat,validation,"; end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90áµ’N; Î»f = latitude_faces.(1:Nx); Ny = findfirst(Î»f .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; Ï† = Ï†nodes(grid, Center()); Î”x = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Î”y = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Î”x ./ 1e3, Ï†). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Î”y ./ 1e3, Ï†). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `RectilinearGrid`. To build a grid whose fields are represented with single-precision floating point values,; we specify the `float_type` argument along with the (optional) `architecture` argument,. ```jldoctest grids; architecture = CPU(); float_type = Float32. grid = RectilinearGrid(architecture, float_type,; topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16Ã—8Ã—4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. !!! warn ""Using single precision""; Single precision should be used with care.; Users interested in performing single-precision simulations should get in touch via; [Discussions](https://github.com/CliMA/Oceananigans.jl/discussions),; and should subject their work to extensive testing and validation. For more examples see [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid); and [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid).; ",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Testability,test,testing,"; end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90áµ’N; Î»f = latitude_faces.(1:Nx); Ny = findfirst(Î»f .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; Ï† = Ï†nodes(grid, Center()); Î”x = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Î”y = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Î”x ./ 1e3, Ï†). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Î”y ./ 1e3, Ï†). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `RectilinearGrid`. To build a grid whose fields are represented with single-precision floating point values,; we specify the `float_type` argument along with the (optional) `architecture` argument,. ```jldoctest grids; architecture = CPU(); float_type = Float32. grid = RectilinearGrid(architecture, float_type,; topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16Ã—8Ã—4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. !!! warn ""Using single precision""; Single precision should be used with care.; Users interested in performing single-precision simulations should get in touch via; [Discussions](https://github.com/CliMA/Oceananigans.jl/discussions),; and should subject their work to extensive testing and validation. For more examples see [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid); and [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid).; ",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Usability,simpl,simple,"# [Grids](@id grids_tutorial). ```@meta; DocTestSetup = quote; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); set_theme!(Theme(fontsize=24)); end; ```. Oceananigans simulates the dynamics of ocean-flavored fluids by solving equations that conserve momentum, mass, and energy on a grid of finite volumes or ""cells"".; The first decision we make when setting up a simulation is: on what _grid_ are we going to run our simulation?; The ""grid"" captures the. 1. The geometry of the physical domain;; 2. The way that domain is divided into a mesh of finite volumes;; 3. The machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and; 4. The precision of floating point numbers (double precision or single precision). We start by making a simple grid that divides a three-dimensional rectangular domain -- ""a box"" -- into evenly-spaced cells,. ```jldoctest grids; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16Ã—8Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [0.0, 8.0] regularly spaced with Î”z=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](",MatchSource.DOCS,docs/src/grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md
Availability,down,downloads,"# Oceananigans.jl. *ðŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,docs/src/index.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md
Deployability,install,install,"# Oceananigans.jl. *ðŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,docs/src/index.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md
Integrability,interface,interface,"# Oceananigans.jl. *ðŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,docs/src/index.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md
Modifiability,flexible,flexible,"# Oceananigans.jl. *ðŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,docs/src/index.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md
Security,access,accessing,"igans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live dangerously.; ; If you've got a question or something to talk about, don't hesitate to [start a new discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new?)!; * The [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki), which contains practical tips for [getting started with Julia](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans), [accessing and using GPUs](https://github.com/CliMA/Oceananigans.jl/wiki/Oceananigans-on-GPUs), and [productive workflows when using Oceananigans](https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments).; * [Issues](https://github.com/CliMA/Oceananigans.jl/issues) and [pull requests](https://github.com/CliMA/Oceananigans.jl/pulls) also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better ðŸŒˆ. ## Getting in touch. Whether you need help getting started with Oceananigans, found a bug, want Oceananigans to be more awesome, or just want to chat about computational oceanography, you've got a few options for getting in touch:. * [Start a discussion](https://github.com/CliMA/Oceananigans.jl/discussions). This is great for general questions about numerics, science, experimental or under-documented features, and for getting help setting up a neat new nu",MatchSource.DOCS,docs/src/index.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md
Usability,simpl,simple,"# Oceananigans.jl. *ðŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,docs/src/index.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md
Energy Efficiency,power,powerful,"# Operations and averaging. `Field`s are more than mere vessels for data.; They come equipped with a powerful infrastructure for assembling expression trees that represent; arithmetic and discrete calculus operations.; We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of `Field`s.; This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed; and saved to disk while a simulation runs, and also for post-processing. We start by constructing a `CenterField` on a simple grid,. ```jldoctest operations; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded),; size = (4, 4),; x = (0, 2Ï€),; z = (-4, 0)). c = CenterField(grid). periodic_but_decaying(x, z) = sin(x) * exp(z); set!(c, periodic_but_decaying). # output; 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 10Ã—1Ã—10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7Ã—1:1Ã—-2:7; â””â”€â”€ max=0.428882, min=-0.428882, mean=1.04083e-17; ```. An `AbstractOperation` (or _operation_ for short) differs from a `Field` in that only represents a computation.; Unlike `Field`s, `AbstractOperation`s do not have any data, and are associated only with minimal memory allocation.; `AbstractOperations` are generated by inflicting `Field`s with ordinary arithmetic expressions,. ```jldoctest operations; two_c = 2 * c. # output; BinaryOperation at (Center, Center, Center); â”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo; â””â”€â”€ tree:; * at (Center, Center, Center); Â Â  â”œâ”€â”€ 2; Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; ```. and even by chaining e",MatchSource.DOCS,docs/src/operations.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md
Performance,perform,performed,"# Operations and averaging. `Field`s are more than mere vessels for data.; They come equipped with a powerful infrastructure for assembling expression trees that represent; arithmetic and discrete calculus operations.; We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of `Field`s.; This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed; and saved to disk while a simulation runs, and also for post-processing. We start by constructing a `CenterField` on a simple grid,. ```jldoctest operations; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded),; size = (4, 4),; x = (0, 2Ï€),; z = (-4, 0)). c = CenterField(grid). periodic_but_decaying(x, z) = sin(x) * exp(z); set!(c, periodic_but_decaying). # output; 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 10Ã—1Ã—10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7Ã—1:1Ã—-2:7; â””â”€â”€ max=0.428882, min=-0.428882, mean=1.04083e-17; ```. An `AbstractOperation` (or _operation_ for short) differs from a `Field` in that only represents a computation.; Unlike `Field`s, `AbstractOperation`s do not have any data, and are associated only with minimal memory allocation.; `AbstractOperations` are generated by inflicting `Field`s with ordinary arithmetic expressions,. ```jldoctest operations; two_c = 2 * c. # output; BinaryOperation at (Center, Center, Center); â”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo; â””â”€â”€ tree:; * at (Center, Center, Center); Â Â  â”œâ”€â”€ 2; Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; ```. and even by chaining e",MatchSource.DOCS,docs/src/operations.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md
Usability,simpl,simple,"# Operations and averaging. `Field`s are more than mere vessels for data.; They come equipped with a powerful infrastructure for assembling expression trees that represent; arithmetic and discrete calculus operations.; We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of `Field`s.; This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed; and saved to disk while a simulation runs, and also for post-processing. We start by constructing a `CenterField` on a simple grid,. ```jldoctest operations; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded),; size = (4, 4),; x = (0, 2Ï€),; z = (-4, 0)). c = CenterField(grid). periodic_but_decaying(x, z) = sin(x) * exp(z); set!(c, periodic_but_decaying). # output; 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 10Ã—1Ã—10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7Ã—1:1Ã—-2:7; â””â”€â”€ max=0.428882, min=-0.428882, mean=1.04083e-17; ```. An `AbstractOperation` (or _operation_ for short) differs from a `Field` in that only represents a computation.; Unlike `Field`s, `AbstractOperation`s do not have any data, and are associated only with minimal memory allocation.; `AbstractOperations` are generated by inflicting `Field`s with ordinary arithmetic expressions,. ```jldoctest operations; two_c = 2 * c. # output; BinaryOperation at (Center, Center, Center); â”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo; â””â”€â”€ tree:; * at (Center, Center, Center); Â Â  â”œâ”€â”€ 2; Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU; ```. and even by chaining e",MatchSource.DOCS,docs/src/operations.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md
Availability,avail,available," A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Î¶); heatmap(Î¶, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Î”t` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-Ï€, Ï€),; y = (-Ï€, Ï€),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Î´ = 0.5; cáµ¢(x, y) = exp(-(x^2 + y^2) / 2Î´^2); Ïµ(x, y) = 2rand() - 1; set!(model, u=Ïµ, v=Ïµ, c=cáµ¢). simulation = Simulation(model; Î”t=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). fig = Figure(size=(1200, 600)); axÎ¶ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axÎ¶, Î¶, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `RectilinearGrid`.; (This only works if a GPU is available, of course, and; [CUDA.jl is configured](https://cuda.juliagpu.org/stable/installation/overview/).). ## Well, that was tantalizing. But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions,; turbulence closures, output writing, actually labeling your axes... ðŸ¤¯).; It'd be best to move on to the [one-dimensional diffusion example](@ref one_dimensional_diffusion_example).; ",MatchSource.DOCS,docs/src/quick_start.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md
Deployability,update,update,"urbulence simulation with `128Â²` [finite volume](https://en.wikipedia.org/wiki/Finite_volume_method) cells; and a fifth-order upwinded [WENO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). heatmap(Î¶, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Î¶); heatmap(Î¶, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Î”t` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-Ï€, Ï€),; y = (-Ï€, Ï€),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Î´ = 0.5; cáµ¢(x, y) = exp(-(x^2 + y^2) / 2Î´^2); Ïµ(x, y) = 2rand() - 1; set!(model, u=Ïµ, v=Ïµ, c=cáµ¢). simulation = Simulation(model; Î”t=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). fig = Figure(size=(1200, 600)); axÎ¶ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axÎ¶, Î¶, colorm",MatchSource.DOCS,docs/src/quick_start.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md
Energy Efficiency,adapt,adaptively,"NO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). heatmap(Î¶, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Î¶); heatmap(Î¶, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Î”t` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-Ï€, Ï€),; y = (-Ï€, Ï€),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Î´ = 0.5; cáµ¢(x, y) = exp(-(x^2 + y^2) / 2Î´^2); Ïµ(x, y) = 2rand() - 1; set!(model, u=Ïµ, v=Ïµ, c=cáµ¢). simulation = Simulation(model; Î”t=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). fig = Figure(size=(1200, 600)); axÎ¶ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axÎ¶, Î¶, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `Re",MatchSource.DOCS,docs/src/quick_start.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md
Modifiability,adapt,adaptively,"NO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). heatmap(Î¶, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Î¶); heatmap(Î¶, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Î”t` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-Ï€, Ï€),; y = (-Ï€, Ï€),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Î´ = 0.5; cáµ¢(x, y) = exp(-(x^2 + y^2) / 2Î´^2); Ïµ(x, y) = 2rand() - 1; set!(model, u=Ïµ, v=Ïµ, c=cáµ¢). simulation = Simulation(model; Î”t=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). fig = Figure(size=(1200, 600)); axÎ¶ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axÎ¶, Î¶, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `Re",MatchSource.DOCS,docs/src/quick_start.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md
Usability,simpl,simple," simulation = Simulation(model; Î”t=0.01, stop_iteration=100); run!(simulation); ```. runs 100 time steps of a two-dimensional turbulence simulation with `128Â²` [finite volume](https://en.wikipedia.org/wiki/Finite_volume_method) cells; and a fifth-order upwinded [WENO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). heatmap(Î¶, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Î¶); heatmap(Î¶, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Î”t` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-Ï€, Ï€),; y = (-Ï€, Ï€),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Î´ = 0.5; cáµ¢(x, y) = exp(-(x^2 + y^2) / 2Î´^2); Ïµ(x, y) = 2rand() - 1; set!(model, u=Ïµ, v=Ïµ, c=cáµ¢). simulation = Simulation(model; Î”t=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Î¶ = Field(âˆ‚x(v) - âˆ‚y(u)); compute!(Î¶). fig = Figure(size=(1200, 600))",MatchSource.DOCS,docs/src/quick_start.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md
Energy Efficiency,schedul,scheduling,"# Simulations. `Simulation`s are basically a utility for managing a time-stepping loop, including scheduling; important activities such as:. * Logging the progress of a simulation,; * Computing and writing diagnostics or other output to disk,; * Stopping a simulation when its time has come. The most important line in any script is `run!(simulation)`.; ",MatchSource.DOCS,docs/src/simulations.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulations.md
Availability,down,down,"much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings)",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Energy Efficiency,efficient,efficient,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Integrability,depend,depends," Î½). Îµ = Field(Îµ_op). compute!(Îµ); ```. Writing kernel functions like `isotropic_viscous_dissipation_rate_ccc`; requires understanding the C-grid, but incurs only one iteration over the domain. `KernelFunctionOperation`s for some diagnostics common to large eddy simulation are defined in; [Oceanostics.jl](https://github.com/tomchor/Oceanostics.jl/blob/3b8f67338656557877ef8ef5ebe3af9e7b2974e2/src/TurbulentKineticEnergyTerms.jl#L35-L57),. ```julia; using Oceanostics: IsotropicPseudoViscousDissipationRate; Îµ = IsotropicViscousDissipationRate(model, u, v, w, Î½); compute!(Îµ); ```; [Start an issue on Github](https://github.com/CliMA/Oceananigans.jl/issues/new) if more help is needed. ### Try to decrease the memory-use of your runs. GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of; memory -- enough memory for simulations with about 100 million points, or grids a bit smaller; than 512 Ã— 512 Ã— 512. (The maximum grid size depends on some user-specified factors,; like the number of passive tracers or computed diagnostics.); For large simulations on the GPU, careful management of memory allocation may be required:. - Use the [`nvidia-smi`](https://developer.nvidia.com/nvidia-system-management-interface) command; line utility to monitor the memory usage of the GPU. It should tell you how much memory there is; on your GPU and how much of it you're using and you can run it from Julia via. ```julia; julia> ;; shell> run(`nvidia-smi`); ```. - Try to use higher-order advection schemes. In general when you use a higher-order scheme you need; fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the; [documentation](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Advection); for available advection schemes. - Manually define scratch space to be reused in diagnostics. By default, every time a user-defined; diagnostic is calculated the compiler reserves a new chunk of memory for that c",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Modifiability,variab,variables,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Performance,optimiz,optimize,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Safety,avoid,avoid,"lang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The advantage of inlining; (which in julia can be done with the [`@inline`; macro](https://docs.julialang.org/en/v1/devdocs/meta/)) is that gets rid of the time spent calling; the function. The Julia compiler automatically makes some calls as to what functions it should or; shouldn't inline, but you can force a function to be inlined by including the macro `@inline` before; its definition. This is more suited for small functions that are called often. Here's an example of; an implementation of the Heaviside function that forces it to be inlined:. ```ju",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Security,access,accessed,"ince Julia and KernelAbstractions.jl (needed for GPU runs) already inline some; functions automatically. However, it is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; Tâ‚€ = 20 # áµ’C; surface_temperature(x, y, t) = Tâ‚€ * sin(2Ï€ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const Tâ‚€ = 20 # áµ’C; ```. fixes the issue by indicating to the compiler that `Tâ‚€` will not change. Note that the _literal_ `2Ï€ / 86400` is not an issue -- it's only the; _variable_ `Tâ‚€` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument:. ```julia; Tâ‚€ = 20 # áµ’C; surface_temperature(x, y, t, p) = p.Tâ‚€ * sin(2Ï€ / 86400 * t); T_bcs = FieldBoundaryCondi",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Usability,learn,learning,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,docs/src/simulation_tips.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md
Deployability,continuous,continuous,"3.069 s â”‚ 3.115 s â”‚ 23.03 MiB â”‚ 1034063 â”‚ 2 â”‚; â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜. Shallow water model weak multithreading scaling speedup; â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”; â”‚ size â”‚ threads â”‚ slowdown â”‚ efficiency â”‚ memory â”‚ allocs â”‚; â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤; â”‚ (8192, 512) â”‚ 1 â”‚ 1.0 â”‚ 1.0 â”‚ 1.0 â”‚ 1.0 â”‚; â”‚ (8192, 1024) â”‚ 2 â”‚ 2.04972 â”‚ 0.487872 â”‚ 13.2156 â”‚ 464.601 â”‚; â”‚ (8192, 2048) â”‚ 4 â”‚ 1.63302 â”‚ 0.612363 â”‚ 9.95278 â”‚ 327.951 â”‚; â”‚ (8192, 4096) â”‚ 8 â”‚ 1.62507 â”‚ 0.615359 â”‚ 11.9706 â”‚ 384.754 â”‚; â”‚ (8192, 8192) â”‚ 16 â”‚ 1.74747 â”‚ 0.572257 â”‚ 12.755 â”‚ 372.71 â”‚; â”‚ (8192, 16384) â”‚ 32 â”‚ 2.10486 â”‚ 0.47509 â”‚ 16.846 â”‚ 446.101 â”‚; â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜; ```. ### Strong Scaling Multithreaded Nonhydrostatic Model. The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the `256^3` grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark) to obtain more recent and hopefully ameliorated benchmark results. ```; Oceananigans v0.58.9; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = ",MatchSource.DOCS,docs/src/appendix/benchmarks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md
Energy Efficiency,allocate,allocated,"9 â”‚ 1.13541 â”‚; â”‚ (256, 256, 256) â”‚ (1, 8, 1) â”‚ 6.94845 â”‚ 0.868556 â”‚ 0.972279 â”‚ 1.16437 â”‚; â”‚ (256, 256, 256) â”‚ (1, 16, 1) â”‚ 11.2086 â”‚ 0.700536 â”‚ 0.978143 â”‚ 1.2223 â”‚; â”‚ (256, 256, 256) â”‚ (1, 32, 1) â”‚ 13.0841 â”‚ 0.408879 â”‚ 0.992685 â”‚ 1.33816 â”‚; â”‚ (256, 256, 256) â”‚ (1, 64, 1) â”‚ 17.0612 â”‚ 0.266582 â”‚ 1.03519 â”‚ 1.5735 â”‚; â”‚ (256, 256, 256) â”‚ (1, 128, 1) â”‚ 25.409 â”‚ 0.198508 â”‚ 1.16772 â”‚ 2.03693 â”‚; â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water mode",MatchSource.DOCS,docs/src/appendix/benchmarks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md
Performance,perform,performance,"; # [Performance benchmarks](@id performance_benchmarks). The performance benchmarking scripts in the; [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark); directory of the git repository can be run to benchmark Oceananigans.jl on your machine.; They use [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl) to collect data and [PrettyTables.jl](https://github.com/ronisbr/PrettyTables.jl) to nicely; format the benchmark results. ## Shallow Water Model. This benchmark tests the performance of the shallow water model run in a doubly periodic domain (`topology = (Periodic, Periodic, Flat)`); on a CPU versus a GPU. We find that with the `WENO` advection scheme we get a maximum speedup of more than 400 times on a `16384^2` grid. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”; â”‚ Architectures â”‚ Float_types â”‚ Ns â”‚ min â”‚ median â”‚ mean â”‚ max â”‚ memory â”‚ allocs â”‚ samples â”‚; â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤; â”‚ CPU â”‚ Float64 â”‚ 32 â”‚ 2.677 ms â”‚ 2.876 ms â”‚ 3.047 ms â”‚ 4.806 ms â”‚ 1.36 MiB â”‚ 2253 â”‚ 10 â”‚; â”‚ CPU â”‚ Float64 â”‚ 64 â”‚ 5.795 ms â”‚ 5.890 ms â”‚ 6.073 ms â”‚ 7.770 ms â”‚ 1.36 MiB â”‚ 2255 â”‚ 10 â”‚; â”‚ CPU â”‚ Float64 â”‚ 128 â”‚ 16.979 ms â”‚ 17.350 ms â”‚ 17.578 ms â”‚ 19.993 ms â”‚ ",MatchSource.DOCS,docs/src/appendix/benchmarks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md
Testability,benchmark,benchmarks,"; # [Performance benchmarks](@id performance_benchmarks). The performance benchmarking scripts in the; [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark); directory of the git repository can be run to benchmark Oceananigans.jl on your machine.; They use [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl) to collect data and [PrettyTables.jl](https://github.com/ronisbr/PrettyTables.jl) to nicely; format the benchmark results. ## Shallow Water Model. This benchmark tests the performance of the shallow water model run in a doubly periodic domain (`topology = (Periodic, Periodic, Flat)`); on a CPU versus a GPU. We find that with the `WENO` advection scheme we get a maximum speedup of more than 400 times on a `16384^2` grid. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”; â”‚ Architectures â”‚ Float_types â”‚ Ns â”‚ min â”‚ median â”‚ mean â”‚ max â”‚ memory â”‚ allocs â”‚ samples â”‚; â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤; â”‚ CPU â”‚ Float64 â”‚ 32 â”‚ 2.677 ms â”‚ 2.876 ms â”‚ 3.047 ms â”‚ 4.806 ms â”‚ 1.36 MiB â”‚ 2253 â”‚ 10 â”‚; â”‚ CPU â”‚ Float64 â”‚ 64 â”‚ 5.795 ms â”‚ 5.890 ms â”‚ 6.073 ms â”‚ 7.770 ms â”‚ 1.36 MiB â”‚ 2255 â”‚ 10 â”‚; â”‚ CPU â”‚ Float64 â”‚ 128 â”‚ 16.979 ms â”‚ 17.350 ms â”‚ 17.578 ms â”‚ 19.993 ms â”‚ ",MatchSource.DOCS,docs/src/appendix/benchmarks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md
Usability,simpl,simple,"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤; â”‚ (256, 256, 256) â”‚ (1, 1, 1) â”‚ 1.0 â”‚ 1.0 â”‚ 1.0 â”‚ 1.0 â”‚; â”‚ (256, 256, 256) â”‚ (1, 2, 1) â”‚ 1.89655 â”‚ 0.948276 â”‚ 0.968543 â”‚ 1.12093 â”‚; â”‚ (256, 256, 256) â”‚ (1, 4, 1) â”‚ 3.73522 â”‚ 0.933804 â”‚ 0.969719 â”‚ 1.13541 â”‚; â”‚ (256, 256, 256) â”‚ (1, 8, 1) â”‚ 6.94845 â”‚ 0.868556 â”‚ 0.972279 â”‚ 1.16437 â”‚; â”‚ (256, 256, 256) â”‚ (1, 16, 1) â”‚ 11.2086 â”‚ 0.700536 â”‚ 0.978143 â”‚ 1.2223 â”‚; â”‚ (256, 256, 256) â”‚ (1, 32, 1) â”‚ 13.0841 â”‚ 0.408879 â”‚ 0.992685 â”‚ 1.33816 â”‚; â”‚ (256, 256, 256) â”‚ (1, 64, 1) â”‚ 17.0612 â”‚ 0.266582 â”‚ 1.03519 â”‚ 1.5735 â”‚; â”‚ (256, 256, 256) â”‚ (1, 128, 1) â”‚ 25.409 â”‚ 0.198508 â”‚ 1.16772 â”‚ 2.03693 â”‚; â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/",MatchSource.DOCS,docs/src/appendix/benchmarks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md
Availability,error,error,"implies that ``F_{\omega}`` is given by; ```math; F_{\omega} = -\xi^\prime f_x (g - g^{\prime\prime}) + f f_x (g g^{\prime\prime\prime} - g^\prime g^{\prime\prime}) + f (g - 2 g^{\prime\prime} + g^{\prime\prime\prime\prime}) \, ,; ```; where primes denote derivatives of functions of a single argument. ; Setting ``\partial_y F_v = F_{\omega}``, we find that if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v =",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Deployability,integrat,integration,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Integrability,integrat,integration,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Modifiability,evolve,evolves,"y be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operat",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Performance,perform,performed,"hat if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Security,validat,validation,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Testability,test,tests,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,docs/src/appendix/convergence_tests.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md
Availability,reliab,reliably," an approximation to ; the discretized momentum equation for an intermediate velocity field ``\boldsymbol{v}^\star`` ; without worrying about satisfying the incompressibility constraint. We then project ``\boldsymbol{v}^\star`` ; onto the space of divergence-free velocity fields to obtain a value for ``\boldsymbol{v}^{n+1}`` ; that satisfies continuity. For example, for the `NonhydrostaticModel`, if we ignore the background velocity fields and the; surface waves, we thus discretize the momentum equation as; ```math; \frac{\boldsymbol{v}^\star - \boldsymbol{v}^n}{\Delta t}; = - \left[ \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} \right]^{n+\frac{1}{2}}; - \boldsymbol{f} \times \boldsymbol{v}^{n+\frac{1}{2}}; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \nu \boldsymbol{\nabla} \boldsymbol{v}^{n+\frac{1}{2}} \right ); + \boldsymbol{F}_{\boldsymbol{v}}^{n+\frac{1}{2}} \, ,; ```; where the superscript ``n + \frac{1}{2}`` indicates that these terms are evaluated at time step ; ``n + \frac{1}{2}``, which we compute explicitly (see [Time-stepping section](@ref time_stepping)). The projection is then performed; ```math; \boldsymbol{v}^{n+1} = \boldsymbol{v}^\star - \Delta t \, \boldsymbol{\nabla} p^{n+1} \, ,; ```; to obtain a divergence-free velocity field ``\boldsymbol{v}^{n+1}``. Here the projection is performed by solving an elliptic; problem for the pressure ``p^{n+1}`` with the boundary condition; ```math; \boldsymbol{\hat{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} p^{n+1} |_{\partial\Omega} = 0 \, .; ```. [Orszag86](@citet) and [Brown01](@citet) raise an important issue regarding these fractional step ; methods, which is that ""*while the velocity can be reliably computed to second-order accuracy ; in time and space, the pressure is typically only first-order accurate in the ``L_\infty``-norm.*"" ; The numerical boundary conditions must be carefully accounted for to ensure the second-order ; accuracy promised by the fractional step methods.; ",MatchSource.DOCS,docs/src/appendix/fractional_step.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/fractional_step.md
Performance,perform,performed," an approximation to ; the discretized momentum equation for an intermediate velocity field ``\boldsymbol{v}^\star`` ; without worrying about satisfying the incompressibility constraint. We then project ``\boldsymbol{v}^\star`` ; onto the space of divergence-free velocity fields to obtain a value for ``\boldsymbol{v}^{n+1}`` ; that satisfies continuity. For example, for the `NonhydrostaticModel`, if we ignore the background velocity fields and the; surface waves, we thus discretize the momentum equation as; ```math; \frac{\boldsymbol{v}^\star - \boldsymbol{v}^n}{\Delta t}; = - \left[ \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} \right]^{n+\frac{1}{2}}; - \boldsymbol{f} \times \boldsymbol{v}^{n+\frac{1}{2}}; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \nu \boldsymbol{\nabla} \boldsymbol{v}^{n+\frac{1}{2}} \right ); + \boldsymbol{F}_{\boldsymbol{v}}^{n+\frac{1}{2}} \, ,; ```; where the superscript ``n + \frac{1}{2}`` indicates that these terms are evaluated at time step ; ``n + \frac{1}{2}``, which we compute explicitly (see [Time-stepping section](@ref time_stepping)). The projection is then performed; ```math; \boldsymbol{v}^{n+1} = \boldsymbol{v}^\star - \Delta t \, \boldsymbol{\nabla} p^{n+1} \, ,; ```; to obtain a divergence-free velocity field ``\boldsymbol{v}^{n+1}``. Here the projection is performed by solving an elliptic; problem for the pressure ``p^{n+1}`` with the boundary condition; ```math; \boldsymbol{\hat{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} p^{n+1} |_{\partial\Omega} = 0 \, .; ```. [Orszag86](@citet) and [Brown01](@citet) raise an important issue regarding these fractional step ; methods, which is that ""*while the velocity can be reliably computed to second-order accuracy ; in time and space, the pressure is typically only first-order accurate in the ``L_\infty``-norm.*"" ; The numerical boundary conditions must be carefully accounted for to ensure the second-order ; accuracy promised by the fractional step methods.; ",MatchSource.DOCS,docs/src/appendix/fractional_step.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/fractional_step.md
Integrability,interface,interface,"# Library. Documenting the public user interface. ## Oceananigans.jl. ```@autodocs; Modules = [Oceananigans]; Private = false; ```. ## Abstract operations. ```@autodocs; Modules = [Oceananigans.AbstractOperations]; Private = false; ```. ## Advection. ```@autodocs; Modules = [Oceananigans.Advection]; Private = false; ```. ## Architectures. ```@autodocs; Modules = [Oceananigans.Architectures]; Private = false; ```. ## Boundary conditions. ```@autodocs; Modules = [Oceananigans.BoundaryConditions]; Private = false; ```. ## Buoyancy models. ```@autodocs; Modules = [Oceananigans.BuoyancyModels]; Private = false; ```. ## Coriolis. ```@autodocs; Modules = [Oceananigans.Coriolis]; Private = false; ```. ## Diagnostics. ```@autodocs; Modules = [Oceananigans.Diagnostics]; Private = false; ```. ## Distributed. ```@autodocs; Modules = [Oceananigans.DistributedComputations]; Private = false; ```. ## Fields. ```@autodocs; Modules = [Oceananigans.Fields]; Private = false; ```. ## Forcings. ```@autodocs; Modules = [Oceananigans.Forcings]; Private = false; ```. ## Grids. ```@autodocs; Modules = [Oceananigans.Grids]; Private = false; ```. ## Immersed boundaries. ```@autodocs; Modules = [Oceananigans.ImmersedBoundaries]; Private = false; ```. ## Logger. ```@autodocs; Modules = [Oceananigans.Logger]; Private = false; Pages = [""Logger.jl""]; ```. ## Models. ```@autodocs; Modules = [Oceananigans.Models]; Private = false; ```. ### Non-hydrostatic models. ```@autodocs; Modules = [Oceananigans.Models.NonhydrostaticModels]; Private = false; ```. ### Hydrostatic free-surface models. ```@autodocs; Modules = [Oceananigans.Models.HydrostaticFreeSurfaceModels]; Private = false; ```. ### Shallow-water models. ```@autodocs; Modules = [Oceananigans.Models.ShallowWaterModels]; Private = false; ```. ### Lagrangian particle tracking. ```@autodocs; Modules = [Oceananigans.Models.LagrangianParticleTracking]; Private = false; ```. ## MultiRegion. ```@autodocs; Modules = [Oceananigans.MultiRegion]; Private = f",MatchSource.DOCS,docs/src/appendix/library.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/library.md
Availability,error,error,"odes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model. [Arakawa77](@citet) investigated the dispersion relation of inertia-gravity waves[^2] traveling in the ``x``-direction; ```math; \omega^2 = f^2 + gHk^2 \, ,; ```; in the linearized rotating shallow-water equations for five grids. Here ``\omega`` is the angular frequency, ``H`` is the; height of the fluid and ``k`` is the wavenumber in the ``x``-direction. Looking at the effect of spatial discretization; error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely; out of the five [Arakawa77](@citet) (Figure 5). In particular, the dispersion relation for the C-grid is given by; ```math; \omega^2 = f^2 \left[ \cos^2 \left( \frac{k\Delta}{2} \right); + 4 \left( \frac{\lambda}{\Delta} \right)^2 \sin^2 \left( \frac{k\Delta}{2} \right) \right] \, ,; ```; where ``\lambda`` is the wavelength and ``\Delta`` is the grid spacing. Paraphrasing p. 184 of [Arakawa77](@citet): The; wavelength of the shortest resolvable wave is ``2\Delta`` with corresponding wavenumber ``k = \pi/\Delta`` so it is; sufficient to evaluate the dispersion relation over the range ``0 < k \Delta < \pi``. The frequency is monotonically; increasing for ``\lambda / \Delta > \frac{1}{2}`` and monotonically decreasing for ``\lambda / \Delta < \frac{1}{2}``. For the; fourth smallest wave ``\lambda / \Delta = \frac{1}{2}`` we get ``\omega^2 = f^2`` which matches the ``k = 0`` wave. Furthermore,; the group velocity is zero for all ",MatchSource.DOCS,docs/src/appendix/staggered_grid.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md
Deployability,configurat,configuration,"ence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model. [Arakawa77](@citet) investigated the dispersion relation of inertia-gravity waves[^2] traveling in the ``x``-direction; ```math; \omega^2 = f^2 + gHk^2 \, ,; ```; in the linearized rotating shallow-water equations for five grids. Here ``\omega`` is the angular frequency, ``H`` is the; height of the fluid and ``k`` is the wavenumber in the ``x``-direction. Looking at the effect of spatial discretization; error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely; out of the five [Arakawa77](@citet) (Figure 5). In particular, the dispersion relation for the C-grid is given by; ```math; \omega^2 = f^2 \left[ \cos^2 \left( \frac{k\Delta}{2} \right); + 4 \left( \frac{\lambda}{\Delta} \right)^2 \sin^2 \left( \frac{k\Delta}{2} \right) \right] \, ,; ```; where ``\lambda`` is the wavelength and ``\Delta`` is the",MatchSource.DOCS,docs/src/appendix/staggered_grid.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md
Energy Efficiency,reduce,reduce,"umerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. Â§6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmosp",MatchSource.DOCS,docs/src/appendix/staggered_grid.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md
Modifiability,variab,variables,"# Staggered grid. Velocities ``u``, ``v``, and ``w`` are defined on the faces of the cells, which are coincident with three orthogonal; coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure ``p`` and tracers ``c`` are stored at; the cell centers as cell averages. See schematic below of the different control; volumes. Other quantities may be defined at other locations. For example, vorticity ``\boldsymbol{\omega} = \boldsymbol{\nabla} \times \boldsymbol{v}``; is defined at the cell edges.[^1]. [^1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical; levels as the cell-centered variables and so they really lie at the cell edges. ![Schematic of control volumes](../numerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. Â§6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actuall",MatchSource.DOCS,docs/src/appendix/staggered_grid.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md
Safety,avoid,avoids,"la} \times \boldsymbol{v}``; is defined at the cell edges.[^1]. [^1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical; levels as the cell-centered variables and so they really lie at the cell edges. ![Schematic of control volumes](../numerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. Â§6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced b",MatchSource.DOCS,docs/src/appendix/staggered_grid.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md
Integrability,wrap,wrapped,"""Model compatibility""; `BackgroundFields` are only supported by [`NonhydrostaticModel`](@ref). ## Specifying background fields. `BackgroundField`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. U(x, y, z, t) = 0.2 * z. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U,)). model.background_fields.velocities.u. # output; FunctionField located at (Face, Center, Center); â”œâ”€â”€ func: U (generic function with 1 method); â”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo; â”œâ”€â”€ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Î”t=Inf days); â””â”€â”€ parameters: nothing; ```. `BackgroundField`s are specified by passing them to the kwarg `background_fields`; in the `NonhydrostaticModel` constructor. The kwarg `background_fields` expects; a `NamedTuple` of fields, which are internally sorted into `velocities` and `tracers`,; wrapped in `FunctionField`s, and assigned their appropriate locations. `BackgroundField`s with parameters require using the `BackgroundField` wrapper:. ```jldoctest moar_background; using Oceananigans. parameters = (Î±=3.14, N=1.0, f=0.1). # Background fields are defined via function of x, y, z, t, and optional parameters; U(x, y, z, t, Î±) = Î± * z; B(x, y, z, t, p) = - p.Î± * p.f * y + p.N^2 * z . U_field = BackgroundField(U, parameters=parameters.Î±); B_field = BackgroundField(B, parameters=parameters). # output; BackgroundField{typeof(B), @NamedTuple{Î±::Float64, N::Float64, f::Float64}}; â”œâ”€â”€ func: B (generic function with 1 method); â””â”€â”€ parameters: (Î± = 3.14, N = 1.0, f = 0.1); ```. When inserted into `NonhydrostaticModel`, we get. ```jldoctest moar_background; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U_field, b=B_field),; tracers=:b, buoyancy=BuoyancyTracer()). model.background",MatchSource.DOCS,docs/src/model_setup/background_fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md
Modifiability,evolve,evolve,"# Background fields. `BackgroundField`s are velocity and tracer fields around which the resolved; velocity and tracer fields evolve. Only the _advective_ terms associated with; the interaction between background and resolved fields are included.; For example, tracer advection is described by. ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) \, ,; ```. where ``\boldsymbol{v}`` is the resolved velocity field and ``c`` is the resolved; tracer field corresponding to `model.tracers.c`. . When a background field ``C`` is provided, the tracer advection term becomes. ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} C \right ) \, .; ```. When both a background field velocity field ``\boldsymbol{U}`` and a background tracer field ``C``; are provided, then the tracer advection term becomes. ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} C \right ); + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} c \right ) \, .; ```. Notice that the term ``\boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} C \right )`` ; is neglected: only the terms describing the advection of resolved tracer by the background ; velocity field and the advection of background tracer by the resolved velocity field are included.; An analogous statement holds for the advection of background momentum by the resolved; velocity field.; Other possible terms associated with the Coriolis force, buoyancy, turbulence closures,; and surface waves acting on background fields are neglected. !!! compat ""Model compatibility""; `BackgroundFields` are only supported by [`NonhydrostaticModel`](@ref). ## Specifying background fields. `BackgroundField`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. ",MatchSource.DOCS,docs/src/model_setup/background_fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md
Usability,simpl,simple,"oldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} C \right ); + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} c \right ) \, .; ```. Notice that the term ``\boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} C \right )`` ; is neglected: only the terms describing the advection of resolved tracer by the background ; velocity field and the advection of background tracer by the resolved velocity field are included.; An analogous statement holds for the advection of background momentum by the resolved; velocity field.; Other possible terms associated with the Coriolis force, buoyancy, turbulence closures,; and surface waves acting on background fields are neglected. !!! compat ""Model compatibility""; `BackgroundFields` are only supported by [`NonhydrostaticModel`](@ref). ## Specifying background fields. `BackgroundField`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. U(x, y, z, t) = 0.2 * z. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U,)). model.background_fields.velocities.u. # output; FunctionField located at (Face, Center, Center); â”œâ”€â”€ func: U (generic function with 1 method); â”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo; â”œâ”€â”€ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Î”t=Inf days); â””â”€â”€ parameters: nothing; ```. `BackgroundField`s are specified by passing them to the kwarg `background_fields`; in the `NonhydrostaticModel` constructor. The kwarg `background_fields` expects; a `NamedTuple` of fields, which are internally sorted into `velocities` and `tracers`,; wrapped in `FunctionField`s, and assigned their appropriate locations. `BackgroundField`s with parameters require using the `BackgroundField` wrapper:. ```jldoctest moar_background; using Oceananigan",MatchSource.DOCS,docs/src/model_setup/background_fields.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md
Availability,down,downwards,"boundary conditions on the; _normal_ velocity component must use the [`Open`](@ref) boundary condition type. Finally, note that `ValueBoundaryCondition(condition)` is an alias for `BoundaryCondition(Value, condition)`. ### 2. Constant `Flux` boundary condition. ```jldoctest; julia> Ïâ‚€ = 1027; # Reference density [kg/mÂ³]. julia> Ï„â‚“ = 0.08; # Wind stress [N/mÂ²]. julia> wind_stress_bc = FluxBoundaryCondition(-Ï„â‚“/Ïâ‚€); FluxBoundaryCondition: -7.78968e-5; ```. A constant [`Flux`](@ref) boundary condition can be imposed on tracers and tangential velocity components; that can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface. !!! info ""The flux convention in Oceananigans""; `Oceananigans` uses the convention that positive fluxes produce transport in the; _positive_ direction (east, north, and up for ``x``, ``y``, ``z``).; This means, for example, that a _negative_ flux of momentum or velocity at a _top_; boundary, such as in the above example, produces currents in the _positive_ direction,; because it prescribes a downwards flux of momentum into the domain from the top.; Likewise, a _positive_ temperature flux at the top boundary; causes _cooling_, because it transports heat _upwards_, out of the domain.; Conversely, a positive flux at a _bottom_ boundary acts to increase the interior; values of a quantity. ### 3. Spatially- and temporally-varying flux. Boundary conditions may be specified by functions,. ```jldoctest; julia> @inline surface_flux(x, y, t) = cos(2Ï€ * x) * cos(t);. julia> top_tracer_bc = FluxBoundaryCondition(surface_flux); FluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions""; By default, a function boundary condition is called with the signature; ```julia; f(Î¾, Î·, t); ```; where `t` is time and `Î¾, Î·` are spatial coordinates that vary along the boundary:; * `f(y, z, t)` on `x`-boundaries;; * `f(x, z, t)` on `y`-boundaries;; *",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Integrability,depend,dependent,", z, t)` on `y`-boundaries;; * `f(x, y, t)` on `z`-boundaries.; Alternative function signatures are specified by keyword arguments to; `BoundaryCondition`, as illustrated in subsequent examples. ### 4. Spatially- and temporally-varying flux with parameters. Boundary condition functions may be 'parameterized',. ```jldoctest; julia> @inline wind_stress(x, y, t, p) = - p.Ï„ * cos(p.k * x) * cos(p.Ï‰ * t); # function with parameters. julia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4Ï€, Ï‰=3.0, Ï„=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBound",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Modifiability,evolve,evolved,"e near-surface temperature gradient and the temperature diffusivity;; * constant velocity tangential to a boundary as in a driven-cavity flow (for example), ; where the top boundary is moving. Momentum will flux into the domain do the difference; between the top boundary velocity and the interior velocity, and the prescribed viscosity. 3. `GradientBoundaryCondition` (Neumann) specifies the gradient of a field on a boundary.; For example, if there is a known `diffusivity`, we can express `FluxBoundaryCondition(flux)`; using `GradientBoundaryCondition(-flux / diffusivity)` (aka ""Neumann"" boundary condition). In addition to these primary boundary conditions, `ImpenetrableBoundaryCondition` applies to velocity; components in wall-normal directions. !!! warn ""`ImpenetrableBoundaryCondition`""; `ImpenetrableBoundaryCondition` is internally enforced for fields created inside the model constructor.; As a result, `ImpenetrableBoundaryCondition` is only used for _additional_ velocity components; that are not evolved by a model, such as a velocity component used for (`AdvectiveForcing`)[@ref]. Finally, note that `Periodic` boundary conditions are internally enforced for `Periodic` directions,; and `DefaultBoundaryCondition`s may exist before boundary conditions are ""materialized"" by a model. ## Default boundary conditions. The default boundary condition in `Bounded` directions is no-flux, or `FluxBoundaryCondition(nothing)`.; The default boundary condition can be changed by passing a positional argument to `FieldBoundaryConditions`,; as in. ```jldoctest; julia> no_slip_bc = ValueBoundaryCondition(0.0); ValueBoundaryCondition: 0.0. julia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing)); Oceananigans.FieldBoundaryConditions, with boundary conditions; â”œâ”€â”€ west: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0); â”œâ”€â”€ east: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0); â”œâ”€â”€ south: DefaultBoundaryCondition (ValueBoundaryCon",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Performance,perform,performance,"ses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary conditions expect that `i, j` is replaced; with `j, k` and `i, k` respectively. ### 8. Discrete-form boundary condition with parameters. ```jldoctest; julia> Cd = 0.2; # drag coefficient. julia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];. julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd); FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2; ```. !!! info ""Inlining and avoiding bounds-checking in boundary condition functions""; Boundary condition functions should be decorated with `@inline` when running on CPUs for performance reasons.; On the GPU, all functions are force-inlined by default.; In addition, the annotation `@inbounds` should be used when accessing the elements of an array; in a boundary condition function (such as `model_fields.u[i, j, 1]` in the above example).; Using `@inbounds` will avoid a relatively expensive check that the index `i, j, 1` is 'in bounds'. ### 9. A random, spatially-varying, constant-in-time temperature flux specified by an array. ```jldoctest; julia> Nx = Ny = 16; # Number of grid points. julia> Q = randn(Nx, Ny); # temperature flux. julia> white_noise_T_bc = FluxBoundaryCondition(Q); FluxBoundaryCondition: 16Ã—16 Matrix{Float64}; ```. When running on the GPU, `Q` must be converted to a `CuArray`. ## Building boundary conditions on a field. To create a set of [`FieldBoundaryConditions`](@ref) for a temperature field,; we write. ```jldoctest; julia> T_bcs = FieldBoundaryConditions(top = V",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Safety,avoid,avoiding,"ses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary conditions expect that `i, j` is replaced; with `j, k` and `i, k` respectively. ### 8. Discrete-form boundary condition with parameters. ```jldoctest; julia> Cd = 0.2; # drag coefficient. julia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];. julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd); FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2; ```. !!! info ""Inlining and avoiding bounds-checking in boundary condition functions""; Boundary condition functions should be decorated with `@inline` when running on CPUs for performance reasons.; On the GPU, all functions are force-inlined by default.; In addition, the annotation `@inbounds` should be used when accessing the elements of an array; in a boundary condition function (such as `model_fields.u[i, j, 1]` in the above example).; Using `@inbounds` will avoid a relatively expensive check that the index `i, j, 1` is 'in bounds'. ### 9. A random, spatially-varying, constant-in-time temperature flux specified by an array. ```jldoctest; julia> Nx = Ny = 16; # Number of grid points. julia> Q = randn(Nx, Ny); # temperature flux. julia> white_noise_T_bc = FluxBoundaryCondition(Q); FluxBoundaryCondition: 16Ã—16 Matrix{Float64}; ```. When running on the GPU, `Q` must be converted to a `CuArray`. ## Building boundary conditions on a field. To create a set of [`FieldBoundaryConditions`](@ref) for a temperature field,; we write. ```jldoctest; julia> T_bcs = FieldBoundaryConditions(top = V",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Security,access,accessed,":u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing); ```. Put differently, `Î¾, Î·, t` come first in the function signature, followed by field dependencies,; followed by `parameters` is `!isnothing(parameters)`. ### 7. Discrete-form boundary condition with parameters. Discrete field data may also be accessed directly from boundary condition functions; using the `discrete_form`. For example:. ```jldoctest; @inline filtered_drag(i, j, grid, clock, model_fields) =; @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1]). u_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true). # output; FluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag; ```. !!! info ""The 'discrete form' for boundary condition functions""; The argument `discrete_form=true` indicates to [`BoundaryCondition`](@ref) that `filtered_drag`; uses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary con",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Usability,simpl,simple,"ial coordinates that vary along the boundary:; * `f(y, z, t)` on `x`-boundaries;; * `f(x, z, t)` on `y`-boundaries;; * `f(x, y, t)` on `z`-boundaries.; Alternative function signatures are specified by keyword arguments to; `BoundaryCondition`, as illustrated in subsequent examples. ### 4. Spatially- and temporally-varying flux with parameters. Boundary condition functions may be 'parameterized',. ```jldoctest; julia> @inline wind_stress(x, y, t, p) = - p.Ï„ * cos(p.k * x) * cos(p.Ï‰ * t); # function with parameters. julia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4Ï€, Ï‰=3.0, Ï„=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_dra",MatchSource.DOCS,docs/src/model_setup/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md
Integrability,contract,contraction,",\text{s}^{-2}``,; we might alternatively specify. ```jldoctest buoyancy; julia> buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3); SeawaterBuoyancy{Float64}:; â”œâ”€â”€ gravitational_acceleration: 1.3; â””â”€â”€ equation_of_state: LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078). julia> model = NonhydrostaticModel(; grid, buoyancy, tracers=(:T, :S)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (T, S); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=1.3 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection(); â””â”€â”€ coriolis: Nothing; ```. for example. ### Linear equation of state. To specify the thermal expansion and haline contraction coefficients; ``\alpha = 2 \times 10^{-3} \; \text{K}^{-1}`` and ``\beta = 5 \times 10^{-4} \text{psu}^{-1}``,. ```jldoctest; julia> buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-3, haline_contraction=5e-4)); SeawaterBuoyancy{Float64}:; â”œâ”€â”€ gravitational_acceleration: 9.80665; â””â”€â”€ equation_of_state: LinearEquationOfState(thermal_expansion=0.002, haline_contraction=0.0005); ```. ### Idealized nonlinear equations of state. Instead of a linear equation of state, six idealized (second-order) nonlinear equations of state; as described by [Roquet15Idealized](@citet) may be used. These equations of state are provided; via the [SeawaterPolynomials.jl](https://github.com/CliMA/SeawaterPolynomials.jl) package. ```jldoctest buoyancy; julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials. julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; â”œâ”€â”€ seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; â””â”€â”€ reference_density: 1024.6; ; juli",MatchSource.DOCS,docs/src/model_setup/buoyancy_and_equation_of_state.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md
Modifiability,evolve,evolve,"# Buoyancy models and equations of state. The buoyancy option selects how buoyancy is treated in `NonhydrostaticModel`s and; `HydrostaticFreeSurfaceModel`s (`ShallowWaterModel`s do not have that option given the physics of; the model). There are currently three alternatives:. 1. No buoyancy (and no gravity).; 2. Evolve buoyancy as a tracer.; 3. _Seawater buoyancy_: evolve temperature ``T`` and salinity ``S`` as tracers with a value for the gravitational; acceleration ``g`` and an equation of state of your choosing. ## No buoyancy. To turn off buoyancy (and gravity) you can simply pass `buoyancy = nothing` to the model; constructor. For example to create a `NonhydrostaticModel`:. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest buoyancy; julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid, buoyancy=nothing); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. The option `buoyancy = nothing` is the default for [`NonhydrostaticModel`](@ref), so omitting the; `buoyancy` keyword argument from the `NonhydrostaticModel` constructor yields the same:. ```jldoctest buoyancy; julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. The same is true for `HydrostaticFreeSurfaceModel`,. ```jldoctest buoyancy; julia> model = HydrostaticFreeSurfaceModel(; grid); Hydro",MatchSource.DOCS,docs/src/model_setup/buoyancy_and_equation_of_state.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md
Usability,simpl,simply,"# Buoyancy models and equations of state. The buoyancy option selects how buoyancy is treated in `NonhydrostaticModel`s and; `HydrostaticFreeSurfaceModel`s (`ShallowWaterModel`s do not have that option given the physics of; the model). There are currently three alternatives:. 1. No buoyancy (and no gravity).; 2. Evolve buoyancy as a tracer.; 3. _Seawater buoyancy_: evolve temperature ``T`` and salinity ``S`` as tracers with a value for the gravitational; acceleration ``g`` and an equation of state of your choosing. ## No buoyancy. To turn off buoyancy (and gravity) you can simply pass `buoyancy = nothing` to the model; constructor. For example to create a `NonhydrostaticModel`:. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest buoyancy; julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid, buoyancy=nothing); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. The option `buoyancy = nothing` is the default for [`NonhydrostaticModel`](@ref), so omitting the; `buoyancy` keyword argument from the `NonhydrostaticModel` constructor yields the same:. ```jldoctest buoyancy; julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. The same is true for `HydrostaticFreeSurfaceModel`,. ```jldoctest buoyancy; julia> model = HydrostaticFreeSurfaceModel(; grid); Hydro",MatchSource.DOCS,docs/src/model_setup/buoyancy_and_equation_of_state.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md
Availability,checkpoint,checkpointing,"# Callbacks. A [`Callback`](@ref) can be used to execute an arbitrary user-defined function on the; simulation at user-defined times. For example, we can specify a callback which displays the run time every 2 iterations:; ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). show_time(sim) = @info ""Time is $(prettytime(sim.model.clock.time))"". simulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2)). simulation; ```. Now when simulation runs the simulation the callback is called. ```@example checkpointing; run!(simulation); ```. We can also use the convenience [`add_callback!`](@ref):. ```@example checkpointing; add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2)). simulation; ```. The keyword argument `callsite` determines the moment at which the callback is executed.; By default, `callsite = TimeStepCallsite()`, indicating execution _after_ the completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.Gâ¿[params.c] .+= param",MatchSource.DOCS,docs/src/model_setup/callbacks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md
Energy Efficiency,schedul,schedule,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.Gâ¿[params.c] .+= params.Î´; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Î´ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,docs/src/model_setup/callbacks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md
Modifiability,variab,variables,"gans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). show_time(sim) = @info ""Time is $(prettytime(sim.model.clock.time))"". simulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2)). simulation; ```. Now when simulation runs the simulation the callback is called. ```@example checkpointing; run!(simulation); ```. We can also use the convenience [`add_callback!`](@ref):. ```@example checkpointing; add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2)). simulation; ```. The keyword argument `callsite` determines the moment at which the callback is executed.; By default, `callsite = TimeStepCallsite()`, indicating execution _after_ the completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.Gâ¿[params.c] .+= params.Î´; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Î´ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info mode",MatchSource.DOCS,docs/src/model_setup/callbacks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md
Safety,redund,redundant,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.Gâ¿[params.c] .+= params.Î´; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Î´ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,docs/src/model_setup/callbacks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md
Usability,simpl,simple,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.Gâ¿[params.c] .+= params.Î´; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Î´ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,docs/src/model_setup/callbacks.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md
Availability,checkpoint,checkpointing,"# [Checkpointing](@id checkpointing). A [`Checkpointer`](@ref) can be used to serialize the entire model state to a file from which the model; can be restored at any time. This is useful if you'd like to periodically checkpoint when running; long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore; from a checkpoint and try out multiple scenarios. For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkp",MatchSource.DOCS,docs/src/model_setup/checkpointing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md
Deployability,update,updates," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,docs/src/model_setup/checkpointing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md
Energy Efficiency,schedul,schedule,"r`](@ref) can be used to serialize the entire model state to a file from which the model; can be restored at any time. This is useful if you'd like to periodically checkpoint when running; long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore; from a checkpoint and try out multiple scenarios. For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads pr",MatchSource.DOCS,docs/src/model_setup/checkpointing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md
Performance,load,loads," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,docs/src/model_setup/checkpointing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md
Usability,simpl,simple," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Î”t=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,docs/src/model_setup/checkpointing.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md
Availability,avail,available,"# Coriolis. The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently; three options are available: no rotation, ``f``-plane, and ``\beta``-plane. !!! info ""Coriolis vs. rotation""; If you are wondering why this option is called ""Coriolis"" it is because rotational effects could include the; Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only; considers the Coriolis force. ## No rotation. By default there is no rotation. This can be made explicit by passing `coriolis = nothing` to a model constructor. ## Traditional ``f``-plane. To set up an ``f``-plane with, for example, Coriolis parameter ``f = 10^{-4} \text{s}^{-1}``. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest; julia> coriolis = FPlane(f=1e-4); FPlane{Float64}(f=0.0001); ```. An ``f``-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example,; to specify an ``f``-plane at a latitude of ``\varphi = 45Â°\text{N}`` on Earth which has a rotation rate of; ``\Omega = 7.292115 \times 10^{-5} \text{s}^{-1}``. ```jldoctest; julia> coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45); FPlane{Float64}(f=0.000103126); ```. in which case the value of ``f`` is given by ``2\Omega\sin\varphi``. ## Coriolis term for constant rotation in a Cartesian coordinate system. One can use `ConstantCartesianCoriolis` to set up a Coriolis acceleration term where the Coriolis parameter; is constant and the rotation axis is arbitrary. For example, with; ``\boldsymbol{f} = (0, f_y, f_z) = (0, 2, 1) \times 10^{-4} \text{s}^{-1}``,. ```jldoctest; julia> coriolis = ConstantCartesianCoriolis(fx=0, fy=2e-4, fz=1e-4); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04; ```. Or alternatively, the same result can be achieved by specifying the magnitude of the Coriolis; frequency `f` and the `rotation_axis`. So another way ",MatchSource.DOCS,docs/src/model_setup/coriolis.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/coriolis.md
Availability,mask,masked,"l coordinates,; time, model velocity and tracer fields, and external parameters. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); â”œâ”€â”€ func: u_forcing (generic function with 1 method); â”œâ”€â”€ parameters: nothing; â””â”€â”€ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing",MatchSource.DOCS,docs/src/model_setup/forcing_functions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md
Deployability,continuous,continuous,"tilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); â”œâ”€â”€ func: w_forcing_func (generic function with 1 method); â”œâ”€â”€ parameters: nothing; â””â”€â”€ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); â”œâ”€â”€ func: S_forcing_func (generic function with 1 method); â”œâ”€â”€ parameters: 0.01; â””â”€â”€ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, y, z, t`, and `parameters` follow `field_dependencies`. Model fields that arise in the arguments of continuous `Forcing` `func`tions are; automatically interpolated to the staggered grid location at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ```julia; func(i, j, k, grid, clock, model_fields, parameters); ```. Discrete form forcing functions can access the entirety of model field; data through the argument `model_fields`. The object `model_fields` is a `NamedTuple`; whose properties include the velocity fields `model_fields.u`, `model_fields.v`,; `model_fields.w` and all fields in `model.tracers`. Using discrete forcing functions may require understanding the; staggered arrangement of velocity fields and tracers in `Oceananigans`.; Here's a slightly non-sensical example in which the vertical derivative of a buoyancy; tracer is used as a time-scale for damping the u-velocity field:. ```jldoctest discrete_forcing; # A damping term that depends on a ",MatchSource.DOCS,docs/src/model_setup/forcing_functions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md
Integrability,interface,interface,"# Forcing functions. ""Forcings"" are user-defined terms appended to right-hand side of; the momentum or tracer evolution equations. In `Oceananigans`, momentum; and tracer forcings are defined via julia functions. `Oceananigans` includes; an interface for implementing forcing functions that depend on spatial coordinates,; time, model velocity and tracer fields, and external parameters. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); â”œâ”€â”€ func: u_forcing (generic function with 1 method); â”œâ”€â”€ parameters: nothing; â””â”€â”€ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve externa",MatchSource.DOCS,docs/src/model_setup/forcing_functions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md
Modifiability,layers,layers,"p = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); â”œâ”€â”€ func: u_forcing (generic function with 1 method); â”œâ”€â”€ parameters: nothing; â””â”€â”€ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p",MatchSource.DOCS,docs/src/model_setup/forcing_functions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md
Performance,perform,performance,"nanigans.Operators: âˆ‚zá¶ á¶œá¶ , â„‘xzá¶ áµƒá¶œ. function u_forcing_func(i, j, k, grid, clock, model_fields, Îµ); # The vertical derivative of buoyancy, interpolated to the u-velocity location:; NÂ² = â„‘xzá¶ áµƒá¶œ(i, j, k, grid, âˆ‚zá¶ á¶œá¶ , model_fields.b). # Set to zero in unstable stratification where NÂ² < 0:; NÂ² = max(NÂ², zero(typeof(NÂ²))). return @inbounds - Îµ * sqrt(NÂ²) * model_fields.u[i, j, k]; end. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing)). model.forcing.b. # output; DiscreteForcing{Nothing}; â”œâ”€â”€ func: b_forcing_func (generic function with 1 method); â””â”€â”€ parameters: nothing; ```. ```jldoctest discrete_forcing; model.forcing.u. # output; DiscreteForcing{Float64}; â”œâ”€â”€ func: u_forcing_func (generic function with 1 method); â””â”€â”€ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); â”œâ”€â”€ func: Relaxation(rate=0.001, mask=1, target=0); â”œâ”€â”€ parameters: nothing; â””â”€â”€ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y",MatchSource.DOCS,docs/src/model_setup/forcing_functions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md
Security,access,access,"forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); â”œâ”€â”€ func: u_forcing (generic function with 1 method); â”œâ”€â”€ parameters: nothing; â””â”€â”€ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Î¼ * exp(z / p.Î») * cos(p.k * x) * sin(p.Ï‰ * t). T_forcing = Forcing(T_forcing_func, parameters=(Î¼=1, Î»=0.5, k=2Ï€, Ï‰=4Ï€)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Î¼::Int64, Î»::Float64, k::Float64, Ï‰::Float64}} at (Center, Center, Center); â”œâ”€â”€ func: T_forcing_",MatchSource.DOCS,docs/src/model_setup/forcing_functions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md
Energy Efficiency,schedul,schedule,"yâ‚€ = rand(Nparticles). zâ‚€ = -0.5 * ones(Nparticles). species = [:rock, :paper, :scissors]. dna = [""TATACCCC"", ""CCTAGGAC"", ""CGATTTAA""]. particles = StructArray{LagrangianMicrobe}((xâ‚€, yâ‚€, zâ‚€, species, dna));. lagrangian_particles = LagrangianParticles(particles). # output; 3 LagrangianParticles with eltype LagrangianMicrobe:; â”œâ”€â”€ 5 properties: (:x, :y, :z, :species, :dna); â”œâ”€â”€ particle-wall restitution coefficient: 1.0; â”œâ”€â”€ 0 tracked fields: (); â””â”€â”€ dynamics: no_dynamics; ```. !!! warn ""Custom properties on GPUs""; Not all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure; particle properties consist of only simple data types. The symbols and strings in this example won't; work on the GPU. ## Writing particle properties to disk. Particle properties can be written to disk using JLD2 or NetCDF. When writing to JLD2 you can pass `model.particles` as part of the named tuple of outputs. ```@setup particles; using Oceananigans; grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1)); Nparticles = 3; xâ‚€ = zeros(Nparticles); yâ‚€ = rand(Nparticles); zâ‚€ = -0.5 * ones(Nparticles); lagrangian_particles = LagrangianParticles(x=xâ‚€, y=yâ‚€, z=zâ‚€); model = NonhydrostaticModel(; grid, particles=lagrangian_particles); ```. ```@example particles; JLD2OutputWriter(model, (; particles=model.particles), filename=""particles"", schedule=TimeInterval(15)); ```. When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for; particle trajectories. You can just pass `model.particles` straight to `NetCDFOutputWriter`:. ```@example particles; NetCDFOutputWriter(model, model.particles, filename=""particles.nc"", schedule=TimeInterval(15)); ```. !!! warn ""Outputting custom particle properties to NetCDF""; NetCDF does not support arbitrary data types. If you need to write custom particle properties to disk; that are not supported by NetCDF then you should use JLD2 (which should support almost any Julia data type).; ",MatchSource.DOCS,docs/src/model_setup/lagrangian_particles.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/lagrangian_particles.md
Usability,simpl,simple,"agrangian particle; representing a microbe in an agent-based model, then you can create your own custom particle type; and pass a `StructArray` to the `LagrangianParticles` constructor. ```jldoctest particles; using Oceananigans; using StructArrays. struct LagrangianMicrobe{T, S, D}; x :: T; y :: T; z :: T; species :: S; dna :: D; end. Nparticles = 3. xâ‚€ = zeros(Nparticles). yâ‚€ = rand(Nparticles). zâ‚€ = -0.5 * ones(Nparticles). species = [:rock, :paper, :scissors]. dna = [""TATACCCC"", ""CCTAGGAC"", ""CGATTTAA""]. particles = StructArray{LagrangianMicrobe}((xâ‚€, yâ‚€, zâ‚€, species, dna));. lagrangian_particles = LagrangianParticles(particles). # output; 3 LagrangianParticles with eltype LagrangianMicrobe:; â”œâ”€â”€ 5 properties: (:x, :y, :z, :species, :dna); â”œâ”€â”€ particle-wall restitution coefficient: 1.0; â”œâ”€â”€ 0 tracked fields: (); â””â”€â”€ dynamics: no_dynamics; ```. !!! warn ""Custom properties on GPUs""; Not all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure; particle properties consist of only simple data types. The symbols and strings in this example won't; work on the GPU. ## Writing particle properties to disk. Particle properties can be written to disk using JLD2 or NetCDF. When writing to JLD2 you can pass `model.particles` as part of the named tuple of outputs. ```@setup particles; using Oceananigans; grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1)); Nparticles = 3; xâ‚€ = zeros(Nparticles); yâ‚€ = rand(Nparticles); zâ‚€ = -0.5 * ones(Nparticles); lagrangian_particles = LagrangianParticles(x=xâ‚€, y=yâ‚€, z=zâ‚€); model = NonhydrostaticModel(; grid, particles=lagrangian_particles); ```. ```@example particles; JLD2OutputWriter(model, (; particles=model.particles), filename=""particles"", schedule=TimeInterval(15)); ```. When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for; particle trajectories. You can just pass `model.particles` straight to `NetCDFOutputWriter`:. ```@example particle",MatchSource.DOCS,docs/src/model_setup/lagrangian_particles.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/lagrangian_particles.md
Energy Efficiency,meter,meters,"# Grids. The grids currently supported are:; - `RectilinearGrid`s with either constant or variable grid spacings and; - `LatitudeLongitudeGrid` on the sphere. ## `RectilinearGrid`. A `RectilinearGrid` is constructed by specifying the `size` of the grid (a `Tuple` specifying; the number of grid points in each direction) and either the `extent` (a `Tuple` specifying the; physical extent of the grid in each direction), or by prescribing `x`, `y`, and `z`. Keyword; arguments `x`, `y`, and `z` could be either *(i)* 2-`Tuple`s that define the the _end points_ in; each direction, or *(ii)* arrays or functions of the corresponding indices `i`, `j`, or `k` that; specify the locations of cell faces in the `x`-, `y`-, or `z`-direction, respectively. A regular rectilinear grid with ``N_x \times N_y \times N_z = 32 \times 64 \times 256`` grid points; and an `extent` of ``L_x = 128`` meters, ``L_y = 256`` meters, and ``L_z = 512`` meters is constructed; by. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest; julia> grid = RectilinearGrid(size = (32, 64, 256), extent = (128, 256, 512)); 32Ã—64Ã—256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 128.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 256.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [-512.0, 0.0] regularly spaced with Î”z=2.0; ```. !!! info ""Default domain""; When using the `extent` keyword, e.g., `extent = (Lx, Ly, Lz)`, then the ``x \in [0, L_x]``,; ``y \in [0, L_y]``, and ``z \in [-L_z, 0]`` -- a sensible choice for oceanographic applications. ### Specifying the grid's architecture. The first positional argument in either `RectilinearGrid` or `LatitudeLongitudeGrid` is the grid's; architecture. By default `architecture = CPU()`. By providing `GPU()` as the `architecture` argument; we can construct the grid on GPU:. ```julia; julia> grid = RectilinearGrid(GPU(), size = (32, 64, 256), extent = (128, 256, 512)); 32Ã—64Ã—256 RectilinearGri",MatchSource.DOCS,docs/src/model_setup/legacy_grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md
Modifiability,variab,variable,"# Grids. The grids currently supported are:; - `RectilinearGrid`s with either constant or variable grid spacings and; - `LatitudeLongitudeGrid` on the sphere. ## `RectilinearGrid`. A `RectilinearGrid` is constructed by specifying the `size` of the grid (a `Tuple` specifying; the number of grid points in each direction) and either the `extent` (a `Tuple` specifying the; physical extent of the grid in each direction), or by prescribing `x`, `y`, and `z`. Keyword; arguments `x`, `y`, and `z` could be either *(i)* 2-`Tuple`s that define the the _end points_ in; each direction, or *(ii)* arrays or functions of the corresponding indices `i`, `j`, or `k` that; specify the locations of cell faces in the `x`-, `y`-, or `z`-direction, respectively. A regular rectilinear grid with ``N_x \times N_y \times N_z = 32 \times 64 \times 256`` grid points; and an `extent` of ``L_x = 128`` meters, ``L_y = 256`` meters, and ``L_z = 512`` meters is constructed; by. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest; julia> grid = RectilinearGrid(size = (32, 64, 256), extent = (128, 256, 512)); 32Ã—64Ã—256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ Periodic x âˆˆ [0.0, 128.0) regularly spaced with Î”x=4.0; â”œâ”€â”€ Periodic y âˆˆ [0.0, 256.0) regularly spaced with Î”y=4.0; â””â”€â”€ Bounded z âˆˆ [-512.0, 0.0] regularly spaced with Î”z=2.0; ```. !!! info ""Default domain""; When using the `extent` keyword, e.g., `extent = (Lx, Ly, Lz)`, then the ``x \in [0, L_x]``,; ``y \in [0, L_y]``, and ``z \in [-L_z, 0]`` -- a sensible choice for oceanographic applications. ### Specifying the grid's architecture. The first positional argument in either `RectilinearGrid` or `LatitudeLongitudeGrid` is the grid's; architecture. By default `architecture = CPU()`. By providing `GPU()` as the `architecture` argument; we can construct the grid on GPU:. ```julia; julia> grid = RectilinearGrid(GPU(), size = (32, 64, 256), extent = (128, 256, 512)); 32Ã—64Ã—256 RectilinearGri",MatchSource.DOCS,docs/src/model_setup/legacy_grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md
Usability,simpl,simple,"y spaced with min(Î”y)=6.02272, max(Î”y)=245.338; â””â”€â”€ Bounded z âˆˆ [-1000.0, 0.0] variably spaced with min(Î”z)=2.40764, max(Î”z)=49.0086; ```. ```@setup 1; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); Nx, Ny, Nz = 64, 64, 32; Lx, Ly, Lz = 1e4, 1e4, 1e3; chebychev_spaced_y_faces(j) = - Ly/2 * cos(Ï€ * (j - 1) / Ny);; chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(Ï€ * (k - 1) / Nz);; grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); ```. We can easily visualize the spacings of ``y`` and ``z`` directions. We can use, e.g.,; [`ynodes`](@ref) and [`yspacings`](@ref) to extract the positions and spacings of the; nodes from the grid. ```@example 1; yá¶œ = ynodes(grid, Center()); Î”yá¶œ = yspacings(grid, Center()). zá¶œ = znodes(grid, Center()); Î”zá¶œ = zspacings(grid, Center()). using CairoMakie. fig = Figure(size=(800, 900)). ax1 = Axis(fig[1, 1]; xlabel = ""y (m)"", ylabel = ""y-spacing (m)"", limits = (nothing, (0, 250))); lines!(ax1, yá¶œ, Î”yá¶œ); scatter!(ax1, yá¶œ, Î”yá¶œ). ax2 = Axis(fig[2, 1]; xlabel = ""z-spacing (m)"", ylabel = ""z (m)"", limits = ((0, 50), nothing)); lines!(ax2, zá¶œ, Î”zá¶œ); scatter!(ax2, zá¶œ, Î”zá¶œ). save(""plot_stretched_grid.svg"", fig); nothing #hide; ```. ![](plot_stretched_grid.svg). ## `LatitudeLongitudeGrid`. A simple latitude-longitude grid with `Float64` type can be constructed by. ```jldoctest; julia> grid = LatitudeLongitudeGrid(size = (36, 34, 25),; longitude = (-180, 180),; latitude = (-85, 85),; z = (-1000, 0)); 36Ã—34Ã—25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics; â”œâ”€â”€ longitude: Periodic Î» âˆˆ [-180.0, 180.0) regularly spaced with Î”Î»=10.0; â”œâ”€â”€ latitude: Bounded Ï† âˆˆ [-85.0, 85.0] regularly spaced with Î”Ï†=5.0; â””â”€â”€ z: Bounded z âˆˆ [-1000.0, 0.0] regularly spaced with Î”z=40.0; ```. For more examples see [`RectilinearGrid`](@ref) and [`LatitudeLongitudeGrid`](@ref).; ",MatchSource.DOCS,docs/src/model_setup/legacy_grids.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md
Performance,perform,performance,"# Number type. Passing `Float64` or `Float32` to the grid constructor causes the grid to store all numbers; with 64-bit or 32-bit floating point precision. !!! note ""Avoiding mixed-precision operations""; When not using `Float64` be careful to not mix different precisions as it could introduce implicit type conversions; which can negatively effect performance. You can pass the number type desires to many constructors to enforce; the type you want: e.g. `RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1))` and; `ScalarDiffusivity(Float16; Îº=1//7, Î½=2//7)`. !!! warning ""Effect of floating point precision on simulation accuracy""; While we run many tests with both `Float32` and `Float64` it is not clear whether `Float32` is precise enough to; provide similar accuracy in all use cases. If accuracy is a concern, stick to `Float64`. We will be actively investigating the possibility of using lower precision floating point numbers such as `Float32`; and `Float16` for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.; ",MatchSource.DOCS,docs/src/model_setup/number_type.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md
Testability,test,tests,"# Number type. Passing `Float64` or `Float32` to the grid constructor causes the grid to store all numbers; with 64-bit or 32-bit floating point precision. !!! note ""Avoiding mixed-precision operations""; When not using `Float64` be careful to not mix different precisions as it could introduce implicit type conversions; which can negatively effect performance. You can pass the number type desires to many constructors to enforce; the type you want: e.g. `RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1))` and; `ScalarDiffusivity(Float16; Îº=1//7, Î½=2//7)`. !!! warning ""Effect of floating point precision on simulation accuracy""; While we run many tests with both `Float32` and `Float64` it is not clear whether `Float32` is precise enough to; provide similar accuracy in all use cases. If accuracy is a concern, stick to `Float64`. We will be actively investigating the possibility of using lower precision floating point numbers such as `Float32`; and `Float16` for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.; ",MatchSource.DOCS,docs/src/model_setup/number_type.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md
Usability,clear,clear,"# Number type. Passing `Float64` or `Float32` to the grid constructor causes the grid to store all numbers; with 64-bit or 32-bit floating point precision. !!! note ""Avoiding mixed-precision operations""; When not using `Float64` be careful to not mix different precisions as it could introduce implicit type conversions; which can negatively effect performance. You can pass the number type desires to many constructors to enforce; the type you want: e.g. `RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1))` and; `ScalarDiffusivity(Float16; Îº=1//7, Î½=2//7)`. !!! warning ""Effect of floating point precision on simulation accuracy""; While we run many tests with both `Float32` and `Float64` it is not clear whether `Float32` is precise enough to; provide similar accuracy in all use cases. If accuracy is a concern, stick to `Float64`. We will be actively investigating the possibility of using lower precision floating point numbers such as `Float32`; and `Float16` for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.; ",MatchSource.DOCS,docs/src/model_setup/number_type.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md
Availability,checkpoint,checkpointing,"# Output writers. `AbstractOutputWriter`s save data to disk.; `Oceananigans` provides three ways to write output:. 1. [`NetCDFOutputWriter`](@ref) for output of arrays and scalars that uses [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl); 2. [`JLD2OutputWriter`](@ref) for arbitrary julia data structures that uses [JLD2.jl](https://github.com/JuliaIO/JLD2.jl); 3. [`Checkpointer`](@ref) that automatically saves as much model data as possible, using [JLD2.jl](https://github.com/JuliaIO/JLD2.jl). The `Checkpointer` is discussed in detail on a separate [section](@ref checkpointing) of the documentation. ## Basic usage. [`NetCDFOutputWriter`](@ref) and [`JLD2OutputWriter`](@ref) require four inputs:. 1. The `model` from which output data is sourced (required to initialize the `OutputWriter`).; 2. A key-value pairing of output ""names"" and ""output"" objects. `JLD2OutputWriter` accepts `NamedTuple`s and `Dict`s;; `NetCDFOutputWriter` accepts `Dict`s with string-valued keys. Output objects are either `AbstractField`s or; functions that return data when called via `func(model)`.; 3. A `schedule` on which output is written. `TimeInterval`, `IterationInterval`, `WallTimeInterval` schedule; periodic output according to the simulation time, simulation interval, or ""wall time"" (the physical time; according to a clock on your wall). A fourth `schedule` called `AveragedTimeInterval` specifies; periodic output that is time-averaged over a `window` prior to being written.; 4. The `filename` and `dir`ectory. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; de",MatchSource.DOCS,docs/src/model_setup/output_writers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md
Energy Efficiency,schedul,schedule,"FOutputWriter`](@ref) for output of arrays and scalars that uses [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl); 2. [`JLD2OutputWriter`](@ref) for arbitrary julia data structures that uses [JLD2.jl](https://github.com/JuliaIO/JLD2.jl); 3. [`Checkpointer`](@ref) that automatically saves as much model data as possible, using [JLD2.jl](https://github.com/JuliaIO/JLD2.jl). The `Checkpointer` is discussed in detail on a separate [section](@ref checkpointing) of the documentation. ## Basic usage. [`NetCDFOutputWriter`](@ref) and [`JLD2OutputWriter`](@ref) require four inputs:. 1. The `model` from which output data is sourced (required to initialize the `OutputWriter`).; 2. A key-value pairing of output ""names"" and ""output"" objects. `JLD2OutputWriter` accepts `NamedTuple`s and `Dict`s;; `NetCDFOutputWriter` accepts `Dict`s with string-valued keys. Output objects are either `AbstractField`s or; functions that return data when called via `func(model)`.; 3. A `schedule` on which output is written. `TimeInterval`, `IterationInterval`, `WallTimeInterval` schedule; periodic output according to the simulation time, simulation interval, or ""wall time"" (the physical time; according to a clock on your wall). A fourth `schedule` called `AveragedTimeInterval` specifies; periodic output that is time-averaged over a `window` prior to being written.; 4. The `filename` and `dir`ectory. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; default). * `array_type` for specifying the type of the array that holds outputted field data. The default is; `Array{Float64}`",MatchSource.DOCS,docs/src/model_setup/output_writers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md
Modifiability,config,configured,"file output (vector). xC, yF = xnodes(grid, Center()), ynodes(grid, Face()). XC = [xC[i] for i in 1:Nx, j in 1:Ny]; YF = [yF[j] for i in 1:Nx, j in 1:Ny]. h(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array). outputs = Dict(""scalar"" => f, ""profile"" => g, ""slice"" => h). dims = Dict(""scalar"" => (), ""profile"" => (""zC"",), ""slice"" => (""xC"", ""yC"")). output_attributes = Dict(; ""scalar"" => Dict(""longname"" => ""Some scalar"", ""units"" => ""bananas""),; ""profile"" => Dict(""longname"" => ""Some vertical profile"", ""units"" => ""watermelons""),; ""slice"" => Dict(""longname"" => ""Some slice"", ""units"" => ""mushrooms""); ). global_attributes = Dict(""location"" => ""Bay of Fundy"", ""onions"" => 7). simulation.output_writers[:things] =; NetCDFOutputWriter(model, outputs,; schedule=IterationInterval(1), filename=""things.nc"", dimensions=dims, verbose=true,; global_attributes=global_attributes, output_attributes=output_attributes); ```. `NetCDFOutputWriter` can also be configured for `outputs` that are interpolated or regridded; to a different grid than `model.grid`. To use this functionality, include the keyword argument; `grid = output_grid`. ```@example; using Oceananigans; using Oceananigans.Fields: interpolate!. grid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));; model = NonhydrostaticModel(; grid). coarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.NzÃ·2), extent=(grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). interpolate_u(model) = interpolate!(coarse_u, model.velocities.u); outputs = (; u = interpolate_u). output_writer = NetCDFOutputWriter(model, outputs;; grid = coarse_grid,; filename = ""coarse_u.nc"",; schedule = IterationInterval(1)); ```. See [`NetCDFOutputWriter`](@ref) for more information. ## JLD2 output writer. JLD2 is a fast HDF5 compatible file format written in pure Julia.; JLD2 files can be opened in Julia with the [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) package; and in Python with the [h5py](https://www.h",MatchSource.DOCS,docs/src/model_setup/output_writers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md
Security,validat,validation,"# Model setup. This section describes all the options and features that can be used to set up a model. For ; more detailed information consult the API documentation. Each structure covered in this section can be constructed and passed to the models' constructors. ; For examples of model construction, see the examples. The validation experiments provide more ; advanced examples. For reference, here are all the option or keyword arguments that can be passed to the; currently implemented models. See the different sections on the sidebar for more ; details and examples for each keyword argument. ### `NonhydrostaticModel`. ```@docs; NonhydrostaticModel; ```. ### `HydrostaticFreeSurfaceModel`. ```@docs; HydrostaticFreeSurfaceModel; ```. ### `ShallowWaterModel`. ```@docs; ShallowWaterModel; ```; ",MatchSource.DOCS,docs/src/model_setup/overview.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/overview.md
Modifiability,evolve,evolve,"# Tracers. The tracers to be advected around can be specified via a list of symbols. By default the model doesn't evolve any; tracers. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest tracers; julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. But tracers can be added with the `tracers` keyword.; For example, to add conservative temperature `T` and absolute salinity `S`:. ```jldoctest tracers; julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (T, S); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. whose fields can be accessed via `model.tracers.T` and `model.tracers.S`. ```jldoctest tracers; julia> model.tracers.T; 16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19; â””â”€â”€ max=0.0, min=0.0, mean=0.0. julia> model.tracers.S; 16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 16Ã—16Ã—16 Rectilin",MatchSource.DOCS,docs/src/model_setup/tracers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md
Security,access,accessed,"julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. But tracers can be added with the `tracers` keyword.; For example, to add conservative temperature `T` and absolute salinity `S`:. ```jldoctest tracers; julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ timestepper: RungeKutta3TimeStepper; â”œâ”€â”€ advection scheme: Centered reconstruction order 2; â”œâ”€â”€ tracers: (T, S); â”œâ”€â”€ closure: Nothing; â”œâ”€â”€ buoyancy: Nothing; â””â”€â”€ coriolis: Nothing; ```. whose fields can be accessed via `model.tracers.T` and `model.tracers.S`. ```jldoctest tracers; julia> model.tracers.T; 16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19; â””â”€â”€ max=0.0, min=0.0, mean=0.0. julia> model.tracers.S; 16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU; â”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo; â”œâ”€â”€ boundary conditions: FieldBoundaryConditions; â”‚ â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; â””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Floa",MatchSource.DOCS,docs/src/model_setup/tracers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md
Modifiability,enhance,enhanced,"```. The example above sets a viscosity of `1e-6`, a diffusivity for a tracer called `T` of `1e-7`,; and a diffusivity for a tracer called `S` of `1e-10`. Specifying diffusivities this way is also valid; for `HorizontalScalarDiffusivity` and `VerticalScalarDiffusivity`. If this method is used, diffusivities; for all tracers need to be specified. ## Smagorinsky-Lilly. To use the default Smagorinsky-Lilly LES closure, we write. ```jldoctest; julia> using Oceananigans.TurbulenceClosures. julia> closure = SmagorinskyLilly(); SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; ```. The parameters `C`, `Cb`, and `Pr` may alternatively be specified explicitly.; For more details see [`SmagorinskyLilly`](@ref). ## Anisotropic minimum dissipation. To use the constant anisotropic minimum dissipation (AMD) LES closure,. ```jldoctest; julia> using Oceananigans.TurbulenceClosures. julia> closure = AnisotropicMinimumDissipation(); AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:; PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333; PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.08333333333333333; Buoyancy modification multiplier Cb: nothing; ```. no parameters are required although they may be specified. By default, the background viscosity and diffusivity; are assumed to be the molecular values for seawater. For more details see [`AnisotropicMinimumDissipation`](@ref). ## Convective Adjustment Vertical Diffusivity--Viscosity. To use the a convective adjustment scheme that applies enhanced values for vertical diffusivity ``\kappa_z`` and/or; viscosity ``\nu_z``, anytime and anywhere the background stratification becomes unstable. ```jldoctest; julia> using Oceananigans. julia> closure = ConvectiveAdjustmentVerticalDiffusivity(convective_Îºz = 1.0, background_Îºz = 1e-3); ConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_Îºz=0.001 convective_Îºz=1.0 background_Î½z=0.0 convective_Î½z=0.0); ```; ",MatchSource.DOCS,docs/src/model_setup/turbulent_diffusivity_closures_and_les_models.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/turbulent_diffusivity_closures_and_les_models.md
Availability,avail,available,". To explain how flux boundary conditions are imposed ; in `Oceananigans.jl`, we note that the average of the tracer conservation equation over a finite ; volume yields; ```math; \begin{equation}; \label{eq:dc/dt}; \partial_t c_{i, j, k} = - \frac{1}{V_{i, j, k}} \oint_{\partial \Omega_{i, j, k}} (\boldsymbol{v} c + \boldsymbol{q}_c) ; \boldsymbol{\cdot} \hat{\boldsymbol{n}} \, \mathrm{d} S; + \frac{1}{V_{i, j, k}} \int_{V_{i, j, k}} F_c \, \mathrm{d} V \, ,; \end{equation}; ```; where the surface integral over ``\partial \Omega_{i, j, k}`` averages the flux of ``c`` across ; the six faces of the finite volume. The right-hand-side of \eqref{eq:dc/dt} above is denoted as ; ``G_c |_{i, j, k}``. An external boundary of a finite volume is associated with a no-penetration condition such that; ``\hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{v} \, |_{\partial \Omega_b} = 0``, where ; ``\hat{\boldsymbol{n}}`` is the vector normal to ``\partial \Omega_b``. Furthermore, the closures ; currently available in `Oceananigans.jl` have the property that ``\boldsymbol{q}_c \propto \boldsymbol{\nabla} c``.; Thus setting ``\hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} c \, |_{\partial \Omega_b} = 0`` ; on the external boundary implies that the total flux of ``c`` across the external boundary is; ```math; \begin{equation}; \hat{\boldsymbol{n}} \boldsymbol{\cdot} \left ( \boldsymbol{v} c + \boldsymbol{q}_c \right ) |_{\partial \Omega_b} = 0 \, .; \end{equation}; ```; `Oceananigans.jl` exploits this fact to define algorithm that prescribe fluxes across external ; boundaries ``\partial \Omega_b``:. 1. Impose a constant gradient ``\hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} c ; \, |_{\partial \Omega_b} = 0`` across external boundaries via using halo points (similar ; to \eqref{eq:gradient-bc}), which ensures that the evaluation of ``G_c`` in boundary-adjacent; cells does not include fluxes across the external boundary, and;; 2. Add the prescribed flux to",MatchSource.DOCS,docs/src/numerical_implementation/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md
Integrability,depend,depending,"# [Numerical implementation of boundary conditions](@id numerical_bcs). We adopt a mixed approach for implementing boundary conditions that uses both halo regions and ""direct""; imposition of boundary conditions, depending on the condition prescribed. We illustrate how boundary conditions are implemented by considering the tracer equation; ```math; \begin{align}; \partial_t c = - \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} c; - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{q}_c; + F_c \, ,; \label{eq:tracer}; \end{align}; ```; where ``\boldsymbol{q}_c`` is the diffusive flux of ``c`` and ``F_c`` is an arbitrary source term. See [Model setup: boundary conditions](@ref model_step_bcs) for how to create and use these; boundary conditions in Oceananigans. ## Gradient boundary conditions. Users impose gradient boundary conditions by prescribing the gradient ``\gamma`` of a field ; ``c`` across an *external boundary* ``\partial \Omega_b``. The prescribed gradient ``\gamma`` ; may be a constant, discrete array of values, or an arbitrary function. The gradient boundary ; condition is enforced setting the value of halo points located outside the domain interior ; such that; ```math; \begin{equation}; \label{eq:gradient-bc}; \hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} c |_{\partial \Omega_b} = \gamma \, .; \end{equation}; ```; where ``\hat{\boldsymbol{n}}`` is the vector normal to ``\partial \Omega_b``. Across the bottom boundary in ``z``, for example, this requires that; ```math; \begin{equation}; \label{eq:linear-extrapolation}; c_{i, j, 0} = c_{i, j, 1} + \gamma_{i, j, 1} \tfrac{1}{2} \left ( \Delta z_{i, j, 1} + \Delta z_{i, j, 0} \right ) \, ,; \end{equation}; ```; where ``\Delta z_{i, j, 1} = \Delta z_{i, j, 0}`` are the heights of the finite volume at ``i, j`` and ``k=1`` and ``k=0``.; This prescription implies that the ``z``-derivative of ``c`` across the boundary at ``k=1`` is; ```math; \begin{equation}; \partial_z c \, |_{i, j, 1} \equiv",MatchSource.DOCS,docs/src/numerical_implementation/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md
Safety,predict,predictor,"pen boundaries behave differently for fields on face points in the ; boundary direction due to the [staggered grid](@ref finite_volume). For example, the u-component; of velocity lies on `(Face, Center, Center)` points so for open `west` or `east` boundaries the ; point specified by the boundary condition is the point lying on the boundary, where as for a ; tracer on `(Center, Center, Center)` points the open boundary condition specifies a point outside; of the domain (hence the difference with `Value` boundary conditions). The other important detail is that open (including no-penetration) boundary conditions are the ; only conditions used on wall normal velocities when the domain is not periodic. This means that ; their value affects the pressure calculation for nonhydrostatic models as it is involved in ; calculating the divergence in the boundary adjacent center point (as described in the ; [fractional step method](@ref time_stepping) documentation). Usually boundary points are filled; for the predictor velocity (i.e. before the pressure is calculated), and on the corrected field; (i.e. after the pressure correction is applied), but for open boundaries this would result in; the boundary adjacent center point becoming divergent so open boundaries are only filled for the ; predictor velocity and stay the same after the pressure correction (so the boundary point is filled; with the final corrected velocity at the predictor step). The restriction arrises as the boundary condition is specifying the wall normal velocity, ; ``\hat{\boldsymbol{n}}\cdot\boldsymbol{u}``, which leads to the pressure boundary condition; ```math; \begin{equation}; \label{eq:pressure_boundary_condition}; \Delta t \, \hat{\boldsymbol{n}}\cdot\boldsymbol{\nabla}p^{n+1}\big |_{\partial\Omega} = \left[\Delta t \, \hat{\boldsymbol{n}}\cdot\boldsymbol{u}^\star - \hat{\boldsymbol{n}}\cdot\boldsymbol{u}^{n+1}\right],; \end{equation}; ```; implying that there is a pressure gradient across the boundary. ",MatchSource.DOCS,docs/src/numerical_implementation/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md
Usability,intuit,intuitive,"l{x}_\Omega\right)\boldsymbol{\nabla}p\right].; \end{equation}; ```; Given the boundary condition on pressure given above, we can define a new modified predictor velocity; which is equal to the predictor velocity within the domain but shares boundary conditions with the ; corrected field,; ```math; \begin{equation}; \label{eq:quasi_predictor_velocity}; \tilde{\boldsymbol{u}}^\star:=\boldsymbol{u}^\star + \delta\left(\boldsymbol{x} - \boldsymbol{x}_\Omega\right)(\boldsymbol{u}^{n+1} - \boldsymbol{u}^\star).; \end{equation}; ```; The modified pressure poisson equation becomes ``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\tilde{\boldsymbol{u}}^\star}{\Delta t}``; which can easily be solved. . Perhaps a more intuitive way to consider this is to recall that the corrector step projects ``\boldsymbol{u}^\star``; to the space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; `",MatchSource.DOCS,docs/src/numerical_implementation/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md
Availability,mask,masks,"sine transform for a real signal of length ``N_1 \times N_2`` is then given by; ```math; Y_{k_1, k_2} = \text{DCT}(X_{n_1, n_2}) =; 2 \text{Re} \left\lbrace; \omega_{4N_1}^k \left( \omega_{4N_2}^k \tilde{X} + \omega_{4N_2}^{-k} \tilde{X}^- \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{FFT}(X^\prime)`` and ``\tilde{X}^-`` indicates that ``\tilde{X}`` is indexed in reverse. ### 2D fast inverse cosine transform; The inverse can be computed using; ```math; Y_{k_1, k_2} = \text{IDCT}(X_{n_1, n_2}) =; \frac{1}{4} \text{Re} \left\lbrace; \omega_{4N_1}^{-k} \omega_{4N_2}^{-k}; \left( \tilde{X} - M_1 M_2 \tilde{X}^{--} \right); - \mathrm{i} \left( M_1 \tilde{X}^{-+} + M_2 \tilde{X}^{+-} \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{IFFT}(X)`` here, ``\tilde{X}^{-+}`` is indexed in reverse along the first dimension,; ``\tilde{X}^{-+}`` along the second dimension, and ``\tilde{X}^{--}`` along both. ``M_1`` and ``M_2`` are masks of lengths; ``N_1`` and ``N_2`` respectively, both containing ones except at the first element where ``M_0 = 0``. Afterwards, the inverse; permutation of \eqref{eq:permutation} must be applied. Due to the extra steps involved in calculating the cosine transform in 2D, running with two ; wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Deployability,integrat,integrated,"# Elliptic solvers. ## The elliptic problem for the pressure. The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal ; component of the momentum equations and invoking the vertical component to yield an elliptic ; Poisson equation for the non-hydrostatic kinematic pressure; ```math; \begin{equation}; \label{eq:poisson-pressure}; \nabla^2 p_{NH} = \frac{\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^n}{\Delta t} + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (Â§2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by ",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Energy Efficiency,efficient,efficiently,"l{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (Â§2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \frac{\widehat{\mathscr{F}}}{k_x^2 + k_y^2 + k_z^2} \, ,; \end{equation}; ```; where ``\widehat{\cdot}`` denotes the Fourier component. Here ``k_x``, ``k_y``, and ``k_z`` are the wavenumbers. However, when; solving the eq",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Integrability,integrat,integrated,"# Elliptic solvers. ## The elliptic problem for the pressure. The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal ; component of the momentum equations and invoking the vertical component to yield an elliptic ; Poisson equation for the non-hydrostatic kinematic pressure; ```math; \begin{equation}; \label{eq:poisson-pressure}; \nabla^2 p_{NH} = \frac{\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^n}{\Delta t} + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (Â§2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by ",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Modifiability,variab,variables,"oisson equation for the non-hydrostatic kinematic pressure; ```math; \begin{equation}; \label{eq:poisson-pressure}; \nabla^2 p_{NH} = \frac{\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^n}{\Delta t} + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (Â§2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \f",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Performance,perform,perform,"} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (Â§2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \frac{\widehat{\mathscr{F}}}{k_x^2 + k_y^2 + k_z^2} \, ,; \end{equation}; ```; where ``\widehat{\cdot}`` denotes the Fourier component. Here ``k_x``, ``k_y``, and ``k_z`` are the wavenumbers. However, when; solving the equation on a staggered grid we require a solution for ``p_{NH}`` that is second-order accurate such that; when when its Laplacian is computed, ``\nabla^2 p_{NH}`` matches ``\mathscr{F}`` to machine pre",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Testability,benchmark,benchmarked,"rmed on a staggered grid, DCT-II (`REDFT10`) is used to perform the forward cosine transform and DCT-III; (`REDFT01`) is used to perform the inverse cosine transform. ## Direct method with a vertically stretched grid. Using Fourier transforms for all three dimensions results in a method requiring ``\mathcal{O}(N \log_2 N)`` operations; where ``N`` is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal; system along one of the dimensions and utilizing cyclic reduction. This results in the *Fourier analysis cyclic; reduction* or ``\text{FACR}(\ell)`` algorithm (with ``\ell`` cyclic reduction steps) which requires only; ``\mathcal{O}(N \log_2\log_2 N)`` operations provided the optimal number of cyclic reduction steps is taken, which is; ``\ell = \log_2 \log_2 n`` where ``n`` is the number of grid points in the cyclic reduction dimension. The FACR algorithm; was first developed by [Hockney69](@citet) and is well reviewed by [Swarztrauber77](@citet) then further benchmarked and; extended by [Temperton79](@citet) and [Temperton80](@citet). Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can; be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the; along the vertical dimension. Expanding ``p_{NH}`` and ``\mathscr{F}`` into Fourier modes along the ``x`` and ``y`` directions; ```math; p_{ijk} = \sum_{m=1}^{N_x} \sum_{n=1}^{N_y} \tilde{p}_{mnk} \; e^{-\mathrm{i} 2\pi i m / N_x} \; e^{-\mathrm{i} 2\pi j n / N_y} \, ,; ```; and recalling that Fourier transforms do ``\partial_x \rightarrow \mathrm{i} k_x`` and ``\partial_y \rightarrow \mathrm{i} k_y`` we can write; \eqref{eq:poisson-pressure} as; ```math; \sum_{m=1}^{N_x} \sum_{n=1}^{N_y}; \left\lbrace; \partial_z^2 \tilde{p}_{mnk} - (k_x^2 + k_y^2) \tilde{p}_{mnk} - \tilde{\mathscr{F}}_{mnk}; \right\rbrace e^{-\mathrm{i} 2 \pi i m / N_x} e^{-\mathrm{i",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Usability,simpl,simple,"=; \frac{1}{4} \text{Re} \left\lbrace; \omega_{4N_1}^{-k} \omega_{4N_2}^{-k}; \left( \tilde{X} - M_1 M_2 \tilde{X}^{--} \right); - \mathrm{i} \left( M_1 \tilde{X}^{-+} + M_2 \tilde{X}^{+-} \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{IFFT}(X)`` here, ``\tilde{X}^{-+}`` is indexed in reverse along the first dimension,; ``\tilde{X}^{-+}`` along the second dimension, and ``\tilde{X}^{--}`` along both. ``M_1`` and ``M_2`` are masks of lengths; ``N_1`` and ``N_2`` respectively, both containing ones except at the first element where ``M_0 = 0``. Afterwards, the inverse; permutation of \eqref{eq:permutation} must be applied. Due to the extra steps involved in calculating the cosine transform in 2D, running with two ; wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated ",MatchSource.DOCS,docs/src/numerical_implementation/elliptic_solvers.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md
Availability,down,downwards,"d grid](@id finite_volume). The `Oceananigans.jl` staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions ; ``\Delta x_{i, j, k}, \Delta y_{i, j, k}`` and vertical dimension ; ``\Delta z_{i, j, k}``, where ``(i, j, k)`` index the location of each cell in the staggered grid.; Note that the indices ``(i, j, k)`` increase with increasing coordinate ``(x, y, z)``. ![Schematic of staggered grid](assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. Dropping explicit indexing, the areas of cell faces are given by; ```math; A_x = \Delta y \Delta z, \quad A_y = \Delta x \Delta z, \quad A_z = \Delta x \Delta y \, ,; ```; so that each cell encloses a volume ``V = \Delta x \Delta y \Delta z``. A finite volume method discretizes a continuous quantity ``c`` by considering its average over a finite volume:; ```math; c_{i, j, k} \equiv \frac{1}{V_{i, j, k}} \int c(\boldsymbol{x}) \, \mathrm{d} V_{i, j, k} \, .; ```; The finite volumes that discretize each of ``u``, ``v``, and ``w`` are located on a grid which is ""staggered"" ; with respect to the grid that defines tracer finite volumes. ; The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer ; finite volume.; In particular, the ``u``-nodes are located in the center of the ""``x``-face"" (east of the tracer point), ; ``v``-nodes are located on ``y``-faces south of the tracer point, and ``w``-nodes are located on ; ``z``-faces downwards from the tracer point.; ",MatchSource.DOCS,docs/src/numerical_implementation/finite_volume.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/finite_volume.md
Deployability,continuous,continuous,"d grid](@id finite_volume). The `Oceananigans.jl` staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions ; ``\Delta x_{i, j, k}, \Delta y_{i, j, k}`` and vertical dimension ; ``\Delta z_{i, j, k}``, where ``(i, j, k)`` index the location of each cell in the staggered grid.; Note that the indices ``(i, j, k)`` increase with increasing coordinate ``(x, y, z)``. ![Schematic of staggered grid](assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. Dropping explicit indexing, the areas of cell faces are given by; ```math; A_x = \Delta y \Delta z, \quad A_y = \Delta x \Delta z, \quad A_z = \Delta x \Delta y \, ,; ```; so that each cell encloses a volume ``V = \Delta x \Delta y \Delta z``. A finite volume method discretizes a continuous quantity ``c`` by considering its average over a finite volume:; ```math; c_{i, j, k} \equiv \frac{1}{V_{i, j, k}} \int c(\boldsymbol{x}) \, \mathrm{d} V_{i, j, k} \, .; ```; The finite volumes that discretize each of ``u``, ``v``, and ``w`` are located on a grid which is ""staggered"" ; with respect to the grid that defines tracer finite volumes. ; The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer ; finite volume.; In particular, the ``u``-nodes are located in the center of the ""``x``-face"" (east of the tracer point), ; ``v``-nodes are located on ``y``-faces south of the tracer point, and ``w``-nodes are located on ; ``z``-faces downwards from the tracer point.; ",MatchSource.DOCS,docs/src/numerical_implementation/finite_volume.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/finite_volume.md
Energy Efficiency,energy,energy,"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method. ## Smagorinsky-Lilly model. [Smagorinsky63](@citet) estimated the eddy viscosity ``\nu_e`` via a characteristic length scale ``\Delta`` times a velocity; scale given by ``\Delta |\overline{S}|`` where ``|\overline{S}| = \sqrt{2\overline{S}_{ij}\overline{S}_{ij}}``. Thus the; SGS stress tensor is given by; ```math; \tau_{ij} = -2 \nu_e \overline{S}_{ij} = -2 (C_s \Delta)^2 |\overline{S}| \overline{S}_{ij} \, ,; ```; where ``C_s`` is a dimensionless constant. The grid spacing is usually used for the characteristic length scale ``\Delta``.; The eddy diffusivities are calculated via ``\kappa_e = \nu_e / \text{Pr}_t`` where the turbulent Prandtl number; ``\text{Pr}_t`` is usually chosen to be ``\mathcal{O}(1)`` from experimental observations. Assuming that the SGS energy cascade is equal to the overall dissipation rate ``\varepsilon`` from the; [Kolmogorov41](@citet) theory, [Lilly66](@citet) was able to derive a value of; ```math; C_s = \left( \frac{3}{2}C_K\pi^\frac{4}{3} \right)^{-\frac{3}{4}} \approx 0.16 \, ,; ```; using an empirical value of ``C_K \approx 1.6`` for the Kolmogorov constant. This seems reasonable for isotropic; turbulence if the grid spacing ``\Delta`` falls in the inertial range. In practice, ``C_s`` is a tunable parameter. Due to the presence of the constant ``C_s``, the model is sometimes referred to as the *constant Smagorinsky* model; in contrast to *dynamic Smagorinsky* models that dynamically compute ``C_s`` to account for effects such as buoyant; convection. ## Anisotropic minimum dissipation models. Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model.",MatchSource.DOCS,docs/src/numerical_implementation/large_eddy_simulation.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md
Integrability,depend,depend," C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{\partial}_l \hat{v}_m \right) \left( \hat{\partial}_l \hat{v}_m \right)} \, ,; \end{equation}; ```; and the eddy diffusivity predictor by; ```math; \begin{equation}; \kappa_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{\theta} \right) \hat{\partial}_i \theta}; {\left( \hat{\partial}_l \hat{\theta} \right) \left( \hat{\partial}_l \hat{\theta} \right)} \, ,; \end{equation}; ```; where; ```math; \begin{equation}; \hat{x}_i = \frac{x_i}{\Delta_i}, \quad; \hat{v}_i(\hat{x}, t) = \frac{v_i(x, t)}{\Delta_i}, \quad; \hat{\partial}_i \hat{v}_j(\hat{x}, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t), \quad; \hat{\delta}_{i3} = \frac{\delta_{i3}}{\Delta_3} \, ,; \end{equation}; ```; so that the normalized rate of strain tensor is; ```math; \begin{equation}; \label{eq:S-hat}; \hat{S}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(\hat{x}, t) + \hat{\partial}_j \hat{v}_i(\hat{x}, t) \right] \, .; \end{equation}; ```. In equations \eqref{eq:nu-dagger}--\eqref{eq:S-hat}, ``C`` is a modified PoincarÃ© ""constant"" that is independent from; the filter width ``\Delta`` but does depend on the accuracy of the discretization method used. [Abkar16](@citet) cite; ``C^2 = \frac{1}{12}`` for a spectral method and ``C^2 = \frac{1}{3}`` for a second-order accurate scheme. ``\Delta_i`` is; the filter width in the ``x_i``-direction, and ``\Delta`` is given by the square root of the harmonic mean of the squares; of the filter widths in each direction; ```math; \frac{1}{\Delta^2} = \frac{1}{3} \left( \frac{1}{\Delta x^2} + \frac{1}{\Delta y^2} + \frac{1}{\Delta z^2} \right) \, .; ```; The term multiplying ``C_b`` is the buoyancy modification introduced by [Abkar17](@citet) and is small for weakly; stratified flows. We have introduced the ``C_b`` constant so that the buoyancy modification term may be turned on and off.; ",MatchSource.DOCS,docs/src/numerical_implementation/large_eddy_simulation.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md
Modifiability,extend,extended,"e. In practice, ``C_s`` is a tunable parameter. Due to the presence of the constant ``C_s``, the model is sometimes referred to as the *constant Smagorinsky* model; in contrast to *dynamic Smagorinsky* models that dynamically compute ``C_s`` to account for effects such as buoyant; convection. ## Anisotropic minimum dissipation models. Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model. It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic; Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that; the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity,; to derive a modified AMD model. The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and u",MatchSource.DOCS,docs/src/numerical_implementation/large_eddy_simulation.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md
Safety,predict,predictors,"sky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that; the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity,; to derive a modified AMD model. The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and understanding that all variables; represent the resolved/filtered variables, the eddy viscosity predictor is given by; ```math; \begin{equation}; \label{eq:nu-dagger}; \nu_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{v}_j \right) \hat{S}_{ij}; + C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{\partial}_l \hat{v}_m \right) \left( \hat{\partial}_l \hat{v}_m \right)} \, ,; \end{equation}; ```; and the eddy diffusivity predictor by; ```math; \begin{equation}; \kappa_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{\theta} \right) \hat{\partial}_i \theta}; {\left( \hat{\partial}_l \hat{\theta} \right) \left( \",MatchSource.DOCS,docs/src/numerical_implementation/large_eddy_simulation.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md
Usability,simpl,simply,", t) G(\boldsymbol{x} - \boldsymbol{x}^\prime, t - \tau) \, \mathrm{d}\boldsymbol{x}^\prime \, \mathrm{d} \tau \, ,; ```; as described by [Leonard75](@citet) who introduced the general filtering formalism. The ``\overline{v_i^\prime v_j^\prime}`` terms are now components of what is called the sub-grid scale (SGS) stress; tensor ``\tau^\text{SGS}_{ij}``, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript. It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties; of a Reynolds operator (Â§2.1) [sagaut06](@cite) and that in general, the filtered residual is not zero:; ``\overline{\boldsymbol{v}^\prime(\boldsymbol{x}, t)} \ne 0``. Â§13.2 of [Pope00](@citet) lists a number of popular choices for the filter function ``G``. For practical reasons we; simply employ the box kernel; ```math; \begin{equation}; \label{eq:box-kernel}; G_\Delta = G(\boldsymbol{x}, t) = \frac{1}{\Delta} H \left( \frac{1}{2}\Delta - |\boldsymbol{x}| \right) \delta(t - t_n) \, ,; \end{equation}; ```; where ``H`` is the Heaviside function, ``\Delta`` is the grid spacing, and ``t_n`` is the current time step. With; \eqref{eq:box-kernel} we get back the averaging operator originally used by [Deardorff70](@citet); ```math; \overline{\boldsymbol{v}(x, y, z, t)} =; \frac{1}{\Delta x \Delta y \Delta z}; \int_{x - \frac{1}{2}\Delta x}^{x + \frac{1}{2}\Delta x}; \int_{y - \frac{1}{2}\Delta y}^{y + \frac{1}{2}\Delta y}; \int_{z - \frac{1}{2}\Delta z}^{z + \frac{1}{2}\Delta z}; \boldsymbol{v}(\xi, \eta, \zeta, t) \, \mathrm{d} \xi \, \mathrm{d} \eta \, \mathrm{d} \zeta \, ,; ```; which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method. ## Smagorinsky-Lilly model. [Smagorinsky63](@citet) estimated the eddy viscosity ``\nu_e`` via a characteristic length scale ``\Delta`` times a velocity; scale given by ``\Delta |\overline{S}|`` where ``|\overline{S}| = \sqrt{2\o",MatchSource.DOCS,docs/src/numerical_implementation/large_eddy_simulation.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md
Availability,down,downwards,"ca} w ); + \delta_z^{aaf} ( \nu \overline{A_z}^{aac} \partial_z^{aac} w ); \right ] \, ,; ```; where ``\nu`` is the kinematic viscosity. An isotropic diffusion operator acting on a tracer ``c``, on the other hand, is discretized via; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \kappa \boldsymbol{\nabla} c \right ); = \frac{1}{V} \left[ \vphantom{\overline{A_x}^{caa}}; \delta_x^{caa} ( \kappa A_x \partial_x^{faa} c ); + \delta_y^{aca} ( \kappa A_y \partial_y^{afa} c ); + \delta_z^{aac} ( \kappa A_z \partial_z^{aaf} c ); \right] \, .; ```. ## Vertical integrals; Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure ; anomaly is; ```math; p_{HY}^\prime = \int_{-L_z}^0 b^\prime \, \mathrm{d} z \, ,; ```; where ``b^\prime`` is the buoyancy perturbation. Converting it into a sum that we compute from ; the top downwards we get; ```math; \begin{equation}; p_{HY}^\prime(k) =; \begin{cases}; - \overline{b_{N_z}^\prime}^{aaf} \Delta z^F_{N_z}, & \quad k = N_z \, , \\; p_{HY}^\prime(k+1) - \overline{b_{k+1}^\prime}^{aaf} \Delta z^F_k, & \quad 1 \le k \le N_z - 1 \, ,; \end{cases}; \end{equation}; ```; where we converted the sum into a recursive definition for ``p_{HY}^\prime(k)`` in terms of ; ``p_{HY}^\prime(k+1)`` so that the integral may be computed with ``\mathcal{O}(N_z)`` operations ; by a single thread. The vertical velocity ``w`` may be computed from ``u`` and ``v`` via the continuity equation; ```math; w = - \int_{-L_z}^0 (\partial_x u + \partial_y v) \, \mathrm{d} z \, ,; ```; to satisfy the incompressibility condition ``\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} = 0``; to numerical precision. This also involves computing a vertical integral, in this case evaluated; from the bottom up; ```math; \begin{equation}; w_k =; \begin{cases}; 0, & \quad k = 1 \, , \\; w_{k-1} - \left( \partial_x^{caa} u + \partial_y^{aca} v \right) \Delta z^C_k, & \quad 2 \le k \le N_z \, .; \end{cases}; \end{equation}; ```; ",MatchSource.DOCS,docs/src/numerical_implementation/spatial_operators.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md
Modifiability,variab,variable,"# Spatial operators. To calculate the various terms and perform the time-stepping, discrete difference and interpolation ; operators must be designed from which all the terms, such as momentum advection and Laplacian ; diffusion, may be constructed. Much of the material in this section is derived from [Marshall97FV](@citet). ## Differences. Difference operators act as the discrete form of the derivative operator. Care must be taken ; when calculating differences on a staggered grid. For example, the the difference of a cell-centered ; variable such as temperature ``T`` lies on the faces in the direction of the difference, and ; vice versa. In principle, there are three difference operators, one for each direction; ```math; \delta_x f = f_E - f_W , \quad; \delta_y f = f_N - f_S , \quad; \delta_z f = f_T - f_B ,; ```; where the ``E`` and ``W`` subscripts indicate that the value is evaluated the eastern or western ; wall of the cell, ``N`` and ``S`` indicate the northern and southern walls, and ``T`` and ``B`` ; indicate the top and bottom walls. Additionally, two ``\delta`` operators must be defined for each direction to account for the ; staggered nature of the grid. One for taking the difference of a cell-centered variable and ; projecting it onto the cell faces; ```math; \begin{align}; \delta_x^{faa} f_{i, j, k} &= f_{i, j, k} - f_{i-1, j, k} \, , \\; \delta_y^{afa} f_{i, j, k} &= f_{i, j, k} - f_{i, j-1, k} \, , \\; \delta_z^{aaf} f_{i, j, k} &= f_{i, j, k} - f_{i, j, k-1} \, , ; \end{align}; ```; and another for taking the difference of a face-centered variable and projecting it onto the; cell centers; ```math; \begin{align}; \delta_x^{caa} f_{i, j, k} &= f_{i+1, j, k} - f_{i, j, k} \, , \\; \delta_y^{aca} f_{i, j, k} &= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our cas",MatchSource.DOCS,docs/src/numerical_implementation/spatial_operators.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md
Performance,perform,perform,"# Spatial operators. To calculate the various terms and perform the time-stepping, discrete difference and interpolation ; operators must be designed from which all the terms, such as momentum advection and Laplacian ; diffusion, may be constructed. Much of the material in this section is derived from [Marshall97FV](@citet). ## Differences. Difference operators act as the discrete form of the derivative operator. Care must be taken ; when calculating differences on a staggered grid. For example, the the difference of a cell-centered ; variable such as temperature ``T`` lies on the faces in the direction of the difference, and ; vice versa. In principle, there are three difference operators, one for each direction; ```math; \delta_x f = f_E - f_W , \quad; \delta_y f = f_N - f_S , \quad; \delta_z f = f_T - f_B ,; ```; where the ``E`` and ``W`` subscripts indicate that the value is evaluated the eastern or western ; wall of the cell, ``N`` and ``S`` indicate the northern and southern walls, and ``T`` and ``B`` ; indicate the top and bottom walls. Additionally, two ``\delta`` operators must be defined for each direction to account for the ; staggered nature of the grid. One for taking the difference of a cell-centered variable and ; projecting it onto the cell faces; ```math; \begin{align}; \delta_x^{faa} f_{i, j, k} &= f_{i, j, k} - f_{i-1, j, k} \, , \\; \delta_y^{afa} f_{i, j, k} &= f_{i, j, k} - f_{i, j-1, k} \, , \\; \delta_z^{aaf} f_{i, j, k} &= f_{i, j, k} - f_{i, j, k-1} \, , ; \end{align}; ```; and another for taking the difference of a face-centered variable and projecting it onto the; cell centers; ```math; \begin{align}; \delta_x^{caa} f_{i, j, k} &= f_{i+1, j, k} - f_{i, j, k} \, , \\; \delta_y^{aca} f_{i, j, k} &= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our cas",MatchSource.DOCS,docs/src/numerical_implementation/spatial_operators.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md
Integrability,depend,dependent," \, ,; \end{align}; ```; while treating the rest of the terms on the right hand side of \eqref{eq:momentum-time-integral} ; explicitly. The implicit treatment of pressure ensures that the velocity field obtained at ; time step ``n+1`` is divergence-free. To effect such a fractional step method, we define an intermediate velocity field ``\boldsymbol{v}^\star`` such that; ```math; \begin{equation}; \label{eq:intermediate-velocity-field}; \boldsymbol{v}^\star - \boldsymbol{v}^n = \int_{t_n}^{t_{n+1}} \boldsymbol{G}_{\boldsymbol{v}} \, \mathrm{d} t \, ,; \end{equation}; ```. The integral on the right of the equation for ``\boldsymbol{v}^\star`` may be approximated by a variety of explicit; methods. For example, a forward Euler method approximates the integral via; ```math; \begin{equation}; \int_{t_n}^{t_{n+1}} G \, \mathrm{d} t \approx \Delta t G^n \, ,; \label{eq:forward-euler}; \end{equation}; ```; for any time-dependent function ``G(t)``, while a second-order Adams-Bashforth method uses the approximation; ```math; \begin{equation}; \label{eq:adams-bashforth}; \int_{t_n}^{t_{n+1}} G \, \mathrm{d} t \approx; \Delta t \left [ \left ( \tfrac{3}{2} + \chi \right ) G^n ; - \left ( \tfrac{1}{2} + \chi \right ) G^{n-1} \right ] \, ,; \end{equation}; ```; where ``\chi`` is a parameter. [Ascher95](@citet) claim that ``\chi = \tfrac{1}{8}`` is optimal; ; ``\chi = -\tfrac{1}{2}`` yields the forward Euler scheme. Combining the equation \eqref{eq:intermediate-velocity-field} for ``\boldsymbol{v}^\star`` and the time integral; of the non-hydrostatic pressure \eqref{eq:pnon_implicit} yields; ```math; \begin{equation}; \label{eq:fractional-step}; \boldsymbol{v}^{n+1} - \boldsymbol{v}^\star = - \Delta t \boldsymbol{\nabla} p_{\rm{non}}^{n+1} \, .; \end{equation}; ```. Taking the divergence of fractional step equation \eqref{eq:fractional-step} and requiring that ; ``\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^{n+1} = 0`` yields a Poisson equation ; for the kinematic pressur",MatchSource.DOCS,docs/src/numerical_implementation/time_stepping.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/time_stepping.md
Modifiability,evolve,evolves,"# [Time-stepping and the fractional step method](@id time_stepping). With the [pressure decomposition](@ref pressure_decomposition) as discussed, the momentum evolves via:. ```math; \begin{equation}; \label{eq:momentum-time-derivative}; \partial_t \boldsymbol{v} = \boldsymbol{G}_{\boldsymbol{v}} - \boldsymbol{\nabla} p_{\rm{non}} \, ,; \end{equation}; ```. where, e.g., for the non-hydrostatic model (ignoring background velocities and surface-wave effects). ```math; \boldsymbol{G}_{\boldsymbol{v}} \equiv - \boldsymbol{\nabla}_h p_{\rm{hyd}} ; - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{v} ; - \boldsymbol{f} \times \boldsymbol{v} ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau} ; + \boldsymbol{F}_{\boldsymbol{v}}; ```. collects all terms on the right side of the momentum equation \eqref{eq:momentum-time-derivative}, *except* the ; contribution of non-hydrostatic pressure ``\boldsymbol{\nabla} p_{\rm{non}}``. The time-integral of the momentum equation \eqref{eq:momentum-time-derivative} from time step ``n`` at ``t = t_n``; to time step ``n+1`` at ``t_{n+1}`` is:; ```math; \begin{equation}; \label{eq:momentum-time-integral}; \boldsymbol{v}^{n+1} - \boldsymbol{v}^n = ; \int_{t_n}^{t_{n+1}} \Big [ - \boldsymbol{\nabla} p_{\rm{non}} + \boldsymbol{G}_{\boldsymbol{v}} \Big ] \, \mathrm{d} t \, ,; \end{equation}; ```; where the superscript ``n`` and ``n+1`` imply evaluation at ``t_n`` and ``t_{n+1}``, such that ; ``\boldsymbol{v}^n \equiv \boldsymbol{v}(t=t_n)``. The crux of the fractional step method is ; to treat the pressure term ``\boldsymbol{\nabla} p_{\rm{non}}`` implicitly using the approximation; ```math; \begin{align}; \label{eq:pnon_implicit}; \int_{t_n}^{t_{n+1}} \boldsymbol{\nabla} p_{\rm{non}} \, \mathrm{d} t \approx; \Delta t \boldsymbol{\nabla} p_{\rm{non}}^{n+1} \, ,; \end{align}; ```; while treating the rest of the terms on the right hand side of \eqref{eq:momentum-time-integral} ; explicitly. The implicit t",MatchSource.DOCS,docs/src/numerical_implementation/time_stepping.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/time_stepping.md
Availability,down,down,"# [Turbulence closures](@id numerical_closures). To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require; you resolve all motions down to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (Â§13) [Pope00](@cite). ## Reynolds-averaged Navierâ€“Stokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see Â§4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha ",MatchSource.DOCS,docs/src/numerical_implementation/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md
Energy Efficiency,energy,energy,"# [Turbulence closures](@id numerical_closures). To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require; you resolve all motions down to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (Â§13) [Pope00](@cite). ## Reynolds-averaged Navierâ€“Stokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see Â§4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha ",MatchSource.DOCS,docs/src/numerical_implementation/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md
Integrability,depend,depends,"g in the Reynolds; decomposition for ``\boldsymbol{v}`` and after some manipulation arrive at the following form for the *Reynolds-averaged; Navier-Stokes equations*; ```math; \begin{align}; \partial_i \overline{u}_i &= 0 \, ,\\; \partial_t \overline{u}_i + \overline{u}_j \partial_j \overline{u}_i &= \overline{f}_i -; \partial_j \left(-\alpha\overline{p}\delta_{ij} + 2\nu \overline{S}_{ij} - \overline{v_i^\prime v_j^\prime}\right) \, ,; \end{align}; ```; where; ```math; \overline{S}_{ij} = \frac{1}{2} ( \partial_j \overline{u}_i + \partial_i \overline{u}_j ) \, ,; ```; is the mean rate of strain tensor. Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation; terms which form the components of the *Reynolds stress tensor*; ```math; \tau_{ij} = \rho \overline{v_i^\prime v_j^\prime} \, .; ```; Attempting to close the equations leads to the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (Â§4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \qu",MatchSource.DOCS,docs/src/numerical_implementation/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md
Modifiability,variab,variables,"# [Turbulence closures](@id numerical_closures). To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require; you resolve all motions down to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (Â§13) [Pope00](@cite). ## Reynolds-averaged Navierâ€“Stokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see Â§4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha ",MatchSource.DOCS,docs/src/numerical_implementation/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md
Usability,simpl,simple,"the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (Â§4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \quad \text{and} \quad; \overline{v_i^\prime v_j^\prime} = -2\nu_e \overline{S}_{ij} \, ,; ```; where ``\nu_e = \nu_e(\boldsymbol{x}, t)`` is the turbulent or *eddy viscosity* and ``\kappa_e = \kappa_e(\boldsymbol{x}, t)``; is the *eddy diffusivity*. The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated; value for the viscosity and diffusivity, you are already using an eddy viscosity model. The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy; diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent; flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law; (Â§4.4,10.1) [Pope00](@cite). So we might want something a little bit more sophisticated.; ",MatchSource.DOCS,docs/src/numerical_implementation/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md
Availability,avail,available,"# Boundary conditions. Users may impose *no-penetration*, *flux*, *gradient* (Neumann), and; *value* (Dirichlet) boundary conditions in bounded, non-periodic directions.; Note that the only boundary condition available for a velocity field normal to the bounded; direction is *no-penetration*. ## Flux boundary conditions. A flux boundary condition prescribes flux of a quantity normal to the boundary.; For a tracer ``c`` this corresponds to prescribing; ```math; q_c \, |_b \equiv \boldsymbol{q}_c \boldsymbol{\cdot} \hat{\boldsymbol{n}} \, |_{\partial \Omega_b} \, ,; ```; where ``\partial \Omega_b`` is an external boundary. ## Gradient (Neumann) boundary condition. A gradient boundary condition prescribes the gradient of a field normal to the boundary.; For a tracer ``c`` this prescribes; ```math; \gamma \equiv \boldsymbol{\nabla} c \boldsymbol{\cdot} \hat{\boldsymbol{n}} \, |_{\partial \Omega_b} \, .; ```. ## Value (Dirichlet) boundary condition. A value boundary condition prescribes the value of a field on a boundary; for a tracer this; prescribes; ```math; c_b \equiv c \, |_{\partial \Omega_b} \, .; ```. ## No penetration boundary condition. A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0,; so that; ```math; \boldsymbol{\hat{n}} \boldsymbol{\cdot} \boldsymbol{v} \, |_{\partial \Omega_b} = 0 \, .; ```; ",MatchSource.DOCS,docs/src/physics/boundary_conditions.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boundary_conditions.md
Energy Efficiency,reduce,reduces,"eneral, decomposed into three components:; ```math; \rho(\boldsymbol{x}, t) = \rho_0 + \rho_*(z) + \rho'(\boldsymbol{x}, t) \, ,; ```; where ``\rho_0`` is a constant 'reference' density, ``\rho_*(z)`` is a background density; profile which, when non-zero, is typically associated with the hydrostatic compression; of seawater in the deep ocean, and ``\rho'(\boldsymbol{x}, t)`` is the dynamic component of density; corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity. The fluid *buoyancy*, associated with the buoyant acceleration of fluid, is; defined in terms of ``\rho'`` as; ```math; b = - \frac{g \rho'}{\rho_0} \, ,; ```; where ``g`` is gravitational acceleration. The Boussinesq approximation is valid when ``\rho_* + \rho' \ll \rho_0``, which implies the; fluid is _approximately_ incompressible, and thus does not support acoustic waves. In this case, ; the mass conservation equation reduces to the continuity equation; ```math; \begin{equation}; \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} = \partial_x u + \partial_y v + \partial_z w = 0 \, .; \label{eq:continuity}; \end{equation}; ```. Similarly, in the the momentum equations we can divide through with ``\rho_0`` and use that ``\rho_* + \rho' \ll \rho_0`` to get:; ```math; \begin{equation}; \partial_t \boldsymbol{v} + \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} + \dotsb = - \frac1{\rho_0} \boldsymbol{\nabla} p - g \frac{\rho}{\rho_0} \hat{\boldsymbol{z}} + \dotsb \, .; \label{eq:momentum}; \end{equation}; ```. We refer to ``p / \rho_0`` as the ""kinematic pressure"" with dimensions of velocity squared. Hereafter, we; abuse notation a bit and denote the kinematic pressure simply as ``p``. !!! info ""Convention on dynamic versus kinematic pressure""; In Oceananigans, the pressure ``p`` refers to ""kinematic pressure"" (with dimensions velocity squared),; i.e., the dynamic pressure scaled with the reference fluid density ``\rho_0``. [^1]: Named afte",MatchSource.DOCS,docs/src/physics/boussinesq.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boussinesq.md
Usability,simpl,simply,"with the buoyant acceleration of fluid, is; defined in terms of ``\rho'`` as; ```math; b = - \frac{g \rho'}{\rho_0} \, ,; ```; where ``g`` is gravitational acceleration. The Boussinesq approximation is valid when ``\rho_* + \rho' \ll \rho_0``, which implies the; fluid is _approximately_ incompressible, and thus does not support acoustic waves. In this case, ; the mass conservation equation reduces to the continuity equation; ```math; \begin{equation}; \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} = \partial_x u + \partial_y v + \partial_z w = 0 \, .; \label{eq:continuity}; \end{equation}; ```. Similarly, in the the momentum equations we can divide through with ``\rho_0`` and use that ``\rho_* + \rho' \ll \rho_0`` to get:; ```math; \begin{equation}; \partial_t \boldsymbol{v} + \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} + \dotsb = - \frac1{\rho_0} \boldsymbol{\nabla} p - g \frac{\rho}{\rho_0} \hat{\boldsymbol{z}} + \dotsb \, .; \label{eq:momentum}; \end{equation}; ```. We refer to ``p / \rho_0`` as the ""kinematic pressure"" with dimensions of velocity squared. Hereafter, we; abuse notation a bit and denote the kinematic pressure simply as ``p``. !!! info ""Convention on dynamic versus kinematic pressure""; In Oceananigans, the pressure ``p`` refers to ""kinematic pressure"" (with dimensions velocity squared),; i.e., the dynamic pressure scaled with the reference fluid density ``\rho_0``. [^1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq; approximation neglects density differences in the momentum equation except when associated; with the gravitational term. It is an accurate approximation for many flows, and especially; so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4); for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A); for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering; introduction. ",MatchSource.DOCS,docs/src/physics/boussinesq.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boussinesq.md
Integrability,contract,contraction,"# Buoyancy model and equations of state. The buoyancy model determines the relationship between tracers and the buoyancy ``b`` in the momentum equation. ## Buoyancy tracer. The simplest buoyancy model uses buoyancy ``b`` itself as a tracer: ``b`` obeys the tracer; conservation equation and is used directly in the momentum equations. ## Seawater buoyancy. For seawater buoyancy is, in general, modeled as a function of conservative temperature; ``T``, absolute salinity ``S``, and depth below the ocean surface ``d`` via; ```math; \begin{equation}; b = - \frac{g}{\rho_0} \rho' \left (T, S, d \right ) \, ,; \label{eq:seawater-buoyancy}; \end{equation}; ```; where ``g`` is gravitational acceleration, ``\rho_0`` is the reference density.; The function ``\rho'(T, S, d)`` in the seawater buoyancy relationship that links conservative temperature,; salinity, and depth to the density perturbation is called the *equation of state*.; Both ``T`` and ``S`` obey the tracer conservation equation. ### Linear equation of state. Buoyancy is determined from a linear equation of state via; ```math; b = g \left ( \alpha T - \beta S \right ) \, ,; ```; where ``g`` is gravitational acceleration, ``\alpha`` is the thermal expansion coefficient,; and ``\beta`` is the haline contraction coefficient. ### Nonlinear equation of state. Buoyancy is determined by the simplified equations of state introduced by [Roquet15TEOS](@citet).; ",MatchSource.DOCS,docs/src/physics/buoyancy_and_equations_of_state.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/buoyancy_and_equations_of_state.md
Usability,simpl,simplest,"# Buoyancy model and equations of state. The buoyancy model determines the relationship between tracers and the buoyancy ``b`` in the momentum equation. ## Buoyancy tracer. The simplest buoyancy model uses buoyancy ``b`` itself as a tracer: ``b`` obeys the tracer; conservation equation and is used directly in the momentum equations. ## Seawater buoyancy. For seawater buoyancy is, in general, modeled as a function of conservative temperature; ``T``, absolute salinity ``S``, and depth below the ocean surface ``d`` via; ```math; \begin{equation}; b = - \frac{g}{\rho_0} \rho' \left (T, S, d \right ) \, ,; \label{eq:seawater-buoyancy}; \end{equation}; ```; where ``g`` is gravitational acceleration, ``\rho_0`` is the reference density.; The function ``\rho'(T, S, d)`` in the seawater buoyancy relationship that links conservative temperature,; salinity, and depth to the density perturbation is called the *equation of state*.; Both ``T`` and ``S`` obey the tracer conservation equation. ### Linear equation of state. Buoyancy is determined from a linear equation of state via; ```math; b = g \left ( \alpha T - \beta S \right ) \, ,; ```; where ``g`` is gravitational acceleration, ``\alpha`` is the thermal expansion coefficient,; and ``\beta`` is the haline contraction coefficient. ### Nonlinear equation of state. Buoyancy is determined by the simplified equations of state introduced by [Roquet15TEOS](@citet).; ",MatchSource.DOCS,docs/src/physics/buoyancy_and_equations_of_state.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/buoyancy_and_equations_of_state.md
Availability,recover,recover,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,docs/src/physics/hydrostatic_free_surface_model.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md
Deployability,integrat,integrate,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,docs/src/physics/hydrostatic_free_surface_model.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md
Integrability,integrat,integrate,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,docs/src/physics/hydrostatic_free_surface_model.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md
Safety,recover,recover,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,docs/src/physics/hydrostatic_free_surface_model.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md
Modifiability,variab,variables,"# Shallow water model. The [`ShallowWaterModel`](@ref) simulates the shallow water dynamics for a fluid of constant density; but with varying fluid depth ``h(x, y, t)`` and whose velocity only varies in the horizontal,; ``\boldsymbol{u}(x, y, t) = u(x, y, t) \boldsymbol{\hat x} + v(x, y, t) \boldsymbol{\hat y}``. [`ShallowWaterModel`](@ref) allows users to prescribe the shallow water dynamics using two different formulations:; `VectorInvariantFormulation()` and `ConservativeFormulation()`. The `VectorInvariantFormulation` uses the horizontal velocity ``\boldsymbol{u}`` and the total depth of the fluid, ``h``,; as the dynamical variables. Furthermore, the advective terms are rewritten via the vector identity:; ```math; \boldsymbol{u} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{u} = (\boldsymbol{\nabla} \times \boldsymbol{u}) \times \boldsymbol{u} + \boldsymbol{\nabla} \left( \frac1{2} \boldsymbol{u} \boldsymbol{\cdot} \boldsymbol{u} \right ) \, .; ```; Thus, the shallow water dynamics in vector-invariant form become:. ```math; \begin{align}; \partial_t \boldsymbol{u} + (\zeta \boldsymbol{\hat z} + \boldsymbol{f}) \times\boldsymbol{u} & = ; - \boldsymbol{\nabla} \left [ g (h +b) + \frac12 \boldsymbol{u} \cdot \boldsymbol{u} \right ] \, , \\; \partial_t h + \boldsymbol{\nabla} \boldsymbol{\cdot} (\boldsymbol{u} h) & = 0 \, ,; \end{align}; ```; where ``\zeta(x, y, t) = \partial_x v - \partial_y u`` is the vertical component of the relative vorticity. The elevation of the bottom bathymetry, measured with respect to the free-surface at rest, is ``b(x, y)``.; The free-surface elevation ``\eta`` is then:. ```math; \eta(x, y, t) = h(x, y, t) + b(x, y) \, .; ```. The `ConservativeFormulation()` uses the volume transport along each direction ``\boldsymbol{u} h = (u h, v h)`` and the total; depth of the fluid ``h`` as the dynamical variables. The shallow water dynamics in conservative form is:; ```math; \begin{align}; \partial_t (\boldsymbol{u} h) + \boldsymbol{\nabla} \b",MatchSource.DOCS,docs/src/physics/shallow_water_model.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/shallow_water_model.md
Energy Efficiency,energy,energy,"x, y, z)`` is average velocity of a fluid particle whose average position is ``(x, y, z)`` ; at time ``t``. The average position of a fluid particle ``\boldsymbol{\xi}(t) = (\xi, \eta, \zeta)`` ; is thus governed by; ```math; \partial_t \boldsymbol{\xi} + \boldsymbol{v}(\boldsymbol{\xi}, t) \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{\xi} = \boldsymbol{v}(\boldsymbol{\xi}, t) \, ,; ```; which is the same relationship that holds when surface waves are not present and ``\boldsymbol{v}`` ; ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean ; momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather ; than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged ; by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests ; either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background ; rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not ; explicitly include the effects of surface waves in turbulence closures that model the effects ; of subgrid turbulence. More specifically, the effect of steady surface waves does not effect ; the conservation of Lagrangian-mean turbulent kinetic energy. The Lagrangian-mean velocity field ``\boldsymbol{v}`` contrasts with the Eulerian-mean velocity ; field ``\boldsymbol{v}^E``, which is the fluid velocity averaged at the fixed Eulerian position ; ``(x, y, z)``. The surface wave Stokes drift field supplied by the user is, in fact, defined; by the difference between the Eulerian- and Lagrangian-mean velocity:; ```math; \boldsymbol{u}^S \equiv \boldsymbol{v} - \boldsymbol{v}^E \, .; ```; The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined; from a wave model for the evolution of surface waves under time-dependent atmospheric winds; in more realistic cases.; ",MatchSource.DOCS,docs/src/physics/surface_gravity_waves.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md
Integrability,depend,dependent,"x, y, z)`` is average velocity of a fluid particle whose average position is ``(x, y, z)`` ; at time ``t``. The average position of a fluid particle ``\boldsymbol{\xi}(t) = (\xi, \eta, \zeta)`` ; is thus governed by; ```math; \partial_t \boldsymbol{\xi} + \boldsymbol{v}(\boldsymbol{\xi}, t) \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{\xi} = \boldsymbol{v}(\boldsymbol{\xi}, t) \, ,; ```; which is the same relationship that holds when surface waves are not present and ``\boldsymbol{v}`` ; ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean ; momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather ; than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged ; by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests ; either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background ; rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not ; explicitly include the effects of surface waves in turbulence closures that model the effects ; of subgrid turbulence. More specifically, the effect of steady surface waves does not effect ; the conservation of Lagrangian-mean turbulent kinetic energy. The Lagrangian-mean velocity field ``\boldsymbol{v}`` contrasts with the Eulerian-mean velocity ; field ``\boldsymbol{v}^E``, which is the fluid velocity averaged at the fixed Eulerian position ; ``(x, y, z)``. The surface wave Stokes drift field supplied by the user is, in fact, defined; by the difference between the Eulerian- and Lagrangian-mean velocity:; ```math; \boldsymbol{u}^S \equiv \boldsymbol{v} - \boldsymbol{v}^E \, .; ```; The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined; from a wave model for the evolution of surface waves under time-dependent atmospheric winds; in more realistic cases.; ",MatchSource.DOCS,docs/src/physics/surface_gravity_waves.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md
Usability,simpl,simplicity,"herefore, are not present in the resolved velocity field ``\boldsymbol{v}``, and only the ; steady, averaged effect of surface waves that manifests over several or more wave oscillations ; are modeled. When surface waves are included, the resolved velocity field ``\boldsymbol{v}`` is the ; Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location ; ``(x, y, z)`` is average velocity of a fluid particle whose average position is ``(x, y, z)`` ; at time ``t``. The average position of a fluid particle ``\boldsymbol{\xi}(t) = (\xi, \eta, \zeta)`` ; is thus governed by; ```math; \partial_t \boldsymbol{\xi} + \boldsymbol{v}(\boldsymbol{\xi}, t) \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{\xi} = \boldsymbol{v}(\boldsymbol{\xi}, t) \, ,; ```; which is the same relationship that holds when surface waves are not present and ``\boldsymbol{v}`` ; ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean ; momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather ; than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged ; by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests ; either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background ; rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not ; explicitly include the effects of surface waves in turbulence closures that model the effects ; of subgrid turbulence. More specifically, the effect of steady surface waves does not effect ; the conservation of Lagrangian-mean turbulent kinetic energy. The Lagrangian-mean velocity field ``\boldsymbol{v}`` contrasts with the Eulerian-mean velocity ; field ``\boldsymbol{v}^E``, which is the fluid velocity averaged at the fixed Eulerian position ; ``(x, y, z)``. The surface wave Stokes drift field supplied by the use",MatchSource.DOCS,docs/src/physics/surface_gravity_waves.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md
Energy Efficiency,reduce,reduces,"fusivity components ``\kappa_h`` and ``\kappa_z``. ## Smagorinsky-Lilly turbulence closure. In the turbulence closure proposed by [Lilly62](@citet) and [Smagorinsky63](@citet),; the subgrid stress associated with unresolved turbulent motions is modeled diffusively via; ```math; \tau_{ij} = - 2 \nu_e \Sigma_{ij} \, ,; ```; where ``\Sigma_{ij} = \tfrac{1}{2} \left ( v_{i, j} + v_{j, i} \right )`` is the resolved; strain rate.; The eddy viscosity is given by; ```math; \begin{align}; \nu_e = \left ( C \Delta_f \right )^2 \sqrt{ \Sigma^2 } \, \varsigma(N^2 / \Sigma^2) \, ,; \label{eq:smagorinsky-viscosity}; \end{align}; ```; where ``\Delta_f`` is the ""filter width"" associated with the finite volume grid spacing and; ``C`` is a user-specified model constant, ``\Sigma^2 \equiv \Sigma_{ij} \Sigma_{ij}``.; The factor ``\varsigma(N^2 / \Sigma^2)`` reduces ``\nu_e`` in regions of; strong stratification via; ```math; \varsigma(N^2 / \Sigma^2) = \sqrt{1 - \min \left ( 1, C_b N^2 / \Sigma^2 \right )} \, ,; ```; where ``N^2 = \max \left (0, \partial_z b \right )`` is the squared buoyancy frequency for stable; stratification with ``\partial_z b > 0`` and ``C_b`` is a user-specified constant. Lilly (1962); proposed ``C_b = 1/Pr``, where ``Pr`` is a turbulent Prandtl number.; The filter width for the Smagorinsky-Lilly closure is; ```math; \Delta_f(\boldsymbol{x}) = \left ( \Delta x \Delta y \Delta z \right)^{1/3} \, ,; ```; where ``\Delta x``, ``\Delta y``, and ``\Delta z`` are the grid spacing in the; ``\boldsymbol{\hat x}``, ``\boldsymbol{\hat y}``, and ``\boldsymbol{\hat z}`` directions at location ``\boldsymbol{x} = (x, y, z)``. The effect of subgrid turbulence on tracer mixing is also modeled diffusively via; ```math; \boldsymbol{q}_c = - \kappa_e \boldsymbol{\nabla} c \, ,; ```; where the eddy diffusivity ``\kappa_e`` is; ```math; \kappa_e = \frac{\nu_e}{Pr} + \kappa \, .; ```; Both ``Pr`` and ``\kappa`` may be set independently for each tracer. ## Anisotropic minimum dissipatio",MatchSource.DOCS,docs/src/physics/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md
Modifiability,enhance,enhanced,", .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` and ``C_b`` are; user-specified model constants, ``\Delta_f`` is a ""filter width"" associated with the finite volume; grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker; delta ``\hat \delta_{i3}`` are defined such that; ```math; \hat \partial_i \equiv \Delta_i \partial_i, \qquad; \hat{v}_i(x, t) \equiv \frac{v_i(x, t)}{\Delta_i}, \quad \text{and} \quad; \hat{\delta}_{i3} \equiv \frac{\delta_{i3}}{\Delta_3} \, .; ```; A velocity gradient, for example, is therefore; ``\hat{\partial}_i \hat{v}_j(x, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t)``,; while the normalized strain tensor is; ```math; \hat{\Sigma}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(x, t) + \hat{\partial}_j \hat{v}_i(x, t) \right] \, .; ```; The filter width ``\Delta_f`` in that appears in the viscosity and diffusivity predictors; is taken as the square root of the harmonic mean of the squares of the filter widths in; each direction:; ```math; \frac{1}{\Delta_f^2} = \frac{1}{3} \left( \frac{1}{\Delta x^2}; + \frac{1}{\Delta y^2}; + \frac{1}{\Delta z^2} \right) \, .; ```; The constant ``C_b`` permits the ""buoyancy modification"" term it multiplies to be omitted; from a calculation. By default we use the model constants ``C = 1/12`` and ``C_b = 0``. ## Convective adjustment vertical diffusivity. This closure aims to model the enhanced mixing that occurs due to convection.; At every point and for every time instance, the closure diagnoses the gravitational stability of the fluid and; applies the vertical diffusivities (i) `background_Î½z` to `u, v` and `background_Îºz` to all tracers if the fluid; is gravitationally neutral or stable with ``âˆ‚b/âˆ‚z â‰¥ 0``, or (ii) `convective_Î½z` and `convective_Îºz` if ``âˆ‚b/âˆ‚z < 0``. This closure is a plausible model for convection if `convective_Îºz` ``\gg`` `background_Îºz` and `convective_Î½z` ``\gg`` `background_Î½z`.; ",MatchSource.DOCS,docs/src/physics/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md
Safety,predict,predictors,"ymbol{\hat x}``, ``\boldsymbol{\hat y}``, and ``\boldsymbol{\hat z}`` directions at location ``\boldsymbol{x} = (x, y, z)``. The effect of subgrid turbulence on tracer mixing is also modeled diffusively via; ```math; \boldsymbol{q}_c = - \kappa_e \boldsymbol{\nabla} c \, ,; ```; where the eddy diffusivity ``\kappa_e`` is; ```math; \kappa_e = \frac{\nu_e}{Pr} + \kappa \, .; ```; Both ``Pr`` and ``\kappa`` may be set independently for each tracer. ## Anisotropic minimum dissipation (AMD) turbulence closure. The anisotropic minimum dissipation (AMD) model proposed by [Verstappen18](@citet) and was; described and tested by [Vreugdenhil18](@citet). The AMD model uses an eddy diffusivity hypothesis; similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each; tracer are defined in terms of eddy viscosity and diffusivity *predictors* ``\nu_e^\dagger`` and ``\kappa_e^\dagger``,; such that; ```math; \nu_e = \max \left ( 0, \nu_e^\dagger \right ) + \nu; \quad \text{and} \quad; \kappa_e = \max \left ( 0, \kappa_e^\dagger \right ) + \kappa \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``, where ``\nu`` and ``\kappa`` are the; constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity ; predictor is; ```math; \begin{equation}; \nu_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k \hat{v}_j) \hat{\Sigma}_{ij}; + C_b \hat{\delta}_{i3} (\hat{\partial}_k \hat{v_i}) (\hat{\partial}_k b)}; {(\hat{\partial}_l \hat{v}_m) (\hat{\partial}_l \hat{v}_m)} \, ,; \label{eq:nu-dagger}; \end{equation}; ```; while the eddy diffusivity predictor for tracer ``c`` is; ```math; \begin{equation}; \label{eq:kappa-dagger}; \kappa_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k c) (\hat{\partial}_i c)}; {(\hat{\partial}_l c) (\hat{\partial}_l c)} \, .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` an",MatchSource.DOCS,docs/src/physics/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md
Testability,test,tested,"y for stable; stratification with ``\partial_z b > 0`` and ``C_b`` is a user-specified constant. Lilly (1962); proposed ``C_b = 1/Pr``, where ``Pr`` is a turbulent Prandtl number.; The filter width for the Smagorinsky-Lilly closure is; ```math; \Delta_f(\boldsymbol{x}) = \left ( \Delta x \Delta y \Delta z \right)^{1/3} \, ,; ```; where ``\Delta x``, ``\Delta y``, and ``\Delta z`` are the grid spacing in the; ``\boldsymbol{\hat x}``, ``\boldsymbol{\hat y}``, and ``\boldsymbol{\hat z}`` directions at location ``\boldsymbol{x} = (x, y, z)``. The effect of subgrid turbulence on tracer mixing is also modeled diffusively via; ```math; \boldsymbol{q}_c = - \kappa_e \boldsymbol{\nabla} c \, ,; ```; where the eddy diffusivity ``\kappa_e`` is; ```math; \kappa_e = \frac{\nu_e}{Pr} + \kappa \, .; ```; Both ``Pr`` and ``\kappa`` may be set independently for each tracer. ## Anisotropic minimum dissipation (AMD) turbulence closure. The anisotropic minimum dissipation (AMD) model proposed by [Verstappen18](@citet) and was; described and tested by [Vreugdenhil18](@citet). The AMD model uses an eddy diffusivity hypothesis; similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each; tracer are defined in terms of eddy viscosity and diffusivity *predictors* ``\nu_e^\dagger`` and ``\kappa_e^\dagger``,; such that; ```math; \nu_e = \max \left ( 0, \nu_e^\dagger \right ) + \nu; \quad \text{and} \quad; \kappa_e = \max \left ( 0, \kappa_e^\dagger \right ) + \kappa \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``, where ``\nu`` and ``\kappa`` are the; constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity ; predictor is; ```math; \begin{equation}; \nu_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k \hat{v}_j) \hat{\Sigma}_{ij}; + C_b \hat{\delta}_{i3} (\hat{\partial}_k \hat{v_i}) (\hat{\partial}_k b)}; {(\hat{\partial}_l \hat{v}_m) (\hat{\partial}_l \hat{v}_m)} \, ,; ",MatchSource.DOCS,docs/src/physics/turbulence_closures.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md
Performance,perform,performed,"## Differentiation and interpolation operators. The geometry of the staggerd grid used by Oceananigans.jl (sometimes called the ""C grid""); is (in one dimension) shown below; ```; face cell face cell face. i-1 i; â†“ â†“; | Ã— | Ã— |; â†‘ â†‘ â†‘; i-1 i i+1; ```; Difference operators are denoted by a `Î´` (`\delta`). Calculating the difference; of a cell-centered quantity `c` at cell `i` returns the difference at face `i`; ```; Î´cáµ¢ = cáµ¢ - cáµ¢â‚‹â‚; ```; and so this operation, if applied along the x-dimension, is denoted by `Î´xá¶ áµƒáµƒ`. The difference of a face-centered quantity `u` at face `i` returns the difference at cell `i`; ```; Î´uáµ¢ = uáµ¢â‚Šâ‚ - uáµ¢; ```; and is thus denoted `Î´xá¶œáµƒáµƒ` when applied along the x-dimension. The three characters at the end of the function name, `faa` for example, indicates that the; output lies on the cell faces in the x-dimension but remains at their original positions in ; the y- and z-dimensions. Thus we further identify this operator by the superscript `á¶ áµƒáµƒ`, where; the `a` stands for ""any"" as the location is unchanged by the operator and is determined by; the input. As a result, the interpolation of a quantity `c` from a cell `i` to face `i` (which is denoted; ""`â„‘xá¶ áµƒáµƒ`"" in the code below) is; ```; â„‘xá¶ áµƒáµƒ(c)áµ¢ = (cáµ¢ + cáµ¢â‚‹â‚) / 2; ```; Conversely, the interpolation of a quantity `u` from a face `i` to cell `i` is given by; ```; â„‘xá¶œáµƒáµƒ(u)áµ¢ = (uáµ¢â‚Šâ‚ + uáµ¢) / 2; ```; The `â„‘` (`\Im`) symbol indicates that an interpolation is being performed. For example, `â„‘x`; indicates that the interpolation is performed along the x-dimension.; ",MatchSource.DOCS,src/Operators/README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/src/Operators/README.md
Testability,test,testing,"# Convergence Tests. This directory contains scripts and modules for testing the numerical; convergence of `Oceananigans` time stepping algorithms and spatial discretiation. To instantiate the convergence test environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."", "".."")))'; ```. ## Time stepping convergence tests. ```; julia --project point_exponential_decay.jl; ```. produces `figs/point_exponential_decay_time_stepper_convergence.png`. ## One-dimensional advection-diffusion tests. ### Advection and diffusion of a cosine. ```; julia --project one_dimensional_cosine_advection_diffusion.jl; ```. produces. * `figs/cosine_advection_diffusion_solutions.png`; * `figs/cosine_advection_diffusion_error_convergence.png`. ### Advection and diffusion of a Gaussian. ```; julia --project one_dimensional_gaussian_advection_diffusion.jl; ```. produces. * `figs/gaussian_advection_diffusion_solutions.png`; * `figs/gaussian_advection_diffusion_error_convergence.png`. ## Two-dimensional diffusion. ```; julia --project two_dimensional_diffusion.jl; ```. produces `figs/two_dimensional_diffusion_convergence.png`. ## Two-dimensional Taylor-Green vortex. ```; julia --project run_taylor_green.jl; ```. and then. ```; julia --project analyze_taylor_green.jl; ```. produces `figs/taylor_green_convergence.png`. ## Two-dimensional forced flow with free-slip boundary conditions. ```; julia --project run_forced_free_slip.jl; ```. followed by. ```; julia --project analyze_forced_free_slip.jl; ```. produces `figs/forced_free_slip_convergence.png`. ## Two-dimensional forced flow with fixed-slip boundary conditions. ```; julia --project run_forced_fixed_slip.jl; ```. followed by. ```; julia --project analyze_forced_fixed_slip.jl; ```. produces `figs/forced_fixed_slip_convergence.png`.; ",MatchSource.DOCS,validation/convergence_tests/README.md,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/validation/convergence_tests/README.md
