id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:1124,Usability,user-friendly,user-friendly,1124,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1330,Availability,error,erroring,1330,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637
https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1567,Availability,ERROR,ERROR,1567,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637
https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1668,Availability,error,error,1668,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637
https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1695,Availability,error,error,1695,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637
https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1629,Safety,Abort,Aborting,1629,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637
https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986785546:26,Testability,test,test,26,"Great! Now we just need a test in CI to make sure it doesn't break in the future, and we can merge this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986785546
https://github.com/CliMA/Oceananigans.jl/pull/2088#issuecomment-991887660:306,Usability,clear,clearer,306,"> We could also use `AndSchedule` (rather than `AllSchedule`) and `OrSchedule` (rather than `AnySchedule`). ""and"" / ""or"" refer to the underlying conditionals that are used in the reductions `all` / `any`. Is this easier to understand (I'm not sure)?. I think the `AndSchedule` and `OrSchedule` notation is clearer (or at least more explicit), so I'm leaning toward that one. But I don't feel strongly anyway so feel free to merge this whenever you're happy!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088#issuecomment-991887660
https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984231034:284,Testability,test,tests,284,"@simone-silvestri, most `test_something.jl` files were re-including `include(""utils_for_runtests.jl"")`. Did you made this? Is there a reason for this?. The problem is that `utils_for_runtests.jl` defines some constants and Julia v1.7 does not allow re-definition of constants. So the tests were failing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984231034
https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:110,Availability,ERROR,ERROR,110,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840
https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:428,Energy Efficiency,reduce,reduce,428,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840
https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:471,Energy Efficiency,reduce,reducedim,471,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840
https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:512,Energy Efficiency,reduce,reducedim,512,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840
https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:117,Testability,Assert,AssertionError,117,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840
https://github.com/CliMA/Oceananigans.jl/issues/2091#issuecomment-984776242:16,Testability,test,test,16,Yes --- and the test should be generalized to have east-west boundary conditions as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2091#issuecomment-984776242
https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014:150,Deployability,configurat,configurations,150,> Is there any other model that may be impacted from this?. As mentioned in a DM I don't think `HydrostaticFreeSurfaceModel` supports vertically-flat configurations; even with one grid point in the vertical we may need vertically `Bounded`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014
https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014:150,Modifiability,config,configurations,150,> Is there any other model that may be impacted from this?. As mentioned in a DM I don't think `HydrostaticFreeSurfaceModel` supports vertically-flat configurations; even with one grid point in the vertical we may need vertically `Bounded`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014
https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177:428,Integrability,wrap,wrapped,428,"I think `base_grid` is a good name. ""underlying"" is also a little long and ""base"" helps with that. . Note we also should change the name of this abstract type if we use a different name than `underlying`:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/Grids.jl#L86-L92. Another possibility that comes to mind now is `parent_grid`, which is used throughout Julia to indicate a ""wrapped"" object:. ```julia; help?> parent; search: parent parentmodule parentindices. parent(A). Return the underlying ""parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> A = [1 2; 3 4]; 2×2 Matrix{Int64}:; 1 2; 3 4. julia> V = view(A, 1:2, :); 2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:; 1 2; 3 4. julia> parent(V); 2×2 Matrix{Int64}:; 1 2; 3 4; ```. (And there's also `parentmodule`, etc.) Perhaps that docstring is partly inspiration for referring to things as ""underlying"" (elsewhere we also have descriptions of ""underlying data"" for fields. But I like either `parent` or `base` better than `underlying`, with maybe a preference for `parent` now that I see its fairly widespread. As a side note (issue creep...) we also don't need `AbstractRectilinearGrid`, since there's only one:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/rectilinear_grid.jl#L8. eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177
https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177:766,Integrability,wrap,wrapped,766,"I think `base_grid` is a good name. ""underlying"" is also a little long and ""base"" helps with that. . Note we also should change the name of this abstract type if we use a different name than `underlying`:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/Grids.jl#L86-L92. Another possibility that comes to mind now is `parent_grid`, which is used throughout Julia to indicate a ""wrapped"" object:. ```julia; help?> parent; search: parent parentmodule parentindices. parent(A). Return the underlying ""parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> A = [1 2; 3 4]; 2×2 Matrix{Int64}:; 1 2; 3 4. julia> V = view(A, 1:2, :); 2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:; 1 2; 3 4. julia> parent(V); 2×2 Matrix{Int64}:; 1 2; 3 4; ```. (And there's also `parentmodule`, etc.) Perhaps that docstring is partly inspiration for referring to things as ""underlying"" (elsewhere we also have descriptions of ""underlying data"" for fields. But I like either `parent` or `base` better than `underlying`, with maybe a preference for `parent` now that I see its fairly widespread. As a side note (issue creep...) we also don't need `AbstractRectilinearGrid`, since there's only one:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/rectilinear_grid.jl#L8. eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:102,Deployability,Update,Update,102,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:134,Energy Efficiency,adapt,adapting,134,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:134,Modifiability,adapt,adapting,134,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:31,Testability,test,tests,31,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015083888:0,Deployability,Update,Update,0,"Update: we have to regenerate the Hydrostatic regression data because of a bug where; `@inline znode(::Center, k, grid::LatitudeLongitudeGrid) = @inbounds grid.zᵃᵃᶠ[k]` instead of; `@inline znode(::Center, k, grid::LatitudeLongitudeGrid) = @inbounds grid.zᵃᵃᶜ[k]` (and viceversa for faces). for the rest, it should be ready to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015083888
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597:124,Modifiability,layers,layers,124,"Run with implicit vertical diffusion and implicit free-surface, 20 minutes time step, 2.8 degree resolution and 18 vertical layers (constant spacing), ""realistic"" bathymetry, 30 years in about 2 hrs. https://user-images.githubusercontent.com/33547697/149965680-be56233d-3a08-4d2b-8115-cdb14edfd1af.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1016051554:5,Deployability,patch,patch,5,bump patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1016051554
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1016051554:11,Deployability,release,release,11,bump patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1016051554
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1016064200:38,Testability,test,test,38,Maybe! I actually still have a couple test to fix before it's ready 😅,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1016064200
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1017919056:5,Deployability,patch,patch,5,bump patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1017919056
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1017919056:11,Deployability,release,release,11,bump patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1017919056
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248:118,Availability,mask,mask,118,"To summarize the updates, we can make use of the type `ConditionalOperation` to perform conditional reductions with a mask. If a mask is not specified, the specific neutral value for that particular reduction will be used. Example:. ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. This type is used to automatically exclude the immersed region in reductions of `AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248:129,Availability,mask,mask,129,"To summarize the updates, we can make use of the type `ConditionalOperation` to perform conditional reductions with a mask. If a mask is not specified, the specific neutral value for that particular reduction will be used. Example:. ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. This type is used to automatically exclude the immersed region in reductions of `AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248:1219,Availability,mask,mask,1219,"To summarize the updates, we can make use of the type `ConditionalOperation` to perform conditional reductions with a mask. If a mask is not specified, the specific neutral value for that particular reduction will be used. Example:. ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. This type is used to automatically exclude the immersed region in reductions of `AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248:17,Deployability,update,updates,17,"To summarize the updates, we can make use of the type `ConditionalOperation` to perform conditional reductions with a mask. If a mask is not specified, the specific neutral value for that particular reduction will be used. Example:. ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. This type is used to automatically exclude the immersed region in reductions of `AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248
https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248:80,Performance,perform,perform,80,"To summarize the updates, we can make use of the type `ConditionalOperation` to perform conditional reductions with a mask. If a mask is not specified, the specific neutral value for that particular reduction will be used. Example:. ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. This type is used to automatically exclude the immersed region in reductions of `AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248
https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458:469,Integrability,wrap,wrapper,469,"@francispoulin is this a better solution?. ```julia; julia> scheme1 = UpwindBiasedThirdOrder(); UpwindBiasedThirdOrder(). julia> scheme2 = WENO5(); ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Research/Oceananigans.jl/src/Advection/weno_fifth_order.jl:145; WENO5 advection scheme with:; ├── X regular; ├── Y regular; └── Z regular. julia> string(typeof(scheme1).name.wrapper); ""UpwindBiasedThirdOrder"". julia> string(typeof(scheme2).name.wrapper); ""WENO5""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458
https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458:540,Integrability,wrap,wrapper,540,"@francispoulin is this a better solution?. ```julia; julia> scheme1 = UpwindBiasedThirdOrder(); UpwindBiasedThirdOrder(). julia> scheme2 = WENO5(); ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Research/Oceananigans.jl/src/Advection/weno_fifth_order.jl:145; WENO5 advection scheme with:; ├── X regular; ├── Y regular; └── Z regular. julia> string(typeof(scheme1).name.wrapper); ""UpwindBiasedThirdOrder"". julia> string(typeof(scheme2).name.wrapper); ""WENO5""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:449,Integrability,depend,dependent,449,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:1936,Integrability,wrap,wrapper,1936,"d to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter information from a type's string?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:161,Safety,predict,predict,161,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:787,Safety,avoid,avoid,787,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:233,Testability,log,log-file,233,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987:36,Integrability,wrap,wrapper,36,Doesn't `string(typeof(scheme).name.wrapper)` return something similar for all advection schemes? Or am I misunderstanding what you're saying?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:310,Availability,avail,available,310,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:449,Availability,avail,available,449,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:203,Integrability,interface,interface,203,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:585,Integrability,wrap,wrapper,585,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:169,Modifiability,extend,extending,169,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:152,Testability,log,log,152,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986801723:118,Usability,learn,learning,118,"Thanks for the explanation @glwagner . No problem that you didn't understand this perfectly in the past as I am still learning the difference between `print`, `show`, and `summary`. It seems that all the advection schemes have the same structure, except `WENO5` but this is not a problem and therefore I am happy to close #2098 . This issue perhaps better addressed in a future PR, that focuses on the structure we would want in general. Agreed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986801723
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289:203,Integrability,wrap,wrapper,203,"Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999:205,Integrability,wrap,wrapper,205,"> Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`. `nameof` is a cool idea. Is there a similar julia function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606:404,Integrability,wrap,wrapped,404,"I checked the help and indeed there is!. ```; help?> nameof; search: nameof. nameof(m::Module) -> Symbol. Get the name of a Module as a Symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> nameof(Base.Broadcast); :Broadcast. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(t::DataType) -> Symbol. Get the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> module Foo; struct S{T}; end; end; Foo; ; julia> nameof(Foo.S{T} where T); :S. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(f::Function) -> Symbol. Get the name of a generic Function as a symbol. For anonymous functions, this is a compiler-generated name. For; explicitly-declared subtypes of Function, it is the name of the function's type. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488:125,Testability,Test,Test,125,"Ok so I don't think we need `nameof` the way to write this is `string(nameof(typeof(scheme)))`, eg:. ```julia; julia> struct Test{T}; a :: T; end. julia> t = Test(1.1); Test{Float64}(1.1). julia> nameof(typeof(t)); :Test. julia> string(nameof(typeof(t))); ""Test""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488:158,Testability,Test,Test,158,"Ok so I don't think we need `nameof` the way to write this is `string(nameof(typeof(scheme)))`, eg:. ```julia; julia> struct Test{T}; a :: T; end. julia> t = Test(1.1); Test{Float64}(1.1). julia> nameof(typeof(t)); :Test. julia> string(nameof(typeof(t))); ""Test""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488:169,Testability,Test,Test,169,"Ok so I don't think we need `nameof` the way to write this is `string(nameof(typeof(scheme)))`, eg:. ```julia; julia> struct Test{T}; a :: T; end. julia> t = Test(1.1); Test{Float64}(1.1). julia> nameof(typeof(t)); :Test. julia> string(nameof(typeof(t))); ""Test""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488:216,Testability,Test,Test,216,"Ok so I don't think we need `nameof` the way to write this is `string(nameof(typeof(scheme)))`, eg:. ```julia; julia> struct Test{T}; a :: T; end. julia> t = Test(1.1); Test{Float64}(1.1). julia> nameof(typeof(t)); :Test. julia> string(nameof(typeof(t))); ""Test""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488:257,Testability,Test,Test,257,"Ok so I don't think we need `nameof` the way to write this is `string(nameof(typeof(scheme)))`, eg:. ```julia; julia> struct Test{T}; a :: T; end. julia> t = Test(1.1); Test{Float64}(1.1). julia> nameof(typeof(t)); :Test. julia> string(nameof(typeof(t))); ""Test""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986844488
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790:70,Integrability,interface,interface,70,It's also always preferred to use a function (which represents a user interface) rather than directly referencing a `struct` implementation (eg referencing `.name.wrapper`) that's subject to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790
https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790:163,Integrability,wrap,wrapper,163,It's also always preferred to use a function (which represents a user interface) rather than directly referencing a `struct` implementation (eg referencing `.name.wrapper`) that's subject to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987151360:177,Usability,usab,usability,177,"@whitleyv let us know if this feature allows you to compute the time-derivative of outputted quantities, and there's any changes or additional features that might help with its usability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987151360
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645:251,Energy Efficiency,schedul,schedule,251,"> Assuming this has been tested, I think this is a really nice solution, so I'm already approving it :); > ; > Is it worth giving the option to compute a backward time derivative? (Meaning outputting the step immediately before, not after, the parent schedule? Or maybe even a central one?) @whitleyv do you think that would be useful or that it wouldn't produce a meaningful difference for reasonable values of Δt?. I think it's pretty worthwhile! The problem is that, except for `IterationInterval`, we usually can't _guarantee_ that a schedule will always actuate on the _next iteration_ (since the time-step can be modified by a callback, or by an alignment requirement associated with another schedule present in the simulation). Users can implement a custom ""just before iteration interval"" schedule to achieve a backward difference (with respect to other quantities that are output on `IterationInterval` by writing. ```julia; primary_schedule = IterationInterval(10); just_before_iteration_interval(model) = model.clock.iteration + 1 % primary_schedule.interval == 0; schedule = ConsecutiveIterations(just_before_iteration_interval); ```. Thinking about it a bit, I think that we do want to calculate a forward difference for most purposes. The reason is that a time-stepping scheme is largely _explicit_, in the sense that it looks like. ```; uⁿ⁺¹ = uⁿ + Gⁿ dt; ```. Thus, the quantities of interest are `Gⁿ`, `uⁿ`, and `uⁿ⁺¹`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645:538,Energy Efficiency,schedul,schedule,538,"> Assuming this has been tested, I think this is a really nice solution, so I'm already approving it :); > ; > Is it worth giving the option to compute a backward time derivative? (Meaning outputting the step immediately before, not after, the parent schedule? Or maybe even a central one?) @whitleyv do you think that would be useful or that it wouldn't produce a meaningful difference for reasonable values of Δt?. I think it's pretty worthwhile! The problem is that, except for `IterationInterval`, we usually can't _guarantee_ that a schedule will always actuate on the _next iteration_ (since the time-step can be modified by a callback, or by an alignment requirement associated with another schedule present in the simulation). Users can implement a custom ""just before iteration interval"" schedule to achieve a backward difference (with respect to other quantities that are output on `IterationInterval` by writing. ```julia; primary_schedule = IterationInterval(10); just_before_iteration_interval(model) = model.clock.iteration + 1 % primary_schedule.interval == 0; schedule = ConsecutiveIterations(just_before_iteration_interval); ```. Thinking about it a bit, I think that we do want to calculate a forward difference for most purposes. The reason is that a time-stepping scheme is largely _explicit_, in the sense that it looks like. ```; uⁿ⁺¹ = uⁿ + Gⁿ dt; ```. Thus, the quantities of interest are `Gⁿ`, `uⁿ`, and `uⁿ⁺¹`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645:698,Energy Efficiency,schedul,schedule,698,"> Assuming this has been tested, I think this is a really nice solution, so I'm already approving it :); > ; > Is it worth giving the option to compute a backward time derivative? (Meaning outputting the step immediately before, not after, the parent schedule? Or maybe even a central one?) @whitleyv do you think that would be useful or that it wouldn't produce a meaningful difference for reasonable values of Δt?. I think it's pretty worthwhile! The problem is that, except for `IterationInterval`, we usually can't _guarantee_ that a schedule will always actuate on the _next iteration_ (since the time-step can be modified by a callback, or by an alignment requirement associated with another schedule present in the simulation). Users can implement a custom ""just before iteration interval"" schedule to achieve a backward difference (with respect to other quantities that are output on `IterationInterval` by writing. ```julia; primary_schedule = IterationInterval(10); just_before_iteration_interval(model) = model.clock.iteration + 1 % primary_schedule.interval == 0; schedule = ConsecutiveIterations(just_before_iteration_interval); ```. Thinking about it a bit, I think that we do want to calculate a forward difference for most purposes. The reason is that a time-stepping scheme is largely _explicit_, in the sense that it looks like. ```; uⁿ⁺¹ = uⁿ + Gⁿ dt; ```. Thus, the quantities of interest are `Gⁿ`, `uⁿ`, and `uⁿ⁺¹`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645:797,Energy Efficiency,schedul,schedule,797,"> Assuming this has been tested, I think this is a really nice solution, so I'm already approving it :); > ; > Is it worth giving the option to compute a backward time derivative? (Meaning outputting the step immediately before, not after, the parent schedule? Or maybe even a central one?) @whitleyv do you think that would be useful or that it wouldn't produce a meaningful difference for reasonable values of Δt?. I think it's pretty worthwhile! The problem is that, except for `IterationInterval`, we usually can't _guarantee_ that a schedule will always actuate on the _next iteration_ (since the time-step can be modified by a callback, or by an alignment requirement associated with another schedule present in the simulation). Users can implement a custom ""just before iteration interval"" schedule to achieve a backward difference (with respect to other quantities that are output on `IterationInterval` by writing. ```julia; primary_schedule = IterationInterval(10); just_before_iteration_interval(model) = model.clock.iteration + 1 % primary_schedule.interval == 0; schedule = ConsecutiveIterations(just_before_iteration_interval); ```. Thinking about it a bit, I think that we do want to calculate a forward difference for most purposes. The reason is that a time-stepping scheme is largely _explicit_, in the sense that it looks like. ```; uⁿ⁺¹ = uⁿ + Gⁿ dt; ```. Thus, the quantities of interest are `Gⁿ`, `uⁿ`, and `uⁿ⁺¹`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645:1076,Energy Efficiency,schedul,schedule,1076,"> Assuming this has been tested, I think this is a really nice solution, so I'm already approving it :); > ; > Is it worth giving the option to compute a backward time derivative? (Meaning outputting the step immediately before, not after, the parent schedule? Or maybe even a central one?) @whitleyv do you think that would be useful or that it wouldn't produce a meaningful difference for reasonable values of Δt?. I think it's pretty worthwhile! The problem is that, except for `IterationInterval`, we usually can't _guarantee_ that a schedule will always actuate on the _next iteration_ (since the time-step can be modified by a callback, or by an alignment requirement associated with another schedule present in the simulation). Users can implement a custom ""just before iteration interval"" schedule to achieve a backward difference (with respect to other quantities that are output on `IterationInterval` by writing. ```julia; primary_schedule = IterationInterval(10); just_before_iteration_interval(model) = model.clock.iteration + 1 % primary_schedule.interval == 0; schedule = ConsecutiveIterations(just_before_iteration_interval); ```. Thinking about it a bit, I think that we do want to calculate a forward difference for most purposes. The reason is that a time-stepping scheme is largely _explicit_, in the sense that it looks like. ```; uⁿ⁺¹ = uⁿ + Gⁿ dt; ```. Thus, the quantities of interest are `Gⁿ`, `uⁿ`, and `uⁿ⁺¹`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645:25,Testability,test,tested,25,"> Assuming this has been tested, I think this is a really nice solution, so I'm already approving it :); > ; > Is it worth giving the option to compute a backward time derivative? (Meaning outputting the step immediately before, not after, the parent schedule? Or maybe even a central one?) @whitleyv do you think that would be useful or that it wouldn't produce a meaningful difference for reasonable values of Δt?. I think it's pretty worthwhile! The problem is that, except for `IterationInterval`, we usually can't _guarantee_ that a schedule will always actuate on the _next iteration_ (since the time-step can be modified by a callback, or by an alignment requirement associated with another schedule present in the simulation). Users can implement a custom ""just before iteration interval"" schedule to achieve a backward difference (with respect to other quantities that are output on `IterationInterval` by writing. ```julia; primary_schedule = IterationInterval(10); just_before_iteration_interval(model) = model.clock.iteration + 1 % primary_schedule.interval == 0; schedule = ConsecutiveIterations(just_before_iteration_interval); ```. Thinking about it a bit, I think that we do want to calculate a forward difference for most purposes. The reason is that a time-stepping scheme is largely _explicit_, in the sense that it looks like. ```; uⁿ⁺¹ = uⁿ + Gⁿ dt; ```. Thus, the quantities of interest are `Gⁿ`, `uⁿ`, and `uⁿ⁺¹`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987948645
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987949673:25,Testability,test,tested,25,> Assuming this has been tested. It hasn't; that's one of the todo's that must be completed before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987949673
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-989534667:13,Testability,test,test,13,We can add a test. E.g. in the 1D diffusion equation using Euler we can use the `ConsecutiveIterations(TimeInterval(..))` to reproduce the RHS of the equation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-989534667
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-989993922:15,Energy Efficiency,schedul,schedule,15,"> So with this schedule one can reconstruct forward or backwards first-order time-derivative approximations. Can we reconstruct a centered first-order time-derivative? Seems like this can be easily generalized to save the `N` consecutive iterations following the actuation of the `parent_schedule` (instead of just 1). But we can leave this for a future PR. :). That's a good idea. We can also generalize `IterationInterval` with an ""offset"" that could be used to center the output on a particular iteration, if using `IterationInterval`. I believe a centered approximation would be second-order though (in ~2dt), not first order... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-989993922
https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-1013759888:76,Testability,test,test,76,"@glwagner, can you resolve conflicts? perhaps we merge and add an issue for test to be implemented in the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-1013759888
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053:110,Testability,test,test,110,"@glwagner, what about; https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L200. Should we simplify to `topo = (Bounded, Bounded, Bounded)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053:171,Usability,simpl,simplify,171,"@glwagner, what about; https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L200. Should we simplify to `topo = (Bounded, Bounded, Bounded)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988346234:116,Testability,test,test,116,Yes and if statements here:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L203. and here. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L210. should be removed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988346234
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988346234:264,Testability,test,test,264,Yes and if statements here:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L203. and here. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L210. should be removed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988346234
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987:237,Availability,error,errors,237,"@glwagner, after 9c10cb5 tests break. See https://buildkite.com/clima/oceananigans/builds/4750#6ef5a18e-4db4-4881-aabe-e39eafaf2196/40-312. I thought that the mistake was because I had prescribed `Value` bc's for u at East/West. But the errors persists after I [changed](https://github.com/CliMA/Oceananigans.jl/pull/2103/commits/842861f152fa4193a8fb75d58324e209d5f124e5) that to Open. Could you have a look at:; https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L213-L226",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987:25,Testability,test,tests,25,"@glwagner, after 9c10cb5 tests break. See https://buildkite.com/clima/oceananigans/builds/4750#6ef5a18e-4db4-4881-aabe-e39eafaf2196/40-312. I thought that the mistake was because I had prescribed `Value` bc's for u at East/West. But the errors persists after I [changed](https://github.com/CliMA/Oceananigans.jl/pull/2103/commits/842861f152fa4193a8fb75d58324e209d5f124e5) that to Open. Could you have a look at:; https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L213-L226",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987:500,Testability,test,test,500,"@glwagner, after 9c10cb5 tests break. See https://buildkite.com/clima/oceananigans/builds/4750#6ef5a18e-4db4-4881-aabe-e39eafaf2196/40-312. I thought that the mistake was because I had prescribed `Value` bc's for u at East/West. But the errors persists after I [changed](https://github.com/CliMA/Oceananigans.jl/pull/2103/commits/842861f152fa4193a8fb75d58324e209d5f124e5) that to Open. Could you have a look at:; https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L213-L226",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:4,Availability,error,error,4,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:544,Deployability,Continuous,ContinuousBoundaryFunction,544,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:672,Deployability,Continuous,ContinuousBoundaryFunction,672,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:801,Deployability,Continuous,ContinuousBoundaryFunction,801,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:928,Deployability,Continuous,ContinuousBoundaryFunction,928,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:1055,Deployability,Continuous,ContinuousBoundaryFunction,1055,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065:1182,Deployability,Continuous,ContinuousBoundaryFunction,1182,"The error is. ```julia; MethodError: no method matching XFaceField(::Type{Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, DataType}, ::FieldBoundaryConditions{BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Open, ContinuousBoundaryFunction{Nothing, Center, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Nothing, Center, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Value, ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#7#8"", Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}); --;   | Closest candidates are:;   | XFaceField(::AbstractArchitecture, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:89;   | XFaceField(::AbstractGrid, ::Any...) at /var/lib/buildkite-agent/builds/tartarus-8/clima/oceananigans/src/Fields/field.jl:109;   | Stacktrace:;   | [1] VelocityFields(arch::Type, grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetVector{Float64,; <snip>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989356065
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989369767:4,Availability,error,error,4,"The error originates from this line:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/src/Fields/field_tuples.jl#L26. So the first arg `arch` is `Float64` here. I believe the problem is this line:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L139. where only one positional argument is provided (and that's `Float64`). If only one positional argument is provided, then that's `architecture`:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/src/Grids/rectilinear_grid.jl#L256-L257. This propagates down to `XFaceField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989369767
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989369767:664,Availability,down,down,664,"The error originates from this line:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/src/Fields/field_tuples.jl#L26. So the first arg `arch` is `Float64` here. I believe the problem is this line:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L139. where only one positional argument is provided (and that's `Float64`). If only one positional argument is provided, then that's `architecture`:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/src/Grids/rectilinear_grid.jl#L256-L257. This propagates down to `XFaceField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989369767
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989369767:324,Testability,test,test,324,"The error originates from this line:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/src/Fields/field_tuples.jl#L26. So the first arg `arch` is `Float64` here. I believe the problem is this line:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L139. where only one positional argument is provided (and that's `Float64`). If only one positional argument is provided, then that's `architecture`:. https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/src/Grids/rectilinear_grid.jl#L256-L257. This propagates down to `XFaceField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989369767
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451:24,Availability,error,error,24,This PR helps avoid the error; not sure if you want it or not. https://github.com/CliMA/Oceananigans.jl/pull/2110,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451
https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451:14,Safety,avoid,avoid,14,This PR helps avoid the error; not sure if you want it or not. https://github.com/CliMA/Oceananigans.jl/pull/2110,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451
https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166:135,Testability,benchmark,benchmarks,135,"> hey had a few comments, but nothing too serious; > ; > It's hard for me to check thoroughly the whole code. But I'm pleased with the benchmarks and tests -- they look very convincing. I'm approving but perhaps let's hear @glwagner?; > ; > (I'm going offline today in a bit for 2 weeks..). @navidcy thanks for the review, I ll check everything and improve the comments to make it clearer. Have nice vacations!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166
https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166:150,Testability,test,tests,150,"> hey had a few comments, but nothing too serious; > ; > It's hard for me to check thoroughly the whole code. But I'm pleased with the benchmarks and tests -- they look very convincing. I'm approving but perhaps let's hear @glwagner?; > ; > (I'm going offline today in a bit for 2 weeks..). @navidcy thanks for the review, I ll check everything and improve the comments to make it clearer. Have nice vacations!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166
https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166:381,Usability,clear,clearer,381,"> hey had a few comments, but nothing too serious; > ; > It's hard for me to check thoroughly the whole code. But I'm pleased with the benchmarks and tests -- they look very convincing. I'm approving but perhaps let's hear @glwagner?; > ; > (I'm going offline today in a bit for 2 weeks..). @navidcy thanks for the review, I ll check everything and improve the comments to make it clearer. Have nice vacations!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166
https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996383652:0,Deployability,Update,Update,0,"Update: changed the API such that it is possible to specify the preconditioner and the settings:. `preconditioner_method = :None` is no preconditioner, other methods are `:Jacobi`, `:ILUFactorization`, `:SparseInverse`, and `:SimplifiedInverse`. If nothing is specified the solver defaults to `:ILUFactorization` on `CPU` (with `τ = 0.001`) and `:SparseInverse` on `GPU` (with `ε = 0.1` and `nzrel = 1.0`). It is possible to manually specify settings but they must match the `preconditioner_method` chosen (if not defaults parameters are used). . this allowed to remove the architecture from the struct",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996383652
https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996383652:226,Usability,Simpl,SimplifiedInverse,226,"Update: changed the API such that it is possible to specify the preconditioner and the settings:. `preconditioner_method = :None` is no preconditioner, other methods are `:Jacobi`, `:ILUFactorization`, `:SparseInverse`, and `:SimplifiedInverse`. If nothing is specified the solver defaults to `:ILUFactorization` on `CPU` (with `τ = 0.001`) and `:SparseInverse` on `GPU` (with `ε = 0.1` and `nzrel = 1.0`). It is possible to manually specify settings but they must match the `preconditioner_method` chosen (if not defaults parameters are used). . this allowed to remove the architecture from the struct",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996383652
https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-997059293:2,Deployability,Update,Update,2,> Update: changed the API such that it is possible to specify the preconditioner and the settings:; > ; > `preconditioner_method = :None` is no preconditioner. Why not `preconditioner_method = nothing`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-997059293
https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646:97,Availability,error,error,97,"> Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size.; > ; > How about we check the halo size we give an error?. Just to clarify, if the halos aren't set properly then results aren't ""less accurate"" --- instead, they are wrong, even if they are finite. A segfault and program failure is another possibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646
https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646:204,Availability,error,error,204,"> Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size.; > ; > How about we check the halo size we give an error?. Just to clarify, if the halos aren't set properly then results aren't ""less accurate"" --- instead, they are wrong, even if they are finite. A segfault and program failure is another possibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646
https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646:375,Availability,failure,failure,375,"> Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size.; > ; > How about we check the halo size we give an error?. Just to clarify, if the halos aren't set properly then results aren't ""less accurate"" --- instead, they are wrong, even if they are finite. A segfault and program failure is another possibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646
https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-989086708:56,Availability,fault,fault,56,"And when I ran the same code, i received a segmentation fault and Julia failed!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-989086708
https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-988920403:48,Availability,error,error,48,I am for removing the inflation and throwing an error. Might be annoying to always have to specify the halo in the grid (and the refractoring that will come with it) but it can save a lot of debugging for the users,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-988920403
https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865:29,Availability,error,error,29,I am also happy to throw and error and ask the use to specify a halo or at least the right size. It also occurs to me that a user can specify a halo to be bigger than is required. I don't see any advantage of this and believe it would only slow things down. This is not worthy of an error but do we want to notify the user if they pick a halo of length 5 and they only need 1?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865
https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865:252,Availability,down,down,252,I am also happy to throw and error and ask the use to specify a halo or at least the right size. It also occurs to me that a user can specify a halo to be bigger than is required. I don't see any advantage of this and believe it would only slow things down. This is not worthy of an error but do we want to notify the user if they pick a halo of length 5 and they only need 1?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865
https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865:283,Availability,error,error,283,I am also happy to throw and error and ask the use to specify a halo or at least the right size. It also occurs to me that a user can specify a halo to be bigger than is required. I don't see any advantage of this and believe it would only slow things down. This is not worthy of an error but do we want to notify the user if they pick a halo of length 5 and they only need 1?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195:28,Availability,error,errors,28,"Hmm, I looked at one of the errors and saw the following:. ```. Immersed boundaries with hydrostatic free surface models: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl:4;   | Got exception outside of a @test;   | The grid halo (1, 1, 1) must be larger than either (1, 1, 1) or (3, 3, 3);  ; ```. Can't say I know what's going wrong though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195:122,Availability,Error,Error,122,"Hmm, I looked at one of the errors and saw the following:. ```. Immersed boundaries with hydrostatic free surface models: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl:4;   | Got exception outside of a @test;   | The grid halo (1, 1, 1) must be larger than either (1, 1, 1) or (3, 3, 3);  ; ```. Can't say I know what's going wrong though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195:135,Testability,Test,Test,135,"Hmm, I looked at one of the errors and saw the following:. ```. Immersed boundaries with hydrostatic free surface models: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl:4;   | Got exception outside of a @test;   | The grid halo (1, 1, 1) must be larger than either (1, 1, 1) or (3, 3, 3);  ; ```. Can't say I know what's going wrong though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195:235,Testability,test,test,235,"Hmm, I looked at one of the errors and saw the following:. ```. Immersed boundaries with hydrostatic free surface models: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl:4;   | Got exception outside of a @test;   | The grid halo (1, 1, 1) must be larger than either (1, 1, 1) or (3, 3, 3);  ; ```. Can't say I know what's going wrong though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195:347,Testability,test,test,347,"Hmm, I looked at one of the errors and saw the following:. ```. Immersed boundaries with hydrostatic free surface models: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl:4;   | Got exception outside of a @test;   | The grid halo (1, 1, 1) must be larger than either (1, 1, 1) or (3, 3, 3);  ; ```. Can't say I know what's going wrong though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-992830867:25,Testability,test,test,25,@navidcy I changed it to test only 3D topologies because the grid constructors are different for different dimensionalities; the current test only works for 3D I think.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-992830867
https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-992830867:137,Testability,test,test,137,@navidcy I changed it to test only 3D topologies because the grid constructors are different for different dimensionalities; the current test only works for 3D I think.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-992830867
https://github.com/CliMA/Oceananigans.jl/pull/2121#issuecomment-995012766:210,Energy Efficiency,reduce,reduced,210,"> No, sorry, my silly mistake. `Nothing` makes a lot of sense. Please ignore my previous comment. It still might make sense to come up with a better location than `Nothing`... (I guess the meaning is that in a reduced or `Flat` direction, a field has ""no location"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121#issuecomment-995012766
https://github.com/CliMA/Oceananigans.jl/pull/2121#issuecomment-1012207736:443,Deployability,update,updated,443,"> Very nice!; > ; > Could we add to the `show` function a `max` and `min` value of the field (if concrete)?. I agree strongly that we should show some information about field _value_ (not just type info like we show now). Showing some statistics might be a nice step (for small fields, we could also just show the whole array?). However, do you mind if we address this in a future PR? I think it can be resolved along with #2064 (which I just updated to encompass fields)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121#issuecomment-1012207736
https://github.com/CliMA/Oceananigans.jl/issues/2126#issuecomment-1479902034:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2126#issuecomment-1479902034
https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:196,Integrability,depend,depends,196,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933
https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:90,Modifiability,Parameteriz,ParameterizedCallback,90,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933
https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:143,Modifiability,Parameteriz,ParameterizedCallback,143,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933
https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:244,Modifiability,Parameteriz,ParameterizedCallback,244,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933
https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481:74,Modifiability,variab,variable,74,A default argument works great too! You can also capture data as a global variable:. ```julia; julia> a = 3; 3. julia> f(x) = x * a; f (generic function with 4 methods). julia> f(2); 6; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:136,Availability,error,errors,136,"Thanks @aramirezreyes for creating this, and I think this is a great idea to make things more uniformity. Unfortunately, there are some errors. When I looked at the first one it seemed to have an errror due to another model?. ```; Immersed boundaries test divergent flow solve with hydrostatic free surface models: Error During Test at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:8;   | Got exception outside of a @test;   | ArgumentError: The grid halo (1, 1, 1) must be larger than (3, 3, 3).;   | Stacktrace:;   | [1] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:315,Availability,Error,Error,315,"Thanks @aramirezreyes for creating this, and I think this is a great idea to make things more uniformity. Unfortunately, there are some errors. When I looked at the first one it seemed to have an errror due to another model?. ```; Immersed boundaries test divergent flow solve with hydrostatic free surface models: Error During Test at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:8;   | Got exception outside of a @test;   | ArgumentError: The grid halo (1, 1, 1) must be larger than (3, 3, 3).;   | Stacktrace:;   | [1] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:251,Testability,test,test,251,"Thanks @aramirezreyes for creating this, and I think this is a great idea to make things more uniformity. Unfortunately, there are some errors. When I looked at the first one it seemed to have an errror due to another model?. ```; Immersed boundaries test divergent flow solve with hydrostatic free surface models: Error During Test at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:8;   | Got exception outside of a @test;   | ArgumentError: The grid halo (1, 1, 1) must be larger than (3, 3, 3).;   | Stacktrace:;   | [1] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:328,Testability,Test,Test,328,"Thanks @aramirezreyes for creating this, and I think this is a great idea to make things more uniformity. Unfortunately, there are some errors. When I looked at the first one it seemed to have an errror due to another model?. ```; Immersed boundaries test divergent flow solve with hydrostatic free surface models: Error During Test at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:8;   | Got exception outside of a @test;   | ArgumentError: The grid halo (1, 1, 1) must be larger than (3, 3, 3).;   | Stacktrace:;   | [1] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:398,Testability,test,test,398,"Thanks @aramirezreyes for creating this, and I think this is a great idea to make things more uniformity. Unfortunately, there are some errors. When I looked at the first one it seemed to have an errror due to another model?. ```; Immersed boundaries test divergent flow solve with hydrostatic free surface models: Error During Test at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:8;   | Got exception outside of a @test;   | ArgumentError: The grid halo (1, 1, 1) must be larger than (3, 3, 3).;   | Stacktrace:;   | [1] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:505,Testability,test,test,505,"Thanks @aramirezreyes for creating this, and I think this is a great idea to make things more uniformity. Unfortunately, there are some errors. When I looked at the first one it seemed to have an errror due to another model?. ```; Immersed boundaries test divergent flow solve with hydrostatic free surface models: Error During Test at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:8;   | Got exception outside of a @test;   | ArgumentError: The grid halo (1, 1, 1) must be larger than (3, 3, 3).;   | Stacktrace:;   | [1] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2019,Testability,test,test,2019,"oat64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2206,Testability,Test,Test,2206,"tion::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLO",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2215,Testability,Test,Test,2215,"tion::CenteredSecondOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLO",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2309,Testability,test,test,2309,"Nothing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2526,Testability,test,test,2526,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2658,Testability,Test,Test,2658,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2667,Testability,Test,Test,2667,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2761,Testability,test,test,2761,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2893,Testability,Test,Test,2893,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2902,Testability,Test,Test,2902,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185:2997,Testability,test,test,2997,"hing, Nothing, Nothing, Nothing}, buoyancy::Nothing, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Nothing, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}});   | @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/builds/tartarus-1/clima/oceananigans/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:113;   | [2] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:41 [inlined];   | [3] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl:9;   | [5] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [6] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:65 [inlined];   | [7] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [8] macro expansion;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:58 [inlined];   | [9] macro expansion;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined];   | [10] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/test/runtests.jl:4;   | [11] include(fname::String);   | @ Base.MainInclude ./client.jl:444;   | [12] top-level scope;   | @ none:6;   | [13] eval;   | @ ./boot.jl:360 [inlined];   | [14] exec_options(opts::Base.JLOptions);   | @ Base ./client.jl:261;   | [15] _start();   | @ Base ./client.jl:485;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001728185
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001745319:47,Availability,error,errors,47,I noticed that as well but it seems that those errors are present in the latest commit in master (I don't seem to have touched anything related):. https://buildkite.com/clima/oceananigans/builds/4868#67294627-d75d-4346-8392-c67b358b5c3c,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001745319
https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1002265918:23,Testability,test,tests,23,I don’t understand why tests fail. Most probably is not because of editing docstring. Will look at this after New Years.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1002265918
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1002437838:16,Testability,test,test,16,Same issue with test not passing. Not sure what happened. Unable to look into it before Jan 3rd.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1002437838
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1006035272:80,Testability,test,tests,80,"@aramirezreyes, could you bring this up to date with `main` branch? Perhaps all tests pass then and we can merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1006035272
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1006045446:82,Testability,test,tests,82,"> @aramirezreyes, could you bring this up to date with `main` branch? Perhaps all tests pass then and we can merge. turns out I could do that :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1006045446
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013509466:77,Testability,test,tests,77,I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013509466
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717:168,Availability,fault,fault,168,> I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?. Nope. It's not your fault. We are having issues with the CI.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717:79,Testability,test,tests,79,> I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?. Nope. It's not your fault. We are having issues with the CI.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013539188:304,Availability,fault,fault,304,"Ah! Good to know! Thanks.; Argel Ramírez Reyes. > On Jan 14, 2022, at 3:10 PM, Navid C. Constantinou ***@***.***> wrote:; > ; > ; > I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?; > ; > Nope. It's not your fault. We are having issues with the CI.; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ABVLG6KOMQMGZB2JFMSZFMTUWCUM7ANCNFSM5K45P62A>.; > Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. ; > You are receiving this because you were mentioned.; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013539188
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013539188:209,Testability,test,tests,209,"Ah! Good to know! Thanks.; Argel Ramírez Reyes. > On Jan 14, 2022, at 3:10 PM, Navid C. Constantinou ***@***.***> wrote:; > ; > ; > I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?; > ; > Nope. It's not your fault. We are having issues with the CI.; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ABVLG6KOMQMGZB2JFMSZFMTUWCUM7ANCNFSM5K45P62A>.; > Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. ; > You are receiving this because you were mentioned.; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013539188
https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013551552:4,Testability,test,tests,4,The tests are failing :-(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013551552
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167:1153,Security,validat,validate,1153,"ddle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. Here is some output with print added for 5 x 5 version (and with g=1000 ). The solvers don't iterate I think - because Ax == 0? . Also the island is not quite centered? . ```; (base) chriss-MacBook-Pro:onan-2021-12-29 chrishill$ /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; [2021/12/29 11:49:20.908] INFO Testing immersed boundaries divergent flow solve; bottom; 5×5 Matrix{Float64}:; -1.0 -1.0 -1.0 -1.0 -1.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; [2021/12/29 11:49:27.354] WARN ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues. -@-> /Users/chrishill/projects/onan-2021-12-29/src/ImmersedBoundaries/ImmersedBoundaries.jl:102; [2021/12/29 11:49:27.400] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /Users/chrishill/projects/onan-2021-12-29/src/Advection/weno_fifth_order.jl:145; model.free_surface.gravitational_acceleration = 10000.0; ∫ᶻQ.u; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; η; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 -1.0 4.0 -1.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; u before; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 4:4) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167:42,Testability,test,test,42,"> @glwagner (and @simone-silvestri ) this test is OK - but it looks a bit weird to me, so I am confused!; > ; > It looks to me that it; > ; > 1. creates a little square full depth island in the middle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. Here is some output with print added for 5 x 5 version (and with g=1000 ). The solvers don't iterate I think - because Ax == 0? . Also the island is not quite centered? . ```; (base) chriss-MacBook-Pro:onan-2021-12-29 chrishill$ /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; [2021/12/29 11:49:20.908] INFO Testing immersed boundaries divergent flow solve; bottom; 5×5 Matrix{Float64}:; -1.0 -1.0 -1.0 -1.0 -1.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; [2021/12/29 11:49:27.354] WARN ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues. -@-> /Users/chrishill/projects/onan-2021-12-29/src/ImmersedBoundaries/ImmersedBoundaries.jl:102; [2021/12/29 11:49:27.400] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /Users/chrishill/projects/onan-2021-12-29/src/Advection/weno_fifth_order.jl:145; model.free_surface.gravitational_acceleration = 10000.0; ∫ᶻQ.u; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; η; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 -1.0 4.0 -1.0 0.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167:802,Testability,test,test,802,"> @glwagner (and @simone-silvestri ) this test is OK - but it looks a bit weird to me, so I am confused!; > ; > It looks to me that it; > ; > 1. creates a little square full depth island in the middle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. Here is some output with print added for 5 x 5 version (and with g=1000 ). The solvers don't iterate I think - because Ax == 0? . Also the island is not quite centered? . ```; (base) chriss-MacBook-Pro:onan-2021-12-29 chrishill$ /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; [2021/12/29 11:49:20.908] INFO Testing immersed boundaries divergent flow solve; bottom; 5×5 Matrix{Float64}:; -1.0 -1.0 -1.0 -1.0 -1.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; [2021/12/29 11:49:27.354] WARN ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues. -@-> /Users/chrishill/projects/onan-2021-12-29/src/ImmersedBoundaries/ImmersedBoundaries.jl:102; [2021/12/29 11:49:27.400] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /Users/chrishill/projects/onan-2021-12-29/src/Advection/weno_fifth_order.jl:145; model.free_surface.gravitational_acceleration = 10000.0; ∫ᶻQ.u; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; η; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 -1.0 4.0 -1.0 0.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167:852,Testability,Test,Testing,852,"> @glwagner (and @simone-silvestri ) this test is OK - but it looks a bit weird to me, so I am confused!; > ; > It looks to me that it; > ; > 1. creates a little square full depth island in the middle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. Here is some output with print added for 5 x 5 version (and with g=1000 ). The solvers don't iterate I think - because Ax == 0? . Also the island is not quite centered? . ```; (base) chriss-MacBook-Pro:onan-2021-12-29 chrishill$ /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; [2021/12/29 11:49:20.908] INFO Testing immersed boundaries divergent flow solve; bottom; 5×5 Matrix{Float64}:; -1.0 -1.0 -1.0 -1.0 -1.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; [2021/12/29 11:49:27.354] WARN ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues. -@-> /Users/chrishill/projects/onan-2021-12-29/src/ImmersedBoundaries/ImmersedBoundaries.jl:102; [2021/12/29 11:49:27.400] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /Users/chrishill/projects/onan-2021-12-29/src/Advection/weno_fifth_order.jl:145; model.free_surface.gravitational_acceleration = 10000.0; ∫ᶻQ.u; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; η; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 -1.0 4.0 -1.0 0.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167:8780,Testability,Test,Test,8780,"onjugate_gradient_solver.jl:190; [2021/12/29 11:50:08.131] DEBUG PreconditionedConjugateGradientSolver 0, |z|: 0.00044721359549995795 -@-> /Users/chrishill/projects/onan-2021-12-29/src/Solvers/preconditioned_conjugate_gradient_solver.jl:191; [2021/12/29 11:50:08.132] DEBUG PreconditionedConjugateGradientSolver 0, |q|: 4.4721359549995796e-8 -@-> /Users/chrishill/projects/onan-2021-12-29/src/Solvers/preconditioned_conjugate_gradient_solver.jl:206; [2021/12/29 11:50:08.132] DEBUG PreconditionedConjugateGradientSolver 0, α: -10000.0 -@-> /Users/chrishill/projects/onan-2021-12-29/src/Solvers/preconditioned_conjugate_gradient_solver.jl:207; model.free_surface.gravitational_acceleration = 10000.0; ∫ᶻQ.u; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; η; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 -1.0 4.0 -1.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; u before; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 4:4) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; v before; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 4:4) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; u after; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 4:4) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 10000.0 0.0 0.0; 0.0 10000.0 -49999.0 10000.0 0.0; 0.0 -10000.0 49999.0 -10000.0 0.0; 0.0 0.0 -10000.0 0.0 0.0; v after; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 4:4) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 10000.0 0.0 0.0; 0.0 10000.0 -49999.0 10000.0 0.0; 0.0 -10000.0 49999.0 -10000.0 0.0; 0.0 0.0 -10000.0 0.0 0.0; Test Summary: | Pass Total; Oceananigans | 1 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002695037:42,Testability,test,test,42,"> @glwagner (and @simone-silvestri ) this test is OK - but it looks a bit weird to me, so I am confused!; > ; > It looks to me that it; > ; > 1. creates a little square full depth island in the middle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. I didn't write this test so I'm not sure what the intent is...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002695037
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002695037:518,Testability,test,test,518,"> @glwagner (and @simone-silvestri ) this test is OK - but it looks a bit weird to me, so I am confused!; > ; > It looks to me that it; > ; > 1. creates a little square full depth island in the middle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. I didn't write this test so I'm not sure what the intent is...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002695037
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491:5,Deployability,update,update,5,"This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue). I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491:50,Testability,test,test,50,"This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue). I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491:85,Testability,test,tests,85,"This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue). I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491:218,Testability,test,test,218,"This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue). I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002696491
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278:7,Deployability,update,update,7,"> This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > ; > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill. @glwagner that sounds OK. the include(""dependencies_for_runtests.jl"") breaks. ```; export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; ```. workflow because of. ```; const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; ```. in ; ```; utils_for_runtests.jl; ```. which can't be redeclared since its const? Is there a trick to fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278:52,Testability,test,test,52,"> This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > ; > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill. @glwagner that sounds OK. the include(""dependencies_for_runtests.jl"") breaks. ```; export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; ```. workflow because of. ```; const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; ```. in ; ```; utils_for_runtests.jl; ```. which can't be redeclared since its const? Is there a trick to fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278:87,Testability,test,tests,87,"> This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > ; > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill. @glwagner that sounds OK. the include(""dependencies_for_runtests.jl"") breaks. ```; export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; ```. workflow because of. ```; const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; ```. in ; ```; utils_for_runtests.jl; ```. which can't be redeclared since its const? Is there a trick to fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278:227,Testability,test,test,227,"> This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > ; > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill. @glwagner that sounds OK. the include(""dependencies_for_runtests.jl"") breaks. ```; export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; ```. workflow because of. ```; const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; ```. in ; ```; utils_for_runtests.jl; ```. which can't be redeclared since its const? Is there a trick to fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278:578,Testability,test,test,578,"> This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > ; > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill. @glwagner that sounds OK. the include(""dependencies_for_runtests.jl"") breaks. ```; export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; ```. workflow because of. ```; const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; ```. in ; ```; utils_for_runtests.jl; ```. which can't be redeclared since its const? Is there a trick to fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002698278
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:1023,Availability,ERROR,ERROR,1023,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:9,Deployability,update,update,9,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:54,Testability,test,test,54,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:89,Testability,test,tests,89,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:227,Testability,test,test,227,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:601,Testability,test,test,601,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:1418,Testability,test,test,1418,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:1470,Testability,test,test,1470,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:1267,Availability,ERROR,ERROR,1267,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:1823,Availability,error,error,1823,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:11,Deployability,update,update,11,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:56,Testability,test,test,56,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:91,Testability,test,tests,91,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:231,Testability,test,test,231,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:615,Testability,test,test,615,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:1683,Testability,test,test,1683,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:1735,Testability,test,test,1735,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1004424163:431,Availability,ERROR,ERROR,431,"Ah Julia 1.7!. Results look similar... ```julia; gregorywagner:~/ $ julia [16:23:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.7.0 (2021-11-30); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. but I'll take that into account...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1004424163
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1004424163:345,Deployability,release,release,345,"Ah Julia 1.7!. Results look similar... ```julia; gregorywagner:~/ $ julia [16:23:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.7.0 (2021-11-30); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. but I'll take that into account...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1004424163
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:353,Availability,error,error,353,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:415,Availability,error,error,415,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:27,Testability,test,test,27,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:195,Testability,test,test,195,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:223,Testability,test,test,223,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670
https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:274,Testability,test,test,274,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670
https://github.com/CliMA/Oceananigans.jl/pull/2132#issuecomment-1005437100:74,Testability,test,tests,74,"@ErikQQY, could you bring this up to date with `main` branch? Perhaps all tests pass then and we can merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2132#issuecomment-1005437100
https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:152,Modifiability,variab,variable,152,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652
https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:90,Safety,avoid,avoiding,90,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652
https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:216,Testability,test,test,216,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652
https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:249,Testability,test,test,249,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652
https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:446,Testability,test,test,446,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652
https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005285364:71,Safety,avoid,avoid,71,I think we should use `return nothing` at the end of every function to avoid confusion.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005285364
https://github.com/CliMA/Oceananigans.jl/issues/2136#issuecomment-1009071655:173,Testability,test,tests,173,"A pro of the ""tuple"" design is that it may be a bit easier to use. A con is that it's more implicit (perhaps making a script harder to read) and requires some source code / tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2136#issuecomment-1009071655
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009029060:51,Testability,test,tests,51,"It seems like there are some problems with the GPU tests, @navidcy and @glwagner do you have some idea on why tests are running for so long?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009029060
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009029060:110,Testability,test,tests,110,"It seems like there are some problems with the GPU tests, @navidcy and @glwagner do you have some idea on why tests are running for so long?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009029060
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:229,Performance,bottleneck,bottleneck,229,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:15,Testability,test,tests,15,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:73,Testability,test,tests,73,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:130,Testability,test,tests,130,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:204,Testability,test,tests,204,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:286,Testability,test,tested,286,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:322,Testability,test,test,322,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:567,Testability,test,tests,567,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943
https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009465165:97,Testability,test,tests,97,I took out the turbulence closures from the `time_stepping_2` in #2140. I also split the solvers tests in two parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009465165
https://github.com/CliMA/Oceananigans.jl/pull/2140#issuecomment-1006168639:39,Testability,test,tests,39,"Perhaps we should split the regression tests? A natural split can be done for each grid type, e.g., see:; https://github.com/CliMA/Oceananigans.jl/blob/59a8a81f8ff1a0835f9d549428d61d7295c6c5f6/test/test_regression.jl#L73",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2140#issuecomment-1006168639
https://github.com/CliMA/Oceananigans.jl/pull/2140#issuecomment-1006168639:193,Testability,test,test,193,"Perhaps we should split the regression tests? A natural split can be done for each grid type, e.g., see:; https://github.com/CliMA/Oceananigans.jl/blob/59a8a81f8ff1a0835f9d549428d61d7295c6c5f6/test/test_regression.jl#L73",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2140#issuecomment-1006168639
https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009060160:11,Usability,Simpl,Simplified,11,What does `Simplified` mean? Perhaps there's a better term?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009060160
https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009116395:13,Usability,Simpl,Simplified,13,I called it `Simplified` because it tries to mimic an inverse from heuristic rather than strict mathematical reasoning (but it still works very good!) so it doesn't quite look like a sparse inverse but it is applied in the same way. Maybe we can call it `ApproximateInversePreconditioner`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009116395
https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009127291:15,Usability,Simpl,Simplified,15,"> I called it `Simplified` because it tries to mimic an inverse from heuristic rather than strict mathematical reasoning (but it still works very good!) so it doesn't quite look like a sparse inverse but it is applied in the same way. Maybe we can call it `ApproximateInversePreconditioner`?. Nice! ""Approximate"" is better I think!. I was under the impression that good preconditioners are _usually_ ""approximate inverses"" --- perhaps that's not true?. I think the more specific the name, the better. Something to think about --- it looks like this stuff is in `Solvers`. If, someday, the `Solvers` module is moved outside Oceananigans, do all of these names still make sense? Or do these names only make sense in the context of a specific inverse problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009127291
https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009315043:149,Usability,Simpl,SimplifiedInverse,149,"yes, they are always approximate inverses. I wanted to differentiate between the `SparseInverse` which is constructed by mathematical reasoning and `SimplifiedInverse` which is built on heuristic reasoning. . I think the names will always make sense, provided the fact that we are solving a Poisson-like equation (and not a general linear system of equations)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141#issuecomment-1009315043
https://github.com/CliMA/Oceananigans.jl/issues/2146#issuecomment-1479909645:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2146#issuecomment-1479909645
https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1009572063:18,Deployability,patch,patch,18,@glwagner bump up patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1009572063
https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1009572063:24,Deployability,release,release,24,@glwagner bump up patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1009572063
https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179:38,Safety,avoid,avoid,38,I merged main but cancelled the CI to avoid clutter. We should restart the CI when there is no other PR running CI tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179
https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179:115,Testability,test,tests,115,I merged main but cancelled the CI to avoid clutter. We should restart the CI when there is no other PR running CI tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179
https://github.com/CliMA/Oceananigans.jl/issues/2148#issuecomment-1479916612:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2148#issuecomment-1479916612
https://github.com/CliMA/Oceananigans.jl/issues/2149#issuecomment-1011821513:310,Availability,mainten,maintenance,310,"It is possible, but not easy. I suggest that we implement a more modern turbulence closure if we would like a second one for comparisons with CATKE. Implementing any ""production"" turbulence closure will be a significant effort, and we would like it to be worth both the time to implement, and the cost of code maintenance into the future. This will also set us up for comparisons with other ocean models like MOM6 or NEMO. I suggest:. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * ePBL with surface waves ([Reichl and Li 2019](https://journals.ametsoc.org/view/journals/phoc/49/11/jpo-d-18-0258.1.xml?tab_body=pdf)); * The OSMOSIS scheme, the details of which I don't think are yet published, but is implemented in [CVmix](https://github.com/CVMix/CVMix-src).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2149#issuecomment-1011821513
https://github.com/CliMA/Oceananigans.jl/issues/2149#issuecomment-1479899434:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2149#issuecomment-1479899434
https://github.com/CliMA/Oceananigans.jl/pull/2150#issuecomment-1012204391:41,Deployability,update,update,41,"But this is confusing notation... can we update to use the triple notation that we use throughout the code?. The confusion is that MITgcm uses the notation `ΔzF` to denote the _difference of_ `zF`. This is _opposite_ the meaning of our superscripts, which indicate the _location_. In our notation `Δz^aaf` is the _difference of_ `z^aac`. . I suggest we just avoid these capital letters and use only superscripts...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150#issuecomment-1012204391
https://github.com/CliMA/Oceananigans.jl/pull/2150#issuecomment-1012204391:358,Safety,avoid,avoid,358,"But this is confusing notation... can we update to use the triple notation that we use throughout the code?. The confusion is that MITgcm uses the notation `ΔzF` to denote the _difference of_ `zF`. This is _opposite_ the meaning of our superscripts, which indicate the _location_. In our notation `Δz^aaf` is the _difference of_ `z^aac`. . I suggest we just avoid these capital letters and use only superscripts...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150#issuecomment-1012204391
https://github.com/CliMA/Oceananigans.jl/pull/2151#issuecomment-1013762427:3,Testability,test,tests,3,If tests pass then I suggest we merge and leave further work for future PR (perhaps after OSM?),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2151#issuecomment-1013762427
https://github.com/CliMA/Oceananigans.jl/pull/2155#issuecomment-1016927942:41,Deployability,patch,patch,41,let's merge this and then register a new patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2155#issuecomment-1016927942
https://github.com/CliMA/Oceananigans.jl/pull/2155#issuecomment-1016927942:47,Deployability,release,release,47,let's merge this and then register a new patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2155#issuecomment-1016927942
https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978:64,Integrability,interface,interface,64,It's very little coding work! Most of the work is designing the interface. That's true we don't use `tracer_fields`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978
https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1479911272:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1479911272
https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511:338,Modifiability,variab,variable,338,"For regular spacing:. ```julia; julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(2, 2, 2)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 2.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 2.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-2.0, 0.0] regularly spaced with Δzᵃᵃᶜ = 2.0; ```. for variable spacing:. ```julia; julia> σ = 1.1; # stretching factor. julia> Nz = 24; # vertical resolution. julia> Lz = 32; # depth (m). julia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));. julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 64.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 64.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-32.0, -0.0] variably spaced with min(Δzᵃᵃᶜ) = 0.682695, max(Δzᵃᵃᶜ) = 1.830909; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511
https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511:876,Modifiability,variab,variably,876,"For regular spacing:. ```julia; julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(2, 2, 2)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 2.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 2.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-2.0, 0.0] regularly spaced with Δzᵃᵃᶜ = 2.0; ```. for variable spacing:. ```julia; julia> σ = 1.1; # stretching factor. julia> Nz = 24; # vertical resolution. julia> Lz = 32; # depth (m). julia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));. julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 64.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 64.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-32.0, -0.0] variably spaced with min(Δzᵃᵃᶜ) = 0.682695, max(Δzᵃᵃᶜ) = 1.830909; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511
https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892:253,Modifiability,variab,variably,253,"ok, so now we have. ```julia. julia> grid; 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.830909; ```. and. ```julia; julia> c; 32×32×24 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── data: 34×34×26 OffsetArray(::Array{Float64, 3}, 0:33, 0:33, 0:25) with eltype Float64 with indices 0:33×0:33×0:25; │ └── max=0.999994, min=0.000024, mean=0.497759; ├── grid: 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; ```. what do we think so far?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892
https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292:397,Modifiability,variab,variably,397,"@simone-silvestri asked for a little more alignment, so we have. ```julia; julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.83091; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292
https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768:125,Deployability,update,update,125,"@glwagner @simone-silvestri @jm-c - does this look OK for an approve 👍 ; Buildkite is back and happy now! . Its a validation update, but it will make it easier to do next steps (i.e. add new and improved immersed etc.. ) with some tests. . Thx,. Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768
https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768:114,Security,validat,validation,114,"@glwagner @simone-silvestri @jm-c - does this look OK for an approve 👍 ; Buildkite is back and happy now! . Its a validation update, but it will make it easier to do next steps (i.e. add new and improved immersed etc.. ) with some tests. . Thx,. Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768
https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768:231,Testability,test,tests,231,"@glwagner @simone-silvestri @jm-c - does this look OK for an approve 👍 ; Buildkite is back and happy now! . Its a validation update, but it will make it easier to do next steps (i.e. add new and improved immersed etc.. ) with some tests. . Thx,. Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768
https://github.com/CliMA/Oceananigans.jl/pull/2171#issuecomment-1018840627:11,Testability,test,tests,11,Merge when tests pass?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2171#issuecomment-1018840627
https://github.com/CliMA/Oceananigans.jl/pull/2175#issuecomment-1020156593:46,Testability,test,tests,46,Valiant effort. Looks like some matrix solver tests don't pass --- @simone-silvestri perhaps you can take a look when you have time.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2175#issuecomment-1020156593
https://github.com/CliMA/Oceananigans.jl/pull/2175#issuecomment-1020261606:29,Testability,test,test,29,"I ll take a look. weird, the test that fails passes on my computer, I ll try on tartarus",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2175#issuecomment-1020261606
https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787:25,Testability,benchmark,benchmarking,25,"It's very hard to make a benchmarking test with pass/fail criteria. However, I think we should launch nightly benchmarking jobs whose results can be inspected by eye. That will help us catch a regression if we are watchful without having to manually run benchmarks for a string of commits going into the past.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787
https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787:38,Testability,test,test,38,"It's very hard to make a benchmarking test with pass/fail criteria. However, I think we should launch nightly benchmarking jobs whose results can be inspected by eye. That will help us catch a regression if we are watchful without having to manually run benchmarks for a string of commits going into the past.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787
https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787:110,Testability,benchmark,benchmarking,110,"It's very hard to make a benchmarking test with pass/fail criteria. However, I think we should launch nightly benchmarking jobs whose results can be inspected by eye. That will help us catch a regression if we are watchful without having to manually run benchmarks for a string of commits going into the past.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787
https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787:254,Testability,benchmark,benchmarks,254,"It's very hard to make a benchmarking test with pass/fail criteria. However, I think we should launch nightly benchmarking jobs whose results can be inspected by eye. That will help us catch a regression if we are watchful without having to manually run benchmarks for a string of commits going into the past.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176#issuecomment-1021231787
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1086,Availability,mask,masking,1086," one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1530,Availability,mask,masked,1530,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1580,Availability,mask,masking,1580,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1811,Availability,mask,masking,1811,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1907,Availability,mask,masked,1907,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:63,Energy Efficiency,reduce,reduced,63,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:201,Energy Efficiency,reduce,reduced,201,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:249,Energy Efficiency,reduce,reduced,249,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:747,Energy Efficiency,reduce,reduced,747,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1132,Usability,clear,clear,1132,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350:2239,Energy Efficiency,reduce,reduced,2239,"75096 0.631413; 0.357241 0.479499 0.0708911; 0.922986 0.979659 0.117883. [:, :, 3] =; 0.868073 0.0576275 0.328323; 0.522754 0.663369 0.840316; 0.40434 0.631349 0.577748. julia> b = view(a, :, 2:3, 2); 3×2 view(::Array{Float64, 3}, :, 2:3, 2) with eltype Float64:; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> typeof(b); SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Int64}, true}. julia> b.indices; (Base.Slice(Base.OneTo(3)), 2:3, 2); ```. One key difference with `SubArray` is that we want to offset indices. For example with `SubArray` we have. ```julia; julia> b[1, 1, 1]; 0.5750957798298579. julia> a[1, 2, 2]; 0.5750957798298579; ```. But I think we instead want offset indices that behave something like. ```julia; julia> c = OffsetArray(view(a, :, 2:3, 2:2), 0, 1, 1); 3×2×1 OffsetArray(view(::Array{Float64, 3}, :, 2:3, 2:2), 1:3, 2:3, 2:2) with eltype Float64 with indices 1:3×2:3×2:2:; [:, :, 2] =; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> c[1, 2, 2]; 0.5750957798298579; ```. So the indices for `c` and `a` are identical. Something also seems a bit clearer: when we are computing on fields with `indices`, we compute index ""intersections"" to figure out the range of the computation. For example if we want to compute something like. ```julia; u * η; ```. right now our infrastructure would assume this is a 3D computation defined at every level. But what we probably want is to return an object that just computes `u * η` at the _surface_. This will work if `η.indices = (:, :, Nz:Nz)` for example; then the product `u * η` is also defined over the indices `(:, :, Nz:Nz)`. We can also use this feature to support `FieldTimeSeries` of sliced output. If we use this then a `Nothing` location is truly _reduced_, ie, the field has no location in the reduced direction. But a field like the free surface displacement is not reduced; it's `IndexedField` (or something), with `!isnothing(η.indices)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350:2312,Energy Efficiency,reduce,reduced,2312,"75096 0.631413; 0.357241 0.479499 0.0708911; 0.922986 0.979659 0.117883. [:, :, 3] =; 0.868073 0.0576275 0.328323; 0.522754 0.663369 0.840316; 0.40434 0.631349 0.577748. julia> b = view(a, :, 2:3, 2); 3×2 view(::Array{Float64, 3}, :, 2:3, 2) with eltype Float64:; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> typeof(b); SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Int64}, true}. julia> b.indices; (Base.Slice(Base.OneTo(3)), 2:3, 2); ```. One key difference with `SubArray` is that we want to offset indices. For example with `SubArray` we have. ```julia; julia> b[1, 1, 1]; 0.5750957798298579. julia> a[1, 2, 2]; 0.5750957798298579; ```. But I think we instead want offset indices that behave something like. ```julia; julia> c = OffsetArray(view(a, :, 2:3, 2:2), 0, 1, 1); 3×2×1 OffsetArray(view(::Array{Float64, 3}, :, 2:3, 2:2), 1:3, 2:3, 2:2) with eltype Float64 with indices 1:3×2:3×2:2:; [:, :, 2] =; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> c[1, 2, 2]; 0.5750957798298579; ```. So the indices for `c` and `a` are identical. Something also seems a bit clearer: when we are computing on fields with `indices`, we compute index ""intersections"" to figure out the range of the computation. For example if we want to compute something like. ```julia; u * η; ```. right now our infrastructure would assume this is a 3D computation defined at every level. But what we probably want is to return an object that just computes `u * η` at the _surface_. This will work if `η.indices = (:, :, Nz:Nz)` for example; then the product `u * η` is also defined over the indices `(:, :, Nz:Nz)`. We can also use this feature to support `FieldTimeSeries` of sliced output. If we use this then a `Nothing` location is truly _reduced_, ie, the field has no location in the reduced direction. But a field like the free surface displacement is not reduced; it's `IndexedField` (or something), with `!isnothing(η.indices)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350
https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350:1540,Usability,clear,clearer,1540,"75096 0.631413; 0.357241 0.479499 0.0708911; 0.922986 0.979659 0.117883. [:, :, 3] =; 0.868073 0.0576275 0.328323; 0.522754 0.663369 0.840316; 0.40434 0.631349 0.577748. julia> b = view(a, :, 2:3, 2); 3×2 view(::Array{Float64, 3}, :, 2:3, 2) with eltype Float64:; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> typeof(b); SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Int64}, true}. julia> b.indices; (Base.Slice(Base.OneTo(3)), 2:3, 2); ```. One key difference with `SubArray` is that we want to offset indices. For example with `SubArray` we have. ```julia; julia> b[1, 1, 1]; 0.5750957798298579. julia> a[1, 2, 2]; 0.5750957798298579; ```. But I think we instead want offset indices that behave something like. ```julia; julia> c = OffsetArray(view(a, :, 2:3, 2:2), 0, 1, 1); 3×2×1 OffsetArray(view(::Array{Float64, 3}, :, 2:3, 2:2), 1:3, 2:3, 2:2) with eltype Float64 with indices 1:3×2:3×2:2:; [:, :, 2] =; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> c[1, 2, 2]; 0.5750957798298579; ```. So the indices for `c` and `a` are identical. Something also seems a bit clearer: when we are computing on fields with `indices`, we compute index ""intersections"" to figure out the range of the computation. For example if we want to compute something like. ```julia; u * η; ```. right now our infrastructure would assume this is a 3D computation defined at every level. But what we probably want is to return an object that just computes `u * η` at the _surface_. This will work if `η.indices = (:, :, Nz:Nz)` for example; then the product `u * η` is also defined over the indices `(:, :, Nz:Nz)`. We can also use this feature to support `FieldTimeSeries` of sliced output. If we use this then a `Nothing` location is truly _reduced_, ie, the field has no location in the reduced direction. But a field like the free surface displacement is not reduced; it's `IndexedField` (or something), with `!isnothing(η.indices)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350
https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:64,Modifiability,extend,extend,64,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420
https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:28,Safety,avoid,avoid,28,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420
https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021599703:118,Testability,test,test,118,"@simone-silvestri, seems like. https://github.com/CliMA/Oceananigans.jl/blob/50c4b430bb1e6ed4aacaaf588943ada87a56aa7f/test/test_implicit_free_surface_solver.jl#L76-L177. is not used. Should we nuke it?. Also it seems to include deprecated syntax (i.e., `HydrostaticFreeSurfaceModel` no longer has an `architecture` keyword arg).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021599703
https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021681357:57,Performance,bottleneck,bottleneck,57,"I think it's ok, the hydrostatic model tests are not the bottleneck",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021681357
https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021681357:39,Testability,test,tests,39,"I think it's ok, the hydrostatic model tests are not the bottleneck",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021681357
https://github.com/CliMA/Oceananigans.jl/issues/2183#issuecomment-1021711000:38,Testability,test,tests,38,Or just move the vertically stretched tests to a different file... ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2183#issuecomment-1021711000
https://github.com/CliMA/Oceananigans.jl/issues/2183#issuecomment-1021711104:33,Testability,test,tests,33,I would promote splitting up the tests rather than splitting loops if possible!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2183#issuecomment-1021711104
https://github.com/CliMA/Oceananigans.jl/issues/2183#issuecomment-1021789897:32,Testability,test,tests,32,Moving the vertically stretched tests to a different file is what I was thinking also! :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2183#issuecomment-1021789897
https://github.com/CliMA/Oceananigans.jl/issues/2184#issuecomment-1021881101:668,Usability,clear,clear,668,"I don't know. Is the `Vector` somehow a flattened 2D object? We can `reshape` at will without allocating memory:. ```julia; julia> a = Vector(1:16); 16-element Vector{Int64}:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16. julia> b = reshape(a, (4, 4)); 4×4 Matrix{Int64}:; 1 5 9 13; 2 6 10 14; 3 7 11 15; 4 8 12 16. julia> b[1, 1] = 0; 0. julia> a; 16-element Vector{Int64}:; 0; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; ```. But it's a little sketchy if this right hand side doesn't have halos. It's probably ok to allow `Fields` with no halos that don't use `OffsetArray`. Certainly, if it were a field, its physical nature might be a little more clear. As a vector I don't think we can figure out what it represents, just reading the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184#issuecomment-1021881101
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021775876:59,Availability,mask,mask,59,"Actually, I'm just noticing that `Reduction` has a option `mask`. Is that already enough to mimic the windowing behavior?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021775876
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:143,Availability,mask,mask,143,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:798,Energy Efficiency,reduce,reduce,798,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:1849,Energy Efficiency,reduce,reduce,1849,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:515,Usability,simpl,simply,515,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022242069:145,Availability,mask,mask,145,"> For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`...; > ; > https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. Is there an example of how to do that? If not, do you mind writing a quick example? I saw that Oceananigans gained this `ConditionalOperation` lately, but the code has been growing so fast lately that it's hard to keep track, so I really don't know how I'd do it. Also I couldn't find `ConditionalOperation` on the docs or in the PRs (although I know it's in one of the PRs).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022242069
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:190,Availability,mask,mask,190,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:268,Availability,mask,masked,268,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:281,Availability,mask,mask,281,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:659,Availability,mask,mask,659,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:1702,Availability,mask,mask,1702,"lse` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`), and the `mask` (which at the moment is just a number). You can construct it with `condition_operand(field, condition, mask)`. But most of the time you probably won't need it (reductions automatically construct a `ConditionalOperation` when specifying a condition through the keyword argument). @glwagner `condition_operand` is used because we needed to define it in `Fields.jl` which is added before `AbstractOperations.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:2011,Availability,mask,mask,2011,"lse` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`), and the `mask` (which at the moment is just a number). You can construct it with `condition_operand(field, condition, mask)`. But most of the time you probably won't need it (reductions automatically construct a `ConditionalOperation` when specifying a condition through the keyword argument). @glwagner `condition_operand` is used because we needed to define it in `Fields.jl` which is added before `AbstractOperations.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:2120,Availability,mask,mask,2120,"lse` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`), and the `mask` (which at the moment is just a number). You can construct it with `condition_operand(field, condition, mask)`. But most of the time you probably won't need it (reductions automatically construct a `ConditionalOperation` when specifying a condition through the keyword argument). @glwagner `condition_operand` is used because we needed to define it in `Fields.jl` which is added before `AbstractOperations.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:60,Energy Efficiency,reduce,reduce,60,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:252,Energy Efficiency,reduce,reduced,252,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:1865,Energy Efficiency,reduce,reduce,1865,"lse` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`), and the `mask` (which at the moment is just a number). You can construct it with `condition_operand(field, condition, mask)`. But most of the time you probably won't need it (reductions automatically construct a `ConditionalOperation` when specifying a condition through the keyword argument). @glwagner `condition_operand` is used because we needed to define it in `Fields.jl` which is added before `AbstractOperations.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022373316:3394,Energy Efficiency,reduce,reduced,3394,"}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, FieldSlicer{UnitRange{Int64}, Colon, Colon}, Tuple{Int64, Int64, Int64}}(4×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; └── data: 6×3×3 OffsetArray(::Array{Float64, 3}, 0:5, 0:2, 0:2) with eltype Float64 with indices 0:5×0:2×0:2; └── max=4.0, min=1.0, mean=2.5, FieldSlicer{UnitRange{Int64}, Colon, Colon}(3:4, Colon(), Colon(), false), (1, 2, 3)); ```. One can apparently do the following and get the right result:. ```julia; julia> av2 = Field(Average(field, dims=(1,2,3), condition=(i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] > 0.5)); 1×1×1 Field{Nothing, Nothing, Nothing} reduced over dims = (1, 2, 3) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: 4×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── operand: mean! over dims (1, 2, 3) of Conditioned Field at (Center, Center, Center); └── status: time=0.0. julia> compute!(av2); interior(av2). julia> interior(av2); 1×1×1 view(::Array{Float64, 3}, 1:1, 1:1, 1:1) with eltype Float64:; [:, :, 1] =; 3.5; ```. Let me know if I'm not missing anything and I'll open a PR to remove `WindowedSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022373316
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885:114,Performance,perform,performed,114,"Ah, nice! Maybe using `ConditionalOperation` is a bit slower than `WindowSpatialAverage` because the reduction is performed on the whole domain. Anyways, I don't think reduction is performance-critical so I agree to nuke `WindowSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885
https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885:181,Performance,perform,performance-critical,181,"Ah, nice! Maybe using `ConditionalOperation` is a bit slower than `WindowSpatialAverage` because the reduction is performed on the whole domain. Anyways, I don't think reduction is performance-critical so I agree to nuke `WindowSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885
https://github.com/CliMA/Oceananigans.jl/pull/2186#issuecomment-1021897957:11,Testability,test,test,11,I'll add a test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186#issuecomment-1021897957
https://github.com/CliMA/Oceananigans.jl/pull/2186#issuecomment-1021905407:97,Deployability,release,release,97,I brought this back to 0.68.7. Let's wait for this PR and also for #2181 before bumping up minor release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186#issuecomment-1021905407
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022625228:14,Testability,test,tests,14,"How about few tests? E.g., some similar to what is discussed in #2189. Would that be useful you reckon?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022625228
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022682513:16,Testability,test,tests,16,Or perhaps when tests pass? Let me know if you need help with that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022682513
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022702549:18,Testability,test,tests,18,> Or perhaps when tests pass? Let me know if you need help with that. Thanks. I think that test failed due to some server issue. I restarted it and it seems to be going fine.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022702549
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022702549:91,Testability,test,test,91,> Or perhaps when tests pass? Let me know if you need help with that. Thanks. I think that test failed due to some server issue. I restarted it and it seems to be going fine.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1022702549
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1023337935:448,Testability,test,tests,448,"> > @tomchor can you list the operators you added in the description of this PR?; > ; > Done!; > ; > > These have to be defined for all grids...; > ; > These are defined for `Union{ARG, AHCG}`, which I believe are abstract rectilinear and horizontally curvilinear grids, no? I'd prefer not to define these for other grids in this PR since I have no familiarity with them if that's okay. I believe that covers all grids we have, so we are good. The tests should loop over all grids too!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1023337935
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1023339023:46,Testability,test,tests,46,@tomchor can I commit to this PR and add more tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1023339023
https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1023409010:48,Testability,test,tests,48,> @tomchor can I commit to this PR and add more tests?. Sure!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2190#issuecomment-1023409010
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022623596:91,Security,validat,validation,91,Could you comment on what version of Oceananigans you are using?. Perhaps we need to add a validation that spits out a meaningful warning to the user when this happens.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022623596
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786:603,Deployability,hotfix,hotfix,603,"Indeed the pressure solver at the moment allows only a variable z-direction. This is because for a regular grid we can use a full FFT solve while with a singular stretched direction we can solve a tridiagonal system. . For more than one stretched direction we should use an iterative solver to solve the Poisson equation (the solvers are there but the infrastructure not quite yet). We should implement the iterative solver as a default for two or more stretched directions. And set up the FFT-tridiagonal solver as default when we have one stretched direction (either x, y or z). In the meantime, as a hotfix, If you only need one stretched direction I would suggest you to rotate your problem to stretch it in z-direction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786:55,Modifiability,variab,variable,55,"Indeed the pressure solver at the moment allows only a variable z-direction. This is because for a regular grid we can use a full FFT solve while with a singular stretched direction we can solve a tridiagonal system. . For more than one stretched direction we should use an iterative solver to solve the Poisson equation (the solvers are there but the infrastructure not quite yet). We should implement the iterative solver as a default for two or more stretched directions. And set up the FFT-tridiagonal solver as default when we have one stretched direction (either x, y or z). In the meantime, as a hotfix, If you only need one stretched direction I would suggest you to rotate your problem to stretch it in z-direction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819:12,Availability,error,error,12,"I think the error is surprisingly clear actually! There's no pressure solver for grids that are stretched in `x` or `y`. But it won't be much effort to add a more specific warning in the constructor for `NonhydrostaticModel`. @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in `i, j` and solve in `k`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819:34,Usability,clear,clear,34,"I think the error is surprisingly clear actually! There's no pressure solver for grids that are stretched in `x` or `y`. But it won't be much effort to add a more specific warning in the constructor for `NonhydrostaticModel`. @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in `i, j` and solve in `k`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921:4,Availability,error,error,4,"The error is not as clear, @glwagner. ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```. does not immediately reads ""no pressure solver for grids that are stretched in x or y"". One needs to infer that from the long types of the function arguments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921:43,Availability,ERROR,ERROR,43,"The error is not as clear, @glwagner. ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```. does not immediately reads ""no pressure solver for grids that are stretched in x or y"". One needs to infer that from the long types of the function arguments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921:20,Usability,clear,clear,20,"The error is not as clear, @glwagner. ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```. does not immediately reads ""no pressure solver for grids that are stretched in x or y"". One needs to infer that from the long types of the function arguments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022779778:274,Security,validat,validation,274,"I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!. But you're right that you don't know which input is the problem (only I know that only the grid matters). So yeah, I think some input validation for `grid` would help in the `NonhydrostaticModel` constructor. We only support `RegRectilinearGrid` and `HRegRectilinearGrid`. All other grid types are invalid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022779778
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912:259,Availability,error,error,259,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912:271,Usability,clear,clear,271,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912:374,Usability,Clear,Clear,374,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912:402,Usability,clear,clear,402,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047:64,Availability,error,error,64,"I'm using v0.68.6, previously I was on v0.67.1 and saw the same error (not surprising). I was hoping to use a stretched x-grid with a stretched z-grid while I play around with some 2D internal wave simulations. I'm still new to Julia and Oceananigans so I've been trying to simulate the classic vertically oscillating sphere or cylinder as my source. I was playing around with refining the mesh near the oscillation to see if the wave beams were a little cleaner. I can make due with stretched z-grids for now!. --; Regarding the `MethodError`, and while I am new to Julia, but maybe in this case a `NotImplementedError` would work better? I find Julia's stacktraces a bit long winded because of multi-dispatch and I obviously didn't figure out that variable grid spacing is only implemented for the vertical coordinate for the pressure solver. But getting a `NotImplementedError` when I tried would have been painfully obvious even to me. :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047:750,Modifiability,variab,variable,750,"I'm using v0.68.6, previously I was on v0.67.1 and saw the same error (not surprising). I was hoping to use a stretched x-grid with a stretched z-grid while I play around with some 2D internal wave simulations. I'm still new to Julia and Oceananigans so I've been trying to simulate the classic vertically oscillating sphere or cylinder as my source. I was playing around with refining the mesh near the oscillation to see if the wave beams were a little cleaner. I can make due with stretched z-grids for now!. --; Regarding the `MethodError`, and while I am new to Julia, but maybe in this case a `NotImplementedError` would work better? I find Julia's stacktraces a bit long winded because of multi-dispatch and I obviously didn't figure out that variable grid spacing is only implemented for the vertical coordinate for the pressure solver. But getting a `NotImplementedError` when I tried would have been painfully obvious even to me. :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655:318,Availability,fault,fault,318,"> Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU. I think it might be more fruitful to generalize `BatchedTridiagonalSolver`. It's a little annoying (our fault for using `i, j, k` rather than `CartesianIndex`...) --- but we can probably figure out how to rotate indices in https://github.com/CliMA/Oceananigans.jl/blob/a314f1f64e80181ecff84d6bab1e5182644d95cc/src/Solvers/batched_tridiagonal_solver.jl#L91. Not a small refactor, so I'd argue not priority 1 right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655:583,Modifiability,refactor,refactor,583,"> Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU. I think it might be more fruitful to generalize `BatchedTridiagonalSolver`. It's a little annoying (our fault for using `i, j, k` rather than `CartesianIndex`...) --- but we can probably figure out how to rotate indices in https://github.com/CliMA/Oceananigans.jl/blob/a314f1f64e80181ecff84d6bab1e5182644d95cc/src/Solvers/batched_tridiagonal_solver.jl#L91. Not a small refactor, so I'd argue not priority 1 right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655
https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1479915537:24,Availability,error,error,24,We added a more helpful error for this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1479915537
https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022641499:49,Security,validat,validation,49,"Possibly a solution could be that as part of the validation of the grid we check whether; ```Julia; min(Δy) - max(Δy) < abstol; ```; and if the above is true then recreate the grid with `y = (min(grid.y), max(grid.y))`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022641499
https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022684710:43,Testability,test,testing,43,I think the current behavior is useful for testing purposes. It seems to me this would be beneficial only in a very small handful of cases. I vote we keep the current behavior.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022684710
https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084:106,Modifiability,variab,variable,106,"A warning might make sense. `show` can be more specific (spacing `Array` doesn't mean that the spacing is variable, it means the spacing is given by an `Array`). It's good at least now that `show` helps you realize that `Array` spacings are special.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084
https://github.com/CliMA/Oceananigans.jl/pull/2193#issuecomment-1022701614:32,Deployability,patch,patch,32,"This is a breaking change, so a patch release is in order.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2193#issuecomment-1022701614
https://github.com/CliMA/Oceananigans.jl/pull/2193#issuecomment-1022701614:38,Deployability,release,release,38,"This is a breaking change, so a patch release is in order.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2193#issuecomment-1022701614
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291:100,Deployability,configurat,configuration,100,"Good idea. Maybe even suggest the user try `ShallowWaterModel`, as that is a better way to try this configuration? ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291:100,Modifiability,config,configuration,100,"Good idea. Maybe even suggest the user try `ShallowWaterModel`, as that is a better way to try this configuration? ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:731,Availability,error,error,731,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:737,Integrability,message,message,737,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:309,Modifiability,refactor,refactor,309,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166:3999,Availability,error,error,3999,"ck?. Same! Runs again no complaining :). ```julia; julia> using Oceananigans. julia> grid; 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Bounded y ∈ [0.0, 2.0] regularly spaced with Δy=2.0; └── Flat z. julia> model = HydrostaticFreeSurfaceModel(grid=grid, free_surface = ImplicitFreeSurface()); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=1.0, stop_iteration=2); Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1 second; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 2.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (198.852 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.013 minutes).; [ Info: Simulation is stopping. Model iteration 2 has hit or exceeded simulation stop iteration 2.; ```. > Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). yeah!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166
https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166:4005,Integrability,message,message,4005,"ck?. Same! Runs again no complaining :). ```julia; julia> using Oceananigans. julia> grid; 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Bounded y ∈ [0.0, 2.0] regularly spaced with Δy=2.0; └── Flat z. julia> model = HydrostaticFreeSurfaceModel(grid=grid, free_surface = ImplicitFreeSurface()); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=1.0, stop_iteration=2); Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1 second; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 2.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (198.852 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.013 minutes).; [ Info: Simulation is stopping. Model iteration 2 has hit or exceeded simulation stop iteration 2.; ```. > Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). yeah!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166
https://github.com/CliMA/Oceananigans.jl/pull/2199#issuecomment-1023334847:33,Safety,avoid,avoid,33,That's sweet!. I think we should avoid punctuation where possible in `summary` (mirroring Julia Base) so maybe. ```; ImplicitFreeSurface; gravitational acceleration 9.80665 m s⁻²; ```. should be. ```; ImplicitFreeSurface with gravitational acceleration = 9.80665 m s⁻²; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2199#issuecomment-1023334847
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023492365:17,Availability,mask,mask,17,Can we also use `mask = f(neutral_value)` or no?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023492365
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023534535:318,Availability,mask,mask,318,"what is the `neutral_value`? If there is one implemented in Julia that's cool. I saw something about a `GPUarrays.neutral_element` (https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/host/mapreduce.jl) don't know if we can use it; ; I think if we don't want to change `mapreduce` we have to have something like `mask = f⁻¹(get_neutral_value(reduction!))`, which might be very difficult as not all the functions are readily invertible. For the moment I added a function as a property of `ConditionalOperation` such that `getindex` of `c::ConditionalOperation` is `c.func(getindex(c.operand, args...))` when `c.condition = true`. ; Then a reduction like `sum(f, c, condition=condition)` will be called on a `ConditionalOperation` with `func = f` and `condition = condition`.; I am thinking about other methods which do not require adding a property to the type though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023534535
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740:324,Availability,mask,mask,324,"> what is the `neutral_value`? If there is one implemented in Julia that's cool. I saw something about a `GPUarrays.neutral_element` (https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/host/mapreduce.jl) don't know if we can use it; > ; > I think if we don't want to change `mapreduce` we have to have something like `mask = f⁻¹(get_neutral_value(reduction!))`, which might be very difficult as not all the functions are readily invertible.; > ; > For the moment I added a function as a property of `ConditionalOperation` such that `getindex` of `c::ConditionalOperation` is `c.func(getindex(c.operand, args...))` when `c.condition = true`. Then a reduction like `sum(f, c, condition=condition)` will be called on a `ConditionalOperation` with `func = f` and `condition = condition`. I am thinking about other methods which do not require adding a property to the type though. I mean changing. https://github.com/CliMA/Oceananigans.jl/blob/d6a515e2ce5de7c0b10dc29427f96d777dafcf01/src/Fields/field.jl#L422-L423. to. ```julia; Base.$(reduction!)(f::Function, r::ReducedField, a::AbstractArray;; condition = nothing, mask = f(get_neutral_mask(Base.$(reduction!))), kwargs...); ```. so we pass `get_neutral_mask(r)` through `f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740:1121,Availability,mask,mask,1121,"> what is the `neutral_value`? If there is one implemented in Julia that's cool. I saw something about a `GPUarrays.neutral_element` (https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/host/mapreduce.jl) don't know if we can use it; > ; > I think if we don't want to change `mapreduce` we have to have something like `mask = f⁻¹(get_neutral_value(reduction!))`, which might be very difficult as not all the functions are readily invertible.; > ; > For the moment I added a function as a property of `ConditionalOperation` such that `getindex` of `c::ConditionalOperation` is `c.func(getindex(c.operand, args...))` when `c.condition = true`. Then a reduction like `sum(f, c, condition=condition)` will be called on a `ConditionalOperation` with `func = f` and `condition = condition`. I am thinking about other methods which do not require adding a property to the type though. I mean changing. https://github.com/CliMA/Oceananigans.jl/blob/d6a515e2ce5de7c0b10dc29427f96d777dafcf01/src/Fields/field.jl#L422-L423. to. ```julia; Base.$(reduction!)(f::Function, r::ReducedField, a::AbstractArray;; condition = nothing, mask = f(get_neutral_mask(Base.$(reduction!))), kwargs...); ```. so we pass `get_neutral_mask(r)` through `f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740:1067,Energy Efficiency,Reduce,ReducedField,1067,"> what is the `neutral_value`? If there is one implemented in Julia that's cool. I saw something about a `GPUarrays.neutral_element` (https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/host/mapreduce.jl) don't know if we can use it; > ; > I think if we don't want to change `mapreduce` we have to have something like `mask = f⁻¹(get_neutral_value(reduction!))`, which might be very difficult as not all the functions are readily invertible.; > ; > For the moment I added a function as a property of `ConditionalOperation` such that `getindex` of `c::ConditionalOperation` is `c.func(getindex(c.operand, args...))` when `c.condition = true`. Then a reduction like `sum(f, c, condition=condition)` will be called on a `ConditionalOperation` with `func = f` and `condition = condition`. I am thinking about other methods which do not require adding a property to the type though. I mean changing. https://github.com/CliMA/Oceananigans.jl/blob/d6a515e2ce5de7c0b10dc29427f96d777dafcf01/src/Fields/field.jl#L422-L423. to. ```julia; Base.$(reduction!)(f::Function, r::ReducedField, a::AbstractArray;; condition = nothing, mask = f(get_neutral_mask(Base.$(reduction!))), kwargs...); ```. so we pass `get_neutral_mask(r)` through `f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980:155,Availability,mask,mask,155,"but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want. As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori. Or maybe I haven't interpreted correctly what you wrote?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980:421,Availability,mask,mask,421,"but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want. As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori. Or maybe I haven't interpreted correctly what you wrote?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980:528,Availability,mask,mask,528,"but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want. As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori. Or maybe I haven't interpreted correctly what you wrote?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980:698,Availability,mask,mask,698,"but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want. As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori. Or maybe I haven't interpreted correctly what you wrote?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980:730,Availability,mask,mask,730,"but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want. As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori. Or maybe I haven't interpreted correctly what you wrote?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023601980
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735:157,Availability,mask,mask,157,"> but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want.; > ; > As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori.; > ; > Or maybe I haven't interpreted correctly what you wrote?. No that's a good explanation. The ""neutral element"" for an arbitrary reduction with element-wise transformation is inverse transformation applied to the ""identity neutral element"" (for example, the neutral element for `sum(identity)` is 0, while the neutral element for `sum(i -> i+1)` is `-1`). Since we are unable (probably...) to obtain the inverse of arbitrary transformations, we need to implement a workaround. I think its a good idea to add some version of this explanation to the PR description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735:430,Availability,mask,mask,430,"> but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want.; > ; > As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori.; > ; > Or maybe I haven't interpreted correctly what you wrote?. No that's a good explanation. The ""neutral element"" for an arbitrary reduction with element-wise transformation is inverse transformation applied to the ""identity neutral element"" (for example, the neutral element for `sum(identity)` is 0, while the neutral element for `sum(i -> i+1)` is `-1`). Since we are unable (probably...) to obtain the inverse of arbitrary transformations, we need to implement a workaround. I think its a good idea to add some version of this explanation to the PR description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735:537,Availability,mask,mask,537,"> but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want.; > ; > As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori.; > ; > Or maybe I haven't interpreted correctly what you wrote?. No that's a good explanation. The ""neutral element"" for an arbitrary reduction with element-wise transformation is inverse transformation applied to the ""identity neutral element"" (for example, the neutral element for `sum(identity)` is 0, while the neutral element for `sum(i -> i+1)` is `-1`). Since we are unable (probably...) to obtain the inverse of arbitrary transformations, we need to implement a workaround. I think its a good idea to add some version of this explanation to the PR description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735:707,Availability,mask,mask,707,"> but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want.; > ; > As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori.; > ; > Or maybe I haven't interpreted correctly what you wrote?. No that's a good explanation. The ""neutral element"" for an arbitrary reduction with element-wise transformation is inverse transformation applied to the ""identity neutral element"" (for example, the neutral element for `sum(identity)` is 0, while the neutral element for `sum(i -> i+1)` is `-1`). Since we are unable (probably...) to obtain the inverse of arbitrary transformations, we need to implement a workaround. I think its a good idea to add some version of this explanation to the PR description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735:739,Availability,mask,mask,739,"> but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want.; > ; > As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori.; > ; > Or maybe I haven't interpreted correctly what you wrote?. No that's a good explanation. The ""neutral element"" for an arbitrary reduction with element-wise transformation is inverse transformation applied to the ""identity neutral element"" (for example, the neutral element for `sum(identity)` is 0, while the neutral element for `sum(i -> i+1)` is `-1`). Since we are unable (probably...) to obtain the inverse of arbitrary transformations, we need to implement a workaround. I think its a good idea to add some version of this explanation to the PR description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735
https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1024658589:18,Testability,test,tests,18,@simone-silvestri tests haven't passed!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1024658589
https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025021523:61,Deployability,update,update,61,Note that we have pinned CUDA at v3.3.6. Any time I tried to update beyond that version things seem to break. I'll press on with the efforts in #2005...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025021523
https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025054383:63,Deployability,update,update,63,> Note that we have pinned CUDA at v3.3.6. Any time I tried to update beyond that version things seem to break. I'll press on with the efforts in #2005... Is it worth upgrading until we are ready to tackle this issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025054383
https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025932977:434,Deployability,upgrade,upgrade,434,"> According to that blog post, changing the above line; > ; > ```julia; > @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; > ```; > ; > may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. Also, it took me a while to figure out what the term ""register pressure"" meant, so I'm also leaving the relevant wikipedia page here for whoever needs it: https://en.wikipedia.org/wiki/Register_allocation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025932977
https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063:126,Deployability,upgrade,upgrade,126,"> Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. CUDA 3.8 includes features that may allow us to decrease register pressure or implement performance optimizations that would otherwise be difficult or impossible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063
https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063:237,Performance,perform,performance,237,"> Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. CUDA 3.8 includes features that may allow us to decrease register pressure or implement performance optimizations that would otherwise be difficult or impossible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063
https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063:249,Performance,optimiz,optimizations,249,"> Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. CUDA 3.8 includes features that may allow us to decrease register pressure or implement performance optimizations that would otherwise be difficult or impossible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025959022:203,Testability,test,test,203,"> Are you using `diffusive_cfl`? Do you have cases where the time-step is limited by diffusive CFL?. Yes and yes. It's kinda rare that the diffusivity is the limiting factor (and it generally happens in test runs rather in production-ready code) but it happens often enough for me that I always set-it. In fact, now that I think about it, I'd advocate that we set `diffusive_cfl=0.9` (ot even 1) by default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025959022
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025968193:210,Availability,mainten,maintenance,210,"I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users. I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025968193
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025972971:219,Availability,mainten,maintenance,219,"> I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > ; > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful. I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025972971
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:219,Availability,mainten,maintenance,219,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:1260,Integrability,rout,route,1260,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:717,Modifiability,extend,extend,717,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:972,Modifiability,variab,variable,972,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:1122,Safety,avoid,avoids,1122,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:875,Usability,simpl,simple,875,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027435287:203,Availability,mask,mask,203,"I think the best bet is to ensure that all derivatives inside the immersed boundary are zero. . To do that we need to have fully 3D derivatives (i.e. no more `∂xᶜᵃᵃ`, `∂yᵃᶜᵃ` and `∂zᵃᵃᶜ`) so that we can mask them with the `solid_interface` function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027435287
https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1112,Availability,down,down,1112,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1165,Availability,down,down,1165,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1467,Integrability,interface,interfaces,1467,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:229,Usability,simpl,simply,229,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027538953:109,Availability,mask,mask,109,"> To do that we need to have fully 3D derivatives (i.e. no more `∂xᶜᵃᵃ`, `∂yᵃᶜᵃ` and `∂zᵃᵃᶜ`) so that we can mask them with the `solid_interface` function. This certainly might be an improvement. But, practically speaking, I think we only need to ensure that `∂x_∇²h_cᶠᶜᶜ` and `∂y_∇²h_cᶜᶠᶜ` are correct in the presence of immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L69. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L74. right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027538953
https://github.com/CliMA/Oceananigans.jl/pull/2212#issuecomment-1029601165:23,Testability,test,tests,23,"@glwagner, some of the tests fail. I don't see why... Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2212#issuecomment-1029601165
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028185427:22,Testability,test,test,22,"I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028185427
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028185427:88,Testability,test,test,88,"I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028185427
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876:186,Deployability,patch,patch,186,"> I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much. Added the most minimal test I could think of and bumped the patch version since this is a bug fix. If everyone's okay with it, I'll merge if the tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876:24,Testability,test,test,24,"> I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much. Added the most minimal test I could think of and bumped the patch version since this is a bug fix. If everyone's okay with it, I'll merge if the tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876:90,Testability,test,test,90,"> I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much. Added the most minimal test I could think of and bumped the patch version since this is a bug fix. If everyone's okay with it, I'll merge if the tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876:149,Testability,test,test,149,"> I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much. Added the most minimal test I could think of and bumped the patch version since this is a bug fix. If everyone's okay with it, I'll merge if the tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876
https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876:271,Testability,test,tests,271,"> I would add a minimal test given this feature could change, and hopefully make sure the test doesn't increase CI cost much. Added the most minimal test I could think of and bumped the patch version since this is a bug fix. If everyone's okay with it, I'll merge if the tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213#issuecomment-1028191876
https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527:19,Modifiability,refactor,refactor,19,This is an amazing refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527
https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1030167995:52,Deployability,patch,patch,52,Shouldn't this be a minor version bump instead of a patch one? After all it's a breaking change if anyone is using the old operators...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1030167995
https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1030171530:29,Deployability,patch,patch,29,Oh sorry I thought you meant patch version bump. I ll rectify that,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1030171530
https://github.com/CliMA/Oceananigans.jl/issues/2216#issuecomment-1479959055:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2216#issuecomment-1479959055
https://github.com/CliMA/Oceananigans.jl/issues/2219#issuecomment-1305160880:35,Deployability,update,updated,35,Tests were introduced in #1994 and updated in #2786.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219#issuecomment-1305160880
https://github.com/CliMA/Oceananigans.jl/issues/2219#issuecomment-1305160880:0,Testability,Test,Tests,0,Tests were introduced in #1994 and updated in #2786.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219#issuecomment-1305160880
https://github.com/CliMA/Oceananigans.jl/pull/2220#issuecomment-1029737813:16,Testability,test,tests,16,I'll merge when tests pass! This is needed for https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/pull/165,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2220#issuecomment-1029737813
https://github.com/CliMA/Oceananigans.jl/issues/2222#issuecomment-1479916225:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222#issuecomment-1479916225
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913:114,Availability,ERROR,ERROR,114,"```Julia; [ Info: ... simulation initialization complete (1.471 minutes); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException. nested task error: type Tuple has no field surface_TKE_flux; Stacktrace:; [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); @ Base ./Base.jl:33; [2] call; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; [3] fallback; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; [5] overdub; @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Name",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913:165,Availability,error,error,165,"```Julia; [ Info: ... simulation initialization complete (1.471 minutes); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException. nested task error: type Tuple has no field surface_TKE_flux; Stacktrace:; [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); @ Base ./Base.jl:33; [2] call; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; [3] fallback; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; [5] overdub; @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Name",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913:205,Availability,error,error,205,"```Julia; [ Info: ... simulation initialization complete (1.471 minutes); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException. nested task error: type Tuple has no field surface_TKE_flux; Stacktrace:; [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); @ Base ./Base.jl:33; [2] call; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; [3] fallback; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; [5] overdub; @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Name",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913:121,Performance,Load,LoadError,121,"```Julia; [ Info: ... simulation initialization complete (1.471 minutes); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException. nested task error: type Tuple has no field surface_TKE_flux; Stacktrace:; [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); @ Base ./Base.jl:33; [2] call; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; [3] fallback; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; [5] overdub; @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Name",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:122,Availability,ERROR,ERROR,122,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:179,Availability,error,error,179,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:225,Availability,error,error,225,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418
https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:129,Performance,Load,LoadError,129,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418
https://github.com/CliMA/Oceananigans.jl/issues/2233#issuecomment-1479950432:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2233#issuecomment-1479950432
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:323,Deployability,update,update,323,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:287,Energy Efficiency,adapt,adapt,287,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:224,Integrability,interface,interface,224,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:287,Modifiability,adapt,adapt,287,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036754829:318,Integrability,wrap,wrapping,318,"> it took me a while to understand that I couldn't put abstract operations into the output writers. This makes sense to me --- after all, who cares what a `Field` is? We want to write a computation to disk. Maybe we should support AbstractOperations and Reduction as output directly, to save the boilerplate of always wrapping things in `Field`? It occurs to me that the majority of users don't really need to know what a `Field` is (at least not when they're starting out).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036754829
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779:379,Performance,perform,performed,379,"> I think something like you're proposing would have added to my confusion. Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779:223,Testability,log,logical,223,"> I think something like you're proposing would have added to my confusion. Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718:231,Energy Efficiency,allocate,allocate,231,"> Honestly I think this is already pretty handy and enforces the idea that in order to compute something it needs to be a field. Hmm, I think the key concept here is that in order to _store_ the result of a computation, we need to allocate memory. That's what invoking `Field` does. It's worth mentioning for posterity the subtlety that calling `compute!` does have an affect on abstract operation, because it triggers the computation of all the leaves. So if an AbstractOperation depends on a field that needs to be computed, calling `compute!` on the abstract operation will cause that child field to get computed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718:481,Integrability,depend,depends,481,"> Honestly I think this is already pretty handy and enforces the idea that in order to compute something it needs to be a field. Hmm, I think the key concept here is that in order to _store_ the result of a computation, we need to allocate memory. That's what invoking `Field` does. It's worth mentioning for posterity the subtlety that calling `compute!` does have an affect on abstract operation, because it triggers the computation of all the leaves. So if an AbstractOperation depends on a field that needs to be computed, calling `compute!` on the abstract operation will cause that child field to get computed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:641,Modifiability,extend,extended,641,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:388,Performance,perform,performed,388,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591
https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:232,Testability,log,logical,232,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591
https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1033314105:145,Safety,redund,redundancy,145,"I prefer the three letter notation because it's more explicit. I'm worried that mistakes might be easier to make, since the current format has a redundancy that in my experience often catches hard to find bugs when coding and formatting long expressions. I guess I also feel it helps me ""visualize"" terms but maybe that's just me. Here's an example of such an expression:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L262-L301. I agree though that the ""minimal"" notation is more readable for short expressions like the example above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1033314105
https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1479910838:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1479910838
https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034073975:43,Testability,test,tests,43,Looks like a good idea but I see that some tests were not successful?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034073975
https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034086099:45,Testability,test,tests,45,> Looks like a good idea but I see that some tests were not successful?. Tartarus is on the struggle bus it seems,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034086099
https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606:283,Deployability,release,releases,283,"> We need some PlotRecipes for fields...; > ; > (In general, not for this PR!). We need that badly... I think we should take the approach in `ClimaCore.jl` which is to develop an ""external"" package that lives in `/lib`. Perhaps `Makinanigans.jl` or `Vizinanigans.jl`. Performing new releases is a little more arduous with that setup but its probably worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606
https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606:268,Performance,Perform,Performing,268,"> We need some PlotRecipes for fields...; > ; > (In general, not for this PR!). We need that badly... I think we should take the approach in `ClimaCore.jl` which is to develop an ""external"" package that lives in `/lib`. Perhaps `Makinanigans.jl` or `Vizinanigans.jl`. Performing new releases is a little more arduous with that setup but its probably worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606
https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920:5,Modifiability,flexible,flexible,5,more flexible and less code -- what can go wrong?. yeap!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:649,Availability,down,downside,649,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:518,Energy Efficiency,reduce,reduce,518,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:247,Integrability,wrap,wrapped,247,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:691,Security,expose,exposed,691,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:863,Security,expose,exposed,863,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:306,Usability,intuit,intuitive,306,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707:232,Availability,down,downside,232,"> Pardon if this question is naive but why is it important that users to exposed to the Field infrastructure?. Because that way they are prepared to do sophisticated post-processing! But I think you're right, maybe it's not a real ""downside"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707
https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707:73,Security,expose,exposed,73,"> Pardon if this question is naive but why is it important that users to exposed to the Field infrastructure?. Because that way they are prepared to do sophisticated post-processing! But I think you're right, maybe it's not a real ""downside"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707
https://github.com/CliMA/Oceananigans.jl/pull/2243#issuecomment-1038569210:61,Deployability,deploy,deployment,61,"> forcepush a boolean that specifies the behavior of the git-deployment. The default (forcepush = false) is to push a new commit, but when forcepush = true the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2243#issuecomment-1038569210
https://github.com/CliMA/Oceananigans.jl/pull/2243#issuecomment-1038569210:259,Deployability,deploy,deployment,259,"> forcepush a boolean that specifies the behavior of the git-deployment. The default (forcepush = false) is to push a new commit, but when forcepush = true the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2243#issuecomment-1038569210
https://github.com/CliMA/Oceananigans.jl/issues/2244#issuecomment-1039305740:273,Deployability,update,update,273,"> If the barotropic mode is not used in the AB2 scheme, which I presume is the case, then I agree it makes sense to compute it elsewhere.; > ; > `update_state!` seems like a good place to me. Basically we have to calculate the barotropic mode before doing the free surface update if we are using a `SplitExplicitFreeSurface`. But I think we can regard the barotropic mode as part of the ""auxiliary state"" of the problem. The rest of the auxiliary state is calculated in `update_state!`, so I think that's the appropriate place to calculate the barotropic mode as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2244#issuecomment-1039305740
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:1174,Availability,ERROR,ERROR,1174,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:766,Deployability,release,release,766,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:178,Testability,test,test,178,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:273,Testability,test,test,273,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:825,Testability,test,test,825,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:914,Testability,test,test,914,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692
https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633:405,Performance,load,load,405,"I guess in our terminology ""saving"" is a bit more restricted than ""serializing"". When we ""save"" an object, we do it in a way that might be readable from Python or MATLAB (for example). This means that we only ""save"" common types like numbers, arrays, strings. Anything we output to NetCDF is ""saved"". When we ""serialize"" we might embed a Julia struct in a file. So when we serialize something we can only load it back from Julia. We can only serialize with JLD2.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633
https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888:305,Performance,perform,performant,305,"> If I understand correctly this would make the `field_slicer` argument for output writers obsolete, no?. I missed this! Yes, that's correct. We _could_ keep it, however I think it's nicer to remove because it's one of the best ways to ensure that the ""windowing infrastructure"" implemented in this PR is performant and easy to use. In place of `field_slicer`, we will add some convenience arguments (`indices` and `with_halos`) that allow output fields to be ""constructed"" from what's given to `OutputWriter`. This will also allow us to close #2242 (but I haven't implemented that yet here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888
https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039818469:319,Safety,avoid,avoiding,319,"> Can we use types rather than symbols? `ThreeDimensional()`, `Horizontal()`, etc. They are converted into types in the constructor `return ScalarDiffusivity{TD, eval(direction)}(FT(ν), κ)` (and are effectively types in the type signature. I personally prefer it this way because it allows to build closures in the API avoiding to have to import additional types... But, I don't feel so strongly about it... I can also change it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039818469
https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039821816:328,Safety,avoid,avoiding,328,"> > Can we use types rather than symbols? `ThreeDimensional()`, `Horizontal()`, etc.; > ; > They are converted into types in the constructor `return ScalarDiffusivity{TD, eval(direction)}(FT(ν), κ)` (and are effectively types in the type signature. I personally prefer it this way because it allows to build closures in the API avoiding to have to import additional types...; > ; > But, I don't feel so strongly about it... I can also change it. I think the most important thing is a uniform API that's easy to remember. With a few exceptions (that we will hopefully address eventually) we use types throughout (since for many cases we have to since the types can store data). I think if we have an API that's half types, half symbols it will get hard to remember when we use what... I see your point though re: polluting the namespace if there are very many possibilities. Precedent for a ""symbol based specification"" is in Julia's `Colors.jl`. `Makie.jl` also uses a fair amount of symbols.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039821816
https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134:677,Availability,error,error,677,"> * Implementation of zero laplacians on the immersed boundaries to allow a biharmonic closure with immersed boundaries. Do we also need to zero the Laplacian on _non-immersed_ (ie ordinary) boundaries?. Relatedly, I don't think we need to `@unroll` when we fill halos for `FluxBoundaryCondition`:. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/BoundaryConditions/fill_halo_regions_flux.jl#L33. The only point of filling points _beyond_ the first halo point is for `AnisotropicBiharmonicDiffusivity`. So if we aren't using it we can get rid of `@unroll` and just fill the first halo point, I think. I think we also need to throw an error if the _only_ closure if `ScalarBiharmonicDiffusivity` and the boundary condition is anything _but_ `FluxBoundaryCondition`. It's kind of complex because it's still ok to have biharmonic and non-flux, provided that there's _another_ closure (in a closure tuple) present. Maybe we can just open an issue about validating boundary conditions + closures and figure out an algorithm there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134
https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134:992,Security,validat,validating,992,"> * Implementation of zero laplacians on the immersed boundaries to allow a biharmonic closure with immersed boundaries. Do we also need to zero the Laplacian on _non-immersed_ (ie ordinary) boundaries?. Relatedly, I don't think we need to `@unroll` when we fill halos for `FluxBoundaryCondition`:. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/BoundaryConditions/fill_halo_regions_flux.jl#L33. The only point of filling points _beyond_ the first halo point is for `AnisotropicBiharmonicDiffusivity`. So if we aren't using it we can get rid of `@unroll` and just fill the first halo point, I think. I think we also need to throw an error if the _only_ closure if `ScalarBiharmonicDiffusivity` and the boundary condition is anything _but_ `FluxBoundaryCondition`. It's kind of complex because it's still ok to have biharmonic and non-flux, provided that there's _another_ closure (in a closure tuple) present. Maybe we can just open an issue about validating boundary conditions + closures and figure out an algorithm there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134
https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:295,Integrability,interface,interface,295,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132
https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:412,Modifiability,extend,extend,412,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1481474505:148,Testability,test,test,148,"> @navidcy points out this might already work for lat lon anyways. I suspect that's the case as well. @glwagner if that's the case, should we add a test for it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1481474505
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661:28,Modifiability,variab,variable,28,"We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if netCDF allows unicode (and because I felt it was outside of the scope of that PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:501,Availability,down,downside,501,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:607,Energy Efficiency,meter,meters,607,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:30,Modifiability,variab,variable,30,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516669792:6,Availability,down,downside,6,"> The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates. You mean the convention not only specifies what you have to output but also disallows _additional_ information?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516669792
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516669792:112,Energy Efficiency,meter,meters,112,"> The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates. You mean the convention not only specifies what you have to output but also disallows _additional_ information?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516669792
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516716556:8,Availability,down,downside,8,"> > The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.; > ; > You mean the convention not only specifies what you have to output but also disallows _additional_ information?. I had interpreted something as saying that it puts limits on the metadata in files, but it turns out I misinterpreted. So no, it doesn't disallow anything afaik. I amended my previous statement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516716556
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516716556:114,Energy Efficiency,meter,meters,114,"> > The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.; > ; > You mean the convention not only specifies what you have to output but also disallows _additional_ information?. I had interpreted something as saying that it puts limits on the metadata in files, but it turns out I misinterpreted. So no, it doesn't disallow anything afaik. I amended my previous statement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516716556
https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-2350933066:300,Usability,simpl,simpler,300,"> I also see that @tomchor has done quite a bit of work with PRs #2652 and #3143. Also happy to help with those. I do see that grid spacings and metrics can be a thorny subject. Between these two, I'd say https://github.com/CliMA/Oceananigans.jl/pull/3143 should probably take priority. It should be simpler and I see it as a bug, which should be fixed. That PR didn't move forward because I unfortunately ran out of time, so feel free to take over it if you want! That said, it's a different issue than the one raised by @glwagner here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-2350933066
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1041987990:312,Availability,mask,mask,312,"`solid_interface` should be the correct function because. `solid_interface(Center(), Center(), Center(), i, j, k, ibg) = solid_node(Center(), Center(), Center(), i, j, k, ibg) = solid_node(i, j, k, ibg)`. (a ""center location"" can either only be fully solid or fully fluid). You are correct that we don't need to mask scalars (also the free surface should not need masking)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1041987990
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1041987990:364,Availability,mask,masking,364,"`solid_interface` should be the correct function because. `solid_interface(Center(), Center(), Center(), i, j, k, ibg) = solid_node(Center(), Center(), Center(), i, j, k, ibg) = solid_node(i, j, k, ibg)`. (a ""center location"" can either only be fully solid or fully fluid). You are correct that we don't need to mask scalars (also the free surface should not need masking)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1041987990
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042477097:112,Availability,mask,mask,112,"Maybe if we want to be defensive we should implement both. 1. A `mask_immersed_cells!`"" function that inserts a mask value into immersed cells. In reality this is just a convenience as noted, perhaps something to do just prior to output but not needed during the course of a computation. 2. An `enforce_impenetrability!` function that takes in the velocity field and enforces no normal flow. This is a necessary component of our time-step. For the implementations we have now, these are identical (thus we use `solid_interface` for both), but that might not be the case in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042477097
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042488498:48,Availability,mask,masking,48,"I agree, also we have to remember to remove the masking of the tracers as that is not required...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042488498
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042492842:59,Availability,mask,masking,59,"Maybe a silly question, but don't we want to allow for the masking of tracers? I'm thinking about #2251, which is trying to mask a tracer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042492842
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042492842:124,Availability,mask,mask,124,"Maybe a silly question, but don't we want to allow for the masking of tracers? I'm thinking about #2251, which is trying to mask a tracer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042492842
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:24,Availability,mask,mask,24,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:419,Availability,mask,mask,419,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:451,Deployability,integrat,integration,451,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:451,Integrability,integrat,integration,451,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066:11,Availability,mask,masking,11,"Right. The masking is ""only"" for things like visualization / inspection of field values. We have implemented (or have tried to implement) a fully featured system for reducing fields in the presence of immersed boundaries; furthermore the tendency functions are ""boundary aware"", so the values of the fields inside the immersed boundaries _should_ be irrelevant. They could be NaN (maybe...). So we don't _need_ the mask for calculations. In fact I think we may want to use `NaN` as the mask value for output, because lots of visualization software (like Makie) will put blanks in for NaN, which is convenient... ?. On #2251 it seems we are basically using the mask to debug `is_immersed`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066:415,Availability,mask,mask,415,"Right. The masking is ""only"" for things like visualization / inspection of field values. We have implemented (or have tried to implement) a fully featured system for reducing fields in the presence of immersed boundaries; furthermore the tendency functions are ""boundary aware"", so the values of the fields inside the immersed boundaries _should_ be irrelevant. They could be NaN (maybe...). So we don't _need_ the mask for calculations. In fact I think we may want to use `NaN` as the mask value for output, because lots of visualization software (like Makie) will put blanks in for NaN, which is convenient... ?. On #2251 it seems we are basically using the mask to debug `is_immersed`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066:486,Availability,mask,mask,486,"Right. The masking is ""only"" for things like visualization / inspection of field values. We have implemented (or have tried to implement) a fully featured system for reducing fields in the presence of immersed boundaries; furthermore the tendency functions are ""boundary aware"", so the values of the fields inside the immersed boundaries _should_ be irrelevant. They could be NaN (maybe...). So we don't _need_ the mask for calculations. In fact I think we may want to use `NaN` as the mask value for output, because lots of visualization software (like Makie) will put blanks in for NaN, which is convenient... ?. On #2251 it seems we are basically using the mask to debug `is_immersed`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066:660,Availability,mask,mask,660,"Right. The masking is ""only"" for things like visualization / inspection of field values. We have implemented (or have tried to implement) a fully featured system for reducing fields in the presence of immersed boundaries; furthermore the tendency functions are ""boundary aware"", so the values of the fields inside the immersed boundaries _should_ be irrelevant. They could be NaN (maybe...). So we don't _need_ the mask for calculations. In fact I think we may want to use `NaN` as the mask value for output, because lots of visualization software (like Makie) will put blanks in for NaN, which is convenient... ?. On #2251 it seems we are basically using the mask to debug `is_immersed`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042507066
https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1043152842:64,Availability,mask,masked,64,"Thanks for the explainations. I like the idea of defaulting the masked regions to `NaN`. Good for plotting and might be helpful to identify if these values are ever used, which of course they shouldn't be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1043152842
https://github.com/CliMA/Oceananigans.jl/issues/2250#issuecomment-1042078861:331,Availability,error,error,331,"The field is defined on the immersed grid. When initializing (and showing) a field you are, under the hood, calculating the mean, max and min and, in the case of an `ImmersedField`, that involves checking where the field is immersed and where it's fluid (to exclude those nodes from the reductions). . In this case it is giving an error because it is trying to evaluate `GridFittedBottom` as a function of `(x, y)` while `seamount2` is a function of `(x, y, z)`. . If you want to have an immersed boundary which is function of `(x, y, z)` you can use `GridFittedBoundary` instead of `GridFittedBottom`. The latter just gives you an elevation under which the grid is immersed (as a function of horizontal coordinates only)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250#issuecomment-1042078861
https://github.com/CliMA/Oceananigans.jl/issues/2250#issuecomment-1042096724:171,Availability,error,error,171,"Thank you @simone-silvestri , that is very helpful. I went back and saw that before I was using `GridFittedBoundary` and not `GridFitttedBottom`, which is what caused the error. I am happy to say that your suggestion does fix the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250#issuecomment-1042096724
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042393276:831,Security,validat,validate,831,"Good idea to do a partial cell Immersed boundary!. weird, from what I see here the `mask_immersed_field!` should work properly. have you tried to do ; ```; struct PartialCellBottom{B, E} <: AbstractGridFittedBoundary; bottom_height :: B; minimum_fractional_partial_Δz :: E; end; ```. Like that it seems to be working for me... ```; julia> grid = RectilinearGrid(size=(1, 1, 10), extent=(1, 1, 1)); 1×1×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> ibg = ImmersedBoundaryGrid(grid, PartialCellBottom((x, y)-> -0.5, 1)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×1×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; with immersed: PartialCellBottom{var""#1#2"", Int64}. julia> c = CenterField(ibg); 1×1×10 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×10 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; └── data: 3×3×12 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:11) with eltype Float64 with indices 0:2×0:2×0:11; └── max=0.0, min=0.0, mean=0.0. julia> fill!(c, 1); 3×3×12 Array{Float64, 3}:; [:, :, 1] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. ;;; … . [:, :, 10] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042393276
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042473526:128,Availability,mask,masking,128,"I guess we have a decision here, but I think `PartialCellBottom` probably deserves to subtype `AbstractGridFittedBoundary`. The masking algorithm is the same... the only additional feature that `PartialCellBottom` brings is a change in the calculation of the vertical cell spacing in the bottommost cell. For example I think the masking of the velocity field is the same for both partial cells and full cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042473526
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042473526:329,Availability,mask,masking,329,"I guess we have a decision here, but I think `PartialCellBottom` probably deserves to subtype `AbstractGridFittedBoundary`. The masking algorithm is the same... the only additional feature that `PartialCellBottom` brings is a change in the calculation of the vertical cell spacing in the bottommost cell. For example I think the masking of the velocity field is the same for both partial cells and full cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042473526
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042484279:312,Availability,mask,mask,312,"But the `solid_interface` function would have to be different right? . I ll give an example:. ```. Solid Fluid; -------.................; | ∘ | ∘ |; f c f c f; i-1 i-1 i i i+1. ```; In this case `z(c[i-1]) < immersed_boundary` (i.e. `solid_interface(f, i, j, k, grid) = true`) but here I think we do not want to mask the normal velocity which resides on `f[i]`. Actually, what are we going to do with that velocity? . I think usually people interpolate using `f[i+1]` and assuming that `u` is zero at the actual immersed boundary (inbetween `c[i-1]` and `f[i]`)....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042484279
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:838,Availability,toler,tolerance,838,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:293,Integrability,interface,interface,293,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:769,Integrability,interface,interface,769,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:1056,Integrability,interface,interface,1056,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:1223,Testability,test,testing,1223,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:151,Usability,clear,clearer,151,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042496635:266,Availability,mask,masking,266,"Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). In that case, then we wouldn't have to change the masking procedure... Maybe another doubt, what do we do if the `α` is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042496635
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042496635:389,Availability,mask,masking,389,"Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). In that case, then we wouldn't have to change the masking procedure... Maybe another doubt, what do we do if the `α` is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042496635
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042496635:414,Availability,mask,mask,414,"Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). In that case, then we wouldn't have to change the masking procedure... Maybe another doubt, what do we do if the `α` is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042496635
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042499178:20,Testability,log,logic,20,I think we will use logic such that `i-1` is not immersed / solid. Only `i-2` is solid. (It'd be better to use `k` here because I think we are talking about the vertical index.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042499178
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042499978:7,Testability,log,logic,7,"So the logic is slightly different for `is_immersed` with `PartialCellBottom`. `is_immersed` is `false` for cells that are ""partially immersed"". It's only `true` for cells that are ""fully immersed"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042499978
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683:102,Availability,mask,masking,102,"> Maybe another doubt, what do we do if the α is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?. We don't mask the partial cells at all. We only mask cells that are fully immersed. There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683:127,Availability,mask,mask,127,"> Maybe another doubt, what do we do if the α is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?. We don't mask the partial cells at all. We only mask cells that are fully immersed. There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683:174,Availability,mask,mask,174,"> Maybe another doubt, what do we do if the α is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?. We don't mask the partial cells at all. We only mask cells that are fully immersed. There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683:213,Availability,mask,mask,213,"> Maybe another doubt, what do we do if the α is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?. We don't mask the partial cells at all. We only mask cells that are fully immersed. There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195:1006,Availability,error,error,1006,"> Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). The two changes are:. 1. A cell `is_immersed` if the _interface above the cell center_ is below the bottom (or nearly so). Actually the precise condition requires using `minimum_fractional_Δz` as noted above; I think we should have something like. ```julia; function is_immersed(i, j, k, ibg); ϵ = Δzᶜᶜᶜ(i, j, k, ibg) * ibg.immersed_boundary.minimum_fractional_Δz; z_above = znode(c, c, f, i, j, k+1, ibg.grid); return z_above - ϵ < get_bottom_height(i, j, k, ibg.grid, ibg.immersed_boundary.bottom_height); end. function get_bottom_height(i, j, k, grid, bottom_height); x, y, z = nodes(c, c, c, i, j, k, grid); return bottom_height(x, y); end. get_bottom_height(i, j, k, grid, bottom_height::AbstractMatrix) = @inbounds bottom_height[i, j]; ```. Should be inspected closely, might be an error... 2. The vertical grid spacings `Δzᶜᶜᶜ` are modified for the cells that are _just above the bottom_ (ie, `is_immersed(k)` is false, but `is_immersed(k-1)` is true). Note that the interface spacings `Δzᶠᶜᶜ` have to take the minimum between the `Δzᶜᶜᶜ` in adjacent cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195:1192,Integrability,interface,interface,1192,"> Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). The two changes are:. 1. A cell `is_immersed` if the _interface above the cell center_ is below the bottom (or nearly so). Actually the precise condition requires using `minimum_fractional_Δz` as noted above; I think we should have something like. ```julia; function is_immersed(i, j, k, ibg); ϵ = Δzᶜᶜᶜ(i, j, k, ibg) * ibg.immersed_boundary.minimum_fractional_Δz; z_above = znode(c, c, f, i, j, k+1, ibg.grid); return z_above - ϵ < get_bottom_height(i, j, k, ibg.grid, ibg.immersed_boundary.bottom_height); end. function get_bottom_height(i, j, k, grid, bottom_height); x, y, z = nodes(c, c, c, i, j, k, grid); return bottom_height(x, y); end. get_bottom_height(i, j, k, grid, bottom_height::AbstractMatrix) = @inbounds bottom_height[i, j]; ```. Should be inspected closely, might be an error... 2. The vertical grid spacings `Δzᶜᶜᶜ` are modified for the cells that are _just above the bottom_ (ie, `is_immersed(k)` is false, but `is_immersed(k-1)` is true). Note that the interface spacings `Δzᶠᶜᶜ` have to take the minimum between the `Δzᶜᶜᶜ` in adjacent cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:301,Availability,mask,masking,301,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:326,Availability,mask,mask,326,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:379,Availability,mask,mask,379,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:418,Availability,mask,mask,418,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:897,Integrability,Message,Message,897,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924:705,Availability,toler,tolerance,705,"I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction. ```; Immersed Fluid; ----------- ...........; | ∘ | ∘; f c f c; k-1 k-1 k k; ```; My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The grid fitted problem as a special case where the height in the immersed cell is 0, where as in partial cells it can be anything above zero and up to the top of that cell (or within a tolerance). I hope that we can use the same functions for both, otherwise, much more confusion can arise and I am glad we are having this discussion. Thank you @jm-c for the comment. I will now change the default to 0.1, since that's what is currently used. I presume this means we don't don't want to have partial cells that are in the bottom 20% of the cell or the top 20% of the cell as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924:499,Integrability,interface,interface,499,"I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction. ```; Immersed Fluid; ----------- ...........; | ∘ | ∘; f c f c; k-1 k-1 k k; ```; My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The grid fitted problem as a special case where the height in the immersed cell is 0, where as in partial cells it can be anything above zero and up to the top of that cell (or within a tolerance). I hope that we can use the same functions for both, otherwise, much more confusion can arise and I am glad we are having this discussion. Thank you @jm-c for the comment. I will now change the default to 0.1, since that's what is currently used. I presume this means we don't don't want to have partial cells that are in the bottom 20% of the cell or the top 20% of the cell as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605:558,Integrability,interface,interface,558,"> I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction.; > ; > ; > ; > ```; > ; > Immersed Fluid; > ; > ----------- ...........; > ; > | ∘ | ∘; > ; > f c f c; > ; > k-1 k-1 k k; > ; > ```; > ; > My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The question is where bottom_height lies in these diagrams. GridFittedBottom is not a limiting case of PartialCellBottom in the way we have coded it, because GridFittedBottom uses the cell center to determine whether the cell is immersed or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043162822:366,Availability,down,down,366,"Thanks @glwagner . I think that `PartialCellBottom` should also use the cell center to determine if a cell is immersed or not. I agree that `GrifFittedBottom` is not a limiting case right now but it would be nice if we get this as a limit of `PartialCellBottom`. We could do this by instead of using the depth in the centre, we use the depth in the center truncated down to the lower cell. Something I will try and keep in mind as we move forward.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043162822
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043168552:383,Availability,down,down,383,"> Thanks @glwagner . I think that `PartialCellBottom` should also use the cell center to determine if a cell is immersed or not.; > ; > ; > ; > I agree that `GrifFittedBottom` is not a limiting case right now but it would be nice if we get this as a limit of `PartialCellBottom`. We could do this by instead of using the depth in the centre, we use the depth in the center truncated down to the lower cell. Something I will try and keep in mind as we move forward. If we use . bottom_height(x, y) > znode(c, c, f, i, j, k, grid). As criteria, then GridFittedBottom is a limiting case when the minimum fractional height is 1.0. But this doesn't seem like a sensible formulation for GridFittedBottom. Why do we want them to be limited cases of each other?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043168552
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044501306:1413,Availability,avail,available,1413,"> It seems to me that both methods are trying to do the same thing.; > ; > They both identify a cell that the topopgraphy passes through and picks a height to represent the topogrpahy, and it should be the same cell. In the partial cell method we find the height to be something between the bottom and the top of that cell. The grid fitted boundary used the bottom (or the top, if I'm mistaken).; > ; > If they are both doing the same thing and the only differences is the particular height we assign, then do we want to have two completely different methods? Instead we could have one general method that allows for the two (or more) options.; > ; > We might want to have different options on how to pick the height of the topography.; > ; > 1. Bottom of the cell (GridFittedBoundary); > 2. Top of the cell; > 3. Midpoint rule (2nd order approximation, and what I am currently playing with); > 4. Simpsons rule (4th order approxiamtion, and not that much harder to do).; > ; > If it's not that much more effort then why wouldn't we want to give the user a choice in how to represent the topogrpahy?; > ; > Also, one method would be less to maintain, I would think, when we decide what that method should be and code it up.; > ; > This is just a suggestion and I am of course happy to follow whatever people decide is best moving forward. I think generalizing `GridFittedBottom` so that we have different methods available to identify the ""height of a cell"" is a nice idea. Using `bottom_height` evaluated at cell centers is a low-order method in a sense. So we can have higher-order methods available. You can add a property to `GridFittedBottom` that allows the user to control that behavior, something like `height_model` (although I hate the word ""model"" so maybe there's a better name).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044501306
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044501306:1592,Availability,avail,available,1592,"> It seems to me that both methods are trying to do the same thing.; > ; > They both identify a cell that the topopgraphy passes through and picks a height to represent the topogrpahy, and it should be the same cell. In the partial cell method we find the height to be something between the bottom and the top of that cell. The grid fitted boundary used the bottom (or the top, if I'm mistaken).; > ; > If they are both doing the same thing and the only differences is the particular height we assign, then do we want to have two completely different methods? Instead we could have one general method that allows for the two (or more) options.; > ; > We might want to have different options on how to pick the height of the topography.; > ; > 1. Bottom of the cell (GridFittedBoundary); > 2. Top of the cell; > 3. Midpoint rule (2nd order approximation, and what I am currently playing with); > 4. Simpsons rule (4th order approxiamtion, and not that much harder to do).; > ; > If it's not that much more effort then why wouldn't we want to give the user a choice in how to represent the topogrpahy?; > ; > Also, one method would be less to maintain, I would think, when we decide what that method should be and code it up.; > ; > This is just a suggestion and I am of course happy to follow whatever people decide is best moving forward. I think generalizing `GridFittedBottom` so that we have different methods available to identify the ""height of a cell"" is a nice idea. Using `bottom_height` evaluated at cell centers is a low-order method in a sense. So we can have higher-order methods available. You can add a property to `GridFittedBottom` that allows the user to control that behavior, something like `height_model` (although I hate the word ""model"" so maybe there's a better name).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044501306
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044676773:61,Availability,error,errors,61,"We can run our attempts at a partial cell method without any errors. :). Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea. As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. . I'll share our results later on and maybe that will help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044676773
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044676773:332,Availability,toler,tolerance,332,"We can run our attempts at a partial cell method without any errors. :). Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea. As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. . I'll share our results later on and maybe that will help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044676773
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044676773:161,Testability,test,tests,161,"We can run our attempts at a partial cell method without any errors. :). Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea. As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. . I'll share our results later on and maybe that will help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044676773
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063:129,Availability,toler,tolerance,129,"> As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. The only change to existing code you need is a new property in `GridFittedBottom`. Then the current methods are the fallback (default), and we extend behavior by defining new functions for specific cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063:413,Modifiability,extend,extend,413,"> As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. The only change to existing code you need is a new property in `GridFittedBottom`. Then the current methods are the fallback (default), and we extend behavior by defining new functions for specific cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608:63,Availability,error,errors,63,"> We can run our attempts at a partial cell method without any errors. :); > ; > Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea.; > ; > As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like.; > ; > I'll share our results later on and maybe that will help. Great development! I'm excited to see the results! It's great if we can have a better way to represent bathymetry, as deep cells are usually very coarse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608:347,Availability,toler,tolerance,347,"> We can run our attempts at a partial cell method without any errors. :); > ; > Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea.; > ; > As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like.; > ; > I'll share our results later on and maybe that will help. Great development! I'm excited to see the results! It's great if we can have a better way to represent bathymetry, as deep cells are usually very coarse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608:169,Testability,test,tests,169,"> We can run our attempts at a partial cell method without any errors. :); > ; > Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea.; > ; > As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like.; > ; > I'll share our results later on and maybe that will help. Great development! I'm excited to see the results! It's great if we can have a better way to represent bathymetry, as deep cells are usually very coarse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608
https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1057168071:201,Testability,test,tests,201,"With help from @glwagner , I believe we have a partial cell method in this branch [here](https://github.com/CliMA/Oceananigans.jl/tree/fjp/partial_cell_immersed_boundaries). . We are going to run some tests to make sure that everything is behaving as normal but wanted to give you an udpate. Hopefully have something to review soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1057168071
https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044425297:31,Testability,benchmark,benchmark,31,I don't thinks so. I'll try to benchmark it,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044425297
https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044487498:160,Deployability,update,update,160,"> Does this have advantages in terms of speed?. I think we hope the code is similar under the hood but it's hard to say without knowing more about Tullio. This update is more general though, because it will work out of the box on distributed systems / multiple GPUs / multi region scenarios like the cubed sphere (because we will support reductions for those cases).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044487498
https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044694374:84,Usability,learn,learn,84,"I admit that I had to look up [Tullio.jl](https://github.com/mcabbott/Tullio.jl) to learn that it helps with matrix operations. Good for me to know, but if it's going away then maybe no longer essential. I gather that `abs` is being replaced with another version. Where does the new version come from?. Also, I remember a while ago having issues with computing norms on GPUs. Does this help with that at all?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044694374
https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997:20,Modifiability,refactor,refactored,20,"@simone-silvestri I refactored the CFL calculation so that we only have one function all the time, rather than one ""ordinary"" and one ""accurate"". The tests still fail though. I'm not totally sure why, but I am somewhat confused how this is supposed to work on a staggered grid. I don't think we can apply wikipedia's definition; we need the definition that's correct for a C grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997
https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997:150,Testability,test,tests,150,"@simone-silvestri I refactored the CFL calculation so that we only have one function all the time, rather than one ""ordinary"" and one ""accurate"". The tests still fail though. I'm not totally sure why, but I am somewhat confused how this is supposed to work on a staggered grid. I don't think we can apply wikipedia's definition; we need the definition that's correct for a C grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997
https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1416920362:61,Safety,avoid,avoid,61,"I think the conclusion is that we need to use `mapreduce` to avoid Tullio, but we can't use `AbstractOperations` (because the CFL formula involves an operation between fields at different locations, which `AbstractOperations` are not designed to do)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1416920362
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1044754993:559,Usability,simpl,simplest,559,"> I am trying to follow the code, and sorry that it's not obvious to me what's goipartition = XPartition([3, 3, 3, 3])ng on.; > ; > Because you have `devices=(0,1)`, I presume that means you are running on two GPUs?; > ; > But you also have `partition = XPartition([3, 3, 3, 3])`, which seems like you are partitioning it onto 4 regions, each of length 3, which sum to 12 (the length of the domain).; > ; > If you have two devices, wouldn't you normally have two partitions and not four?. We want to allow general partitioning across devices. For example the simplest implementation of the cubed sphere is a 6 region domain, but we won't always have 6 devices. The question to ask is not what our ""usual"" case is, but rather what the most general case that we want to support looks like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1044754993
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:324,Availability,mainten,maintenance,324,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:815,Energy Efficiency,adapt,adapt,815,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:475,Integrability,depend,dependencies,475,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:1027,Integrability,depend,dependency,1027,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:600,Modifiability,refactor,refactoring,600,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:815,Modifiability,adapt,adapt,815,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:847,Modifiability,polymorphi,polymorphism,847,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:1062,Usability,user experience,user experience,1062,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:1565,Usability,simpl,simplify,1565,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1064674270:0,Deployability,Update,Update,0,"Update:. the module is functional for `ExplicitFreeSurface` `Periodic` models in x. ; There is still to address the `Face` fields in a `Bounded` direction that i am going to deal with by introducing a `Connected{LeftTopology, RightTopology}` topology. . The code is not at its maximum efficiency because we would have to restructure the `fill_halo_regions` function such that if we pass a tuple of fields they are done all at the same time (i.e., `fill_halo_west_east`, `north_south` and `top_bottom` for all the fields instead of doing them sequentially per field). This requires defining `fill_halo_west_east`, `fill_halo_north_south` and `top_bottom` for tuples. This said on a fairly large grid (`512²×30`) I get an efficiency of 78% going from 1 to 2 GPUs. I think restructuring the `fill_halo` will allow us to have decent efficiency with multi GPU on one node (at least before we start talking about implicit solvers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1064674270
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:39,Security,validat,validation,39,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:140,Security,validat,validation,140,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:165,Security,validat,validation,165,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:217,Security,validat,validation,217,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:50,Testability,test,tests,50,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:151,Testability,test,tests,151,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:228,Testability,test,tests,228,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:301,Testability,test,tests,301,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:353,Testability,test,tests,353,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:1635,Performance,perform,performance,1635,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:27,Security,validat,validation,27,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:191,Security,validat,validation,191,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:38,Testability,test,test,38,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:16,Usability,simpl,simple,16,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107950812:143,Availability,down,down,143,"Update: https://github.com/CliMA/Oceananigans.jl/pull/2253/commits/a3c297bec11791e4080f62f1d7649c4f880f7c3e brings the 128^2 multi-region time down to 6.8 s, but I think there's still a ways to go. Next up is to figure out whether communication matters at all for this timing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107950812
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107950812:0,Deployability,Update,Update,0,"Update: https://github.com/CliMA/Oceananigans.jl/pull/2253/commits/a3c297bec11791e4080f62f1d7649c4f880f7c3e brings the 128^2 multi-region time down to 6.8 s, but I think there's still a ways to go. Next up is to figure out whether communication matters at all for this timing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107950812
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108512590:71,Testability,benchmark,benchmark,71,"If the solutions are the same, you can try removing the `fill_halo` to benchmark the implementation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108512590
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966:337,Security,validat,validation,337,"@francispoulin yes, it is serial on the CPUs. The halos are indeed 3 for the `WENO5`, but if we use a vector invariant weno formulation (so we are interpolating vorticity) we need 4 halos because calculating vorticity itself requires one halo. @glwagner there is a type inference issue with `getregion(model, 1)` (you can see it in your validation test also). I think, solving that, the only overhead will be the `fill_halo` (and launching multiple kernels which maybe will not affect too much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966:348,Testability,test,test,348,"@francispoulin yes, it is serial on the CPUs. The halos are indeed 3 for the `WENO5`, but if we use a vector invariant weno formulation (so we are interpolating vorticity) we need 4 halos because calculating vorticity itself requires one halo. @glwagner there is a type inference issue with `getregion(model, 1)` (you can see it in your validation test also). I think, solving that, the only overhead will be the `fill_halo` (and launching multiple kernels which maybe will not affect too much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1111318176:0,Deployability,Update,Update,0,"Update on the `multi_region_turbulence.jl` benchmark with `ExplicitFreeSurface`, alternating the `getregion` function with a `getregion_inner` to force compilation (thanks @glwagner); (ran on tartarus' CPU). | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 11.6 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 16.7 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 47.4 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 48.4 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 190.9 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 183.2 s |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1111318176
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1111318176:43,Testability,benchmark,benchmark,43,"Update on the `multi_region_turbulence.jl` benchmark with `ExplicitFreeSurface`, alternating the `getregion` function with a `getregion_inner` to force compilation (thanks @glwagner); (ran on tartarus' CPU). | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 11.6 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 16.7 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 47.4 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 48.4 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 190.9 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 183.2 s |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1111318176
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1111655708:90,Testability,test,tests,90,The results in the table above were run on one `GPU` I gather. Are we planning to do some tests on 2 and 4 GPU's to see how fast they are?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1111655708
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1112117583:56,Testability,benchmark,benchmarking,56,"Actually, this was on 1 CPU. I ll do some more in depth benchmarking today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1112117583
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1112150831:58,Testability,benchmark,benchmarking,58,"> Actually, this was on 1 CPU. I ll do some more in depth benchmarking today. Thanks for explaining and great!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1112150831
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:63,Availability,ERROR,ERROR,63,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:99,Availability,ERROR,ERROR,99,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:314,Availability,error,error,314,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:90,Security,access,access,90,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:51,Testability,test,tests,51,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:234,Testability,test,tests,234,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:73,Availability,ERROR,ERROR,73,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:111,Availability,ERROR,ERROR,111,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:336,Availability,error,error,336,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:100,Security,access,access,100,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:53,Testability,test,tests,53,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:256,Testability,test,tests,256,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:387,Testability,test,tests,387,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115097251:47,Testability,test,tests,47,"I think it might have been with the regression tests in #2035, I am not sure how we solved it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115097251
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116006280:155,Safety,Avoid,Avoid,155,Finally all type issues have been resolved using three different fixes; - Ensure that `apply_regionally!` and `construct_regionally` are always inlined; - Avoid any Generator in the `getregion` function but explicitly pass arguments to it by using metaprogramming to input the correct expression; - Use alternating inner and outer `getregion` to force compilation through recursive use; - For `Tuple`s force compilation by recursive getregion based on tuple's size,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116006280
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:79,Availability,down,down,79,A little benchmarking to make sure that the single grid models have not slowed down in the process...; #### Main; ```; NonhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.775 ms │ 2.790 ms │ 2.823 ms │ 3.051 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 64 │ 20.168 ms │ 20.463 ms │ 20.409 ms │ 20.515 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 128 │ 211.542 ms │ 211.646 ms │ 211.700 ms │ 212.026 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 256 │ 2.511 s │ 2.532 s │ 2.532 s │ 2.552 s │ 520.84 KiB │ 1044 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.195 ms │ 1.205 ms │ 1.254 ms │ 1.626 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 64 │ 2.041 ms │ 2.051 ms │ 2.100 ms │ 2.503 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 128 │ 5.778 ms │ 5.833 ms │ 5.873 ms │ 6.254 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 256 │ 23.662 ms │ 23.740 ms │ 23.730 ms │ 23.840 ms │ 830.98 KiB │ 1831 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬───────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:9,Testability,benchmark,benchmarking,9,A little benchmarking to make sure that the single grid models have not slowed down in the process...; #### Main; ```; NonhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.775 ms │ 2.790 ms │ 2.823 ms │ 3.051 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 64 │ 20.168 ms │ 20.463 ms │ 20.409 ms │ 20.515 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 128 │ 211.542 ms │ 211.646 ms │ 211.700 ms │ 212.026 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 256 │ 2.511 s │ 2.532 s │ 2.532 s │ 2.552 s │ 520.84 KiB │ 1044 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.195 ms │ 1.205 ms │ 1.254 ms │ 1.626 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 64 │ 2.041 ms │ 2.051 ms │ 2.100 ms │ 2.503 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 128 │ 5.778 ms │ 5.833 ms │ 5.873 ms │ 6.254 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 256 │ 23.662 ms │ 23.740 ms │ 23.730 ms │ 23.840 ms │ 830.98 KiB │ 1831 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬───────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:139,Testability,benchmark,benchmarks,139,A little benchmarking to make sure that the single grid models have not slowed down in the process...; #### Main; ```; NonhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.775 ms │ 2.790 ms │ 2.823 ms │ 3.051 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 64 │ 20.168 ms │ 20.463 ms │ 20.409 ms │ 20.515 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 128 │ 211.542 ms │ 211.646 ms │ 211.700 ms │ 212.026 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 256 │ 2.511 s │ 2.532 s │ 2.532 s │ 2.552 s │ 520.84 KiB │ 1044 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.195 ms │ 1.205 ms │ 1.254 ms │ 1.626 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 64 │ 2.041 ms │ 2.051 ms │ 2.100 ms │ 2.503 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 128 │ 5.778 ms │ 5.833 ms │ 5.873 ms │ 6.254 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 256 │ 23.662 ms │ 23.740 ms │ 23.730 ms │ 23.840 ms │ 830.98 KiB │ 1831 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬───────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:1023,Testability,benchmark,benchmarks,1023,nhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.775 ms │ 2.790 ms │ 2.823 ms │ 3.051 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 64 │ 20.168 ms │ 20.463 ms │ 20.409 ms │ 20.515 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 128 │ 211.542 ms │ 211.646 ms │ 211.700 ms │ 212.026 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 256 │ 2.511 s │ 2.532 s │ 2.532 s │ 2.552 s │ 520.84 KiB │ 1044 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.195 ms │ 1.205 ms │ 1.254 ms │ 1.626 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 64 │ 2.041 ms │ 2.051 ms │ 2.100 ms │ 2.503 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 128 │ 5.778 ms │ 5.833 ms │ 5.873 ms │ 6.254 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 256 │ 23.662 ms │ 23.740 ms │ 23.730 ms │ 23.840 ms │ 830.98 KiB │ 1831 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├────────────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:1882,Testability,benchmark,benchmarks,1882,──┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.195 ms │ 1.205 ms │ 1.254 ms │ 1.626 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 64 │ 2.041 ms │ 2.051 ms │ 2.100 ms │ 2.503 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 128 │ 5.778 ms │ 5.833 ms │ 5.873 ms │ 6.254 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 256 │ 23.662 ms │ 23.740 ms │ 23.730 ms │ 23.840 ms │ 830.98 KiB │ 1831 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼──────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 702.250 μs │ 750.875 μs │ 800.300 μs │ 1.115 ms │ 846.23 KiB │ 1475 │ 10 │; │ CPU │ Float64 │ 64 │ 1.085 ms │ 1.128 ms │ 1.140 ms │ 1.313 ms │ 846.23 KiB │ 1475 │ 10 │; │ CPU │ Float64 │ 128 │ 2.628 ms │ 2.718 ms │ 2.725 ms │ 2.901 ms │ 846.23 KiB │ 1475 │ 10 │; │ CPU │ Float64 │ 256 │ 8.693 ms │ 8.740 ms │ 8.766 ms │ 9.044 ms │ 846.23 KiB │ 1475 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴──────────┴────────────┴────────┴─────────┘; ```; #### this PR; ```; NonhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:2775,Testability,benchmark,benchmarks,2775,wWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼──────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 702.250 μs │ 750.875 μs │ 800.300 μs │ 1.115 ms │ 846.23 KiB │ 1475 │ 10 │; │ CPU │ Float64 │ 64 │ 1.085 ms │ 1.128 ms │ 1.140 ms │ 1.313 ms │ 846.23 KiB │ 1475 │ 10 │; │ CPU │ Float64 │ 128 │ 2.628 ms │ 2.718 ms │ 2.725 ms │ 2.901 ms │ 846.23 KiB │ 1475 │ 10 │; │ CPU │ Float64 │ 256 │ 8.693 ms │ 8.740 ms │ 8.766 ms │ 9.044 ms │ 846.23 KiB │ 1475 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴──────────┴────────────┴────────┴─────────┘; ```; #### this PR; ```; NonhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.910 ms │ 2.939 ms │ 2.978 ms │ 3.237 ms │ 531.84 KiB │ 1061 │ 10 │; │ CPU │ Float64 │ 64 │ 20.486 ms │ 20.627 ms │ 20.772 ms │ 22.253 ms │ 531.84 KiB │ 1061 │ 10 │; │ CPU │ Float64 │ 128 │ 194.118 ms │ 194.567 ms │ 194.744 ms │ 196.546 ms │ 531.84 KiB │ 1061 │ 10 │; │ CPU │ Float64 │ 256 │ 2.632 s │ 2.659 s │ 2.659 s │ 2.686 s │ 531.84 KiB │ 1061 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:3659,Testability,benchmark,benchmarks,3659,nhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.910 ms │ 2.939 ms │ 2.978 ms │ 3.237 ms │ 531.84 KiB │ 1061 │ 10 │; │ CPU │ Float64 │ 64 │ 20.486 ms │ 20.627 ms │ 20.772 ms │ 22.253 ms │ 531.84 KiB │ 1061 │ 10 │; │ CPU │ Float64 │ 128 │ 194.118 ms │ 194.567 ms │ 194.744 ms │ 196.546 ms │ 531.84 KiB │ 1061 │ 10 │; │ CPU │ Float64 │ 256 │ 2.632 s │ 2.659 s │ 2.659 s │ 2.686 s │ 531.84 KiB │ 1061 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.157 ms │ 1.182 ms │ 1.220 ms │ 1.607 ms │ 784.72 KiB │ 1801 │ 10 │; │ CPU │ Float64 │ 64 │ 2.152 ms │ 2.298 ms │ 2.342 ms │ 2.857 ms │ 784.72 KiB │ 1801 │ 10 │; │ CPU │ Float64 │ 128 │ 5.851 ms │ 6.036 ms │ 6.061 ms │ 6.579 ms │ 784.72 KiB │ 1801 │ 10 │; │ CPU │ Float64 │ 256 │ 24.192 ms │ 24.634 ms │ 24.702 ms │ 25.757 ms │ 784.72 KiB │ 1801 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:4518,Testability,benchmark,benchmarks,4518,────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.157 ms │ 1.182 ms │ 1.220 ms │ 1.607 ms │ 784.72 KiB │ 1801 │ 10 │; │ CPU │ Float64 │ 64 │ 2.152 ms │ 2.298 ms │ 2.342 ms │ 2.857 ms │ 784.72 KiB │ 1801 │ 10 │; │ CPU │ Float64 │ 128 │ 5.851 ms │ 6.036 ms │ 6.061 ms │ 6.579 ms │ 784.72 KiB │ 1801 │ 10 │; │ CPU │ Float64 │ 256 │ 24.192 ms │ 24.634 ms │ 24.702 ms │ 25.757 ms │ 784.72 KiB │ 1801 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 724.125 μs │ 758.812 μs │ 776.933 μs │ 945.958 μs │ 861.19 KiB │ 1499 │ 10 │; │ CPU │ Float64 │ 64 │ 1.111 ms │ 1.208 ms │ 1.210 ms │ 1.382 ms │ 861.19 KiB │ 1499 │ 10 │; │ CPU │ Float64 │ 128 │ 2.780 ms │ 2.863 ms │ 2.871 ms │ 3.150 ms │ 861.19 KiB │ 1499 │ 10 │; │ CPU │ Float64 │ 256 │ 8.750 ms │ 8.789 ms │ 8.822 ms │ 9.075 ms │ 861.19 KiB │ 1499 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; ```. There are some small differences... I have fiddled a little with the `fill_halo_regions` and the boundary conditions so it might explain that. The BC will be completely overhauled with #2477 so there is nothing to worry about,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116134666:6,Performance,Perform,Performance,6,Nice! Performance differences could be noise too. Is it possible to say what the changes to fill halo regions were? Just in case #2477 takes longer than expected?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116134666
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545:420,Performance,perform,performance,420,"Just some restructuring of the `fill_halo_regions!` to allow the application of `apply_regionally!` to the directional fill_halo.; The `fill_halo_regions!` looks like this; ```; halo_tuple = permute_boundary_conditions(boundary_conditions); ; for task = 1:3; barrier = device_event(arch); fill_halo_event!(task, halo_tuple, c, loc, arch, barrier, grid, args...; kwargs...); end; ```; this should actually not change the performance... but I guess it will change completely since we will not want a loop over halo events anymore, neither to permute BCs.; There are differences in the `HydrostaticFreeSurfaceModel` where I lumped all the `fill_halo_regions` together and exposed a little bit of parallelism, and in the `QuasiAdamsBashforthTimeStepper` which might affect the `NonhydrostaticModel` benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545:669,Security,expose,exposed,669,"Just some restructuring of the `fill_halo_regions!` to allow the application of `apply_regionally!` to the directional fill_halo.; The `fill_halo_regions!` looks like this; ```; halo_tuple = permute_boundary_conditions(boundary_conditions); ; for task = 1:3; barrier = device_event(arch); fill_halo_event!(task, halo_tuple, c, loc, arch, barrier, grid, args...; kwargs...); end; ```; this should actually not change the performance... but I guess it will change completely since we will not want a loop over halo events anymore, neither to permute BCs.; There are differences in the `HydrostaticFreeSurfaceModel` where I lumped all the `fill_halo_regions` together and exposed a little bit of parallelism, and in the `QuasiAdamsBashforthTimeStepper` which might affect the `NonhydrostaticModel` benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545:795,Testability,benchmark,benchmarks,795,"Just some restructuring of the `fill_halo_regions!` to allow the application of `apply_regionally!` to the directional fill_halo.; The `fill_halo_regions!` looks like this; ```; halo_tuple = permute_boundary_conditions(boundary_conditions); ; for task = 1:3; barrier = device_event(arch); fill_halo_event!(task, halo_tuple, c, loc, arch, barrier, grid, args...; kwargs...); end; ```; this should actually not change the performance... but I guess it will change completely since we will not want a loop over halo events anymore, neither to permute BCs.; There are differences in the `HydrostaticFreeSurfaceModel` where I lumped all the `fill_halo_regions` together and exposed a little bit of parallelism, and in the `QuasiAdamsBashforthTimeStepper` which might affect the `NonhydrostaticModel` benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116489219:857,Performance,optimiz,optimize,857,On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation); Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1024×1024×100`| `RectilinearGrid` | 1 | 3.4 minutes | 100% |; | `1024×1024×100`| `MultiRegionGrid` | 2 | 1.9 minutes | 89.5% | ; | `1440×600×48`| `RectilinearGrid` | 1 | 1.4 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 49.2 seconds | 85.4% |; | `1440×600×48`| `MultiRegionGrid` | 3 | 38.8 seconds | 72.2% |. Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116489219
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116489219:124,Testability,benchmark,benchmark,124,On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation); Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1024×1024×100`| `RectilinearGrid` | 1 | 3.4 minutes | 100% |; | `1024×1024×100`| `MultiRegionGrid` | 2 | 1.9 minutes | 89.5% | ; | `1440×600×48`| `RectilinearGrid` | 1 | 1.4 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 49.2 seconds | 85.4% |; | `1440×600×48`| `MultiRegionGrid` | 3 | 38.8 seconds | 72.2% |. Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116489219
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325:782,Performance,optimiz,optimize,782,> On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation) Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling; > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1024×1024×100`	`RectilinearGrid`	1	3.4 minutes	100%; > `1024×1024×100`	`MultiRegionGrid`	2	1.9 minutes	89.5%; > `1440×600×48`	`RectilinearGrid`	1	1.4 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	49.2 seconds	85.4%; > `1440×600×48`	`MultiRegionGrid`	3	38.8 seconds	72.2%; > Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU. Nice results though! Is this for implicit or explicit free surface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325:126,Testability,benchmark,benchmark,126,> On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation) Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling; > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1024×1024×100`	`RectilinearGrid`	1	3.4 minutes	100%; > `1024×1024×100`	`MultiRegionGrid`	2	1.9 minutes	89.5%; > `1440×600×48`	`RectilinearGrid`	1	1.4 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	49.2 seconds	85.4%; > `1440×600×48`	`MultiRegionGrid`	3	38.8 seconds	72.2%; > Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU. Nice results though! Is this for implicit or explicit free surface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634:40,Modifiability,extend,extend,40,"This is for explicit free surface, I ll extend the benchmarks for implicit and weak scaling",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634:51,Testability,benchmark,benchmarks,51,"This is for explicit free surface, I ll extend the benchmarks for implicit and weak scaling",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116777025:27,Performance,perform,performed,27,"This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct). #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.37 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.05 minutes | 65.2% |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116777025
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116777025:17,Testability,benchmark,benchmark,17,"This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct). #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.37 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.05 minutes | 65.2% |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116777025
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:840,Availability,reliab,reliable,840,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:29,Performance,perform,performed,29,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:19,Testability,benchmark,benchmark,19,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:874,Testability,benchmark,benchmarking,874,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Energy Efficiency,Adapt,Adapt,1787,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1547,Integrability,depend,depends,1547,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Modifiability,Adapt,Adapt,1787,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:781,Performance,optimiz,optimization,781,"Using ; ```; grid = RectilinearGrid(arch, size=(Nx, Ny, Nz), halo=(4, 4, 4), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)). bottom = zeros(Nx, Ny); bound = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1612,Performance,Perform,Perform,1612,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:2052,Performance,Optimiz,Optimize,2052,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:814,Testability,benchmark,benchmarking,814,"Using ; ```; grid = RectilinearGrid(arch, size=(Nx, Ny, Nz), halo=(4, 4, 4), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)). bottom = zeros(Nx, Ny); bound = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1636,Testability,benchmark,benchmarking,1636,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116857309:470,Performance,optimiz,optimized,470,That's awesome @simone-silvestri. Great work!. A couple of questions:. > - Design correct OutputWriters and OutputReaders for MultiRegionFields. Does this mean that the code with multi-grid doesn't have the ability to output things at the moment? Or does it output to one file per region/GPU?. > - Implement a multi-region version of the Nonhydrostatic pressure solver. So I take that a nonhydrostatic pressure solver for multi-grid isn't defined yet? Or is it just non-optimized (but will run)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116857309
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842:1167,Deployability,update,updated,1167,"@tomchor, I haven't implemented `MultiRegion` for `NonhydrostaticModel` yet. It would be quite easy to extent it if it weren't for the pressure solver which is done in two different ways and both of them are global (`FFT` and `TridiagonalFFT`). A quick and dirty solution would be to do as I have done with the `ImplicitFreeSurface` and reserve the calculation on 1 GPU only. The problem is that the pressure solve is 3D and not 2D so we would probably like to use the `cuFFT` multi-gpu functionality (in particular the cuFFTxt library, which I hope is implemented in `CUDA.jl` although I haven't checked yet) I ll open a PR to start implementing it. Regarding the `OutputWriters`, they are implemented in jld2 trivially with `reconstruct_global_field`. ; You can specify a `JLDOutputWriter` as you do for a single region grid, provided you don't want to slice the direction across the regions ; for example you cannot do; ```; indices = (1:10, :, :) ; ```; for an `XPartition` or ; ```; indices = (:, 1:10, :); ```; for a `YPartition`; (`MultiRegion` does not play well with `indices` at the moment). . It runs, but there is a weird bug for which the fields are not updated as the model timesteps (i.e., all the outputs are the initial condition). I think it is easily solvable but I have to take a deeper look. So basically, it is not working at the moment... On the other hand, to anticipate the `CubedSphere` refactor, we probably want to have `OutputWriters` which output all regions separately (as `reconstruct_global_field` does not mean much in a cubed sphere context). The `OutputReaders`, on the other hand, are completely undefined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842:1413,Modifiability,refactor,refactor,1413,"@tomchor, I haven't implemented `MultiRegion` for `NonhydrostaticModel` yet. It would be quite easy to extent it if it weren't for the pressure solver which is done in two different ways and both of them are global (`FFT` and `TridiagonalFFT`). A quick and dirty solution would be to do as I have done with the `ImplicitFreeSurface` and reserve the calculation on 1 GPU only. The problem is that the pressure solve is 3D and not 2D so we would probably like to use the `cuFFT` multi-gpu functionality (in particular the cuFFTxt library, which I hope is implemented in `CUDA.jl` although I haven't checked yet) I ll open a PR to start implementing it. Regarding the `OutputWriters`, they are implemented in jld2 trivially with `reconstruct_global_field`. ; You can specify a `JLDOutputWriter` as you do for a single region grid, provided you don't want to slice the direction across the regions ; for example you cannot do; ```; indices = (1:10, :, :) ; ```; for an `XPartition` or ; ```; indices = (:, 1:10, :); ```; for a `YPartition`; (`MultiRegion` does not play well with `indices` at the moment). . It runs, but there is a weird bug for which the fields are not updated as the model timesteps (i.e., all the outputs are the initial condition). I think it is easily solvable but I have to take a deeper look. So basically, it is not working at the moment... On the other hand, to anticipate the `CubedSphere` refactor, we probably want to have `OutputWriters` which output all regions separately (as `reconstruct_global_field` does not mean much in a cubed sphere context). The `OutputReaders`, on the other hand, are completely undefined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059:106,Modifiability,extend,extending,106,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059
https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059:453,Usability,simpl,simpler,453,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059
https://github.com/CliMA/Oceananigans.jl/issues/2258#issuecomment-1479948285:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2258#issuecomment-1479948285
https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516:56,Integrability,depend,depend,56,"Or perhaps write a separate `euler_step!` that does not depend on special values of `χ`. Not sure if that would have an extra GPU cost. But even if so, it'll only be for one time-step, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516
https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046340015:176,Availability,robust,robust,176,"The problem with a separate `euler_step!` is that we might have to define it for a few different models. Another possibility is zero out `G-` if `euler == true`. If `euler` is robust then we don't need to zero it in `reset!`, though we could do that too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046340015
https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764:241,Integrability,interface,interface,241,"A few ideas:. 1) If we're doing an euler step, zero out the `G⁻` tendencies beforehand. 2) Put an if statement in to take `euler_step!` rather than `ab2_step!`. The problem with 2) is that we haven't figured out how to abstract the stepping interface to handle different models. Basically, we don't really have an generic PDE time-stepper. Instead we have manually implemented time-stepping schemes for the different models; for example:. https://github.com/CliMA/Oceananigans.jl/blob/383e5b60ca8d3bfb3c8497b11b6be30946a25728/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L14-L36. Thus to achieve 2) we'll probably have to write an `euler_step!` for the hydrostatic free surface model. Maybe not a problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764
https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046351867:6,Testability,test,test,6,Now a test ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046351867
https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046388403:22,Testability,test,test,22,"I'm trying to write a test. But, while on **`main`** branch:. ```julia; julia> using Oceananigans. julia> model = HydrostaticFreeSurfaceModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 2, 3)),; buoyancy = BuoyancyTracer(),; tracers = (:b, :e)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:b, :e); ├── closure: Nothing; ├── buoyancy: Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}; ├── free surface: ExplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; └── coriolis: Nothing. julia> model.timestepper.Gⁿ.η[1, 1, 1]; 0.0. julia> model.timestepper.G⁻.η[1, 1, 1]; 0.0. julia> model.timestepper.G⁻.η[1, 1, 1] = NaN; NaN. julia> time_step!(model, 1; euler=true). julia> model.timestepper.G⁻.η[1, 1, 1]; 0.0. julia> model.timestepper.Gⁿ.η[1, 1, 1]; 0.0; ```. Why NaNs don't persist?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046388403
https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381:52,Integrability,depend,depend,52,"~~I would try `u` because the behavior of eta could depend on whether you use explicit or implicit time-stepping.~~. Okay, I realized that you're using `ExplicitFreeSurface`. I think the comparison you want to make is to take an `euler` step with a NaN in `G-`, and check whether the NaN appears in the field where the NaN was inserted. You're checking `G-`, rather than the field itself. Since you're checking `G-` for NaNs, it doesn't appear for a couple more time-steps because the NaNs first appear in eta, and then get transferred to `Gn`, and _then_ get transferred to `G-` when `store_tendencies!` is called using `Gn` that has a NaN.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381
https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046437228:21,Testability,Test,Test,21,Good point! Yes. OK. Test is being written!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046437228
https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693:774,Integrability,depend,depends,774,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693
https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693:425,Usability,clear,clear,425,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693
https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720:324,Modifiability,flexible,flexible,324,"I didn't have a use-case in mind when suggesting this. It'll be rare for oceanography that two horizontal directions need to have different eddy diffusivities (though I'm sure that would be reasonable in some cases (balanced jet?)), but I think it's worth to implement that capability if we're trying to make Oceananigans a flexible, general-purpose-ish CFD package. Plus, given that parallelization capabilities are limited to only some directions, I can envision cases where users will rotate their domain in a way where the ""horizontal"" directions are actually `y`, `z`, and then `HorizontalDirections` won't work as intended. In any case, I personally will probably never use this feature, and it was only a suggestions for possible future uses. So feel free to ignore it if you think it's not worth it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720
https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047178584:193,Availability,mainten,maintenance,193,"That's fair. I think it's preferred generally to implement features when there's a strong need for it. The reason to wait is because code features (and their tests) often (not always) impose a maintenance burden on developers. So, given that supporting some features might slow down the pace of code development, it's in the interest of both users and developers to keep low-priority features out of the code for as long as possible / forever. Rotating a domain is an interesting use case. Other solutions are certainly cleaner, but pragmatism may force us in that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047178584
https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047178584:278,Availability,down,down,278,"That's fair. I think it's preferred generally to implement features when there's a strong need for it. The reason to wait is because code features (and their tests) often (not always) impose a maintenance burden on developers. So, given that supporting some features might slow down the pace of code development, it's in the interest of both users and developers to keep low-priority features out of the code for as long as possible / forever. Rotating a domain is an interesting use case. Other solutions are certainly cleaner, but pragmatism may force us in that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047178584
https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047178584:158,Testability,test,tests,158,"That's fair. I think it's preferred generally to implement features when there's a strong need for it. The reason to wait is because code features (and their tests) often (not always) impose a maintenance burden on developers. So, given that supporting some features might slow down the pace of code development, it's in the interest of both users and developers to keep low-priority features out of the code for as long as possible / forever. Rotating a domain is an interesting use case. Other solutions are certainly cleaner, but pragmatism may force us in that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047178584
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497:641,Integrability,interface,interface,641,"Since we throw away any calculations that are entirely inside a solid, we usually don't care what happens there. I think that's why it's called `solid_interface` rather than `fluid_solid_interface`, but @simone-silvestri can confirm. I think we need a bit more information for boundary conditions right? We have to know the _direction_, eg. ```julia; using Oceananigans.AbstractOperations: flip; east_fluid_solid_interface(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. This returns `true` when our cell is not immersed, but the eastern boundary is a fluid-solid interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083:1022,Integrability,Depend,Depends,1022,"> All 6 boundaries are something like; > ; > ```julia; > using Oceananigans.AbstractOperations: flip; > ; > east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); > south_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j, k, grid); > bottom_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k, grid); > ; > west_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i+1, j, k, grid) ; > north_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j+1, k, grid); > top_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k+1, grid); > ```; > ; > something like that. There could be a mistake. Yep I think this would work...; Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not), in that case we would need ; ```; bottom_bounded(LX, LY, LZ, i, j, k, grid) = solid_node(LX, LY, LZ, i, j, k-1, grid) & !solid_node(LX, LY, LZ, i, j, k, grid)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176248:228,Usability,simpl,simpler,228,"I agree with what you're saying (although I didn't know every calculation inside the solid was thrown away; I thought it was just some stuff like setting the velocities to zero). However, wouldn't using `xor` make the functions simpler and decrease the number of computations?. ```julia; east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. The above could be replaced by the following line. ```julia; east_bounded(LX, LY, LZ, i, j, k, grid) = solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. Idk if this makes a lot of difference in the grand scheme of a complete simulation, but as a rule `if` statements and comparisons are pretty expensive, so it might be better to try and decrease them, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176248
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:9,Energy Efficiency,reduce,reduce,9,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:113,Performance,perform,performance,113,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:259,Performance,optimiz,optimizations,259,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:207,Testability,log,logic,207,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:350,Testability,log,logic,350,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180676:102,Testability,log,logic,102,Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180676
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:11,Energy Efficiency,reduce,reduce,11,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:941,Integrability,interface,interface,941,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:115,Performance,perform,performance,115,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:268,Performance,optimiz,optimizations,268,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:216,Testability,log,logic,216,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:359,Testability,log,logic,359,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:556,Testability,log,logic,556,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:916,Testability,test,test,916,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:807,Usability,clear,clearer,807,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:2,Integrability,Depend,Depends,2,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:472,Integrability,interface,interface,472,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:653,Testability,log,logic,653,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:712,Testability,log,logic,712,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:814,Usability,simpl,simple,814,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
https://github.com/CliMA/Oceananigans.jl/issues/2265#issuecomment-1047303258:35,Energy Efficiency,reduce,reduce,35,"This is an API change but it won't reduce source code. For `(1, 2)` (eg `HorizonalDirections()`) we use [a scheme from MITgcm](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation) with special conservation properties (eg conserves potential vorticity), whereas for `(1, 2, 3)` we use the standard 3D isotropic formulation in terms of the strain tensor. Each case `1`, `2`, `3` has to be written out because our code isn't written to be ""n-dimensional""; instead we write out `x, y, z` explicitly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2265#issuecomment-1047303258
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594:460,Integrability,depend,depending,460,"I prefer `HorizontalDirections` to `XYDirections`. ""Horizontal"" is more meaningful when we're on a spherical shell. I understand that gravity can be rotated, but I think ""horizontal directions"" will be primarily used with models that are not rotated. The same issue plagues `XYZDirection` --- its a Cartesian / Rectilinear centric view. The situation makes even less sense on a cubed sphere, where ""x"" and ""y"" are arbitrary and pointed in different directions depending on the location on the sphere. How do others feel?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:880,Availability,down,downside,880,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1630,Availability,down,downside,1630,"irections `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd lea",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1963,Integrability,interface,interface,1963,"ever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd leave `ZDirection` in `Grids`, and define `VerticalFormulation`, `HorizontalFormulation` and `ThreeDimenionalFormulation` in `TurbulenceClosures`. Since these latter aren't ""directions"" anymore, there wouldn't be an overlap with `ZDirection` (which literally indicates only a direction). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:2081,Integrability,interface,interface,2081,"ever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd leave `ZDirection` in `Grids`, and define `VerticalFormulation`, `HorizontalFormulation` and `ThreeDimenionalFormulation` in `TurbulenceClosures`. Since these latter aren't ""directions"" anymore, there wouldn't be an overlap with `ZDirection` (which literally indicates only a direction). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1599,Safety,avoid,avoids,1599,"ur talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:737,Usability,intuit,intuitive,737,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:830,Usability,intuit,intuitive,830,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760:903,Safety,avoid,avoid,903,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760:317,Usability,learn,learned,317,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050033459:233,Testability,test,tests,233,"Great, I also think option 4 is the best. I prefer the kwarg formulation, but I don't feel strongly about it. The issue atm is that I think I won't have time to finish this PR by myself for a few days (I couldn't figure out why some tests aren't passing, so it'll probably take me a fair amount of time to have everything done). So if this needs to be ready for AGU OSM I'd need some help getting the tests to pass (it might actually be better to start over in another PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050033459
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050033459:401,Testability,test,tests,401,"Great, I also think option 4 is the best. I prefer the kwarg formulation, but I don't feel strongly about it. The issue atm is that I think I won't have time to finish this PR by myself for a few days (I couldn't figure out why some tests aren't passing, so it'll probably take me a fair amount of time to have everything done). So if this needs to be ready for AGU OSM I'd need some help getting the tests to pass (it might actually be better to start over in another PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050033459
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050048470:103,Testability,test,tests,103,"I can help you out today if you want, if you change to the formulation we decided I can try to fix the tests. Just let me know when it is ready to fix the bugs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050048470
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050049456:242,Testability,test,tests,242,"> Great, I also think option 4 is the best. I prefer the kwarg formulation, but I don't feel strongly about it.; > ; > The issue atm is that I think I won't have time to finish this PR by myself for a few days (I couldn't figure out why some tests aren't passing, so it'll probably take me a fair amount of time to have everything done). So if this needs to be ready for AGU OSM I'd need some help getting the tests to pass (it might actually be better to start over in another PR). I can open a new PR if you're ok with that. I guess `buoyancy_unit_vector` is in fact the right name (rather than `vertical_unit_vector`! `gravity_unit_vector` (which is antiparallel to `buoyancy_unit_vector`) might be more familiar though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050049456
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050049456:410,Testability,test,tests,410,"> Great, I also think option 4 is the best. I prefer the kwarg formulation, but I don't feel strongly about it.; > ; > The issue atm is that I think I won't have time to finish this PR by myself for a few days (I couldn't figure out why some tests aren't passing, so it'll probably take me a fair amount of time to have everything done). So if this needs to be ready for AGU OSM I'd need some help getting the tests to pass (it might actually be better to start over in another PR). I can open a new PR if you're ok with that. I guess `buoyancy_unit_vector` is in fact the right name (rather than `vertical_unit_vector`! `gravity_unit_vector` (which is antiparallel to `buoyancy_unit_vector`) might be more familiar though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050049456
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050049879:105,Testability,test,tests,105,"> I can help you out today if you want, if you change to the formulation we decided I can try to fix the tests. Just let me know when it is ready to fix the bugs. Or we can fix this up!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050049879
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050061274:242,Testability,test,tests,242,"> > Great, I also think option 4 is the best. I prefer the kwarg formulation, but I don't feel strongly about it.; > > The issue atm is that I think I won't have time to finish this PR by myself for a few days (I couldn't figure out why some tests aren't passing, so it'll probably take me a fair amount of time to have everything done). So if this needs to be ready for AGU OSM I'd need some help getting the tests to pass (it might actually be better to start over in another PR).; > ; > I can open a new PR if you're ok with that.; > ; > I guess `buoyancy_unit_vector` is in fact the right name (rather than `vertical_unit_vector`! `gravity_unit_vector` (which is antiparallel to `buoyancy_unit_vector`) might be more familiar though. I think starting over in another PR is probably the way to go unfortunately. It'll probably take too long to revert some of the things I initially did here. I'll try to help out there however I can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050061274
https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050061274:410,Testability,test,tests,410,"> > Great, I also think option 4 is the best. I prefer the kwarg formulation, but I don't feel strongly about it.; > > The issue atm is that I think I won't have time to finish this PR by myself for a few days (I couldn't figure out why some tests aren't passing, so it'll probably take me a fair amount of time to have everything done). So if this needs to be ready for AGU OSM I'd need some help getting the tests to pass (it might actually be better to start over in another PR).; > ; > I can open a new PR if you're ok with that.; > ; > I guess `buoyancy_unit_vector` is in fact the right name (rather than `vertical_unit_vector`! `gravity_unit_vector` (which is antiparallel to `buoyancy_unit_vector`) might be more familiar though. I think starting over in another PR is probably the way to go unfortunately. It'll probably take too long to revert some of the things I initially did here. I'll try to help out there however I can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1050061274
https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418:21,Availability,error,error,21,I think the proposed error message is more helpful and would encourage such a change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418
https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418:27,Integrability,message,message,27,I think the proposed error message is more helpful and would encourage such a change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418
https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047878192:193,Availability,ERROR,ERROR,193,"As a side note, I noticed recently that Julia does something similarly specific and helpful for the MATLABians at the REPL:. ```julia; julia> a = [1]; 1-element Vector{Int64}:; 1. julia> a(1); ERROR: MethodError: objects of type Vector{Int64} are not callable; Use square brackets [] for indexing an Array.; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047878192
https://github.com/CliMA/Oceananigans.jl/issues/2270#issuecomment-1479950923:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2270#issuecomment-1479950923
https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047936316:450,Usability,simpl,simply,450,"Couple random notes and questions:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L177-L178. belong in `Grids`. Why `W isa Number` for `zweno == true`?. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L171. That line should be written. ```julia; W = zweno ? Number : Nothing; ```. but note we can also simply use `zweno` as the type parameter directly so . ```julia; const JSWENO = WENO5{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, false}; const ZWENO = WENO5{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, true}; ```. might make senes to move that parameter to the top of the struct. The weight calculations in the code are difficult to read and understand:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L642-L668. How can we improve this? I think more describe names would help self-document at least (eg what are `j, c, m, num, l, i, op`?). We probably should add a specific reference to an equation in the comment / docstring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047936316
https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047966020:334,Energy Efficiency,reduce,reduced-precision,334,"It looks like `validate_advection` is also needed if we want to support a nice API for changing the floating point precision:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L139. Right now users have to specify `Float32` in both the `grid` and `WENO5` to get reduced-precision all around. If we `validate_advection` we can use the ""stub, regularization"" strategy where `FT` is set to `eltype(grid)` only if it's not specificed (to support existing behavior where `FT` can be set indepednently of `eltype(grid)`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047966020
https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047966020:407,Testability,stub,stub,407,"It looks like `validate_advection` is also needed if we want to support a nice API for changing the floating point precision:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L139. Right now users have to specify `Float32` in both the `grid` and `WENO5` to get reduced-precision all around. If we `validate_advection` we can use the ""stub, regularization"" strategy where `FT` is set to `eltype(grid)` only if it's not specificed (to support existing behavior where `FT` can be set indepednently of `eltype(grid)`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047966020
https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1049372125:227,Testability,test,testing,227,"Yay!. Ok, then we can just use a special type like `struct Default end` to denote that `WENO()` has not been constructed with a `grid`. That will allow us (or advanced users) to use an ""unstretched"" WENO on a stretched grid if testing / some emergency requires it. Otherwise --- if we think it's wise --- we'll just always use the stretched version on a stretched grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1049372125
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347864:786,Usability,simpl,simple,786,"@glwagner It would be great to have this option implemented! It's basically a function of the wind speed. This estimate gives the depth averaged Stokes drift so you can get the layer averaged Stokes drift profile by applying this estimate to each layer depth then compute the difference. [Here](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) is the implementation in GOTM. . Another useful estimate of the Stokes drift is to use the wind-wave spectrum in [Donelan et al. (1985)](https://doi.org/10.1098/rsta.1979.0079). A modified version of it was used in the LESs of [Harcourt and D'Asaro, (2008)](https://doi.org/10.1175/2007JPO3842.1). See their Section 2b. Also see their Appendix B for computing the layer averaged Stokes drift. I used a simple version of it (without the directional spreading) in the LESs in [Li and Fox-Kemper, (2017)](https://doi.org/10.1175/JPO-D-17-0085.1). It's also [implemented in LANL's version of PALM](https://github.com/lanl/palm_lanl/blob/7f1444073b20ae81b451d4ab469d13e66b5358b7/trunk/SOURCE/stokes_drift_mod.f90#L234). . I think it will be wonderful to have a Stokes drift module in either LESbrary or Oceananigans that contains different options to estimate the Stokes drift profile. Is this something you are thinking of?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347864
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347869:234,Usability,simpl,simple,234,"> I think it will be wonderful to have a Stokes drift module in either LESbrary or Oceananigans that contains different options to estimate the Stokes drift profile. Is this something you are thinking of?. Yes for sure! It's probably simple enough to include directly in Oceananigans. We'd put it here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/StokesDrift.jl. @qingli411 note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347869
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:323,Availability,avail,available,323,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:763,Deployability,integrat,integration,763,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:1026,Deployability,integrat,integration,1026,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:763,Integrability,integrat,integration,763,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:1026,Integrability,integrat,integration,1026,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:1123,Integrability,depend,depends,1123,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:60,Availability,avail,available,60,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:1633,Availability,down,down,1633,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:519,Deployability,continuous,continuous,519,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:682,Deployability,continuous,continuous,682,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:889,Deployability,integrat,integration,889,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:1152,Deployability,integrat,integration,1152,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:1640,Deployability,continuous,continuous,1640,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:889,Integrability,integrat,integration,889,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:1152,Integrability,integrat,integration,1152,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:1249,Integrability,depend,depends,1249,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:1543,Integrability,depend,depends,1543,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:712,Modifiability,parameteriz,parameterize,712,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:863,Modifiability,parameteriz,parameterize,863,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:381,Security,validat,validating,381,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055871038:487,Energy Efficiency,meter,meters,487,Another option is to use a model proposed by [Pizzo et al. 2019](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2019_Pizzo_Melville_Deike-Journal_of_Physical_Oceanography_vol_49.pdf) and described in the appendix of [Lenain and Pizzo 2020](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2021/01/2020_Lenain_Pizzo-Journal_of_Physical_Oceanography_vol_50.pdf). This is conveniently expressed in terms of the friction velocity / momentum flux rather than wind speed at 10 meters.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055871038
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704:1346,Modifiability,parameteriz,parameterize,1346,"bservation at [Ocean Station Papa](https://www.pmel.noaa.gov/ocs/Papa). The UW APL group has very nice [Waverider mooring observations there](https://cdip.ucsd.edu/themes/cdip?d2=p70&u2=s:166:v:parameter). Fig. 7 and Fig.8a,b of [this paper](https://doi.org/10.5194/gmd-14-4261-2021) is a comparison of the Stokes drift between the ""theory wave"" and OS Papa in one year. [Here](https://github.com/qingli411/A2020_CVMix_in_GOTM/blob/main/OSPapa/ospapa_stokes_drift.nc) is the half-hourly Stokes drift data I computed from the wave spectrum at OS Papa used in that paper (without directional spreading). It was computed on a 1 m vertical grid in the upper 36 m and a much coarser grid below. But I can easily compute it on a finer grid if we need. . > Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux τ. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?). The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better...; <img width=""519"" alt=""image"" src=""https://user-images.githubusercontent.com/12438579/156286196-846d07eb-e8a2-4762-b2c8-3d3226401334.png"">. >Another option is to use a model proposed by [Pizzo et al. 2019](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2019_Pizzo_Melville_Deike-",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704:347,Security,validat,validating,347,"```julia; function Stokes_drift(τ, z); kᵖ = peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); return uˢ₀ * (T₁(kᵖ, z) + T₂(kᵖ, z)); end; ```; I think it should be `T₁(kᵖ, z) - T₂(kᵖ, z)` in the above code? It might explain why the maximum Stokes drift in the figure is below the surface rather than at the surface. >It'd be nice to have a way of validating this. . One way is to use the observation at [Ocean Station Papa](https://www.pmel.noaa.gov/ocs/Papa). The UW APL group has very nice [Waverider mooring observations there](https://cdip.ucsd.edu/themes/cdip?d2=p70&u2=s:166:v:parameter). Fig. 7 and Fig.8a,b of [this paper](https://doi.org/10.5194/gmd-14-4261-2021) is a comparison of the Stokes drift between the ""theory wave"" and OS Papa in one year. [Here](https://github.com/qingli411/A2020_CVMix_in_GOTM/blob/main/OSPapa/ospapa_stokes_drift.nc) is the half-hourly Stokes drift data I computed from the wave spectrum at OS Papa used in that paper (without directional spreading). It was computed on a 1 m vertical grid in the upper 36 m and a much coarser grid below. But I can easily compute it on a finer grid if we need. . > Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux τ. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?). The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058116153:1268,Safety,avoid,avoid,1268,"> I think it should be T₁(kᵖ, z) - T₂(kᵖ, z) in the above code?. Thanks @qingli411 ! Fixed:. ![image](https://user-images.githubusercontent.com/15271942/156587002-2f14ad93-f287-4900-bb49-b89101076c4d.png). I talked to Nick Pizzo and spent some time reading [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) and [Lenain and Pizzo 2020](https://journals.ametsoc.org/view/journals/phoc/50/12/JPO-D-20-0116.1.xml) and I'm left with a few questions. First and foremost is: how is it possible to formulate a stationary relationship between Stokes drift and transport as in McWilliams and Restrepo? In the experiments we run, we impose a constant momentum flux / constant wind on top of an _initially quiescent_ boundary layer. Thus it seems the most appropriate model for the peak wavenumber would be one that accounts for the _fetch dependence_; eg, the peak wavenumber decreases in time as the wind continues to blow, consistent with the concept of a constant wind that starts blowing impulsively over an ocean at rest. Two other details in those papers are:. * The relationships are formulated in terms of friction velocity rather than atmospheric wind speed, so we avoid introducing bulk formula which I think is an advantage.; * [Lenain and Pizzo 2020](https://journals.ametsoc.org/view/journals/phoc/50/12/JPO-D-20-0116.1.xml) claim that their correction to the surface wave spectrum changes the surface Stokes drift (and I suppose Stokes shear) by 15-20%. I'm not sure how much this would imprint on our results but it's something to think about.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058116153
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:132,Deployability,continuous,continuously,132,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:41,Integrability,depend,dependence,41,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:61,Integrability,depend,dependence,61,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:270,Integrability,depend,dependence,270,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:1355,Integrability,depend,dependent,1355,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:145,Modifiability,evolve,evolves,145,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264:70,Deployability,update,updated,70,"EDIT: there were a number of mistakes in the original post here. I've updated it. As for the _profiles_, there are some interesting differences between the ""Brevik"" and ""Lenain"" formulations. In particular, the Lenain profile depends on the _air_ friction velocity `u★`, while the Brevik does not. This is because Lenain divide the spectrum into saturation and equilibrium ranges, and the transition wavenumber between the two _depends on the friction velocity_ (it scales with `1 / u★^2`. Lenain also introduce an ""isotropic wavenumber"", which is an upper cutoff above which short waves do not contribute to the net Stokes drift. This isotropic wavenumber also scales with `1 / u★^2`. In all cases the Lenain model has strong shear at the surface. The effect is less pronounced on a (relatively coarse) grid with dz = 1 m, but still significant. The shear is also not monotonic in `u★`, possibly because the lower-frequency components start to contribute more at higher wind speeds, reducing the shear relative to the surface value of the Stokes drift. Check out the results:. ![image](https://user-images.githubusercontent.com/15271942/156649792-02639f67-5d0d-47f3-93f7-e1faa7ad92f9.png). Code:. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; Cᵝ = 0.105 # Toba's constant; Cʳ = 9.7e-3 # Transition wavenumber parameter, Lenain and Pizzo 2020 eq 4; Cⁱ = 0.072 # Cutoff / isotropic wavenumber parameter; # exp(π/2 - θ₀) / γ) from Lenain and Pizzo 2020 Appendix A; Cᴮ = 7e-3 # Saturation constant; g = 9.81 # m s⁻², gravitational acceleration; ρʷ = 1024 # kg m⁻³, water density; ρᵃ = 1.225 # kg m⁻³, air density. #####; ##### Stokes drift profile from Brevik et al 2016; #####. T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))); brevik(k, z) = T₁(k, z) - T₂(k, z). #####; ##### Stokes drift profile from Lenain and Pizzo 2020; #####. kⁿ(u★) = Cʳ * g / u★^2 # Transition wavenumber; kⁱ(u★) = Cⁱ * g / u★^2 # Isotropic wavenumber / upper wav",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264:226,Integrability,depend,depends,226,"EDIT: there were a number of mistakes in the original post here. I've updated it. As for the _profiles_, there are some interesting differences between the ""Brevik"" and ""Lenain"" formulations. In particular, the Lenain profile depends on the _air_ friction velocity `u★`, while the Brevik does not. This is because Lenain divide the spectrum into saturation and equilibrium ranges, and the transition wavenumber between the two _depends on the friction velocity_ (it scales with `1 / u★^2`. Lenain also introduce an ""isotropic wavenumber"", which is an upper cutoff above which short waves do not contribute to the net Stokes drift. This isotropic wavenumber also scales with `1 / u★^2`. In all cases the Lenain model has strong shear at the surface. The effect is less pronounced on a (relatively coarse) grid with dz = 1 m, but still significant. The shear is also not monotonic in `u★`, possibly because the lower-frequency components start to contribute more at higher wind speeds, reducing the shear relative to the surface value of the Stokes drift. Check out the results:. ![image](https://user-images.githubusercontent.com/15271942/156649792-02639f67-5d0d-47f3-93f7-e1faa7ad92f9.png). Code:. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; Cᵝ = 0.105 # Toba's constant; Cʳ = 9.7e-3 # Transition wavenumber parameter, Lenain and Pizzo 2020 eq 4; Cⁱ = 0.072 # Cutoff / isotropic wavenumber parameter; # exp(π/2 - θ₀) / γ) from Lenain and Pizzo 2020 Appendix A; Cᴮ = 7e-3 # Saturation constant; g = 9.81 # m s⁻², gravitational acceleration; ρʷ = 1024 # kg m⁻³, water density; ρᵃ = 1.225 # kg m⁻³, air density. #####; ##### Stokes drift profile from Brevik et al 2016; #####. T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))); brevik(k, z) = T₁(k, z) - T₂(k, z). #####; ##### Stokes drift profile from Lenain and Pizzo 2020; #####. kⁿ(u★) = Cʳ * g / u★^2 # Transition wavenumber; kⁱ(u★) = Cⁱ * g / u★^2 # Isotropic wavenumber / upper wav",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:802,Availability,error,errors,802,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:883,Availability,avail,available,883,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937
https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:837,Modifiability,parameteriz,parameterization,837,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937
https://github.com/CliMA/Oceananigans.jl/issues/2272#issuecomment-1048838427:112,Deployability,update,update,112,It would be great to add CATKE to the channel to address its computational cost. I agree that it makes sense to update the default parameters.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2272#issuecomment-1048838427
https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:17,Deployability,update,updated,17,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824
https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:852,Deployability,configurat,configuration,852,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824
https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:901,Deployability,update,update,901,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824
https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:852,Modifiability,config,configuration,852,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824
https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529:1598,Energy Efficiency,schedul,scheduled,1598,"acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: BetaPlane{Float64}. julia> simulation; Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 20 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: 30 days; ├── Stop iteration : Inf; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 6 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ ├── nan_checker => typename(Callback); │ ├── wizard => typename(Callback); │ └── print_progress => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── fields => typename(JLD2OutputWriter); └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.output_writers[:fields]; JLD2OutputWriter scheduled on TimeInterval(1 hour):; ├── filepath: ./baroclinic_adjustment.jld2; ├── 3 outputs: (:ζ, :b, :c); ├── field slicer: FieldSlicer(:, :, 16, with_halos=false); ├── array type: Array{Float32}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB. julia> horizontal_closure; ScalarBiharmonicDiffusivity: (ν=8.623357172365541e10, κ=8.623357172365541e10), isotropy: Horizontal. julia> diffusive_closure; ScalarDiffusivity:; ν=0.01, κ=0.01; time discretization: VerticallyImplicit(); isotropy: Vertical; ```. # This PR. ```julia; julia> model; HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (b, c); ├── closure: Tuple with 2 closures:; │ ├── ScalarBiharmonicDiffusivity{Horizontal}(ν=8.62336e10, κ=(b=8.62336e10, c=8.62336e10)); │ └── ScalarDiffusivity{VerticallyImplicit, Ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529
https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529:3951,Energy Efficiency,schedul,scheduled,3951,", c); ├── closure: Tuple with 2 closures:; │ ├── ScalarBiharmonicDiffusivity{Horizontal}(ν=8.62336e10, κ=(b=8.62336e10, c=8.62336e10)); │ └── ScalarDiffusivity{VerticallyImplicit, Vertical}(ν=0.01, κ=(b=0.01, c=0.01)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: BetaPlane{Float64}. julia> simulation; Simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── Next time step: 20 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: 30 days; ├── Stop iteration : Inf; ├── Wall time limit: Inf; ├── Callbacks: OrderedDict with 6 entries:; │ ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1); │ ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1); │ ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1); │ ├── nan_checker => Callback of NaNChecker for u on IterationInterval(100); │ ├── wizard => Callback of TimeStepWizard(cfl=0.2, max_Δt=1200.0, min_Δt=0.0) on IterationInterval(1); │ └── print_progress => Callback of print_progress on IterationInterval(20); ├── Output writers: OrderedDict with 1 entry:; │ └── fields => JLD2OutputWriter writing (ζ, b, c) to ./baroclinic_adjustment.jld2 on TimeInterval(1 hour); └── Diagnostics: OrderedDict with no entries. julia> simulation.output_writers[:fields]; JLD2OutputWriter scheduled on TimeInterval(1 hour):; ├── filepath: ./baroclinic_adjustment.jld2; ├── 3 outputs: (ζ, b, c); ├── field slicer: FieldSlicer(:, :, 16, with_halos=false); ├── array type: Array{Float32}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB. julia> horizontal_closure; ScalarBiharmonicDiffusivity{Horizontal}(ν=8.62336e10, κ=8.62336e10). julia> diffusive_closure; ScalarDiffusivity{VerticallyImplicit, Vertical}(ν=0.01, κ=0.01); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:825,Energy Efficiency,adapt,adapt,825,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:37,Integrability,interface,interface,37,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:781,Modifiability,extend,extend,781,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:825,Modifiability,adapt,adapt,825,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:539,Safety,avoid,avoid,539,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921:19,Energy Efficiency,adapt,adapt,19,"> Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions. I think so. Let's definitely try!. Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921:19,Modifiability,adapt,adapt,19,"> Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions. I think so. Let's definitely try!. Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738:21,Energy Efficiency,adapt,adapt,21,"> > Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.; > ; > I think so. Let's definitely try!; > ; > Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?. We have `FluxBoundaryCondition` already which is the same. The difference in terms of user input is that an immersed boundary condition _function_ has to be called with three indices `i, j, k` rather than two like all the other boundary conditions. I don't think we need any new types in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738:21,Modifiability,adapt,adapt,21,"> > Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.; > ; > I think so. Let's definitely try!; > ; > Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?. We have `FluxBoundaryCondition` already which is the same. The difference in terms of user input is that an immersed boundary condition _function_ has to be called with three indices `i, j, k` rather than two like all the other boundary conditions. I don't think we need any new types in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244:36,Integrability,interface,interface,36,"> Quick general question: with this interface IBM immediately goes to drag BC, right?. That's correct. There's no way to run IBM without a drag BC with this implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074183690:366,Energy Efficiency,green,green,366,"> With this last commit the bottom drag should be working for `u` at least, which shows that the function calls are working. Expanding it to other components and directions is now straightforward.; > ; > Here's a video comparing this IBM with drag BC with two non IBM models (one with no-slip BC, and another with drag BC):; > ; > u_drag.mp4. So the blue and dashed green curves should coincide, which they do for most of the domain, but there's the begging part of the dashed curve that doesn't seem to have blue. Is that a plotting issue or is there something I'm missing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074183690
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074209813:632,Availability,mask,masked,632,"> > With this last commit the bottom drag should be working for `u` at least, which shows that the function calls are working. Expanding it to other components and directions is now straightforward.; > > Here's a video comparing this IBM with drag BC with two non IBM models (one with no-slip BC, and another with drag BC):; > > u_drag.mp4; > ; > So the blue and dashed green curves should coincide, which they do for most of the domain, but there's the begging part of the dashed curve that doesn't seem to have blue. Is that a plotting issue or is there something I'm missing?. That's the immersed solid, where the velocities are masked to zero :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074209813
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074209813:370,Energy Efficiency,green,green,370,"> > With this last commit the bottom drag should be working for `u` at least, which shows that the function calls are working. Expanding it to other components and directions is now straightforward.; > > Here's a video comparing this IBM with drag BC with two non IBM models (one with no-slip BC, and another with drag BC):; > > u_drag.mp4; > ; > So the blue and dashed green curves should coincide, which they do for most of the domain, but there's the begging part of the dashed curve that doesn't seem to have blue. Is that a plotting issue or is there something I'm missing?. That's the immersed solid, where the velocities are masked to zero :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074209813
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306:121,Availability,mask,masking,121,"Thanks @tomchor , and very nice. What would the difference of those two curves look like in the region where there is no masking? Are they identicial or just similar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074455752:130,Availability,mask,masking,130,"> Thanks @tomchor , and very nice.; > ; > What would the difference of those two curves look like in the region where there is no masking? Are they identicial or just similar?. In the simulations without the IBM that region does't exist! The domain in those cases starts at `z=0`. And in the simulation with IBM that region exists, but lies inside the immersed solid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074455752
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074479039:130,Availability,mask,masking,130,"> > Thanks @tomchor , and very nice.; > > What would the difference of those two curves look like in the region where there is no masking? Are they identicial or just similar?; > ; > In the simulations without the IBM that region does't exist! The domain in those cases starts at `z=0`. And in the simulation with IBM that region exists, but lies inside the immersed solid. I meant in the physical region. The curves look like they overlap but if you plotted the difference you could see how much they differ in the physical domain. Just an idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074479039
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:1092,Deployability,Continuous,ContinuousBoundaryCondition,1092,"ersed fluxes that would introduce a new term into the tendency kernels, eg here:. https://github.com/CliMA/Oceananigans.jl/blob/30ec599de5e3813d57b46e8d8fa4196bcdd250e0/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl#L44. adding something like. ```julia; + ∂ⱼ_τ₁ⱼ_immersed(i, j, k, grid, closure, diffusivities, immersed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,Energy Efficiency,adapt,adapting,2389,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,Modifiability,adapt,adapting,2389,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:674,Usability,simpl,simpler,674,"@tomchor @whitleyv what's the ultimate vision for this PR? @simone-silvestri and I discussed a method for adding immersed fluxes that would introduce a new term into the tendency kernels, eg here:. https://github.com/CliMA/Oceananigans.jl/blob/30ec599de5e3813d57b46e8d8fa4196bcdd250e0/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl#L44. adding something like. ```julia; + ∂ⱼ_τ₁ⱼ_immersed(i, j, k, grid, closure, diffusivities, immersed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:593,Availability,avail,available,593,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:979,Integrability,depend,dependencies,979,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:271,Safety,avoid,avoiding,271,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:549,Testability,test,test,549,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345:1006,Integrability,depend,dependencies,1006,"> > @tomchor @whitleyv what's the ultimate vision for this PR; > ; > I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. For sure! A forcing function could serve as a prototype for the new tendency kernel function that I'm proposing, right? That was my original motivation for proposing the forcing function --- because we would be able to re-use that code (eg all the right conditionals, etc) when we went to implement immersed boundary conditions in the source code. The new tendency kernel function that @simone-silvestri and I are suggesting would be identical to such a forcing function. > I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input. That's true we have to take care with interpolation. I think the first question is what user API we'd like to support; then we can generate source code to match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345:279,Safety,avoid,avoiding,279,"> > @tomchor @whitleyv what's the ultimate vision for this PR; > ; > I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. For sure! A forcing function could serve as a prototype for the new tendency kernel function that I'm proposing, right? That was my original motivation for proposing the forcing function --- because we would be able to re-use that code (eg all the right conditionals, etc) when we went to implement immersed boundary conditions in the source code. The new tendency kernel function that @simone-silvestri and I are suggesting would be identical to such a forcing function. > I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input. That's true we have to take care with interpolation. I think the first question is what user API we'd like to support; then we can generate source code to match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:908,Availability,mask,masked,908,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:616,Integrability,interface,interface,616,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:986,Integrability,interface,interface,986,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:1208,Integrability,interface,interface,1208,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:1743,Testability,test,tested,1743,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083958509:819,Testability,test,testing,819,"Okay so there's some bad news: this IBM implementation seems to be pretty slow. . I ran two identical simulations with the same number of points on a GPU, but using a regular grid on one and an immersed boundary grid on the other (with the immersed solid boundaries set to coincide with the domain walls). Apparently for a 16×4×4 grid the IBM version is about 10 times slower than the non IBM one. For a 128×32×32 the factor is of about 8 times , so it doesn't appear to be getting better with increasing grid sizes. The difference seems to be similar (albeit a bit smaller) for CPUs. I'm not sure of what the best way is to speed things up. We could try changing how we implement the if-else clauses (right now we're using nested `ifelse()` functions, which always evaluates all arguments). . Alternatively instead of testing whether or not we're inside or outside the solid (in addition to fluid-solid boundaries) every time we calculate fluxes, we could store the indices that correspond to solid boundaries and solid interior points and IBM launch kernels only on those indices (although I'm not sure how to achieve that for GPUs).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083958509
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083973888:98,Testability,test,testing,98,Isn't this because of the implicit solve? What grid/model combination are you using?. You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083973888
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084047640:106,Testability,test,testing,106,"> Isn't this because of the implicit solve? What grid/model combination are you using?; > ; > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar. They are probably using the FFT-based solver + `NonhydrostaticModel`. It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084047640
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084047640:335,Testability,benchmark,benchmarking,335,"> Isn't this because of the implicit solve? What grid/model combination are you using?; > ; > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar. They are probably using the FFT-based solver + `NonhydrostaticModel`. It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084047640
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084047640:562,Testability,test,test,562,"> Isn't this because of the implicit solve? What grid/model combination are you using?; > ; > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar. They are probably using the FFT-based solver + `NonhydrostaticModel`. It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084047640
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663:1225,Deployability,upgrade,upgrade,1225,"> > Isn't this because of the implicit solve? What grid/model combination are you using?; > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > ; > They are probably using the FFT-based solver + `NonhydrostaticModel`. Exactly. > ; > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results. > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here. That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in https://github.com/CliMA/Oceananigans.jl/pull/2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663:106,Testability,test,testing,106,"> > Isn't this because of the implicit solve? What grid/model combination are you using?; > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > ; > They are probably using the FFT-based solver + `NonhydrostaticModel`. Exactly. > ; > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results. > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here. That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in https://github.com/CliMA/Oceananigans.jl/pull/2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663:357,Testability,benchmark,benchmarking,357,"> > Isn't this because of the implicit solve? What grid/model combination are you using?; > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > ; > They are probably using the FFT-based solver + `NonhydrostaticModel`. Exactly. > ; > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results. > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here. That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in https://github.com/CliMA/Oceananigans.jl/pull/2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663:708,Testability,test,test,708,"> > Isn't this because of the implicit solve? What grid/model combination are you using?; > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > ; > They are probably using the FFT-based solver + `NonhydrostaticModel`. Exactly. > ; > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary. We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results. > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here. That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in https://github.com/CliMA/Oceananigans.jl/pull/2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084669663
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:1270,Deployability,upgrade,upgrade,1270,"sing the FFT-based solver + `NonhydrostaticModel`.; > ; > Exactly.; > ; > > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary.; > ; > We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form dr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:1628,Energy Efficiency,reduce,reduce,1628,", but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form drag with `GridFittedBottom` is _less_ than what we think is realistic. If there is indeed too little drag then we have good justification for hard coding a drag boundary condition into `conditional_flux`. On the other hand, if there's too much drag, then the first thing to work on is an alternative representation of b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:110,Testability,test,testing,110,"> > > Isn't this because of the implicit solve? What grid/model combination are you using?; > > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > > ; > > ; > > They are probably using the FFT-based solver + `NonhydrostaticModel`.; > ; > Exactly.; > ; > > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary.; > ; > We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:381,Testability,benchmark,benchmarking,381,"> > > Isn't this because of the implicit solve? What grid/model combination are you using?; > > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > > ; > > ; > > They are probably using the FFT-based solver + `NonhydrostaticModel`.; > ; > Exactly.; > ; > > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary.; > ; > We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:746,Testability,test,test,746,"> > > Isn't this because of the implicit solve? What grid/model combination are you using?; > > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > > ; > > ; > > They are probably using the FFT-based solver + `NonhydrostaticModel`.; > ; > Exactly.; > ; > > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary.; > ; > We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:1900,Usability,simpl,simply,1900,"change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form drag with `GridFittedBottom` is _less_ than what we think is realistic. If there is indeed too little drag then we have good justification for hard coding a drag boundary condition into `conditional_flux`. On the other hand, if there's too much drag, then the first thing to work on is an alternative representation of bathymetry. We can then repeat the form drag analysis with the new bathymetry representation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:2019,Usability,simpl,simple,2019,"change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form drag with `GridFittedBottom` is _less_ than what we think is realistic. If there is indeed too little drag then we have good justification for hard coding a drag boundary condition into `conditional_flux`. On the other hand, if there's too much drag, then the first thing to work on is an alternative representation of bathymetry. We can then repeat the form drag analysis with the new bathymetry representation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:463,Availability,mask,masking,463,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:825,Integrability,Message,Message,825,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882
https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:207,Usability,simpl,simply,207,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882
https://github.com/CliMA/Oceananigans.jl/pull/2276#issuecomment-1050417811:6,Testability,test,tests,6,"Sure, tests should pass in this last commit, when that is done I ll merge!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2276#issuecomment-1050417811
https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:152,Modifiability,variab,variable,152,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114
https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:415,Modifiability,variab,variable,415,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114
https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:464,Modifiability,variab,variable,464,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114
https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:1074,Modifiability,refactor,refactor,1074,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114
https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:321,Modifiability,evolve,evolve,321,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554
https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:414,Security,validat,validated,414,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554
https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1076316613:64,Testability,log,log,64,Maybe we can use `Term.jl` to implement a default / convenience log utility for simulations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1076316613
https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914:289,Modifiability,config,configure,289,"Go for it! If you want to discuss an idea before writing code, let's discuss here. Here's my thoughts:. 1. We can add a color to an important `show` method like one / all of the models, or `Simulation`; 2. We can add a nice utility for logging progress that uses `Term.jl`, that users can configure and then add to `simulation.callbacks` (we could also consider making it default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914
https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914:236,Testability,log,logging,236,"Go for it! If you want to discuss an idea before writing code, let's discuss here. Here's my thoughts:. 1. We can add a color to an important `show` method like one / all of the models, or `Simulation`; 2. We can add a nice utility for logging progress that uses `Term.jl`, that users can configure and then add to `simulation.callbacks` (we could also consider making it default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914
https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1079154232:82,Testability,test,test,82,"Ok. So, to do that, I will fork the main repo and do my modifications.; How can I test the forked repo while running julia?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1079154232
https://github.com/CliMA/Oceananigans.jl/pull/2283#issuecomment-1055659167:715,Testability,test,tests,715,"> @tomchor the relevant fluxes are in the respective files for an `AbstractTurbulenceClosure` (like for `ConvectiveAdjustment` or `IsopycnalSkewSymmetricDiffusivity`), while an `AbstractEddyClosure` (for example `AnisotropicMinimumDissipation` or `SmagorinskyLilly`) uses the functions defined in `AbstractScalarDiffusivity` (for example both `AnisotropicMinimumDissipation` and `SmagorinskyLilly` are only `ThreeDimensional`). Ah, I see. We subtype one with the other here https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/TurbulenceClosures/abstract_eddy_viscosity_closure.jl#L7. Then in this case I think the code will match the docs after this PR. I'll merge as soon as tests pass. ~Just a note, do we wanna consider modifying the subtyping here in the future? The recent changes in the turbulence closures were great, but I'd argue that there's still room for improvement. For example (if I understand correctly) right now `SmagorisnkyLilly` is an `AbstractEddyViscosityClosure`, which itself is a subtype of `AbstractScalarDiffusivity`, even though the diffusivity in a `SmagLilly` isn't a scalar, which is confusing (this is what threw me off at first). Maybe it's worth considering defining an `AbstractViscosityClosure`, and then `AbstractScalarDiffusivity` and `AbstractEddyViscosityClosure` coudl be separate subtypes of it?~. ~I'm happy to open an issue to discuss this more.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2283#issuecomment-1055659167
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:446,Availability,ERROR,ERROR,446,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:486,Availability,error,error,486,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:526,Availability,error,error,526,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:17,Security,validat,validation,17,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:557,Security,access,access,557,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703:945,Modifiability,extend,extend,945,"There seems to be a problem with calculating fluxes in a `Flat` direction. . The `Horizontal` formulation It is trying to calculate the viscous flux in the horizontal direction using the vertical vorticity which requires at least 2 points in each horizontal direction. . (specifically these two lines); ```; @inline viscous_flux_vx(i, j, k, grid, closure::AHD, clock, U, args...) = - ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v); @inline viscous_flux_uy(i, j, k, grid, closure::AHD, clock, U, args...) = + ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v) ; ```. because this calls the circulation operator `Γᶠᶠᶜ`; which is calculated as. ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v) - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); ```. requiring `i-1` which we do not have if `x` is `Flat`. ; I wonder how it was even working before? Maybe a workaround we can implement is to extend the circulation operator for `Flat` directions. ```; @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, Flat}, u, v) = - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, <:Any, Flat}, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v); ```. Or maybe just put it to zero since it actually is zero",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428:164,Availability,robust,robust,164,"Ah, I see... ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); ```; that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428:201,Modifiability,extend,extended,201,"Ah, I see... ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); ```; that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:183,Availability,robust,robust,183,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:220,Modifiability,extend,extended,220,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:289,Testability,test,test,289,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:318,Testability,test,test,318,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054896295:25,Testability,test,test,25,@glwagner let's add that test you mentioned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054896295
https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1055360784:27,Testability,test,test,27,> @glwagner let's add that test you mentioned. Ok!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1055360784
https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558:273,Modifiability,variab,variable,273,I guess we could call it `grid_metric` instead of `area` and the iterator can be called `met` or `m` or `grid_term` instead... Probably also the comment above should be changed to something in the line of `operators of the form M * q where M is a grid metric and q is some variable`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558
https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185:508,Availability,error,error,508,"> > `test_dynamics.jl` fail.; > > Is this correct here?; > > https://github.com/CliMA/Oceananigans.jl/blob/ad110ecdc635192c110e229df4fbfa04fc7a2266/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L39-L41; > > ; > > I guess it should be `if formulation == VerticallFormulation() and ...`?; > ; > No that's correct --- we can't use vertically implicit time-stepping with `HorizontalFormulation`.; > ; > The reason is that `HorizontalFormulation` has no vertical terms. Then the error message should be `only supported for `VerticalFormulation or ThreeDimensionalFormulation""`, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185
https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185:514,Integrability,message,message,514,"> > `test_dynamics.jl` fail.; > > Is this correct here?; > > https://github.com/CliMA/Oceananigans.jl/blob/ad110ecdc635192c110e229df4fbfa04fc7a2266/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L39-L41; > > ; > > I guess it should be `if formulation == VerticallFormulation() and ...`?; > ; > No that's correct --- we can't use vertically implicit time-stepping with `HorizontalFormulation`.; > ; > The reason is that `HorizontalFormulation` has no vertical terms. Then the error message should be `only supported for `VerticalFormulation or ThreeDimensionalFormulation""`, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185
https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059542167:24,Testability,test,tests,24,OK fixed it. Apparently tests were passing before because the `time_discretization` argument was not working properly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059542167
https://github.com/CliMA/Oceananigans.jl/issues/2291#issuecomment-1055425366:112,Testability,test,test,112,I also got confused by . https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/test/test_dynamics.jl#L32-L37. until I realized that `z_viscosity` here is used only to determine a stable but non-trivial time step.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2291#issuecomment-1055425366
https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1055498269:8,Usability,intuit,intuitive,8,This is intuitive and a good idea moving forward. I like it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1055498269
https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1479952841:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1479952841
https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:68,Availability,mask,mask,68,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107
https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:160,Availability,mask,masking,160,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107
https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:187,Availability,mask,mask,187,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107
https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:110,Energy Efficiency,reduce,reduce,110,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107
https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:203,Integrability,interface,interface,203,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107
https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1479958146:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1479958146
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1055989896:14,Usability,simpl,simplification,14,"A lot of code simplification, nice!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1055989896
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973:151,Integrability,message,message,151,"I didn't quite understand what the bug in AMD was. Was it important?. (Asking because one of your commits contained a bugfix for AMD, according to the message)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050:33,Integrability,interface,interface,33,"One remaining question is a user interface for extracting viscosities and diffusivities, especially when we have closure tuples. I think we want a function based interface. Take for example the case. ```julia; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); ```. We could have some API functions that look like. ```julia; viscosity(model) # returns 1.05e-6 + νₑ; diffusivity(model, :b) # returns 1e-7 + κₑ; diffusivities(model) # returns a named tuple with all tracer diffusivities; ```. This could work if _all_ closures are _either_ `AbstractScalarDiffusivity` or `AbstractBiharmonicDiffusivity`. For models with heterogeneous closures we need a bit more. For example with. ```julia; closure = (HorizontalScalarBiharmonicDiffusivity(ν=1e2, κ=1e1), CATKEVerticalDiffusivity()); ```. we might have something like. ```julia; viscosity(closure[1], model); viscosity(closure[2], model); ```. which returns the viscosity associated with `closure[n]` (here, either biharmonic diffusivity or CATKE's nonlinear diffusivity). The issue is that we don't want users picking apart `model.diffusivity_fields` since this will make scripts more fragile, prone to breakage when code changes, and difficult to understand. (I also think we need to change this to `closure_fields` at some point). . Thoughts or other ideas? @navidcy @tomchor @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050:162,Integrability,interface,interface,162,"One remaining question is a user interface for extracting viscosities and diffusivities, especially when we have closure tuples. I think we want a function based interface. Take for example the case. ```julia; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); ```. We could have some API functions that look like. ```julia; viscosity(model) # returns 1.05e-6 + νₑ; diffusivity(model, :b) # returns 1e-7 + κₑ; diffusivities(model) # returns a named tuple with all tracer diffusivities; ```. This could work if _all_ closures are _either_ `AbstractScalarDiffusivity` or `AbstractBiharmonicDiffusivity`. For models with heterogeneous closures we need a bit more. For example with. ```julia; closure = (HorizontalScalarBiharmonicDiffusivity(ν=1e2, κ=1e1), CATKEVerticalDiffusivity()); ```. we might have something like. ```julia; viscosity(closure[1], model); viscosity(closure[2], model); ```. which returns the viscosity associated with `closure[n]` (here, either biharmonic diffusivity or CATKE's nonlinear diffusivity). The issue is that we don't want users picking apart `model.diffusivity_fields` since this will make scripts more fragile, prone to breakage when code changes, and difficult to understand. (I also think we need to change this to `closure_fields` at some point). . Thoughts or other ideas? @navidcy @tomchor @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065:258,Availability,error,error,258,"Another possibility is to get rid of `diffusivity_fields` altogether and put fields inside the closures. Then users have to write things like `AnisotropicMinimumDissipation(grid)`, and we probably also need to stop ""auto halo inflation"" (instead throwing an error). Might be worth it though. Also if we have `halo = (3, 3, 3)` by default then users will basically never have issues with grid construction / halo sizes. Putting fields inside the closures also makes `OceanLearning.jl` more complicated. For example, if we want to change the parameters of a model closure, we ""only"" have to build a new closure with the same type but different parameters. If we put fields inside the closures, we have to work a little harder to combine the existing closure fields with new closure parameters. Those problems are all solvable, so it's just a question of whether simplifications here are worth complications elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065:860,Usability,simpl,simplifications,860,"Another possibility is to get rid of `diffusivity_fields` altogether and put fields inside the closures. Then users have to write things like `AnisotropicMinimumDissipation(grid)`, and we probably also need to stop ""auto halo inflation"" (instead throwing an error). Might be worth it though. Also if we have `halo = (3, 3, 3)` by default then users will basically never have issues with grid construction / halo sizes. Putting fields inside the closures also makes `OceanLearning.jl` more complicated. For example, if we want to change the parameters of a model closure, we ""only"" have to build a new closure with the same type but different parameters. If we put fields inside the closures, we have to work a little harder to combine the existing closure fields with new closure parameters. Those problems are all solvable, so it's just a question of whether simplifications here are worth complications elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064188091:914,Usability,simpl,simplicity,914,"I would go with the second option for one reason:; If a user knows enough to pass a tuple of closures to the model constructor they are well aware that `closure` is a tuple. There is no need to go the extra mile to sum them together. We can also have a function that returns a `tuple` of viscosities associated with the `tuple` of closures but maybe it would require a different name like `closure_viscosities`; ```; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); closure_viscosities(model) #returns (1.05e-6, νₑ); closure_diffusivities(model, :b) # returns (1e-7, κₑ); closure_diffusivities(model) # returns a tuple of named tuples with all tracer diffusivities; ```. The problem is that not every closure might have a diffusivity or viscosity associated with it (like mass flux models), in that case we will have to think at something else. In addition, I am convinced of the simplicity of keeping the `diffusivity_fields`, nesting too many structs might make code too complex (thinking also at future development of `MultiRegion`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064188091
https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064194104:37,Usability,simpl,simplicity,37,"> In addition, I am convinced of the simplicity of keeping the `diffusivity_fields`, nesting too many structs might make code too complex (thinking also at future development of `MultiRegion`). Ok to clarify you're saying we _should keep_ `diffusivity_fields` / `closure_fields`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064194104
https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305714765:49,Availability,error,error,49,"I think they do work, but I am not sure what the error was",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305714765
https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305878063:67,Testability,test,test,67,I believe the simulations would just NaN immediately. Do we have a test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305878063
https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305977970:131,Security,validat,validation,131,I did not notice this problem. `ShallowWaterModel` (`Flat` in z) works with an `ImmersedBoundaryGrid`. An example can be found in `validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl` . this video is the output. https://user-images.githubusercontent.com/33547697/200380534-7a4832d6-bdb4-4044-a019-d8d57e553e8a.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305977970
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825:387,Availability,error,errors,387,"The discussion on #2410 reminded me: to complete this implementation, we are going to need to make some modification to the hydrostatic pressure integral. There are two possibilities. We can either. 1) use the MITgcm method, which _avoids_ using the modified grid spacing in the bottom cell for the hydrostatic pressure integral. Using ""underlying"" grid spacing avoids pressure gradient errors that would otherwise induce flow even for horizontally uniform density stratification. 2) Implement Lin 1997 to evaluate the hydrostatic pressure integral: https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=_4v_YF-yx0cAAAAA:vC9wnmpvE_2HqoKudORNBfVCkxK4_YgRfp5_Lh2hIFFNc0ZyST-D7nwEqt1No4FculdvrohhKVF2wT9r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825:362,Safety,avoid,avoids,362,"The discussion on #2410 reminded me: to complete this implementation, we are going to need to make some modification to the hydrostatic pressure integral. There are two possibilities. We can either. 1) use the MITgcm method, which _avoids_ using the modified grid spacing in the bottom cell for the hydrostatic pressure integral. Using ""underlying"" grid spacing avoids pressure gradient errors that would otherwise induce flow even for horizontally uniform density stratification. 2) Implement Lin 1997 to evaluate the hydrostatic pressure integral: https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=_4v_YF-yx0cAAAAA:vC9wnmpvE_2HqoKudORNBfVCkxK4_YgRfp5_Lh2hIFFNc0ZyST-D7nwEqt1No4FculdvrohhKVF2wT9r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963:615,Availability,error,errors,615,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963:475,Energy Efficiency,reduce,reduces,475,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963:628,Usability,simpl,simple,628,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1090501309:58,Security,validat,validation,58,"First results from the ""stratified ocean remains at rest"" validation:. <img width=""394"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/162029258-21ef073b-62a1-47ae-8515-9fb7e2a7f377.png"">. Short answer --- with partial cells, a resting ocean does not remain at rest! So, we need to implement either the ""MITgcm method"" for hydrostatic pressure, or Lin 1997 (or both).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1090501309
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307:143,Deployability,integrat,integrate,143,"Ok, fixed an issue dispatching on a grid with partial cells in the hydrostatic pressure integral (turns out things go very wrong if we naively integrate to find hydrostatic pressure with partial cells!) here: https://github.com/CliMA/Oceananigans.jl/pull/2306/commits/9cc91dafe140ce4d5124a4d80e8a35496e45ad7e. Things look ok now, and a resting ocean remains at rest:. <img width=""598"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/166724316-df8cd89e-aed3-4027-b0fa-60cec7ad44ac.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307:143,Integrability,integrat,integrate,143,"Ok, fixed an issue dispatching on a grid with partial cells in the hydrostatic pressure integral (turns out things go very wrong if we naively integrate to find hydrostatic pressure with partial cells!) here: https://github.com/CliMA/Oceananigans.jl/pull/2306/commits/9cc91dafe140ce4d5124a4d80e8a35496e45ad7e. Things look ok now, and a resting ocean remains at rest:. <img width=""598"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/166724316-df8cd89e-aed3-4027-b0fa-60cec7ad44ac.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124:36,Security,validat,validation,36,"@fadaie91 is going to run some more validation tests, but I think this PR is basically ready to go. @sandreza this may interest you as well for your 1 deg simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124:47,Testability,test,tests,47,"@fadaie91 is going to run some more validation tests, but I think this PR is basically ready to go. @sandreza this may interest you as well for your 1 deg simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125165195:13,Testability,test,tests,13,"Assuming the tests pass, are there still tests to be done or is this ready to merge/use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125165195
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125165195:41,Testability,test,tests,41,"Assuming the tests pass, are there still tests to be done or is this ready to merge/use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125165195
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:292,Security,validat,validation,292,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:47,Testability,test,tests,47,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:84,Testability,test,tested,84,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:529,Testability,test,test,529,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:569,Testability,test,tests,569,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:437,Usability,simpl,simple,437,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:350,Security,validat,validation,350,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:693,Security,validat,validation,693,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:27,Testability,test,tested,27,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:224,Testability,test,testing,224,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:743,Testability,test,test,743,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:783,Testability,test,tests,783,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:912,Testability,test,tests,912,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:949,Testability,test,test,949,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:1426,Testability,test,test,1426," play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> 0)); test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_dynamics.jl: # Immersed grid cases; test_dynamics.jl: immersed_vertical_grid = ImmersedBoundaryGrid(RectilinearGrid(arch,; test_dynamics.jl: ImmersedBoundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:1674,Testability,Test,Testing,1674,"n script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> 0)); test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_dynamics.jl: # Immersed grid cases; test_dynamics.jl: immersed_vertical_grid = ImmersedBoundaryGrid(RectilinearGrid(arch,; test_dynamics.jl: ImmersedBoundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_bounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:2557,Testability,test,testset,2557,"t_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> 0)); test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_dynamics.jl: # Immersed grid cases; test_dynamics.jl: immersed_vertical_grid = ImmersedBoundaryGrid(RectilinearGrid(arch,; test_dynamics.jl: ImmersedBoundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:2586,Testability,test,test,2586,"t_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> 0)); test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_dynamics.jl: # Immersed grid cases; test_dynamics.jl: immersed_vertical_grid = ImmersedBoundaryGrid(RectilinearGrid(arch,; test_dynamics.jl: ImmersedBoundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:2999,Testability,test,testset,2999,"st_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_dynamics.jl: # Immersed grid cases; test_dynamics.jl: immersed_vertical_grid = ImmersedBoundaryGrid(RectilinearGrid(arch,; test_dynamics.jl: ImmersedBoundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_unit.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, GridFittedBoundary; test_multi_region_unit.jl: ibg = ImmersedBoundaryGrid(grid, immersed_boundary); test_shallow_water_models.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid"" begin; test_shallow_water_models.jl: @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:3261,Testability,Test,Testing,3261,"oundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_unit.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, GridFittedBoundary; test_multi_region_unit.jl: ibg = ImmersedBoundaryGrid(grid, immersed_boundary); test_shallow_water_models.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid"" begin; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid [$arch]"" begin; test_shallow_water_models.jl: @info ""Testing ShallowWaterModels with ImmersedBoundaryGrid [$arch]""; test_shallow_water_models.jl: grid_with_bump = ImmersedBoundaryGrid(grid, Grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:3966,Testability,test,testset,3966,"plicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_unit.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, GridFittedBoundary; test_multi_region_unit.jl: ibg = ImmersedBoundaryGrid(grid, immersed_boundary); test_shallow_water_models.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid"" begin; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid [$arch]"" begin; test_shallow_water_models.jl: @info ""Testing ShallowWaterModels with ImmersedBoundaryGrid [$arch]""; test_shallow_water_models.jl: grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); ```. Although maybe added tests could be done in a separate PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:4059,Testability,test,testset,4059,"plicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_unit.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, GridFittedBoundary; test_multi_region_unit.jl: ibg = ImmersedBoundaryGrid(grid, immersed_boundary); test_shallow_water_models.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid"" begin; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid [$arch]"" begin; test_shallow_water_models.jl: @info ""Testing ShallowWaterModels with ImmersedBoundaryGrid [$arch]""; test_shallow_water_models.jl: grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); ```. Although maybe added tests could be done in a separate PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:4166,Testability,Test,Testing,4166,"plicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_unit.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, GridFittedBoundary; test_multi_region_unit.jl: ibg = ImmersedBoundaryGrid(grid, immersed_boundary); test_shallow_water_models.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid"" begin; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid [$arch]"" begin; test_shallow_water_models.jl: @info ""Testing ShallowWaterModels with ImmersedBoundaryGrid [$arch]""; test_shallow_water_models.jl: grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); ```. Although maybe added tests could be done in a separate PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:4356,Testability,test,tests,4356,"plicit_solve.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:@testset ""Immersed boundaries test divergent flow solve with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_hydrostatic_free_surface_immersed_boundaries.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom; test_hydrostatic_free_surface_immersed_boundaries.jl:@testset ""Immersed boundaries with hydrostatic free surface models"" begin; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(bump)); test_hydrostatic_free_surface_immersed_boundaries.jl: @info "" Testing surface boundary conditions with ImmersedBoundaries in HydrostaticFreeSurfaceModel [$arch_str]...""; test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_hydrostatic_free_surface_immersed_boundaries.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); test_multi_region_unit.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, GridFittedBoundary; test_multi_region_unit.jl: ibg = ImmersedBoundaryGrid(grid, immersed_boundary); test_shallow_water_models.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid"" begin; test_shallow_water_models.jl: @testset ""ShallowWaterModels with ImmersedBoundaryGrid [$arch]"" begin; test_shallow_water_models.jl: @info ""Testing ShallowWaterModels with ImmersedBoundaryGrid [$arch]""; test_shallow_water_models.jl: grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); ```. Although maybe added tests could be done in a separate PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:495,Usability,simpl,simple,495,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126374334:14,Testability,test,tests,14,We should add tests judiciously because our CI resources are currently a little strained.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126374334
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131700908:142,Usability,intuit,intuitive,142,"Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131700908
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131853922:144,Usability,intuit,intuitive,144,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. The problem is that we don't want a cell to be too small because this could cause a serious restriction for numerical stability because of the CFL condition. I haven't faced this yet, but this is common practice in the MITgcm, so we are doing the same. But probably worth playing with it to see if/when it matters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131853922
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:675,Energy Efficiency,reduce,reduces,675,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:1305,Energy Efficiency,reduce,reduce,1305,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:696,Integrability,interface,interface,696,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:144,Usability,intuit,intuitive,144,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:228,Usability,intuit,intuitive,228,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:255,Usability,intuit,intuition,255,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1083551690:104,Deployability,Update,Update,104,"Will this work flow work @navidcy @simone-silvestri ?. 1. Fix tests for Julia 1.7 and merge this PR; 2. Update CUDA + KernelAbstractions. Or, do we need to do 1. and 2. simultaneously?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1083551690
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1083551690:62,Testability,test,tests,62,"Will this work flow work @navidcy @simone-silvestri ?. 1. Fix tests for Julia 1.7 and merge this PR; 2. Update CUDA + KernelAbstractions. Or, do we need to do 1. and 2. simultaneously?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1083551690
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1118132165:111,Testability,test,tests,111,@navidcy I'm pretty sure https://github.com/CliMA/Oceananigans.jl/pull/2502 fixed at least part of the failing tests here. I'm not sure how to deal with some of the conflicts so I'll leave the merging of main to you (unless you're okay with me taking a crack at it...),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1118132165
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1119601938:337,Testability,test,tests,337,I don't know how [5c8a763](https://github.com/CliMA/Oceananigans.jl/pull/2307/commits/5c8a763868bfcd244b84ad07122d11647f4f6994) almost passed (everything except for docs) but then a minor tweak on a doctest in [4e75ed3](https://github.com/CliMA/Oceananigans.jl/pull/2307/commits/4e75ed3f3222e25d51d24a4c74018e41cbe5d0ba) made a bunch of tests fail...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1119601938
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140:56,Testability,test,tests,56,I'd like to help and hopefully clean up or simplify the tests along the way.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140:43,Usability,simpl,simplify,43,I'd like to help and hopefully clean up or simplify the tests along the way.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140
https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1218528804:90,Deployability,release,releases,90,I'll close it as stale. Julia v1.8 is [coming up soon](https://github.com/JuliaLang/julia/releases/tag/v1.8.0) ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1218528804
https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806:74,Deployability,install,install,74,"Some of the points that could be in the Goals/Mission section:. - Easy to install, understand and use; - Versatile: model is made in blocks that could be combined and easily configured across scales; - Modern: this might be no independent from the others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806
https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806:174,Modifiability,config,configured,174,"Some of the points that could be in the Goals/Mission section:. - Easy to install, understand and use; - Versatile: model is made in blocks that could be combined and easily configured across scales; - Modern: this might be no independent from the others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806
https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533:82,Deployability,install,install,82,"> Some of the points that could be in the Goals/Mission section:; > ; > * Easy to install, understand and use; > * Versatile: model is made in blocks that could be combined and easily configured across scales; > * Modern: this might be no independent from the others. Yeah! ""Easy to install"" are ""versatile"" are definitely very important motivators of Julia. Here's some additional points from the ""Vision"" slide presented at Ocean Sciences 2022 Oceananigans town hall:. ![image](https://user-images.githubusercontent.com/15271942/156891514-6ae309ea-597c-4a6a-9ea4-aed1da6f231f.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533
https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533:283,Deployability,install,install,283,"> Some of the points that could be in the Goals/Mission section:; > ; > * Easy to install, understand and use; > * Versatile: model is made in blocks that could be combined and easily configured across scales; > * Modern: this might be no independent from the others. Yeah! ""Easy to install"" are ""versatile"" are definitely very important motivators of Julia. Here's some additional points from the ""Vision"" slide presented at Ocean Sciences 2022 Oceananigans town hall:. ![image](https://user-images.githubusercontent.com/15271942/156891514-6ae309ea-597c-4a6a-9ea4-aed1da6f231f.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533
https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533:184,Modifiability,config,configured,184,"> Some of the points that could be in the Goals/Mission section:; > ; > * Easy to install, understand and use; > * Versatile: model is made in blocks that could be combined and easily configured across scales; > * Modern: this might be no independent from the others. Yeah! ""Easy to install"" are ""versatile"" are definitely very important motivators of Julia. Here's some additional points from the ""Vision"" slide presented at Ocean Sciences 2022 Oceananigans town hall:. ![image](https://user-images.githubusercontent.com/15271942/156891514-6ae309ea-597c-4a6a-9ea4-aed1da6f231f.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533
https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:380,Integrability,depend,dependencies,380,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801
https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:534,Safety,avoid,avoid,534,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801
https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:142,Testability,test,test,142,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801
https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545:702,Availability,mainten,maintenance,702,"I think we'll want a ""community repo"" for cases eventually. Something like https://github.com/FluxML/model-zoo if I understand the purpose of that correctly. > For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. Isn't an ordinary Julia environment enough? For the community repo I think either . 1. There is one repo-wide `Project.toml` and all examples are kept up to date or; 2. Each example has it's own `Project.toml`. As I understand the flux model zoo takes approach 1 (this is in principle better, because otherwise the examples grow stale and cease to be useful). However, that requires maintenance and substantial effort. . I think we will still want in-house examples in addition to an external community repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545
https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545:249,Integrability,depend,dependencies,249,"I think we'll want a ""community repo"" for cases eventually. Something like https://github.com/FluxML/model-zoo if I understand the purpose of that correctly. > For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. Isn't an ordinary Julia environment enough? For the community repo I think either . 1. There is one repo-wide `Project.toml` and all examples are kept up to date or; 2. Each example has it's own `Project.toml`. As I understand the flux model zoo takes approach 1 (this is in principle better, because otherwise the examples grow stale and cease to be useful). However, that requires maintenance and substantial effort. . I think we will still want in-house examples in addition to an external community repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060052035:48,Usability,learn,learning,48,I think we should link to https://julialang.org/learning/getting-started/. and also take care not to repeat any material there. @tomchor do you mind if I edit this PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060052035
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262:302,Deployability,install,install,302,"> I think we should link to https://julialang.org/learning/getting-started/; > ; > and also take care not to repeat any material there. I actually think we should give a bit of the gist here too. A little overlap is okay because I think it helps users get an overview in one place before committing to install Oceananigans (lets them know how easy it is). Although I agree we should link Julia's ""getting started page"" too and what I wrote may be on the side of too much information. > @tomchor do you mind if I edit this PR?. Not at all. Go for it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262:50,Usability,learn,learning,50,"> I think we should link to https://julialang.org/learning/getting-started/; > ; > and also take care not to repeat any material there. I actually think we should give a bit of the gist here too. A little overlap is okay because I think it helps users get an overview in one place before committing to install Oceananigans (lets them know how easy it is). Although I agree we should link Julia's ""getting started page"" too and what I wrote may be on the side of too much information. > @tomchor do you mind if I edit this PR?. Not at all. Go for it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060059596:175,Deployability,install,installing,175,"Yeah, I think we can overlap a bit. I think the benefit of providing a link is because as Julia's instructions get better, we benefit for free. If we write a long essay about installing Julia, our users might miss out on those improvements elsewhere. Plus, we have to maintain it as things change, which creates work for us. But I also think it isn't that likely Julia installation will change very quickly and I agree that a bit more than just a link (even if there's overlap with official instructions) might suffice for a lot of people.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060059596
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060059596:369,Deployability,install,installation,369,"Yeah, I think we can overlap a bit. I think the benefit of providing a link is because as Julia's instructions get better, we benefit for free. If we write a long essay about installing Julia, our users might miss out on those improvements elsewhere. Plus, we have to maintain it as things change, which creates work for us. But I also think it isn't that likely Julia installation will change very quickly and I agree that a bit more than just a link (even if there's overlap with official instructions) might suffice for a lot of people.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060059596
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:466,Deployability,install,install,466,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:398,Energy Efficiency,efficient,efficiently,398,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:83,Integrability,depend,depends,83,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:314,Integrability,depend,dependencies,314,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:520,Integrability,depend,dependencies,520,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:557,Security,access,access,557,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:284,Usability,simpl,simply,284,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:480,Deployability,install,install,480,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:919,Deployability,install,installing,919,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:405,Energy Efficiency,efficient,efficiently,405,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:85,Integrability,depend,depends,85,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:321,Integrability,depend,dependencies,321,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:534,Integrability,depend,dependencies,534,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:571,Security,access,access,571,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:291,Usability,simpl,simply,291,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:478,Deployability,install,install,478,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:922,Deployability,install,installing,922,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:405,Energy Efficiency,efficient,efficiently,405,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:87,Integrability,depend,depends,87,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:321,Integrability,depend,dependencies,321,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:532,Integrability,depend,dependencies,532,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:569,Security,access,access,569,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:291,Usability,simpl,simply,291,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
https://github.com/CliMA/Oceananigans.jl/pull/2313#issuecomment-1060065095:16,Testability,test,tests,16,to anyone: when tests pass merge!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2313#issuecomment-1060065095
https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060142175:63,Safety,avoid,avoid,63,Why do we need to show an `OffsetArray` of a `CuArray`? Can we avoid that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060142175
https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190:195,Testability,test,tested,195,"> ```julia; > julia> using CUDA; CUDA.allowscalar(true); > ; > julia> model.velocities.u.data; > ```. This also isn't working for me now. Although I'm sure it did work at some point because I've tested this. I'm okay removing parts of this page this and linking to some CUDA docs. What led me to write that instead of referring to a link is that I don't find the [Julia GPU docs](https://juliagpu.org/cuda/) very helpful and couldn't find a docs page that explained the differences very clearly. I still can't, actually, but if anyone can suggest a page I also think it's best to just link to that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190
https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190:487,Usability,clear,clearly,487,"> ```julia; > julia> using CUDA; CUDA.allowscalar(true); > ; > julia> model.velocities.u.data; > ```. This also isn't working for me now. Although I'm sure it did work at some point because I've tested this. I'm okay removing parts of this page this and linking to some CUDA docs. What led me to write that instead of referring to a link is that I don't find the [Julia GPU docs](https://juliagpu.org/cuda/) very helpful and couldn't find a docs page that explained the differences very clearly. I still can't, actually, but if anyone can suggest a page I also think it's best to just link to that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190
https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1061159875:211,Testability,test,tested,211,"> > ```julia; > > julia> using CUDA; CUDA.allowscalar(true); > > ; > > julia> model.velocities.u.data; > > ```; > ; > This also isn't working for me now. Although I'm sure it did work at some point because I've tested this. No doubt. Everything's always evolving, always moving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1061159875
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060823690:582,Usability,learn,learned,582,"> Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). A few ideas to make progress. * Attempt to measure a rate of convergence for this case with a resolution study?. * Implement both WENO and third-order reconstruction of vorticity to see what the difference is (perhaps measuring numerical dissipation). If we get nothing from WENO (or they exhibit similar dissipation somehow) then maybe we've learned something. On that last point, it'd be fun to support. ```julia; momentum_advection = VectorInvariant(vorticity=WENO5()); ```. or something. > (there is no viscosity!). I think we can still aim for stable simulations with zero explicit dissipation... see results on https://github.com/CliMA/GeophysicalDissipation.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060823690
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060871207:782,Availability,error,error,782,"Wow! This is making me rethink advection schemes . Will ask a few questions to try and get this straight. 1. If we consider advection of a 2D scalar on a rectilinear grid without the vector invariant form, do the advection schemes preserve their order? I thoguht that it did and wonder if it's because of the vector invariant form that we have a problem. I will read the review paper but it will take me some time.; 2. What if we consdier the rotation of a Gaussian bump? That is a classic problem and we could text the order of accuracy after one time step, or after a full rotation. That way we can determine empirically what the orders of accuracy are for the different schemes.; 3. I suppse even in the propagating Rossby wave, there is an exact solution and we can compute the error to confirm the accuracy of eac method.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060871207
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426:398,Testability,test,test,398,"Thanks @simone-silvestri for clarifying. I checkede and the RH-wave is an exact solution in the case of a rigid-lid. Since the hydrostatic model must have a free-surface, taking gravity to be very big should make the solution even better. . It is impressive that everything is stable and can run with such a large time step considering how strong gravity is. . The advection of a bump is a simpler test case but not nearly as interesting as the RH-wave.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426:390,Usability,simpl,simpler,390,"Thanks @simone-silvestri for clarifying. I checkede and the RH-wave is an exact solution in the case of a rigid-lid. Since the hydrostatic model must have a free-surface, taking gravity to be very big should make the solution even better. . It is impressive that everything is stable and can run with such a large time step considering how strong gravity is. . The advection of a bump is a simpler test case but not nearly as interesting as the RH-wave.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:371,Availability,error,errors,371,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:497,Performance,perform,performance,497,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:808,Testability,test,tests,808,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:865,Testability,test,test,865,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:888,Testability,test,tests,888,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:446,Modifiability,evolve,evolves,446,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:626,Modifiability,sandbox,sandbox,626,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:378,Testability,test,test,378,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:626,Testability,sandbox,sandbox,626,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:637,Testability,test,test,637,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062146789:107,Usability,simpl,simplify,107,"@simone-silvestri : That sounds great!. If you point me to the `VectorInvariant` form I can certainly help simplify the current form to shallow water. One issue to think about is how to switch between the current shallow water model, which is in conservative form, but that's just a detail.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062146789
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062867973:410,Testability,test,testing,410,"> The hydrostatic free surface model is pretty similar to the shallow water model with one layer when the free surface displacement is small. So I think it probably makes sense to just work with `HydrostaticFreeSurfaceModel`. How difficult would it be to get a rigid lid version of `HydrostaticFreeSurface`? If we could do that then the RH wave solution would probably be an exact solution, and might help for testing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062867973
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062904021:219,Energy Efficiency,efficient,efficiently,219,I still think it might be a good idea to implement `VectorInvariant` in `ShallowWaterModel` first because then (1) we have a (hopefully positive) addition to the code (2) we have an exact solution to quantitatively and efficiently test the scheme on,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062904021
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062904021:231,Testability,test,test,231,I still think it might be a good idea to implement `VectorInvariant` in `ShallowWaterModel` first because then (1) we have a (hopefully positive) addition to the code (2) we have an exact solution to quantitatively and efficiently test the scheme on,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062904021
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062924033:904,Usability,simpl,simpler,904,"Just note that you'll have to redo any work you do in the context of shallow water because the formulation is different. `ShallowWaterModel` uses a conservative form and thus solves for `uh`, rather than `u = uh / h`. It was coded in this way explicitly to have different conservation properties. So you should probably not expect that things like numerical dissipation will be consistent between `ShallowWaterModel` and `HydrostaticFreeSurfaceModel`. Note that a single layer `HydrostaticFreeSurfaceModel` is _simpler_ than `ShallowWaterModel` because it linearizes the free surface. In other words, a `HydrostaticFreeSurfaceModel` with one vertical layer is a ""shallow water model"", but with a linear free surface. You can use that fact if you like if you want to derive analytical solutions. I'd just caution that working with `ShallowWaterModel` probably makes the problem _more complex_ rather than simpler. So while interesting in its own right, it doesn't seem like the easiest way to make progress towards getting an advection scheme working for `HydrostaticFreeSurfaceModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062924033
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062935271:419,Testability,test,testing,419,"> > The hydrostatic free surface model is pretty similar to the shallow water model with one layer when the free surface displacement is small. So I think it probably makes sense to just work with `HydrostaticFreeSurfaceModel`.; > ; > How difficult would it be to get a rigid lid version of `HydrostaticFreeSurface`? If we could do that then the RH wave solution would probably be an exact solution, and might help for testing. We get rigid lid by taking `g -> infty`. The implicit solve for the free surface then limits to a barotropic pressure solve. See https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#pressure-method-with-rigid-lid. and https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#pressure-method-with-implicit-linear-free-surface. While mathematically satisfying to take `g` to infinity _strictly_, I think using a very large value likely achieves the same thing practically speaking since it works out both in the mathematics and in the numerical algorithm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062935271
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1138,Availability,down,downstream,1138,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:547,Deployability,Integrat,Integrated,547,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:597,Energy Efficiency,green,green,597,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1230,Energy Efficiency,reduce,reduced,1230,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:547,Integrability,Integrat,Integrated,547,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1313,Performance,perform,perform,1313,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:3284,Availability,robust,robust,3284,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1281,Deployability,integrat,integrate,1281,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,Energy Efficiency,adapt,adapt,2116,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2269,Energy Efficiency,energy,energy,2269,"have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1281,Integrability,integrat,integrate,1281,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:338,Modifiability,extend,extend,338,"Thanks for the questions @simone-silvestri . I'll answer them here as it's probably easier for the discussion. **Q1**: You can certainly solve the equations in the non-conservative form and the method should work. But it does't have any advantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,Modifiability,adapt,adapt,2116,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:3908,Testability,test,test,3908,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1274,Usability,simpl,simply,1274,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2840,Usability,simpl,simply,2840,"sity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for st",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:3839,Usability,learn,learning,3839,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:4013,Usability,simpl,simpler,4013,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116:13,Deployability,update,update,13,"Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`. `VectorInvariant`. https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4. `WENOVectorInvariant`. https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4. `WENOVectorInvariantZVEL`. https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4. `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; - Noise is reduced significantly despite dissipation not being too high; - Agreement between different resolutions is much higher",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116:880,Energy Efficiency,reduce,reduced,880,"Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`. `VectorInvariant`. https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4. `WENOVectorInvariant`. https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4. `WENOVectorInvariantZVEL`. https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4. `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; - Noise is reduced significantly despite dissipation not being too high; - Agreement between different resolutions is much higher",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116:676,Performance,perform,perform,676,"Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`. `VectorInvariant`. https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4. `WENOVectorInvariant`. https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4. `WENOVectorInvariantZVEL`. https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4. `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; - Noise is reduced significantly despite dissipation not being too high; - Agreement between different resolutions is much higher",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116:48,Testability,test,test,48,"Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`. `VectorInvariant`. https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4. `WENOVectorInvariant`. https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4. `WENOVectorInvariantZVEL`. https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4. `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; - Noise is reduced significantly despite dissipation not being too high; - Agreement between different resolutions is much higher",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:15,Deployability,update,update,15,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:909,Energy Efficiency,reduce,reduced,909,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:1307,Energy Efficiency,energy,energy,1307,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:699,Performance,perform,perform,699,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:50,Testability,test,test,50,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:485,Deployability,integrat,integrated,485,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:837,Deployability,integrat,integrated,837,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:524,Energy Efficiency,green,green,524,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:848,Energy Efficiency,energy,energy,848,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:880,Energy Efficiency,energy,energy,880,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:485,Integrability,integrat,integrated,485,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:837,Integrability,integrat,integrated,837,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064523603:1348,Security,validat,validate,1348,"I have tried it on by completely removing lateral dissipation but unfortunately it crashes after 165 days of simulation with a time step of 6 minutes. This is the last snapshot I have of vertical vorticity compared to a run that starts at the same initial condition but with lateral dissipation and vector invariant scheme. Indeed the structures are much smaller (probably because of the fact that I completely removed horizontal dissipation, both laplacian and biharmonic for both tracers and velocity). On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. . The positive is that actually, for some weird reason, this scheme is a bit faster! (Maybe it has to do with how it interacts with the implicit solver?). I see a lot of wave propagation when I start the solution, maybe coming from adjustment to a zero-dissipation solution or maybe just because the numerical dissipation is not enough. I am trying to rerun it with a smaller timestep now to allow an adjustment period, maybe it helps? (or maybe the dream of running without explicit lateral dissipation is not attainable :sweat_smile:) . Also, I am _still_ not sure about this formulation on the sphere so trying it like this is kind of a hail Mary (@francispoulin I hope we can make it work on the`ShallowWaterModel` to validate it would be great). In particular I am not sure what to do with `Coriolis`, which we treat separately but I suspect has to be lumped in into the advection formulation. Also, I am not sure I am treating the immersed boundary conditions correctly. ![global](https://user-images.githubusercontent.com/33547697/157757996-da2a42c4-d822-4ab3-a721-82c8e8721ddb.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064523603
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996:602,Availability,robust,robust,602,"> On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. Hypothesis: dissipation by WENO is beautiful but may impose time-step restrictions. Or put another way, for whatever reason the _amount_ of dissipation introduced by WENO may have limits. And, WENO dissipation is, by design, dependent on grid-scale gradients. Thus if there are dynamics that synoptically produce tiny scales WENO may be ""too weak"" to dissipate over a given ""longish"" time-step. A bit vague but that's one guess at what might be happening. Hyperviscosity is more robust of a filter perhaps (the problem is that we always have to guess the coefficient). Does ""vorticity smoothing"" (vs velocity smoothing) WENO also blow up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996:348,Integrability,depend,dependent,348,"> On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. Hypothesis: dissipation by WENO is beautiful but may impose time-step restrictions. Or put another way, for whatever reason the _amount_ of dissipation introduced by WENO may have limits. And, WENO dissipation is, by design, dependent on grid-scale gradients. Thus if there are dynamics that synoptically produce tiny scales WENO may be ""too weak"" to dissipate over a given ""longish"" time-step. A bit vague but that's one guess at what might be happening. Hyperviscosity is more robust of a filter perhaps (the problem is that we always have to guess the coefficient). Does ""vorticity smoothing"" (vs velocity smoothing) WENO also blow up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064730470:350,Usability,simpl,simplest,350,"Very exciting results! Thanks for sharing the plots and animations @simone-silvestri . I am very keen to help with the `ShallowWaterModel` and am sure we can get something working, after we figure out exactly what we want. I am a little surprised that Coriolis might play a problem as those terms don't invovle any derivitaves and so are usually the simplest. But there is probably something I'm not getting. I am happy to think about this more tomorrow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064730470
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1067969115:33,Deployability,update,update,33,"Thanks @simone-silvestri for the update and all the work that came along with it. If we wanted to solve the shallow water model equations in vector invariant form, can we do this as a subset of `HydrostaticModel` since we could use pretty much all of what's there to put the model together? I'm happy to discuss more when you have time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1067969115
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081905400:413,Usability,learn,learn,413,"The movies look great, and I agree that the top row looks much better than the bottom row. @glwagner You mentioned that the top right (vorticity) is more dissipative than the top left (velocity). It's hard for me to see this from the movies. Did you look at other diagnostics to determine this or maybe you are much more perceptive to the fine details than I am. @simone-silvestri : I would be very interested to learn how your scheme difffers from the published method above. I have read through the paper and know it pretty well. Can you give me an idea as to what you do differently? Otherwise, I suppose I can look at the code I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081905400
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582:170,Modifiability,flexible,flexible,170,@simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042:907,Deployability,integrat,integrated,907,"Here's a screenshot of the top row from the final time-step:. ![image](https://user-images.githubusercontent.com/15271942/160630444-6b07529f-cf8b-4d03-8421-a6027153298e.png). showing significantly more small scale features on the left. The difference (the key to this PR) is using the velocity field in the smoothness metric for vorticity reconstruction, rather than the vorticity field. The ordinary WENO algorithm uses the smoothness of the field being reconstructed to produce weights for the candidate stencils. This method is therefore an innovation, since we are using the _velocity_ field to evaluate smoothness for reconstructing _vorticity_. The velocity field is smoother than vorticity, so this generally leads to less-dissipative stencils (but still ""enough"" dissipation to stabilize the simulation). @simone-silvestri definitely has more plots showing differences in spectra and time-series of integrated enstrophy, perhaps he will share!. I'm also going to paste an example of using this scheme in the code once I figure that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042:907,Integrability,integrat,integrated,907,"Here's a screenshot of the top row from the final time-step:. ![image](https://user-images.githubusercontent.com/15271942/160630444-6b07529f-cf8b-4d03-8421-a6027153298e.png). showing significantly more small scale features on the left. The difference (the key to this PR) is using the velocity field in the smoothness metric for vorticity reconstruction, rather than the vorticity field. The ordinary WENO algorithm uses the smoothness of the field being reconstructed to produce weights for the candidate stencils. This method is therefore an innovation, since we are using the _velocity_ field to evaluate smoothness for reconstructing _vorticity_. The velocity field is smoother than vorticity, so this generally leads to less-dissipative stencils (but still ""enough"" dissipation to stabilize the simulation). @simone-silvestri definitely has more plots showing differences in spectra and time-series of integrated enstrophy, perhaps he will share!. I'm also going to paste an example of using this scheme in the code once I figure that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693:172,Modifiability,flexible,flexible,172,> @simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ). @christophernhill don't we need to implement thickness weighting as part of a general overhaul to generic vertical coordinates? Or can we implement thickness weighting even in a fixed Z coordinate system?. @glwagner and @simone-silvestri I think you could explore thickness weighting in the non-linear shallow water. @francispoulin does that make sense? Might be a way to more quickly pilot some API and numerics aspects?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354:343,Modifiability,rewrite,rewrite,343,"Thanks @glwagner and I agree, at the last time I definitely see more smaller scale features. Also, I agree that since velocity is always smoother than vorticity, that is perhaps a better field to use. Clever idea!. In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086:130,Modifiability,rewrite,rewrite,130,"> In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?. That's right. The ""nonlinear Coriolis term"" in the vector invariant advection scheme requires reconstructing the vorticity at the locations of the x- and y-momentum. This PR implements WENO reconstruction of this term with two possibilities for the smoothness calculation: `VorticityStencil()` ([Roullet and Gaillard](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2021MS002663)) and `VelocityStencil()` (uses velocity rather than vorticity to calculate smoothness coefficients, implemented in this PR). The API is probably WIP; hopefully we will smooth this out. Anyways, this scheme can be used by writing. ```julia; using Oceananigans.Advection: VelocityStencil, VorticityStencil. # and then. momentum_advection = WENO5(vector_invariant=VelocityStencil()); ```. for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081963426:116,Usability,learn,learn,116,Thanks @glwagner and great we have both options. I imagine that @pvthinker (Guillaume) would be very interesting to learn about this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081963426
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720:430,Availability,error,errors,430,"@francispoulin, sure, I'd like to discuss the implementation of advection in the `ShallowWaterModel`. We can also zoom if you want, send me an email and we can see when we both have time. @christophernhill I'll take a look at that! It will be nice when implementing the cubed sphere. @pvthinker thanks for the comment! In this case vorticity is still the quantity being upwinded. I agree that upwinding the velocity would lead to errors since you have to ensure consistency in `div(U)` which you break by using an upwinding stencil for U (at least on a C-grid). ; Here I just relied on U to assess the ""smoothness"" of the vorticity stencils for upwinding. (if we look it in an ENO fashion, the choice of wether to upwind strongly or use a (less dissipative) centered stencil for vorticity relies on the velocity field rather than the vorticity field). . This might also be consistent with how you choose the stencils in the advection of tracers, where the choice is based on the evolved quantity (I have no mathematical proof in this case). I agree though, that maybe some more quantitative study is required to ensure that this method plays nicely. Just to share, these are the spectra (KE and enstrophy) at the final time step of the _immersed_ simulation shown above compared with a 2nd oder vector invariant (ensthrophy conserving) scheme with additional biharmonic viscosity (at a resolution of 1024^2) ; ![vel_x_spec-bih](https://user-images.githubusercontent.com/33547697/160655542-18b59170-a928-44ac-85f4-60b22b8e8dce.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720:979,Modifiability,evolve,evolved,979,"@francispoulin, sure, I'd like to discuss the implementation of advection in the `ShallowWaterModel`. We can also zoom if you want, send me an email and we can see when we both have time. @christophernhill I'll take a look at that! It will be nice when implementing the cubed sphere. @pvthinker thanks for the comment! In this case vorticity is still the quantity being upwinded. I agree that upwinding the velocity would lead to errors since you have to ensure consistency in `div(U)` which you break by using an upwinding stencil for U (at least on a C-grid). ; Here I just relied on U to assess the ""smoothness"" of the vorticity stencils for upwinding. (if we look it in an ENO fashion, the choice of wether to upwind strongly or use a (less dissipative) centered stencil for vorticity relies on the velocity field rather than the vorticity field). . This might also be consistent with how you choose the stencils in the advection of tracers, where the choice is based on the evolved quantity (I have no mathematical proof in this case). I agree though, that maybe some more quantitative study is required to ensure that this method plays nicely. Just to share, these are the spectra (KE and enstrophy) at the final time step of the _immersed_ simulation shown above compared with a 2nd oder vector invariant (ensthrophy conserving) scheme with additional biharmonic viscosity (at a resolution of 1024^2) ; ![vel_x_spec-bih](https://user-images.githubusercontent.com/33547697/160655542-18b59170-a928-44ac-85f4-60b22b8e8dce.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720
https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485:549,Integrability,Message,Message,549,"yes please!. On Mon, Mar 28, 2022 at 8:04 PM Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** approved this pull request.; >; > Bump minor version. Would also be sweet to see some of the global; > solutions!; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2317#pullrequestreview-923878927>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXBJN3S56JM4PSIOITVCJCIPANCNFSM5QCCJFGA>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485
https://github.com/CliMA/Oceananigans.jl/pull/2320#issuecomment-1067579051:24,Testability,test,tests,24,What happened here? All tests were OK and one day disaster happened...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320#issuecomment-1067579051
https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512007255:773,Testability,log,logarithmic,773,"Maybe this helps: You could use one `dt::Float32/64` for the time step in the model, and another `dt_int::Int` to count up the time used for output. Because with Float32; ```julia; julia> maxintfloat(Float32)/3600/24; 194.18074f0; ```; after 194 days of +dt you start flipping only the last mantissa bit, e.g. `dt=300f0` (5min); ```julia; julia> bitstring(300f0*3600*24*194); ""01001111100101011101110001000010"". julia> bitstring(300f0*3600*24*194 + 300f0); ""01001111100101011101110001000011""; ```; So after about one year +dt can be rounded back; ```julia; julia> bitstring(300f0*3600*24*366); ""01010000000011010101110011110111"". julia> bitstring(300f0*3600*24*366 + 300f0); ""01010000000011010101110011110111""; ```; but because you can factor out the `dt` and floats being logarithmic, this is actually independent of the time step `dt`.; ```julia; julia> bitstring(30f0*3600*24*366); ""01001110011000100010111001011000"". julia> bitstring(30f0*3600*24*366 + 30f0); ""01001110011000100010111001011000""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512007255
https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:165,Deployability,continuous,continuously,165,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461
https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:178,Energy Efficiency,adapt,adapt,178,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461
https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:119,Integrability,depend,dependent,119,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461
https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:178,Modifiability,adapt,adapt,178,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461
https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512206338:192,Safety,avoid,avoid,192,"Maybe we can design a custom `Clock` object that opts-in to this kind of behavior, when warranted. The default could be our original clock, but if you know what basis to use and you'd like to avoid rounding issues for very long running simulations, you can opt-in to `ExactSteppingClock` or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512206338
https://github.com/CliMA/Oceananigans.jl/issues/2323#issuecomment-1062210149:174,Safety,safe,safely,174,I think the outer one just transforms `kwargs` in positional `args` by requiring a `time` specified and filling the type of time in the parametric type `T`. . I think we can safely delete the interior constructor (if we have no need of something like `Clock(0)`),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2323#issuecomment-1062210149
https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062526156:33,Testability,test,tests,33,I think the new diffusion/cosine tests? Can't think of something else...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062526156
https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828:169,Performance,perform,performance,169,> I think the new diffusion/cosine tests? Can't think of something else... Ah indeed. It's also possible that some PRs caused a compile-time regression. Hopefully not a performance regression though. We should test that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828
https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828:35,Testability,test,tests,35,> I think the new diffusion/cosine tests? Can't think of something else... Ah indeed. It's also possible that some PRs caused a compile-time regression. Hopefully not a performance regression though. We should test that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828
https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828:210,Testability,test,test,210,> I think the new diffusion/cosine tests? Can't think of something else... Ah indeed. It's also possible that some PRs caused a compile-time regression. Hopefully not a performance regression though. We should test that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:521,Integrability,depend,dependent,521,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:62,Modifiability,refactor,refactoring,62,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062848647:96,Testability,test,tests,96,I like @glwagner 's suggestions. . One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062848647
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1234,Availability,avail,available,1234,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:476,Security,validat,validation,476,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1558,Security,validat,validation,1558,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:103,Testability,test,tests,103,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:392,Testability,test,testing,392,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:636,Testability,test,test,636,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:853,Testability,test,tests,853,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1144,Testability,test,test,1144,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1424,Testability,test,tests,1424,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1456,Testability,test,test,1456,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1492,Testability,test,test,1492,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1569,Testability,test,test,1569,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1663,Testability,test,test,1663,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1063185935:258,Usability,simpl,simple,258,"We can apply 4 pretty immediately and start speeding up things if everyone agrees. . @glwagner I'm curious as to why you think we should remove that example. Also, do we need the diffusion example? One might argue that the 2D turbulence example is almost as simple and introductory, while being more illustrative of ocean simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1063185935
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506:24,Modifiability,refactor,refactor,24,As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750:26,Modifiability,refactor,refactor,26,> As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?. I agree Makie is way better. Can we do animations too though? I'll explore. Sadly tartarus is not open CL enabled.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750
https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1479943557:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1479943557
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1062842793:266,Testability,test,tested,266,> Mind if I ask what this PR does? Sorry that i don't quite follow from looking at the code. Not sure about the code but judging from the PR name I think it's going to generate an estimate of code coverage (eg the percentage of lines of code in the package that are tested during CI).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1062842793
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063298738:125,Testability,test,tests,125,"I'm trying to set up back Codecov for Oceananigans.jl, e.g., we'll be able to see which parts of the code are covered by the tests and which bits are not. Something like https://app.codecov.io/gh/CliMA/OceanLearning.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063298738
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:66,Deployability,pipeline,pipeline,66,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:150,Deployability,pipeline,pipeline,150,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:474,Deployability,pipeline,pipeline,474,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:318,Modifiability,plugin,plugins,318,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:379,Testability,test,test,379,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075:78,Modifiability,variab,variable,78,"Correct. Buildkite doesn't support any templating last I looked.The `codecov` variable is currently unused though, so you can leave that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063513131:316,Testability,test,tested,316,"> Is it a good idea then? Is it worth the effort? We'll have to keep it up?. I'm almost there. I just can't seem to be able to submit the coverage reports!. We don't need to keep anything up! It's just for our own information. Well, if, e.g., we notice from the Codecov report that a big chunk of a submodule is not tested then we can have that in mind and either write some tests or inform users to use that module with caution?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063513131
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063513131:375,Testability,test,tests,375,"> Is it a good idea then? Is it worth the effort? We'll have to keep it up?. I'm almost there. I just can't seem to be able to submit the coverage reports!. We don't need to keep anything up! It's just for our own information. Well, if, e.g., we notice from the Codecov report that a big chunk of a submodule is not tested then we can have that in mind and either write some tests or inform users to use that module with caution?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063513131
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063531357:330,Testability,test,tested,330,"> > Is it a good idea then? Is it worth the effort? We'll have to keep it up?; > ; > I'm almost there. I just can't seem to be able to submit the coverage reports!; > ; > We don't need to keep anything up! It's just for our own information. Well, if, e.g., we notice from the Codecov report that a big chunk of a submodule is not tested then we can have that in mind and either write some tests or inform users to use that module with caution?. Oh, I thought it required extensive changes in our yml files.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063531357
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063531357:389,Testability,test,tests,389,"> > Is it a good idea then? Is it worth the effort? We'll have to keep it up?; > ; > I'm almost there. I just can't seem to be able to submit the coverage reports!; > ; > We don't need to keep anything up! It's just for our own information. Well, if, e.g., we notice from the Codecov report that a big chunk of a submodule is not tested then we can have that in mind and either write some tests or inform users to use that module with caution?. Oh, I thought it required extensive changes in our yml files.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063531357
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063818500:303,Deployability,pipeline,pipeline,303,"@maleadt, I tried all combinations I could think of but I couldn't get `Codecov.submit()` to work using the `SECRET_CODECOV_TOKEN`. It was only when I added the actual token as a kwarg that worked, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/ed1fe321199fd08c28052cd23a8c1b9d68368345/.buildkite/pipeline.yml#L540. Any ideas how to avoid using the token per se?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063818500
https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063818500:339,Safety,avoid,avoid,339,"@maleadt, I tried all combinations I could think of but I couldn't get `Codecov.submit()` to work using the `SECRET_CODECOV_TOKEN`. It was only when I added the actual token as a kwarg that worked, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/ed1fe321199fd08c28052cd23a8c1b9d68368345/.buildkite/pipeline.yml#L540. Any ideas how to avoid using the token per se?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063818500
https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063502994:8,Availability,fault,fault,8,"It's my fault, I suggested that @iuryt try using it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063502994
https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063503494:14,Availability,fault,fault,14,It's nobody's fault :); But just wanted to clarify the state of the matters at this point ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063503494
https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063508515:14,Availability,fault,fault,14,It's nobody's fault. Haha; I am just too excited to make it run with my simulations. I will try using convective adjustment for now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063508515
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065032559:82,Deployability,install,install,82,> I think CairoMakie is quite slow... that's one problem... Yea... I think we can install OpenCL on tartarus and then GLMakie will be fast.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065032559
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1556,Availability,ERROR,ERROR,1556,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1581,Availability,error,error,1581,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1614,Availability,error,error,1614,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1654,Availability,error,error,1654,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:670,Deployability,Update,Update,670,"@tomchor check out my changes to the tilted bottom boundary layer example: https://github.com/CliMA/Oceananigans.jl/pull/2333/commits/d8b455ffe1eabac34e9ef1c21ec70731eae03a74. The most important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:413,Energy Efficiency,reduce,reduced,413,"@tomchor check out my changes to the tilted bottom boundary layer example: https://github.com/CliMA/Oceananigans.jl/pull/2333/commits/d8b455ffe1eabac34e9ef1c21ec70731eae03a74. The most important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:582,Energy Efficiency,reduce,reduce,582,"@tomchor check out my changes to the tilted bottom boundary layer example: https://github.com/CliMA/Oceananigans.jl/pull/2333/commits/d8b455ffe1eabac34e9ef1c21ec70731eae03a74. The most important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1201,Performance,perform,perform,1201," important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1563,Performance,Load,LoadError,1563,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1643,Safety,avoid,avoid,1643,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1349,Availability,ERROR,ERROR,1349,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1374,Availability,error,error,1374,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1407,Availability,error,error,1407,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1447,Availability,error,error,1447,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:229,Deployability,update,updated,229,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:423,Energy Efficiency,reduce,reduced,423,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:592,Energy Efficiency,reduce,reduce,592,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:865,Performance,perform,perform,865,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1356,Performance,Load,LoadError,1356,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1436,Safety,avoid,avoid,1436,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1171,Testability,test,test,1171,"background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorien",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065348138:855,Availability,error,error,855,"> > I tried to do that but couldn't make it work in Julia.; > ; > How do you do it in python? We can use python here so if there's a python solution, it's good enough. It's a bit obscure, but you can find an example [here](https://matplotlib.org/stable/gallery/axisartist/demo_floating_axes.html#sphx-glr-gallery-axisartist-demo-floating-axes-py). Is it worth using Python here though? I feel like we'd need to have a whole conda environment set-up just for that. . > I'm re-running the script, keeping the REPL open (so I don't have to precompile, that's the whole point). But there is a line close(ds). Is close(ds) not enough?. The issue happens when Julia tries to open a file that's already in use by another process. So if you're using only the one Julia REPL over and over with this script (and you're closing the dataset afterwards), I think this error shouldn't be happening. Unless the script is crashing before teaching the `close(ds)` statement, which has happened with me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065348138
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482:139,Integrability,depend,dependencies,139,> Is it worth using Python here though? I feel like we'd need to have a whole conda environment set-up just for that. Julia can handle the dependencies if we want to use it. See `PyPlot.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1077657834:440,Usability,clear,clearly,440,"> > > @glwagner, @tomchor, @francispoulin: have a look at the baroclinic adjustment example :); > > ; > > ; > > I did now and it looks great! Nice to see both a vertical slice and a 3D image at the same time. Interesting how at the beginning it seems to be jittering almost before it becomes unstable. I think this is a great addition!; > ; > The jitters are gravity waves from the geostrophic adjustment. Nice. I suppose to see those more clearly one could plot the vertical velocity? I am not suggesting we do that here, but might try it out of my own interests sake.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1077657834
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1077667610:465,Usability,clear,clearly,465,"> > > > @glwagner, @tomchor, @francispoulin: have a look at the baroclinic adjustment example :); > > > ; > > > ; > > > I did now and it looks great! Nice to see both a vertical slice and a 3D image at the same time. Interesting how at the beginning it seems to be jittering almost before it becomes unstable. I think this is a great addition!; > > ; > > ; > > The jitters are gravity waves from the geostrophic adjustment.; > ; > Nice. I suppose to see those more clearly one could plot the vertical velocity? I am not suggesting we do that here, but might try it out of my own interests sake. That's not a bad idea since the experiment is apparently _about_ the adjustment. I think the plotting could use some work anyways, there's a lot of white space. Probably the plot title / label can't be it's own box, we have to somehow make it floating text...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1077667610
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1100777795:13,Testability,test,tests,13,@glwagner if tests pass I'll merge and open new PR or issue for the remaining tasks.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1100777795
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103313328:35,Availability,error,error,35,"Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at . https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182. Can anyone help me here? @glwagner, @tomchor?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103313328
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103316887:37,Availability,error,error,37,"> Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > ; > Can anyone help me here? @glwagner, @tomchor?. Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103316887
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:39,Availability,error,error,39,"> > Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > > ; > > Can anyone help me here? @glwagner, @tomchor?; > ; > Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point. Yeap. But still I get an error... ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs,; filename = joinpath(@__DIR__, ""tilted_bottom_boundary_layer.nc""),; schedule = TimeInterval(20minutes),; overwrite_existing = true); ERROR: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/netcdf_c.jl:255; [2] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/dataset.jl:201; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:542,Availability,error,error,542,"> > Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > > ; > > Can anyone help me here? @glwagner, @tomchor?; > ; > Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point. Yeap. But still I get an error... ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs,; filename = joinpath(@__DIR__, ""tilted_bottom_boundary_layer.nc""),; schedule = TimeInterval(20minutes),; overwrite_existing = true); ERROR: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/netcdf_c.jl:255; [2] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/dataset.jl:201; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:768,Availability,ERROR,ERROR,768,"> > Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > > ; > > Can anyone help me here? @glwagner, @tomchor?; > ; > Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point. Yeap. But still I get an error... ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs,; filename = joinpath(@__DIR__, ""tilted_bottom_boundary_layer.nc""),; schedule = TimeInterval(20minutes),; overwrite_existing = true); ERROR: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/netcdf_c.jl:255; [2] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/dataset.jl:201; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:6389,Deployability,Continuous,ContinuousBoundaryFunction,6389,"Tuple{Float64, Int64, Float64}}, ConstantCartesianCoriolis{Float64}, Nothing, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:7581,Deployability,Continuous,ContinuousBoundaryFunction,7581,"ndaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 1, typeof(drag_v), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:16028,Deployability,Continuous,ContinuousBoundaryFunction,16028,"}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, outputs::NamedTuple{(:u, :total_v, :w, :total_b, :ω_y), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Oceananigans.AbstractOperations.BinaryOperation{Center, Face, Center, typeof(+), Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:17301,Deployability,Continuous,ContinuousBoundaryFunction,17301,".Flux, Nothing}}, Nothing}, Oceananigans.AbstractOperations.BinaryOperation{Center, Face, Center, typeof(+), Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 1, typeof(drag_v), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Float64, typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.identity1), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:22167,Deployability,Continuous,ContinuousBoundaryFunction,22167,"eof(-), Oceananigans.AbstractOperations.Derivative{Face, Center, Face, typeof(Oceananigans.Operators.∂zᶠᶜᶠ), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, typeof(Oceananigans.Operators.identity2), typeof(∂z), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}, Oceananigans.AbstractOperations.Derivative{Face, Center, Face, typeof(Oceananigans.Operators.∂xᶠᶜᶠ), Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:703,Energy Efficiency,schedul,schedule,703,"> > Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > > ; > > Can anyone help me here? @glwagner, @tomchor?; > ; > Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point. Yeap. But still I get an error... ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs,; filename = joinpath(@__DIR__, ""tilted_bottom_boundary_layer.nc""),; schedule = TimeInterval(20minutes),; overwrite_existing = true); ERROR: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/netcdf_c.jl:255; [2] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/dataset.jl:201; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:25011,Energy Efficiency,schedul,schedule,25011,"rrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, typeof(Oceananigans.Operators.identity3), typeof(∂x), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/Research/OC.jl/src/OutputWriters/netcdf_output_writer.jl:349; [4] top-level scope; @ REPL[113]:1; ```. I think it's coming from . https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/src/OutputWriters/netcdf_output_writer.jl#L349",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515401:27,Testability,benchmark,benchmark,27,Probably should do a quick benchmark before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515401
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736:3,Energy Efficiency,Reduce,Reduced,3,> (Reduced Fields and Windowed Fields will have to be done separately). I think we just need to make sure these routines can handle `Nothing` boundary conditions and we're fine.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736:112,Integrability,rout,routines,112,> (Reduced Fields and Windowed Fields will have to be done separately). I think we just need to make sure these routines can handle `Nothing` boundary conditions and we're fine.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:58,Energy Efficiency,reduce,reduced,58,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:105,Energy Efficiency,reduce,reduced,105,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:325,Energy Efficiency,reduce,reduced,325,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:490,Energy Efficiency,reduce,reduced,490,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:429,Performance,optimiz,optimization,429,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:60,Energy Efficiency,reduce,reduced,60,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:107,Energy Efficiency,reduce,reduced,107,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:337,Energy Efficiency,reduce,reduced,337,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:502,Energy Efficiency,reduce,reduced,502,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:441,Performance,optimiz,optimization,441,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:517,Testability,benchmark,benchmark,517,"```; julia> grid = RectilinearGrid(GPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 5334 samples with 1 evaluation.; Range (min … max): 688.320 μs … 40.334 ms ┊ GC (min … max): 0.00% … 48.53%; Time (median): 840.539 μs ┊ GC (median): 0.00%; Time (mean ± σ): 931.289 μs ± 1.680 ms ┊ GC (mean ± σ): 4.12% ± 2.23%. ▂▆▇▇█▅▃ ▁▅▄▃▁▁ ▁ ; ▁▁▁▁▁▂▃▄▅▆████████████████████▅▆▄▄▅▄▄▃▄▅▃▄▃▃▃▃▂▂▂▁▂▂▂▂▁▂▁▂▁▁ ▄; 688 μs Histogram: frequency by time 1.11 ms <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:577,Testability,Benchmark,BenchmarkTools,577,"```; julia> grid = RectilinearGrid(GPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 5334 samples with 1 evaluation.; Range (min … max): 688.320 μs … 40.334 ms ┊ GC (min … max): 0.00% … 48.53%; Time (median): 840.539 μs ┊ GC (median): 0.00%; Time (mean ± σ): 931.289 μs ± 1.680 ms ┊ GC (mean ± σ): 4.12% ± 2.23%. ▂▆▇▇█▅▃ ▁▅▄▃▁▁ ▁ ; ▁▁▁▁▁▂▃▄▅▆████████████████████▅▆▄▄▅▄▄▃▄▅▃▄▃▃▃▃▂▂▂▁▂▂▂▂▁▂▁▂▁▁ ▄; 688 μs Histogram: frequency by time 1.11 ms <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:1017,Testability,benchmark,benchmark,1017,"), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 5334 samples with 1 evaluation.; Range (min … max): 688.320 μs … 40.334 ms ┊ GC (min … max): 0.00% … 48.53%; Time (median): 840.539 μs ┊ GC (median): 0.00%; Time (mean ± σ): 931.289 μs ± 1.680 ms ┊ GC (mean ± σ): 4.12% ± 2.23%. ▂▆▇▇█▅▃ ▁▅▄▃▁▁ ▁ ; ▁▁▁▁▁▂▃▄▅▆████████████████████▅▆▄▄▅▄▄▃▄▅▃▄▃▃▃▃▂▂▂▁▂▂▂▂▁▂▁▂▁▁ ▄; 688 μs Histogram: frequency by time 1.11 ms <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:1055,Testability,Benchmark,BenchmarkTools,1055,"), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 5334 samples with 1 evaluation.; Range (min … max): 688.320 μs … 40.334 ms ┊ GC (min … max): 0.00% … 48.53%; Time (median): 840.539 μs ┊ GC (median): 0.00%; Time (mean ± σ): 931.289 μs ± 1.680 ms ┊ GC (mean ± σ): 4.12% ± 2.23%. ▂▆▇▇█▅▃ ▁▅▄▃▁▁ ▁ ; ▁▁▁▁▁▂▃▄▅▆████████████████████▅▆▄▄▅▄▄▃▄▅▃▄▃▃▃▃▂▂▂▁▂▂▂▂▁▂▁▂▁▁ ▄; 688 μs Histogram: frequency by time 1.11 ms <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:1990,Testability,benchmark,benchmark,1990," <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 232.677 μs … 19.414 ms ┊ GC (min … max): 0.00% … 98.38%; Time (median): 257.090 μs ┊ GC (median): 0.00%; Time (mean ± σ): 283.748 μs ± 477.843 μs ┊ GC (mean ± σ): 5.51% ± 3.23%. ▁▂ ▄█▁ ; ▂██▆▅▃▂▁▁▁▁▃███▇▆▄▃▂▂▂▂▂▂▂▂▂▃▄▄▄▄▃▂▂▂▂▂▂▃▃▄▄▄▄▃▃▃▃▂▂▂▂▂▂▂▁▁▁▁ ▂; 233 μs Histogram: frequency by time 325 μs <. Memory estimate: 100.95 KiB, allocs estimate: 714. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 56.666 μs … 8.788 ms ┊ GC (min … max): 0.00% … 90.04%; Time (median): 60.193 μs ┊ GC (median): 0.00%; Time (mean ± σ): 65.835 μs ± 166.794 μs ┊ GC (mean ± σ): 4.88% ± 1.93%. ▄▆██▆▃▁ ; ▁▁▁▃▅████████▆▅▃▂▂▁▁▁▁▁▂▂▂▂▂▂▂▃▂▂▂▃▃▃▂▃▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂; 56.7 μs Histogram: frequency by time 77.1 μs <. Memory estimate: 41.09 KiB, allocs estimate: 103. julia> . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:2050,Testability,Benchmark,BenchmarkTools,2050," <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 232.677 μs … 19.414 ms ┊ GC (min … max): 0.00% … 98.38%; Time (median): 257.090 μs ┊ GC (median): 0.00%; Time (mean ± σ): 283.748 μs ± 477.843 μs ┊ GC (mean ± σ): 5.51% ± 3.23%. ▁▂ ▄█▁ ; ▂██▆▅▃▂▁▁▁▁▃███▇▆▄▃▂▂▂▂▂▂▂▂▂▃▄▄▄▄▃▂▂▂▂▂▂▃▃▄▄▄▄▃▃▃▃▂▂▂▂▂▂▂▁▁▁▁ ▂; 233 μs Histogram: frequency by time 325 μs <. Memory estimate: 100.95 KiB, allocs estimate: 714. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 56.666 μs … 8.788 ms ┊ GC (min … max): 0.00% … 90.04%; Time (median): 60.193 μs ┊ GC (median): 0.00%; Time (mean ± σ): 65.835 μs ± 166.794 μs ┊ GC (mean ± σ): 4.88% ± 1.93%. ▄▆██▆▃▁ ; ▁▁▁▃▅████████▆▅▃▂▂▁▁▁▁▁▂▂▂▂▂▂▂▃▂▂▂▃▃▃▂▃▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂; 56.7 μs Histogram: frequency by time 77.1 μs <. Memory estimate: 41.09 KiB, allocs estimate: 103. julia> . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:2482,Testability,benchmark,benchmark,2482," <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 232.677 μs … 19.414 ms ┊ GC (min … max): 0.00% … 98.38%; Time (median): 257.090 μs ┊ GC (median): 0.00%; Time (mean ± σ): 283.748 μs ± 477.843 μs ┊ GC (mean ± σ): 5.51% ± 3.23%. ▁▂ ▄█▁ ; ▂██▆▅▃▂▁▁▁▁▃███▇▆▄▃▂▂▂▂▂▂▂▂▂▃▄▄▄▄▃▂▂▂▂▂▂▃▃▄▄▄▄▃▃▃▃▂▂▂▂▂▂▂▁▁▁▁ ▂; 233 μs Histogram: frequency by time 325 μs <. Memory estimate: 100.95 KiB, allocs estimate: 714. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 56.666 μs … 8.788 ms ┊ GC (min … max): 0.00% … 90.04%; Time (median): 60.193 μs ┊ GC (median): 0.00%; Time (mean ± σ): 65.835 μs ± 166.794 μs ┊ GC (mean ± σ): 4.88% ± 1.93%. ▄▆██▆▃▁ ; ▁▁▁▃▅████████▆▅▃▂▂▁▁▁▁▁▂▂▂▂▂▂▂▃▂▂▂▃▃▃▂▃▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂; 56.7 μs Histogram: frequency by time 77.1 μs <. Memory estimate: 41.09 KiB, allocs estimate: 103. julia> . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:2520,Testability,Benchmark,BenchmarkTools,2520," <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 232.677 μs … 19.414 ms ┊ GC (min … max): 0.00% … 98.38%; Time (median): 257.090 μs ┊ GC (median): 0.00%; Time (mean ± σ): 283.748 μs ± 477.843 μs ┊ GC (mean ± σ): 5.51% ± 3.23%. ▁▂ ▄█▁ ; ▂██▆▅▃▂▁▁▁▁▃███▇▆▄▃▂▂▂▂▂▂▂▂▂▃▄▄▄▄▃▂▂▂▂▂▂▃▃▄▄▄▄▃▃▃▃▂▂▂▂▂▂▂▁▁▁▁ ▂; 233 μs Histogram: frequency by time 325 μs <. Memory estimate: 100.95 KiB, allocs estimate: 714. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 56.666 μs … 8.788 ms ┊ GC (min … max): 0.00% … 90.04%; Time (median): 60.193 μs ┊ GC (median): 0.00%; Time (mean ± σ): 65.835 μs ± 166.794 μs ┊ GC (mean ± σ): 4.88% ± 1.93%. ▄▆██▆▃▁ ; ▁▁▁▃▅████████▆▅▃▂▂▁▁▁▁▁▂▂▂▂▂▂▂▃▂▂▂▃▃▃▂▃▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂; 56.7 μs Histogram: frequency by time 77.1 μs <. Memory estimate: 41.09 KiB, allocs estimate: 103. julia> . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:5,Testability,benchmark,benchmarking,5,Some benchmarking...; ```; This PR. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 49.720 ms │ 479.12 KiB │ 1016 │ 10 │; │ CPU │ Float64 │ 128 │ 400.668 ms │ 479.12 KiB │ 1016 │ 10 │; │ CPU │ Float64 │ 256 │ 3.303 s │ 479.12 KiB │ 1016 │ 2 │; │ GPU │ Float64 │ 64 │ 3.179 ms │ 738.19 KiB │ 3039 │ 10 │; │ GPU │ Float64 │ 128 │ 8.913 ms │ 746.97 KiB │ 3601 │ 10 │; │ GPU │ Float64 │ 256 │ 68.202 ms │ 1.25 MiB │ 37738 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 14.389 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 128 │ 26.194 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 256 │ 127.087 ms │ 1.33 MiB │ 2157 │ 10 │; │ GPU │ Float64 │ 64 │ 4.682 ms │ 1.73 MiB │ 4444 │ 10 │; │ GPU │ Float64 │ 128 │ 3.091 ms │ 1.73 MiB │ 4457 │ 10 │; │ GPU │ Float64 │ 256 │ 3.346 ms │ 1.73 MiB │ 4416 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.130 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 128 │ 6.043 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 256 │ 34.627 ms │ 796.97 KiB │ 1460 │ 10 │; │ GPU │ Float64 │ 64 │ 2.164 ms │ 1.0,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:57,Testability,benchmark,benchmarks,57,Some benchmarking...; ```; This PR. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 49.720 ms │ 479.12 KiB │ 1016 │ 10 │; │ CPU │ Float64 │ 128 │ 400.668 ms │ 479.12 KiB │ 1016 │ 10 │; │ CPU │ Float64 │ 256 │ 3.303 s │ 479.12 KiB │ 1016 │ 2 │; │ GPU │ Float64 │ 64 │ 3.179 ms │ 738.19 KiB │ 3039 │ 10 │; │ GPU │ Float64 │ 128 │ 8.913 ms │ 746.97 KiB │ 3601 │ 10 │; │ GPU │ Float64 │ 256 │ 68.202 ms │ 1.25 MiB │ 37738 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 14.389 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 128 │ 26.194 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 256 │ 127.087 ms │ 1.33 MiB │ 2157 │ 10 │; │ GPU │ Float64 │ 64 │ 4.682 ms │ 1.73 MiB │ 4444 │ 10 │; │ GPU │ Float64 │ 128 │ 3.091 ms │ 1.73 MiB │ 4457 │ 10 │; │ GPU │ Float64 │ 256 │ 3.346 ms │ 1.73 MiB │ 4416 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.130 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 128 │ 6.043 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 256 │ 34.627 ms │ 796.97 KiB │ 1460 │ 10 │; │ GPU │ Float64 │ 64 │ 2.164 ms │ 1.0,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:796,Testability,benchmark,benchmarks,796,Some benchmarking...; ```; This PR. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 49.720 ms │ 479.12 KiB │ 1016 │ 10 │; │ CPU │ Float64 │ 128 │ 400.668 ms │ 479.12 KiB │ 1016 │ 10 │; │ CPU │ Float64 │ 256 │ 3.303 s │ 479.12 KiB │ 1016 │ 2 │; │ GPU │ Float64 │ 64 │ 3.179 ms │ 738.19 KiB │ 3039 │ 10 │; │ GPU │ Float64 │ 128 │ 8.913 ms │ 746.97 KiB │ 3601 │ 10 │; │ GPU │ Float64 │ 256 │ 68.202 ms │ 1.25 MiB │ 37738 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 14.389 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 128 │ 26.194 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 256 │ 127.087 ms │ 1.33 MiB │ 2157 │ 10 │; │ GPU │ Float64 │ 64 │ 4.682 ms │ 1.73 MiB │ 4444 │ 10 │; │ GPU │ Float64 │ 128 │ 3.091 ms │ 1.73 MiB │ 4457 │ 10 │; │ GPU │ Float64 │ 256 │ 3.346 ms │ 1.73 MiB │ 4416 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.130 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 128 │ 6.043 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 256 │ 34.627 ms │ 796.97 KiB │ 1460 │ 10 │; │ GPU │ Float64 │ 64 │ 2.164 ms │ 1.0,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:1522,Testability,benchmark,benchmarks,1522,s │ 1.25 MiB │ 37738 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 14.389 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 128 │ 26.194 ms │ 1.33 MiB │ 2157 │ 10 │; │ CPU │ Float64 │ 256 │ 127.087 ms │ 1.33 MiB │ 2157 │ 10 │; │ GPU │ Float64 │ 64 │ 4.682 ms │ 1.73 MiB │ 4444 │ 10 │; │ GPU │ Float64 │ 128 │ 3.091 ms │ 1.73 MiB │ 4457 │ 10 │; │ GPU │ Float64 │ 256 │ 3.346 ms │ 1.73 MiB │ 4416 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.130 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 128 │ 6.043 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 256 │ 34.627 ms │ 796.97 KiB │ 1460 │ 10 │; │ GPU │ Float64 │ 64 │ 2.164 ms │ 1.06 MiB │ 3315 │ 10 │; │ GPU │ Float64 │ 128 │ 2.112 ms │ 1.06 MiB │ 3315 │ 10 │; │ GPU │ Float64 │ 256 │ 2.614 ms │ 1.06 MiB │ 3315 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴────────────┴────────┴─────────┘. origin/main. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 81.958 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 128 │ 405.241 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Floa,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:2257,Testability,benchmark,benchmarks,2257,ms │ 1.73 MiB │ 4416 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.130 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 128 │ 6.043 ms │ 796.97 KiB │ 1460 │ 10 │; │ CPU │ Float64 │ 256 │ 34.627 ms │ 796.97 KiB │ 1460 │ 10 │; │ GPU │ Float64 │ 64 │ 2.164 ms │ 1.06 MiB │ 3315 │ 10 │; │ GPU │ Float64 │ 128 │ 2.112 ms │ 1.06 MiB │ 3315 │ 10 │; │ GPU │ Float64 │ 256 │ 2.614 ms │ 1.06 MiB │ 3315 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴────────────┴────────┴─────────┘. origin/main. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 81.958 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 128 │ 405.241 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 256 │ 6.018 s │ 636.84 KiB │ 1576 │ 1 │; │ GPU │ Float64 │ 64 │ 3.386 ms │ 953.50 KiB │ 4124 │ 10 │; │ GPU │ Float64 │ 128 │ 11.686 ms │ 979.23 KiB │ 5771 │ 10 │; │ GPU │ Float64 │ 256 │ 68.086 ms │ 1.24 MiB │ 24592 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 9.178 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 128 │ 29.660 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ F,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:2997,Testability,benchmark,benchmarks,2997,3315 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴────────────┴────────┴─────────┘. origin/main. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 81.958 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 128 │ 405.241 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 256 │ 6.018 s │ 636.84 KiB │ 1576 │ 1 │; │ GPU │ Float64 │ 64 │ 3.386 ms │ 953.50 KiB │ 4124 │ 10 │; │ GPU │ Float64 │ 128 │ 11.686 ms │ 979.23 KiB │ 5771 │ 10 │; │ GPU │ Float64 │ 256 │ 68.086 ms │ 1.24 MiB │ 24592 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 9.178 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 128 │ 29.660 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 256 │ 225.186 ms │ 1.39 MiB │ 2714 │ 10 │; │ GPU │ Float64 │ 64 │ 6.415 ms │ 1.82 MiB │ 5793 │ 10 │; │ GPU │ Float64 │ 128 │ 6.660 ms │ 1.82 MiB │ 5806 │ 10 │; │ GPU │ Float64 │ 256 │ 4.325 ms │ 1.82 MiB │ 5813 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.512 ms │ 801.66 KiB │ 1742 │ 10 │; │ CPU │ Float64 │ 128 │ 9.964 ms │ 801.66 KiB │ 1742 │ 10 │; │ CPU │ Float64 │ 256 │ 33,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:3722,Testability,benchmark,benchmarks,3722,ples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 81.958 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 128 │ 405.241 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 256 │ 6.018 s │ 636.84 KiB │ 1576 │ 1 │; │ GPU │ Float64 │ 64 │ 3.386 ms │ 953.50 KiB │ 4124 │ 10 │; │ GPU │ Float64 │ 128 │ 11.686 ms │ 979.23 KiB │ 5771 │ 10 │; │ GPU │ Float64 │ 256 │ 68.086 ms │ 1.24 MiB │ 24592 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 9.178 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 128 │ 29.660 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 256 │ 225.186 ms │ 1.39 MiB │ 2714 │ 10 │; │ GPU │ Float64 │ 64 │ 6.415 ms │ 1.82 MiB │ 5793 │ 10 │; │ GPU │ Float64 │ 128 │ 6.660 ms │ 1.82 MiB │ 5806 │ 10 │; │ GPU │ Float64 │ 256 │ 4.325 ms │ 1.82 MiB │ 5813 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.512 ms │ 801.66 KiB │ 1742 │ 10 │; │ CPU │ Float64 │ 128 │ 9.964 ms │ 801.66 KiB │ 1742 │ 10 │; │ CPU │ Float64 │ 256 │ 33.379 ms │ 801.66 KiB │ 1742 │ 10 │; │ GPU │ Float64 │ 64 │ 3.847 ms │ 1.05 MiB │ 4029 │ 10 │; │ GPU │ Float64 │ 128 │ 3.874 ms │ 1.05 MiB │ 4029 │ 10 │; │ GPU │ Float64 │ 256 │ 4.248 ms │ 1.05 MiB │ 4029 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴────────────┴────────┴─────────┘; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300:983,Energy Efficiency,reduce,reduces,983,"The boundary condition functions should have the arguments `x, y, t, p` (no `z`!) so. ```julia; Qᵘ(x, y, t, p) = radius(x, y) < p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; Qᵛ(x, y, t, p) = radius(x, y) < p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; ```. You may also want to tag functions with `@inline` and use `ifelse` rather than the shortcircuiting ternary `? :` for performance:. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline U(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = ifelse(d(x, y) < p.L, +imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = ifelse(d(x, y) < p.L, -real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; ```. Is `U` air speed? We sometimes recommend using the momentum flux itself as an input, rather than introducing a bulk formula (like a drag law) because this reduces the number of parameters in the problem (making it easier to understand and reproduce) --- but that's up to you. Here you could write. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline s(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, +imag(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, -real(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; ```. or something like that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300:444,Performance,perform,performance,444,"The boundary condition functions should have the arguments `x, y, t, p` (no `z`!) so. ```julia; Qᵘ(x, y, t, p) = radius(x, y) < p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; Qᵛ(x, y, t, p) = radius(x, y) < p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; ```. You may also want to tag functions with `@inline` and use `ifelse` rather than the shortcircuiting ternary `? :` for performance:. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline U(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = ifelse(d(x, y) < p.L, +imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = ifelse(d(x, y) < p.L, -real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; ```. Is `U` air speed? We sometimes recommend using the momentum flux itself as an input, rather than introducing a bulk formula (like a drag law) because this reduces the number of parameters in the problem (making it easier to understand and reproduce) --- but that's up to you. Here you could write. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline s(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, +imag(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, -real(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; ```. or something like that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425:48,Performance,perform,performance,48,"Could you explain why using `ifelse` has better performance?; Is this because the ternary `? :` is an alias for `ifelse`? ; What about `@inline`?. In this case, we only had the wind velocity from the specifications of the computer fans we used for the rotating tank experiment, but I understand that even in this case, I could calculate `τ₀` using bulk formula while defining `p`. Thanks for the idea. For the boundary conditions. I was my bad. You specify on the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux) that. > By default, a function boundary condition is called with the signature; > ; > `f(ξ, η, t)`; > ; > where t is time and ξ, η are spatial coordinates that vary along the boundary:; > ; > `f(y, z, t)` on x-boundaries;; > `f(x, z, t)` on y-boundaries;; > `f(x, y, t)` on z-boundaries. I am just repeating here in case someone falls in the same problem and comes to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:577,Availability,ERROR,ERROR,577,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1051,Availability,ERROR,ERROR,1051,"s an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execut",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1300,Availability,ERROR,ERROR,1300,"=== true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:48,Performance,perform,performance,48,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1866,Performance,optimiz,optimize,1866," second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we spec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:2049,Performance,optimiz,optimizations,2049,"empt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we specifically annotate them. So it seems we probably need to add `@inline` to every ""hot"" function that's called in a kernel, at every grid point (like a forcing function or boundary condition functi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:2716,Performance,optimiz,optimize,2716,"[2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we specifically annotate them. So it seems we probably need to add `@inline` to every ""hot"" function that's called in a kernel, at every grid point (like a forcing function or boundary condition function). But I suggest you benchmark yourself and see!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:608,Security,access,access,608,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1082,Security,access,access,1082,"s an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execut",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1331,Security,access,access,1331,"=== true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:249,Testability,log,logicals,249,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:2024,Testability,log,logic,2024,"empt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we specifically annotate them. So it seems we probably need to add `@inline` to every ""hot"" function that's called in a kernel, at every grid point (like a forcing function or boundary condition functi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:3097,Testability,benchmark,benchmark,3097,"[2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we specifically annotate them. So it seems we probably need to add `@inline` to every ""hot"" function that's called in a kernel, at every grid point (like a forcing function or boundary condition function). But I suggest you benchmark yourself and see!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:3588,Availability,down,downside,3588,"losure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:2158,Energy Efficiency,efficient,efficient,2158,"licitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstract operations of `fake_model.velocities` and `fake_model.tracers`, and these named tuples can be passed on to a ""true"" model. This _could_ be slightly more efficient than computing and storing `Ri` every time-step. This would look something like. ```julia; grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=nothing). velocities = fake_model.velocities; tracers = fake_model.tracers; Ri = ∂z(b) / (∂z(u)^2 + ∂z(v)^2). ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)); closure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdams",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:3692,Safety,predict,predictor-corrector,3692,"losure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:547,Usability,simpl,simplest,547,"@iuryt this is a great question! Do you mind if I convert this to a discussion? I think there are multiple answers and a discussion might be better suited for keeping track of the solutions for future users. There are a few possible solutions. Note that the diffusivities can also be `AbstractArray`, which include `Field` and `AbstractOperations`. Using either a concrete `Field` or `AbstractOperation` is how you'll solve this problem. ## Solution: pre-define a Richardson number field and compute in `Simulation.callbacks`. This is perhaps the simplest solution: create a field `Ri = Field{Center, Center, Face}(grid)`, and then to define an abstract operation that's a function of this field as your diffusivity, something like:. ```julia; # Pacanowski-Philander (eg https://glwagner.github.io/OceanTurb.jl/latest/models/pacanowskiphilander/); Ri = Field{Center, Center, Face}(grid) # ∂z(b) / (∂z(u)^2 + ∂z(v)^2); ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:4169,Usability,simpl,simply,4169," tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` and set them to 0 _during_ the `Ri` computation (I don't have the code for that off the top of my head so I'll have to look into it and post later) or 2) write a kernel function (this requires using more primitive operators than `AbstractOperations`, and also being careful about staggered grid locations) to use with `KernelFunctionOperation` that does the necessary checking. There's a lot of great examples of how to use `KernelFunctionOperation` here: https://github.com/tomchor/Oceanostics.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065996051:2722,Performance,perform,performant,2722,"actOperation that computes Ri in advance; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end. simulation.callbacks[:compute_Ri] = Callback(compute_Ri!) # uses default IterationInterval(1). fields = []; function grab_fields!(sim); uⁿ = Array(interior(u, 1, 1, :)); vⁿ = Array(interior(v, 1, 1, :)); bⁿ = Array(interior(b, 1, 1, :)); iter = iteration(sim); t = time(sim); push!(fields, (; t, iter, u=uⁿ, v=vⁿ, b=bⁿ)); return nothing; end. simulation.callbacks[:grabber] = Callback(grab_fields!, TimeInterval(10minutes)). N² = 1e-4; S² = 1e-3 # Ri = 0.1; z₀ = -50; Δzu = 4; Δzb = 16. step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. uᵢ(x, y, z) = Δzu * sqrt(S²) * step(z, z₀, Δzu); bᵢ(x, y, z) = Δzb * N² * step(z, z₀, Δzb). set!(model, u=uᵢ, b=bᵢ). run!(simulation). z = znodes(Center, grid); fig = Figure(); ax_u = Axis(fig[1, 1], ylabel=""z (m)"", xlabel=""u (m s⁻¹)""); ax_b = Axis(fig[1, 2], ylabel=""z (m)"", xlabel=""b (m s⁻²)""); slider = Slider(fig[2, :], range=1:length(fields), startvalue=1); n = slider.value; uⁿ = @lift fields[$n].u; bⁿ = @lift fields[$n].b. lines!(ax_u, uⁿ, z); lines!(ax_b, bⁿ, z). title = @lift ""Diffusing shear layer at t = "" * prettytime(fields[$n].t); Label(fig[0, :], title). display(fig). record(fig, ""pacanowski_philander_diffusion.gif"", 1:length(fields), framerate=12) do nn; @info ""Drawing frame $nn of $(length(fields))...""; n[] = nn; end; ```. produces. ![pacanowski_philander_diffusion](https://user-images.githubusercontent.com/15271942/158040409-1157f273-89b7-429e-b9f1-2bde8a62d00b.gif). My main concern is that our broadcasting may not be performant when used online during a simulation. Possibly, we can fix that or make it better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065996051
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:474,Availability,down,downside,474,"Ok, a bit better now!. The following uses some lower-level Oceananigans functions and `KernelFunctionOperation`. I suspect this is a bit more performant, but I'm not sure. The main reason is that I think our broadcasting machinery has some overhead right now, so writing `field .= op` is not all that cheap (we can fix this, but it might take some work). @iuryt if you have the chance to benchmark different solutions, it'd be interesting to hear what works best!. The main downside of this solution is that we need to understand the staggered grid to implement it. Maybe not too onerous (@simone-silvestri thinks I should give users more credit), but part of me feels like we should be able to auto-magic our way around this. The main barrier to using abstract operations here is figuring out how to implement this function with a `ConditionalOperation` (and also having `<` as a valid `BinaryOperation`, eg figuring out #2169). I also like the following because it's the first known example of `auxiliary_fields` being used. Hooray for that! Also I realized that we can just use a linear stratification which is nice. I made the shear stronger to increase the drama. Working on this helped uncover a few wrinkles in the user API:. * `closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=κᵇ)` doesn't work (#2342); * `HydrostaticFreeSurfaceModel(; velocities=velocities)` doesn't work (#2341). ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, trac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:2861,Deployability,update,updated,2861," RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); velocities = fake_model.velocities; tracers = fake_model.tracers. # Pacanowski-Philander implementation; #; # The following implements the Packanowski-Philander model for shear-modulated mixing; # with parameters:; ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. # In Packanowski-Philander both the viscosity and diffusivity; # depend on the Richardson number:; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); Ri = Field(Ri_op). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). # For `closure` to work correctly, the Ri must be defined as an ""auxiliary field"" of the model.; # Fields in model.auxiliary_fields are updated every time-stepper stage.; model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer(), auxiliary_fields = (; Ri)); model.velocities = velocities; model.tracers = tracers. # Initial condition with Ri ≈ 0.01; step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. N² = 1e-4; bᵢ(x, y, z) = N² * z. S² = 1e-2; Δu = 4 # m; uᵢ(x, y, z) = Δu * sqrt(S²) * step(z, -grid.Lz/2, Δu). set!(model, u=uᵢ, b=bᵢ). simulation = Simulation(model, Δt=1minute, stop_time=1day). # Alternative to writing output.; fields = []; function grab_fields!(sim); u, v, w = sim.model.velocities; b = sim.model.tracers.b; Ri = sim.model.auxiliary_fields.Ri; uⁿ = Array(interior(u, 1, 1, :)); vⁿ = Array(interior(v, 1, 1, :)); bⁿ = Array(interior(b, 1, 1, :)); Riⁿ = Array(interior(Ri, 1, 1, :)); push!(fields, (; t=time(sim), i=iteration(sim), u=uⁿ, v=vⁿ, b=bⁿ, Ri=Riⁿ)); return nothing; end. simulation.callbacks[:grabber] = Callback(grab_fields!, TimeInterval(10minutes)). run!(sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:2375,Integrability,depend,depend,2375,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); velocities = fake_model.velocities; tracers = fake_model.tracers. # Pacanowski-Philander implementation; #; # The following implements the Packanowski-Philander model for shear-modulated mixing; # with parameters:; ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. # In Packanowski-Philander both the viscosity and diffusivity; # depend on the Richardson number:; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); Ri = Field(Ri_op). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). # For `closure` to work correctly, the Ri must be defined as an ""auxiliary field"" of the model.; # Fields in model.auxiliary_fields are updated every time-stepper stage.; model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer(), auxiliary_fields = (; Ri)); model.velocities = velocities; model.tracers = tracers. # Initial condition with Ri ≈ 0.01; step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. N² = 1e-4; bᵢ(x, y, z) = N² * z. S² = 1e-2; Δu = 4 # m; uᵢ(x, y, z) = Δu * sqrt(S²) * step(z, -grid.Lz/2, Δu). set!(model, u=uᵢ, b=bᵢ). simulation = Simulation(model, Δt=1minute, stop_time=1day). # Alternative to writing output.; fields ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:142,Performance,perform,performant,142,"Ok, a bit better now!. The following uses some lower-level Oceananigans functions and `KernelFunctionOperation`. I suspect this is a bit more performant, but I'm not sure. The main reason is that I think our broadcasting machinery has some overhead right now, so writing `field .= op` is not all that cheap (we can fix this, but it might take some work). @iuryt if you have the chance to benchmark different solutions, it'd be interesting to hear what works best!. The main downside of this solution is that we need to understand the staggered grid to implement it. Maybe not too onerous (@simone-silvestri thinks I should give users more credit), but part of me feels like we should be able to auto-magic our way around this. The main barrier to using abstract operations here is figuring out how to implement this function with a `ConditionalOperation` (and also having `<` as a valid `BinaryOperation`, eg figuring out #2169). I also like the following because it's the first known example of `auxiliary_fields` being used. Hooray for that! Also I realized that we can just use a linear stratification which is nice. I made the shear stronger to increase the drama. Working on this helped uncover a few wrinkles in the user API:. * `closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=κᵇ)` doesn't work (#2342); * `HydrostaticFreeSurfaceModel(; velocities=velocities)` doesn't work (#2341). ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, trac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:388,Testability,benchmark,benchmark,388,"Ok, a bit better now!. The following uses some lower-level Oceananigans functions and `KernelFunctionOperation`. I suspect this is a bit more performant, but I'm not sure. The main reason is that I think our broadcasting machinery has some overhead right now, so writing `field .= op` is not all that cheap (we can fix this, but it might take some work). @iuryt if you have the chance to benchmark different solutions, it'd be interesting to hear what works best!. The main downside of this solution is that we need to understand the staggered grid to implement it. Maybe not too onerous (@simone-silvestri thinks I should give users more credit), but part of me feels like we should be able to auto-magic our way around this. The main barrier to using abstract operations here is figuring out how to implement this function with a `ConditionalOperation` (and also having `<` as a valid `BinaryOperation`, eg figuring out #2169). I also like the following because it's the first known example of `auxiliary_fields` being used. Hooray for that! Also I realized that we can just use a linear stratification which is nice. I made the shear stronger to increase the drama. Working on this helped uncover a few wrinkles in the user API:. * `closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=κᵇ)` doesn't work (#2342); * `HydrostaticFreeSurfaceModel(; velocities=velocities)` doesn't work (#2341). ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, trac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:791,Deployability,update,update,791,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1671,Integrability,depend,depend,1671,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:300,Modifiability,parameteriz,parameterization,300,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:373,Modifiability,parameteriz,parameterization,373,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1817,Modifiability,parameteriz,parameterizations,1817,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:142,Usability,learn,learning,142,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:398,Usability,simpl,simple,398,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:664,Usability,simpl,simply,664,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:774,Usability,simpl,simply,774,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1948,Usability,simpl,simply,1948,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:2066,Usability,learn,learn,2066,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1719,Availability,ERROR,ERROR,1719,"from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1444,Energy Efficiency,reduce,reduces,1444," using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2804,Integrability,depend,depend,2804,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:84,Modifiability,parameteriz,parameterization,84,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2950,Modifiability,parameteriz,parameterizations,2950,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:3111,Modifiability,parameteriz,parameterizations,3111,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1322,Performance,optimiz,optimized,1322," this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1419,Performance,perform,performance,1419," using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1613,Testability,Test,Test,1613,"is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and se",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1646,Testability,Test,Test,1646,"quares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1657,Testability,Test,Test,1657," rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2075,Testability,Test,Test,2075,"operties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as po",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2187,Testability,Test,Test,2187," it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a lo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2361,Testability,Test,Test,2361,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:393,Usability,simpl,simply,393,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1564,Usability,simpl,simple,1564,"es) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_clos",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2624,Usability,simpl,simpler,2624,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2692,Usability,learn,learn,2692,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:497,Deployability,update,updated,497,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1336,Deployability,update,updated,1336,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1779,Deployability,update,updated,1779,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:368,Integrability,depend,dependencies,368,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:474,Integrability,depend,dependency,474,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:687,Integrability,depend,dependency,687,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1039,Integrability,protocol,protocol,1039,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1207,Integrability,depend,dependencies,1207,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1313,Integrability,depend,dependency,1313,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1526,Integrability,depend,dependency,1526,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1650,Integrability,depend,dependencies,1650,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1756,Integrability,depend,dependency,1756,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1969,Integrability,depend,dependency,1969,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:637,Performance,Load,Loading,637,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1476,Performance,Load,Loading,1476,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1919,Performance,Load,Loading,1919,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:227,Testability,Benchmark,Benchmarks,227,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:251,Testability,benchmark,benchmarks,251,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:323,Testability,Benchmark,Benchmarks,323,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:399,Testability,Benchmark,Benchmarks,399,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:623,Testability,Benchmark,Benchmarks,623,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:663,Testability,Benchmark,Benchmarks,663,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:719,Testability,Benchmark,Benchmarks,719,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:865,Testability,Benchmark,Benchmarking,865,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1162,Testability,Benchmark,Benchmarks,1162,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1238,Testability,Benchmark,Benchmarks,1238,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1462,Testability,Benchmark,Benchmarks,1462,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1502,Testability,Benchmark,Benchmarks,1502,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1558,Testability,Benchmark,Benchmarks,1558,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1605,Testability,Benchmark,Benchmarks,1605,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1681,Testability,Benchmark,Benchmarks,1681,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1905,Testability,Benchmark,Benchmarks,1905,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1945,Testability,Benchmark,Benchmarks,1945,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:2001,Testability,Benchmark,Benchmarks,2001,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:2302,Testability,benchmark,benchmark,2302,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:2228,Usability,clear,clearer,2228,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222:12,Integrability,depend,depends,12,The default depends on whether the file already exists or not? Just above that... https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/netcdf_output_writer.jl#L293-L298,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222
https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1100262668:287,Usability,clear,clearer,287,"Kinda. The current behavior is this https://github.com/CliMA/Oceananigans.jl/blob/470fd110a99b1967510979fbc313093dac060636/src/OutputWriters/netcdf_output_writer.jl#L302-L308. So the default is similar to what it was when this issue was posted, although I think it's formulated a little clearer now. I'm okay with this and also okay with closing this issue, but I'm not sure everyone else feels this way. You mentioned at some point that we could move this part to after `run!()` is called and I don't think we discussed that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1100262668
https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1479957661:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1479957661
https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786:80,Integrability,depend,dependencies,80,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786
https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786:145,Integrability,depend,dependencies,145,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786
https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786:325,Usability,clear,clearly,325,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786
https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902:154,Performance,perform,performance,154,"> What if we get rid of `parameters` and `computed_dependencies`, and call `compute!` on all the arguments?. That'd work for me. Would that have the same performance or would it add some overhead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902
https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1069134148:166,Usability,clear,clear,166,"If it's the same, then I'm okay calling compute on everything and don't separate between `parameters` and `computed_dependencies` anymore. I think we gotta make that clear on the docstring though!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1069134148
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1066192924:13,Availability,error,error,13,I think that error stems from here:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. which probably means that `solver.eigenvalues` are not being set up correctly for whatever reason. Those are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L27. and then (I think) supposed to be partitioned rank-wise with this piece of code:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L38-L44. so maybe the size is wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1066192924
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:41,Availability,error,error,41,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:251,Modifiability,variab,variables,251,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:402,Performance,perform,performed,402,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067792174:157,Energy Efficiency,reduce,reduce,157,"Yes, xc is a PencilArray object. Right now it looks like each process calculates the eigenvalues on the global grid and then the code on line 42 attempts to reduce the size to the local grid. One approach would be to calculate the eigenvalues on the local grid. I think that this would be more generalizable to other distributed domain decompositions (right now line 42 assumes that the domain is decomposed in one direction) but this approach would require a re-write of poisson_eigenvalues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067792174
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302:129,Integrability,interface,interface,129,"Just a clue from https://github.com/jipolanco/PencilArrays.jl/issues/49:. I think it's likely we need to use some `PencilArrays` interface to set up / partition the eigenvalues, rather than attempting to manually hack together a partition. Also by the way, it looks like we might be able to use ""pencil"" decomposition with the non-hydrostatic model now too: . https://github.com/jipolanco/PencilArrays.jl/issues/42#issuecomment-1029766858. previously we could not because PencilFFTs required FFTs to be performed along dimension 1. Since we can't decompose in ""z"" (because at least right now there are vertical integrals in `NonhydrostaticModel` --- this should also be relaxed), this only left the `y` dimension for partitioning. It feels like we might be relatively straightforward to solve if we become proficient with PencilArrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302:503,Performance,perform,performed,503,"Just a clue from https://github.com/jipolanco/PencilArrays.jl/issues/49:. I think it's likely we need to use some `PencilArrays` interface to set up / partition the eigenvalues, rather than attempting to manually hack together a partition. Also by the way, it looks like we might be able to use ""pencil"" decomposition with the non-hydrostatic model now too: . https://github.com/jipolanco/PencilArrays.jl/issues/42#issuecomment-1029766858. previously we could not because PencilFFTs required FFTs to be performed along dimension 1. Since we can't decompose in ""z"" (because at least right now there are vertical integrals in `NonhydrostaticModel` --- this should also be relaxed), this only left the `y` dimension for partitioning. It feels like we might be relatively straightforward to solve if we become proficient with PencilArrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:1387,Availability,ping,ping,1387,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:156,Integrability,interface,interface,156,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:591,Integrability,wrap,wrappers,591,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:425,Performance,perform,performed,425,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:526,Safety,avoid,avoid,526,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:757,Usability,intuit,intuitive,757,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:987,Deployability,integrat,integration,987,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:987,Integrability,integrat,integration,987,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:220,Usability,intuit,intuitive,220,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1106766485:494,Testability,test,tests,494,"> It would be ideal if the nonhydrostatic model could eventually handle data decomposed in z which would eliminate the need for this. This can be achieved by eliminating the vertical integral that calculates the hydrostatic pressure anomaly as in this PR: https://github.com/CliMA/Oceananigans.jl/pull/1910. With this change the whole pressure field is found through the nonhydrostatic solve. This seems like a very minor change to the temporal discretization, but it does cause the regression tests to fail (and I think @tomchor noticed some differences in the solution for ocean problems --- maybe there was a bit more noise?) . That means that maybe we want to keep the _option_ for computing the integral for hydrostatic pressure, but disable it either by default or when using a distributed model. That'd require a bit more work on https://github.com/CliMA/Oceananigans.jl/pull/1910 but not too much I don't think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1106766485
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113:188,Testability,test,tests,188,"> With this change the whole pressure field is found through the nonhydrostatic solve. This seems like a very minor change to the temporal discretization, but it does cause the regression tests to fail (and I think @tomchor noticed some differences in the solution for ocean problems --- maybe there was a bit more noise?). The video here: https://clima.github.io/OceananigansDocumentation/previews/PR1910/generated/internal_wave/; (using the preview from https://github.com/CliMA/Oceananigans.jl/pull/1910) is what more clearly illustrates the differences. The difference is more subtle in the other examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113:521,Usability,clear,clearly,521,"> With this change the whole pressure field is found through the nonhydrostatic solve. This seems like a very minor change to the temporal discretization, but it does cause the regression tests to fail (and I think @tomchor noticed some differences in the solution for ocean problems --- maybe there was a bit more noise?). The video here: https://clima.github.io/OceananigansDocumentation/previews/PR1910/generated/internal_wave/; (using the preview from https://github.com/CliMA/Oceananigans.jl/pull/1910) is what more clearly illustrates the differences. The difference is more subtle in the other examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:223,Deployability,integrat,integrating,223,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:223,Integrability,integrat,integrating,223,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:853,Integrability,depend,depend,853,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:460,Testability,test,tested,460,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:975,Testability,test,tested,975,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116705227:27,Testability,test,test,27,@glwagner did you actually test that #2502 resolved this issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116705227
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116712744:20,Testability,test,test,20,"I didn't _actually_ test that, but I also didn't merge #2502 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116712744
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116713258:21,Availability,error,error,21,If you encounter the error @tomchor please reopen this issue!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116713258
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273:99,Safety,safe,safe,99,Just tested the script and it runs! I haven't tested that the outputs are correct but I think it's safe to leave this closed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273:5,Testability,test,tested,5,Just tested the script and it runs! I haven't tested that the outputs are correct but I think it's safe to leave this closed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273
https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273:46,Testability,test,tested,46,Just tested the script and it runs! I haven't tested that the outputs are correct but I think it's safe to leave this closed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273
https://github.com/CliMA/Oceananigans.jl/pull/2348#issuecomment-1103413079:0,Testability,Test,Tests,0,Tests pass so maybe all is fine...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348#issuecomment-1103413079
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066202040:162,Safety,detect,detect,162,Can someone explain the purpose of `MPI.Init()`? Is it a bad idea to call this inside `MultiArch` constructor rather than requiring users to write it out? Can we detect if it's been called in the constructor and then call _by default_ if it hasn't been called yet?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066202040
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066790992:613,Availability,error,error,613,"I guess changing to `MultiArchitecture` makes sense but I admit, I do like `MultiArch` since we do use `arch` in places and it has become pretty common, I think. Do we need default ranks? We can always find the number of runs in any run, and why not just check? Sorry if I am missing something. To answer the above question, you can see [here](https://juliaparallel.github.io/MPI.jl/stable/environment/#MPI.Init), but the short version is it initializes MPI in the current process. I guess this tells each process that it should get ready for the possibility of sharing information, otherwise, we probably get an error. It sounds cleaner to me to hide it in `MultiArch` but wonder if there is a good reason why not. Sadly, I don't know it but am happy to hear more from others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066790992
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676:349,Integrability,rout,routines,349,"Just to follow on from what @francispoulin wrote, we normally use MPI_Init() at the start and MPI_Finalize() at the end. All code that calls MPI needs to be between these statements. To your question about whether you can call MPI_Init() within MultiArch (or MultiArchitecture), I think the question is whether it would ever be useful to use an MPI routines before calling MultiArch. For example, you can't find out the local rank until you call MPI_Init(). Also, it is good practice to use both MPI_Init() and MPI_Finalize(), so if MPI_Init() is in MultiArch, it leaves the question of where MPI_Finalize() should be. This might be an argument for having them both outside of MultiArch where they are visible to the user.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896:426,Integrability,wrap,wrapper,426,"@simone-silvestri suggests removing `topology` as an argument from the `MultiArch` constructor. `MultiArch` now uses `topology` to construct `RankConnectivity` (ie the mapping between ranks). But in @simone-silvestri's words ""connectivity is a grid thing"". I'm not 100% sure how to solve it though. One possibility is to 1) rebuild `MultiArch` in the grid constructor adding connectivity information. Or we can 2) introduce a wrapper for grids on distributed domains or 3) add `connectivity` to all grids, set to `nothing` when not distributred. I think 1) is easiest but maybe not the cleanest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:1176,Availability,down,downside,1176,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:791,Integrability,wrap,wrapper,791,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:1413,Integrability,wrap,wrapping,1413,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110:381,Integrability,interface,interface,381,"> It will allow us embed a little more multi process in the code. Can you explain this point?. To me it looks like the main difference / improvement of (3) is the _user interface_ rather than functionality, because every grid has an `architecture`. Thus in source code it's the difference between `grid.architecture.partition` or `grid.partition`. With a `process_partition(grid)` interface (which we should have...) even that distinction is lost. The primary tradeoff against the user interface change is an increase in code complexity. New developers have to wrestle with and users have to puzzle over `grid.partition`, even though it's relevant only in a minority of cases (particularly because we are GPU-focused, and are providing features for multi-GPU). For example with `MultiRegionGrid` we'd have `grid.partition` and `grid.region_grids[1].partition`. But maybe I am missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110
https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110:486,Integrability,interface,interface,486,"> It will allow us embed a little more multi process in the code. Can you explain this point?. To me it looks like the main difference / improvement of (3) is the _user interface_ rather than functionality, because every grid has an `architecture`. Thus in source code it's the difference between `grid.architecture.partition` or `grid.partition`. With a `process_partition(grid)` interface (which we should have...) even that distinction is lost. The primary tradeoff against the user interface change is an increase in code complexity. New developers have to wrestle with and users have to puzzle over `grid.partition`, even though it's relevant only in a minority of cases (particularly because we are GPU-focused, and are providing features for multi-GPU). For example with `MultiRegionGrid` we'd have `grid.partition` and `grid.region_grids[1].partition`. But maybe I am missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110
https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1067549112:254,Deployability,update,updated,254,"How about discussions? Anyone can start a discussion about running simulations with immersed boundaries, for example. Perhaps that will also encourage developers to open discussions like that too. Wiki and docs are more work because they will have to be updated / changed. That’s why experimental things aren’t well-documented; it’s an onerous burden to formally document rapidly changing features.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1067549112
https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1068043951:11,Usability,clear,clear,11,"Just to be clear, I'm not suggesting that we document experimental features to the level that we document mature ones. That'd be impossibly hard to maintain. But maybe a page somewhere with a list of experimental features (all I know about are immersed boundaries and parallelism, although I'm sure there are more that I'm not aware) that links to the relevant issues/PRs/discussions and maybe to relevant files in `src`? Otherwise I think it's hard for users to know what experimental features there are since they have to browse issues/PRs/discussions looking for stuff in the titles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1068043951
https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1072772581:312,Availability,mainten,maintenance,312,"> That way if users decide to experiment with a new feature they can also contribute their experience to the discussion. It might be more fluid and easier for everyone to work with than something more formal like a wiki?. I don't really see the wiki as being formal, but I do agree that discussions are more low-maintenance. I think if we can tag them properly as ""experimental features"" it would really help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1072772581
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:487,Integrability,interface,interface,487,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:1065,Integrability,interface,interface,1065,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:475,Usability,simpl,simple,475,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184:388,Availability,error,errors,388,"> If we change the name and that's a breaking change we will bump the version and all users will be happy or keep working with the Oceananigans version they want to. I understand that it'll just be a breaking release. My concern is that a user that has a tilted-domain simulation with `gravity_unit_vector=g` will update their Oceananigans version, the code will run possibly without any errors, give a completely different result since gravity just flipped, and they won't know that it's because now they should have `gravity_unit_vector=-g`. But if we think that's an acceptable price (I don't know how many people use this feature) and that keeping the name while changing the code is the way to go, then I'm fine moving forward with that. I do think we should decide this and resolve this though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184:209,Deployability,release,release,209,"> If we change the name and that's a breaking change we will bump the version and all users will be happy or keep working with the Oceananigans version they want to. I understand that it'll just be a breaking release. My concern is that a user that has a tilted-domain simulation with `gravity_unit_vector=g` will update their Oceananigans version, the code will run possibly without any errors, give a completely different result since gravity just flipped, and they won't know that it's because now they should have `gravity_unit_vector=-g`. But if we think that's an acceptable price (I don't know how many people use this feature) and that keeping the name while changing the code is the way to go, then I'm fine moving forward with that. I do think we should decide this and resolve this though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184:314,Deployability,update,update,314,"> If we change the name and that's a breaking change we will bump the version and all users will be happy or keep working with the Oceananigans version they want to. I understand that it'll just be a breaking release. My concern is that a user that has a tilted-domain simulation with `gravity_unit_vector=g` will update their Oceananigans version, the code will run possibly without any errors, give a completely different result since gravity just flipped, and they won't know that it's because now they should have `gravity_unit_vector=-g`. But if we think that's an acceptable price (I don't know how many people use this feature) and that keeping the name while changing the code is the way to go, then I'm fine moving forward with that. I do think we should decide this and resolve this though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276:21,Integrability,message,message,21,"We can add a warning message ""note that if you used to use version blah then this now changed... etc"" and keep it there for a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276
https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1457014531:53,Usability,clear,clearer,53,I am okay with a change of names. If the new name is clearer then probably better to change it sooner than later.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1457014531
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:391,Energy Efficiency,Adapt,Adapt,391,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:633,Energy Efficiency,meter,meters,633,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:1726,Energy Efficiency,schedul,schedule,1726,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:192,Modifiability,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,192,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:391,Modifiability,Adapt,Adapt,391,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:865,Modifiability,layers,layers,865,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259:143,Modifiability,layers,layers,143,"Try. ```julia; const width = 100kilometers; @inline ν(x, y, z, t) = ifelse(abs(y - Ny*kilometers/2) < Ny*kilometers/2 - width, 1, 10) # sponge layers; ```. The `const` is necessary here for GPU and will also improve performance on CPU. The reason is that we need to assure the compiler that the type of `width` will not change for GPU compilation to be possible. If that fails you may also need to change `kilometers` to `1e3`, or to define another `const`. However, I think that `kilometers` should already b `const` so this may not be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259
https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259:216,Performance,perform,performance,216,"Try. ```julia; const width = 100kilometers; @inline ν(x, y, z, t) = ifelse(abs(y - Ny*kilometers/2) < Ny*kilometers/2 - width, 1, 10) # sponge layers; ```. The `const` is necessary here for GPU and will also improve performance on CPU. The reason is that we need to assure the compiler that the type of `width` will not change for GPU compilation to be possible. If that fails you may also need to change `kilometers` to `1e3`, or to define another `const`. However, I think that `kilometers` should already b `const` so this may not be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259
https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069647760:5,Deployability,patch,patch,5,Bump patch release?; Perhaps a test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069647760
https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069647760:11,Deployability,release,release,11,Bump patch release?; Perhaps a test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069647760
https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069647760:31,Testability,test,test,31,Bump patch release?; Perhaps a test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069647760
https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069820663:47,Testability,test,test,47,It's weird... time stepping itself should be a test because of the multiple `fill_halo_regions!` both on individual fields and tuples. Here it seems that everything passes also without this fix...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069820663
https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069821057:49,Testability,test,test,49,> It's weird... time stepping itself should be a test because of the multiple `fill_halo_regions!` both on individual fields and tuples. Here it seems that everything passes also without this fix... without this fix?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069821057
https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069821739:70,Testability,test,tests,70,"yeah, it helped me getting it working on julia 1.6 on my computer but tests which use julia 1.6 passed already when I merged https://github.com/CliMA/Oceananigans.jl/pull/2335. So maybe I would wait a bit before merging this. I ll assess a little bit more the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2362#issuecomment-1069821739
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:423,Availability,error,error,423,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:720,Availability,error,error,720,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:791,Availability,error,error,791,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:946,Availability,error,error-to-a-file,946,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:1513,Availability,Error,ErrorException,1513,"Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305, (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387, #invokelatest#2 at essentials.jl:708 [inlined], invokelatest at essentials.jl:706 [inlined], run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372, exec_options(opts::Base.JLOptions) at client.jl:302, _start() at client.jl:485]). julia> st; 13-element Vector{Base.StackTraces.StackFrame}:; top-level scope at REPL[2]:4; eval at boot.jl:360 [inlined]; eval_user_input(ast::Any, backe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:3351,Availability,Error,ErrorException,3351,"jl:485]). julia> st; 13-element Vector{Base.StackTraces.StackFrame}:; top-level scope at REPL[2]:4; eval at boot.jl:360 [inlined]; eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139; repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200; start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185; run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317; run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305; (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387; #invokelatest#2 at essentials.jl:708 [inlined]; invokelatest at essentials.jl:706 [inlined]; run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372; exec_options(opts::Base.JLOptions) at client.jl:302; _start() at client.jl:485julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305, (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387, #invokelatest#2 at essentials.jl:708 [inlined], invokelatest at essentials.jl:706 [inlined], run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372, exec_options(opts::Base.JLOptions) at client.jl:302, _start() at client.jl:485]). julia> st; 13-element Vector{Base.StackTraces.StackFrame}:; top-level scope at REPL[2]:4; eval at boot.jl:360 [inlined]; eval_user_input(ast::Any, backe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:5329,Availability,error,errors,5329,"""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305, (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387, #invokelatest#2 at essentials.jl:708 [inlined], invokelatest at essentials.jl:706 [inlined], run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372, exec_options(opts::Base.JLOptions) at client.jl:302, _start() at client.jl:485]). julia> st; 13-element Vector{Base.StackTraces.StackFrame}:; top-level scope at REPL[2]:4; eval at boot.jl:360 [inlined]; eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139; repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200; start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185; run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317; run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305; (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387; #invokelatest#2 at essentials.jl:708 [inlined]; invokelatest at essentials.jl:706 [inlined]; run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372; exec_options(opts::Base.JLOptions) at client.jl:302; _start() at client.jl:485; ```. I'm not sure how this can be turned into something useful, but perhaps its a starting point. It may even be possible (though probably a bit futuristic) to implement a kwarg in `run!`, or to provide some debugging features for users that isolate errors due to user-defined functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:429,Integrability,message,message,429,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162:86,Availability,error,error,86,This is helpful - thanks Greg. It's good to have some options when unable to find the error messages during debugging!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162:92,Integrability,message,messages,92,This is helpful - thanks Greg. It's good to have some options when unable to find the error messages during debugging!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162
https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032646:179,Availability,down,down,179,"Probably the best solution right now is to re-run in a terminal. But there is still some improvement to be had since that option requires re-compilation, so will slow development down. If you find any VSCode-specific information please post here. I wonder if VSCode can pipe stdout to file?. Also we may want to convert this to a discussion, what do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032646
https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073022456:199,Energy Efficiency,Reduce,ReducedComputedField,199,"I think we still need `Base.show` for `Reduction`. That would go here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/field_reductions.jl. The issue is that we only added `show` for `ReducedComputedField`, but not `Reduction` itself. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/Fields/field_reductions.jl#L85. A pattern we use elsewhere is to start `show(io, obj)` by printing `summary(obj)`. This allows us to define new `summary` but keep the same `show` body. Like here:. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/AbstractOperations/show_abstract_operations.jl#L24-L28",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073022456
https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073150458:493,Energy Efficiency,reduce,reduced,493,"> That looks great! Should we show the operand tree? I think concise is probably best though. one sees that if they just call ; ```Julia; julia> bb_op; BinaryOperation at (Center, Center, Center); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; └── tree:; * at (Center, Center, Center);    ├── - at (Center, Center, Center);    │   ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;    │   └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;    └── - at (Center, Center, Center);       ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;       └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073150458
https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073150458:703,Energy Efficiency,reduce,reduced,703,"> That looks great! Should we show the operand tree? I think concise is probably best though. one sees that if they just call ; ```Julia; julia> bb_op; BinaryOperation at (Center, Center, Center); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; └── tree:; * at (Center, Center, Center);    ├── - at (Center, Center, Center);    │   ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;    │   └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;    └── - at (Center, Center, Center);       ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;       └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073150458
https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192:384,Modifiability,variab,variable,384,"how about if we make it to something like. ```julia; julia> b′b′; mean! over dims (1,) of BinaryOperation at (Center, Center, Center); └── operand: BinaryOperation at (Center, Center, Center); call b′b′.operand to see the operation tree; └── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ```. I tried but I can't seem to be able to get the variable name as a string, e.g., a string with `""b′b′""` for this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073124614:286,Availability,down,down,286,"I don't see anything obvious, but I would try. ```julia; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, 0.0); ```. so that `tank` always returns `Float64`, rather than sometimes `Int64` (eg, `0`), and sometimes `Float64` (`-H`). If that doesn't work, we'll have to strip this script down to a more minimal example so that we can debug it. For example, the forcing functions and all the constants and parameters associated with them may not be relevant? Perhaps we can try. ```julia; @inline tank(x, y) = -0.15; ```. as the immersed boundary function first, too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073124614
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073132435:9,Availability,error,error,9,"Note the error comes from. ```julia; [13] fill_bottom_and_top_halo!(::NTuple{5, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::GPU, ::CUDAKernels.CudaEvent, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Fl...; @ Oceananigans.BoundaryConditions ~/.julia/packages/Oceananigans/JIHfS/src/BoundaryConditions/fill_halo_regions.jl:153; ```. And I guess this has nothing to do with the immersed boundary grid explicitly. The fill halo region code recently got more complicated (from the compiler's point of view) in #2335:. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/BoundaryConditions/fill_halo_regions.jl#L136-L145. My main guess ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073132435
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073132435:580,Deployability,Continuous,ContinuousBoundaryFunction,580,"Note the error comes from. ```julia; [13] fill_bottom_and_top_halo!(::NTuple{5, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::GPU, ::CUDAKernels.CudaEvent, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Fl...; @ Oceananigans.BoundaryConditions ~/.julia/packages/Oceananigans/JIHfS/src/BoundaryConditions/fill_halo_regions.jl:153; ```. And I guess this has nothing to do with the immersed boundary grid explicitly. The fill halo region code recently got more complicated (from the compiler's point of view) in #2335:. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/BoundaryConditions/fill_halo_regions.jl#L136-L145. My main guess ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073132435
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073132435:772,Deployability,Continuous,ContinuousBoundaryFunction,772,"Note the error comes from. ```julia; [13] fill_bottom_and_top_halo!(::NTuple{5, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::GPU, ::CUDAKernels.CudaEvent, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Fl...; @ Oceananigans.BoundaryConditions ~/.julia/packages/Oceananigans/JIHfS/src/BoundaryConditions/fill_halo_regions.jl:153; ```. And I guess this has nothing to do with the immersed boundary grid explicitly. The fill halo region code recently got more complicated (from the compiler's point of view) in #2335:. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/BoundaryConditions/fill_halo_regions.jl#L136-L145. My main guess ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073132435
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1083925352:99,Usability,clear,clears,99,"Indeed, it seems like . ```; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); ```; clears the problem. Interesting... ; Do you guys have any idea why that could influence the `fill_halo_bottom`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1083925352
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084029838:74,Testability,test,test,74,Had some research deadline and couldn't come back to this problem. I will test with your suggestion and let you know.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084029838
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:356,Availability,down,downstream,356,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:857,Availability,error,error,857,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:743,Safety,safe,safest,743,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:882,Security,access,access,882,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:116,Usability,clear,clears,116,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1089373051:190,Testability,test,tested,190,"I am closing the issue because the solution is to give always `Float64` as suggested by @simone-silvestri . ```julia; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); ```. I tested and this is working now.; Had some issues in the boundaries, but I might discuss that in another issue/discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1089373051
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1089415019:207,Testability,test,tested,207,"> I am closing the issue because the solution is to give always `Float64` as suggested by @simone-silvestri; > ; > ```julia; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > I tested and this is working now. Had some issues in the boundaries, but I might discuss that in another issue/discussion. Note there is no difference between `0.0` and `Float64(0.0)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1089415019
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1089431710:275,Testability,test,tested,275,"> > I am closing the issue because the solution is to give always `Float64` as suggested by @simone-silvestri; > > ```julia; > > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I tested and this is working now. Had some issues in the boundaries, but I might discuss that in another issue/discussion.; > ; > Note there is no difference between `0.0` and `Float64(0.0)`. Sorry,. What I actually used was; ```julia; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, 0.0); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1089431710
https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1091746195:112,Availability,error,error,112,"I just saw this issue and I know I'm late to the party but I thought I'd report that I've encountered this same error before in the past, and what solved the issue was exactly the solution that you guys found here. . It was long ago enough that the version of CUDA was different, so I'd say this probably isn't a bug in this CUDA version (as suggested at some point), rather it is some kind of compiler limitation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1091746195
https://github.com/CliMA/Oceananigans.jl/issues/2369#issuecomment-1074294876:95,Energy Efficiency,reduce,reduces,95,Sure! only the first halo node is required since we have 2nd order viscous terms and advection reduces to second order near the boundary,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2369#issuecomment-1074294876
https://github.com/CliMA/Oceananigans.jl/issues/2371#issuecomment-1073377398:160,Testability,test,test,160,Probably here https://github.com/JuliaGPU/CUDA.jl/blob/71e9760f02bc6e1bc76aaaf32e98be10a41bae6b/src/device/intrinsics/math.jl#L56. I would start with writing a test here for sind/cosd https://github.com/JuliaGPU/CUDA.jl/blob/71e9760f02bc6e1bc76aaaf32e98be10a41bae6b/test/device/intrinsics/math.jl#L97,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2371#issuecomment-1073377398
https://github.com/CliMA/Oceananigans.jl/issues/2371#issuecomment-1073377398:266,Testability,test,test,266,Probably here https://github.com/JuliaGPU/CUDA.jl/blob/71e9760f02bc6e1bc76aaaf32e98be10a41bae6b/src/device/intrinsics/math.jl#L56. I would start with writing a test here for sind/cosd https://github.com/JuliaGPU/CUDA.jl/blob/71e9760f02bc6e1bc76aaaf32e98be10a41bae6b/test/device/intrinsics/math.jl#L97,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2371#issuecomment-1073377398
https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:169,Availability,error,error,169,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255
https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:175,Integrability,message,message,175,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255
https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:191,Usability,clear,clearer,191,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255
https://github.com/CliMA/Oceananigans.jl/pull/2378#issuecomment-1075617026:40,Testability,test,tests,40,I approve the idea. But only merge when tests are sorted out. ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2378#issuecomment-1075617026
https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081894372:331,Integrability,interface,interfaces,331,"> > > Very interesting idea. How do you plan to combine the different schemes to get a smooth result?; > > ; > > ; > > We'll use the WENO method, which weights candidate stencils based on a smoothness metric.; > ; > Makes sense, thanks!. The non-trivial part of the method is to use a non-trivial stencil to reconstruct `u` at the interfaces of tracer cells. For both advection and continuity we use the (trivial) second-order reconstruction. ```; u_ijk = u[i, j, k]; ```. Yet high-order reconstructions are possible; for example a fourth-order reconstruction (in the x-direction only) is. ```; u_ijk = 13/12 * u[i, j, k] - 1/24 * u[i-1, j, k] - 1/24 * u[i+1, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081894372
https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138:958,Energy Efficiency,energy,energy,958,"I propose we change the API for vector invariant with WENO interpolation to read something like. ```julia; momentum_advection = VectorInvariant(WENO5(), VelocitySmoothness()); ```. or something like that. In other words I think the nesting should be reversed: the _first_ question is whether we are using the vector invariant or flux form formulation (flux form is default right now). The _second_ question is how we interpolate vorticity. The _third_ question is the field used in the smoothness metric. I also think we should disentangle the smoothness indicators (eg velocity and vorticity) from the WENO5 struct; we can express this concept simply by re-writing the functions to accept two fields: one for reconstruction, and one for smoothness. The default uses the reconstructed field for smoothness. `VectorInvariant` will handle passing vorticity or velocity into those kernels. We'll then need. ```julia; struct VectorInvariant; vorticity_stencil # energy or enstrophy conserving; vorticity_reconstruction # any advection scheme but we focus on `WENO5` and `CenteredSecondOrder()`; smoothness_indicator # `VelocitySmoothness()` or `VorticitySmoothness()`; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138
https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138:645,Usability,simpl,simply,645,"I propose we change the API for vector invariant with WENO interpolation to read something like. ```julia; momentum_advection = VectorInvariant(WENO5(), VelocitySmoothness()); ```. or something like that. In other words I think the nesting should be reversed: the _first_ question is whether we are using the vector invariant or flux form formulation (flux form is default right now). The _second_ question is how we interpolate vorticity. The _third_ question is the field used in the smoothness metric. I also think we should disentangle the smoothness indicators (eg velocity and vorticity) from the WENO5 struct; we can express this concept simply by re-writing the functions to accept two fields: one for reconstruction, and one for smoothness. The default uses the reconstructed field for smoothness. `VectorInvariant` will handle passing vorticity or velocity into those kernels. We'll then need. ```julia; struct VectorInvariant; vorticity_stencil # energy or enstrophy conserving; vorticity_reconstruction # any advection scheme but we focus on `WENO5` and `CenteredSecondOrder()`; smoothness_indicator # `VelocitySmoothness()` or `VorticitySmoothness()`; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138
https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1083113688:92,Availability,robust,robust,92,"Inspired by @simone-silvestri 's concerns, I'm wondering if what we need is actually a more robust system for specifying advection schemes in general (not just `VectorInvariant`), and controlling the behavior of the advective term. Perhaps something like:. ```julia; """""" Specifies a reconstruction scheme for fluxes of the form u * c,; where u is the `advecting_velocity` and c is the `advected_quantity` """"""; struct FluxReconstruction; advecting_velocity; advected_quantity; end. struct AdvectionScheme; formulation # `FluxForm` or `VectorInvariant`; mass_flux_reconstruction # ""cell"" or ""colocated"" reconstruction""; default CenteredSecondOrder; momentum_flux_reconstruction; tracer_reconstruction # NamedTuple for each tracer individually.; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1083113688
https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459:68,Modifiability,refactor,refactor,68,I'm closing this. I'll open an issue to discuss an advection scheme refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081759825:36,Security,validat,validation,36,@iuryt do you want to help set up a validation case for this feature?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081759825
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184:38,Security,validat,validation,38,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184:261,Testability,test,test,261,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184:229,Usability,simpl,simplicity,229,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:548,Safety,avoid,avoid,548,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:40,Security,validat,validation,40,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:267,Testability,test,test,267,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:235,Usability,simpl,simplicity,235,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:537,Usability,simpl,simple,537,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805:126,Security,validat,validation,126,"@glwagner ; Just to confirm, following #2384 , I will fork the main repo, then I switch to your branch, add a new example on `validation/`, then ; `julia --project`; and; `julia> include(""validation/source_sinking/source_sinking.jl"")`; or something like that, right?. Once it runs, I make a PR to your branch that will come back to here, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805:188,Security,validat,validation,188,"@glwagner ; Just to confirm, following #2384 , I will fork the main repo, then I switch to your branch, add a new example on `validation/`, then ; `julia --project`; and; `julia> include(""validation/source_sinking/source_sinking.jl"")`; or something like that, right?. Once it runs, I make a PR to your branch that will come back to here, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081924961:336,Availability,down,down,336,"What about this?; Haven't run yet. ```julia; using Oceananigans; using Oceananigans.Units. # local depth; const H = -10meters; # constant sinking velocity; const w_siking = -1 # m/s. # 1D grid; grid = RectilinearGrid(size=128, z=(H, 0), topology=(Flat, Flat, Bounded)). # constant diffusivity; closure = ScalarDiffusivity(κ=1). # cools down at z=0; @inline cooling_func(x, y, z, t) = ifelse(z==0,-0.1,0); cooling = Forcing(cooling_func). # use WENO to advect down the tracer; sinking = AdvectiveForcing(WENO5(), w=w_siking). model = NonhydrostaticModel(grid=grid, closure=closure, buoyancy=nothing, tracers=:T, forcing = (; T = (cooling, sinking))). simulation = Simulation(model, Δt = 0.01 * H/w_sinking, stop_iteration = 100). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081924961
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081924961:459,Availability,down,down,459,"What about this?; Haven't run yet. ```julia; using Oceananigans; using Oceananigans.Units. # local depth; const H = -10meters; # constant sinking velocity; const w_siking = -1 # m/s. # 1D grid; grid = RectilinearGrid(size=128, z=(H, 0), topology=(Flat, Flat, Bounded)). # constant diffusivity; closure = ScalarDiffusivity(κ=1). # cools down at z=0; @inline cooling_func(x, y, z, t) = ifelse(z==0,-0.1,0); cooling = Forcing(cooling_func). # use WENO to advect down the tracer; sinking = AdvectiveForcing(WENO5(), w=w_siking). model = NonhydrostaticModel(grid=grid, closure=closure, buoyancy=nothing, tracers=:T, forcing = (; T = (cooling, sinking))). simulation = Simulation(model, Δt = 0.01 * H/w_sinking, stop_iteration = 100). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081924961
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081973535:206,Deployability,Continuous,ContinuousForcing,206,"I tried to run, but can't find `AdvectiveForcing()`. But I noticed that this is listed in; https://github.com/CliMA/Oceananigans.jl/blob/glw/forcing-features/src/Forcings/Forcings.jl. It also doesn't find `ContinuousForcing`, for instance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081973535
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081987518:219,Deployability,Continuous,ContinuousForcing,219,"> I tried to run, but can't find `AdvectiveForcing()`; > ; > But I noticed that this is listed in https://github.com/CliMA/Oceananigans.jl/blob/glw/forcing-features/src/Forcings/Forcings.jl; > ; > It also doesn't find `ContinuousForcing`, for instance. `ContinuousForcing` isn't exported by `using Oceananigans`; we have to get that name specifically: `using Oceananigans.Forcings: ContinuousForcing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081987518
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081987518:254,Deployability,Continuous,ContinuousForcing,254,"> I tried to run, but can't find `AdvectiveForcing()`; > ; > But I noticed that this is listed in https://github.com/CliMA/Oceananigans.jl/blob/glw/forcing-features/src/Forcings/Forcings.jl; > ; > It also doesn't find `ContinuousForcing`, for instance. `ContinuousForcing` isn't exported by `using Oceananigans`; we have to get that name specifically: `using Oceananigans.Forcings: ContinuousForcing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081987518
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081987518:382,Deployability,Continuous,ContinuousForcing,382,"> I tried to run, but can't find `AdvectiveForcing()`; > ; > But I noticed that this is listed in https://github.com/CliMA/Oceananigans.jl/blob/glw/forcing-features/src/Forcings/Forcings.jl; > ; > It also doesn't find `ContinuousForcing`, for instance. `ContinuousForcing` isn't exported by `using Oceananigans`; we have to get that name specifically: `using Oceananigans.Forcings: ContinuousForcing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081987518
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081997904:341,Availability,down,down,341,"> ```julia; > using Oceananigans; > using Oceananigans.Units; > ; > # local depth; > const H = -10meters; > # constant sinking velocity; > const w_siking = -1 # m/s; > ; > # 1D grid; > grid = RectilinearGrid(size=128, z=(H, 0), topology=(Flat, Flat, Bounded)); > ; > # constant diffusivity; > closure = ScalarDiffusivity(κ=1); > ; > # cools down at z=0; > @inline cooling_func(x, y, z, t) = ifelse(z==0,-0.1,0); > cooling = Forcing(cooling_func); > ; > # use WENO to advect down the tracer; > sinking = AdvectiveForcing(WENO5(), w=w_siking); > ; > model = NonhydrostaticModel(grid=grid, closure=closure, buoyancy=nothing, tracers=:T, forcing = (; T = (cooling, sinking))); > ; > simulation = Simulation(model, Δt = 0.01 * H/w_sinking, stop_iteration = 100); > ; > run!(simulation); > ```. Nice, thanks! I'm gonna edit this to be 2D and have a source of turbulence, I'll send a result soon!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081997904
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081997904:474,Availability,down,down,474,"> ```julia; > using Oceananigans; > using Oceananigans.Units; > ; > # local depth; > const H = -10meters; > # constant sinking velocity; > const w_siking = -1 # m/s; > ; > # 1D grid; > grid = RectilinearGrid(size=128, z=(H, 0), topology=(Flat, Flat, Bounded)); > ; > # constant diffusivity; > closure = ScalarDiffusivity(κ=1); > ; > # cools down at z=0; > @inline cooling_func(x, y, z, t) = ifelse(z==0,-0.1,0); > cooling = Forcing(cooling_func); > ; > # use WENO to advect down the tracer; > sinking = AdvectiveForcing(WENO5(), w=w_siking); > ; > model = NonhydrostaticModel(grid=grid, closure=closure, buoyancy=nothing, tracers=:T, forcing = (; T = (cooling, sinking))); > ; > simulation = Simulation(model, Δt = 0.01 * H/w_sinking, stop_iteration = 100); > ; > run!(simulation); > ```. Nice, thanks! I'm gonna edit this to be 2D and have a source of turbulence, I'll send a result soon!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081997904
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:10,Availability,error,error,10,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:40,Availability,ERROR,ERROR,40,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:713,Availability,error,error,713,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:47,Performance,Load,LoadError,47,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082024483:876,Deployability,update,update,876,"Here's what I got now!. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. grid = RectilinearGrid(size=(128, 128), x=(0, 128), z=(-64, 0), topology=(Periodic, Flat, Bounded)). b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). @inline growth_func(x, y, z, t, p) = 1 / p.τ * exp(z / p.h); growth = Forcing(growth_func, parameters=(τ=1hour, h=4.0)); sinking = AdvectiveForcing(WENO5(), w=-1). model = NonhydrostaticModel(; grid,; tracers = (:b, :P),; buoyancy = BuoyancyTracer(),; boundary_conditions = (; b=b_bcs),; forcing = (; P = (growth, sinking))). bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(); set!(model, b=bᵢ). Δz = grid.Δzᵃᵃᶜ; Δt = 0.1 * Δz # for a sinking velocity w=1; simulation = Simulation(model; Δt, stop_iteration = 1000). fig = Figure(); ax = Axis(fig[1, 1]). P = model.tracers.P; hm = heatmap!(ax, interior(P, :, 1, :)). function update!(sim); hm.input_args[1][] = interior(P, :, 1, :); return nothing; end. simulation.callbacks[:plot] = Callback(update!, IterationInterval(100)). display(fig). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082024483
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082024483:993,Deployability,update,update,993,"Here's what I got now!. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. grid = RectilinearGrid(size=(128, 128), x=(0, 128), z=(-64, 0), topology=(Periodic, Flat, Bounded)). b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). @inline growth_func(x, y, z, t, p) = 1 / p.τ * exp(z / p.h); growth = Forcing(growth_func, parameters=(τ=1hour, h=4.0)); sinking = AdvectiveForcing(WENO5(), w=-1). model = NonhydrostaticModel(; grid,; tracers = (:b, :P),; buoyancy = BuoyancyTracer(),; boundary_conditions = (; b=b_bcs),; forcing = (; P = (growth, sinking))). bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(); set!(model, b=bᵢ). Δz = grid.Δzᵃᵃᶜ; Δt = 0.1 * Δz # for a sinking velocity w=1; simulation = Simulation(model; Δt, stop_iteration = 1000). fig = Figure(); ax = Axis(fig[1, 1]). P = model.tracers.P; hm = heatmap!(ax, interior(P, :, 1, :)). function update!(sim); hm.input_args[1][] = interior(P, :, 1, :); return nothing; end. simulation.callbacks[:plot] = Callback(update!, IterationInterval(100)). display(fig). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082024483
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016:488,Energy Efficiency,meter,meters,488,"This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this:; lambda=1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0)));; end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016:61,Testability,test,testing,61,"This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this:; lambda=1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0)));; end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863:503,Energy Efficiency,meter,meters,503,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863:63,Testability,test,testing,63,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863:1204,Usability,intuit,intuitive,1204,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718:263,Deployability,integrat,integrated,263,"Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718:191,Integrability,depend,depending,191,"Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718:263,Integrability,integrat,integrated,263,"Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:265,Deployability,integrat,integrated,265,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:193,Integrability,depend,depending,193,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:265,Integrability,integrat,integrated,265,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:1032,Modifiability,rewrite,rewrite,1032,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082454081:733,Usability,simpl,simply,733,"The explanations that @johnryantaylor gave are worth for a textbook. I was just about to write that we usually assume no flux at the boundaries in order to conserve the tracer, but he gave a new perspective to this. Taking an example from [PSOM](https://github.com/PSOM/V1.0/blob/master/code/NA/src/tracersource_nut.f90), they forced phytoplankton flux to zero at the boundaries, but using a first-order upwind scheme. ```fortran; flux(0)= 0.0; flux(NK)= 0.0; do k=NK-1,1,-1; ! Kz is at cell faces; dpdz= (Tr(1,i,j,k+1,0)-Tr(1,i,j,k,0))*wz(i,j,k)*DLinv; flux(k) = KzmaxTr*Kz(i,j,k)*dpdz + wsink*Tr(1,i,j,k+1,0); end do; ```. What if we leave for the users to give the velocity in which it will be advected?; Does that makes sense to simply give `w` as a function of `z` in which relax to 0 a the boundaries?; But you mentioned that Oceananigans assume non-divergent velocity field, but that's for the forcing, so it should be fine, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082454081
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082485930:173,Usability,simpl,simplicity,173,"Good point @iuryt. The slip velocity is proportional to the difference between the particle and fluid densities. Its common to assume that the slip velocity is constant for simplicity, but there are plenty of applications where the user might want the slip velocity to vary in space and time with the fluid density. I think that should be straightforward when adding the extra advection as a forcing term since you could make the slip velocity a function of the fluid density.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082485930
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:144,Integrability,depend,depend,144,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:160,Modifiability,variab,variables,160,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:328,Security,validat,validation,328,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:18,Usability,simpl,simply,18,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:289,Usability,simpl,simplest,289,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082511065:193,Usability,simpl,simply,193,"> It could also be interesting to add this slip velocity to the convecting plankton example. I am developing an NPP model to run on Oceananigans, maybe instead of giving a new example, a could simply add the other terms on the plankton example. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082511065
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:118,Energy Efficiency,adapt,adapted,118,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:200,Energy Efficiency,meter,meters,200,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:118,Modifiability,adapt,adapted,118,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:98,Security,validat,validation,98,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:126,Energy Efficiency,adapt,adapted,126,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:216,Energy Efficiency,meter,meters,216,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:671,Energy Efficiency,allocate,allocates,671,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:1126,Integrability,wrap,wrapping,1126,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:126,Modifiability,adapt,adapted,126,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:807,Safety,avoid,avoids,807,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:106,Security,validat,validation,106,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705:28,Integrability,depend,depends,28,"As for a slip velocity that depends on buoyancy, one method uses `Callback`:. ```julia; # Define slip field with impenetrable boundary conditions; w_slip_bcs = FieldBoundaryConditions(grid, top=OpenBoundaryCondition(), bottom=OpenBoundaryCondition()); w_slip = ZFaceField(grid). # Build AdvectiveForcing; slip_forcing = AdvectiveForcing(w = w_slip). # later...; b = BuoyancyField(model) # or just model.tracers.b for BuoyancyTracer(); b_particle = 1e-4 # define particle ""buoyancy"". Requires reference fluid buoyancy / knowledge of initial condition.; particle_radius = 1e-3; molecular_viscosity = 1e-6. # Define an AbstractOperation that computes the slip velocity:; slip_velocity_op = 2/9 * (b_particle - b) / molecular_viscosity * particle_radius^2. function compute_slip_velocity!(sim); compute!(b) # compute buoyancy if it's a function of T, S; w_slip .= slip_velocity_op; Oceananigans.BoundaryConditions.fill_halo_regions!(w_slip); return nothing; end. simulation.callbacks[:compute_slip_velocity] = Callback(compute_slip_velocity!); ```. It's also possible not to use `Callback` if the forcing is written manually with the `discrete_form`. That requires a bit more work and more knowledge of Oceananigans internals though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:105,Integrability,depend,depends,105,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:16,Security,validat,validation,16,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:37,Testability,test,tests,37,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085246506:101,Testability,test,test,101,"> After passing the checks, It just need a review and will be pushed?. I think we should add a small test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085246506
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087864167:50,Security,validat,validation,50,Here's a video from the `sediment_entrainment.jl` validation case:. https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087864167
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684:402,Integrability,Message,Message,402,"looks really cool - nice work!; On Apr 4, 2022, 11:13 AM -0700, Gregory L. Wagner ***@***.***>, wrote:; > Here's a video from the sediment_entrainment.jl validation case:; > https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684:154,Security,validat,validation,154,"looks really cool - nice work!; On Apr 4, 2022, 11:13 AM -0700, Gregory L. Wagner ***@***.***>, wrote:; > Here's a video from the sediment_entrainment.jl validation case:; > https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1088061129:5,Security,validat,validation,5,"Last validation for now I think... two tracers that react (a - > b), one sinking, one rising:. https://user-images.githubusercontent.com/15271942/161640083-9df98a3c-c6cb-4ccf-bf04-d396b4e4ddc5.mp4. (validates putting forcings in a tuple)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1088061129
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1088061129:199,Security,validat,validates,199,"Last validation for now I think... two tracers that react (a - > b), one sinking, one rising:. https://user-images.githubusercontent.com/15271942/161640083-9df98a3c-c6cb-4ccf-bf04-d396b4e4ddc5.mp4. (validates putting forcings in a tuple)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1088061129
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:23,Availability,error,error,23,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:166,Availability,error,error,166,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:732,Availability,error,error,732,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:38,Testability,Test,Test,38,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:465,Testability,test,test,465,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:593,Testability,test,test,593,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:25,Availability,error,error,25,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:186,Availability,error,error,186,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:779,Availability,error,error,779,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:48,Testability,Test,Test,48,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:500,Testability,test,test,500,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:634,Testability,test,test,634,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:910,Usability,learn,learn,910,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:145,Availability,error,error,145,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:568,Availability,error,error,568,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:158,Testability,test,test,158,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:200,Testability,test,test,200,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:371,Testability,Test,Test,371,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:477,Testability,test,test,477,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:512,Testability,test,tests,512,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:599,Testability,test,tests,599,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:646,Testability,test,test,646,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:767,Testability,test,test,767,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:61,Usability,learn,learn,61,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:154,Availability,error,error,154,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:616,Availability,error,error,616,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:1007,Availability,error,error,1007,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:924,Integrability,wrap,wrap,924,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:167,Testability,test,test,167,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:209,Testability,test,test,209,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:396,Testability,Test,Test,396,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:517,Testability,test,test,517,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:560,Testability,test,tests,560,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:647,Testability,test,tests,647,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:700,Testability,test,test,700,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:827,Testability,test,test,827,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:63,Usability,learn,learn,63,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094126204:87,Testability,test,test,87,"Sorry, I was out. I can try running on GPU to see if I can catch the bug. Any specific test I could run?; I commented on the code, but did not see your post asking me to run the test. When I clicked on the notification it jumped directly to the code, sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094126204
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094126204:178,Testability,test,test,178,"Sorry, I was out. I can try running on GPU to see if I can catch the bug. Any specific test I could run?; I commented on the code, but did not see your post asking me to run the test. When I clicked on the notification it jumped directly to the code, sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094126204
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1095117098:89,Testability,test,test,89,"> Sorry, I was out. I can try running on GPU to see if I can catch the bug. Any specific test I could run? I commented on the code, but did not see your post asking me to run the test. When I clicked on the notification it jumped directly to the code, sorry. No, nothing to do! Just sorting out details now and hopefully will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1095117098
https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1095117098:179,Testability,test,test,179,"> Sorry, I was out. I can try running on GPU to see if I can catch the bug. Any specific test I could run? I commented on the code, but did not see your post asking me to run the test. When I clicked on the notification it jumped directly to the code, sorry. No, nothing to do! Just sorting out details now and hopefully will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1095117098
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665:120,Availability,error,error,120,"@glwagner ; I should have reviewed your code instead, right?. This is now complaining about `af` variable; `nested task error: UndefVarError: af not defined`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665:97,Modifiability,variab,variable,97,"@glwagner ; I should have reviewed your code instead, right?. This is now complaining about `af` variable; `nested task error: UndefVarError: af not defined`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314:19,Deployability,update,updates,19,I sent a flurry of updates once I had the validation case coded up! It should work now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314:42,Security,validat,validation,42,I sent a flurry of updates once I had the validation case coded up! It should work now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978:21,Deployability,update,updates,21,"> I sent a flurry of updates once I had the validation case coded up! It should work now. Wait, what should I do to test that? haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978:44,Security,validat,validation,44,"> I sent a flurry of updates once I had the validation case coded up! It should work now. Wait, what should I do to test that? haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978
https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978:116,Testability,test,test,116,"> I sent a flurry of updates once I had the validation case coded up! It should work now. Wait, what should I do to test that? haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978
https://github.com/CliMA/Oceananigans.jl/issues/2391#issuecomment-1082146704:28,Testability,test,tests,28,Maybe put in a PR with some tests in test_field.jl? I can fix this in a bit.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391#issuecomment-1082146704
https://github.com/CliMA/Oceananigans.jl/issues/2391#issuecomment-1082183488:30,Testability,test,tests,30,> Maybe put in a PR with some tests in test_field.jl? I can fix this in a bit. Created one here: https://github.com/CliMA/Oceananigans.jl/pull/2392. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391#issuecomment-1082183488
https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611:813,Availability,error,error,813,"It's just a small detail... if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`. . This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately). So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611
https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611:677,Security,access,access,677,"It's just a small detail... if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`. . This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately). So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611
https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001:833,Availability,error,error,833,"> It's just a small detail...; > ; > if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`.; > ; > This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately); > ; > So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs. Makes sense. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001
https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001:691,Security,access,access,691,"> It's just a small detail...; > ; > if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`.; > ; > This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately); > ; > So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs. Makes sense. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083533441:66,Availability,error,error,66,Hi @syou83syou83. Can you please add to the post a logfile of the error you are getting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083533441
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083533441:51,Testability,log,logfile,51,Hi @syou83syou83. Can you please add to the post a logfile of the error you are getting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083533441
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083606906:66,Availability,error,error,66,"Thanks @iuryt. Of course. . ```; TaskFailedException. nested task error: UndefVarError: y₂ not defined; Stacktrace:; [1] overdub; @ ~/.julia/packages/Oceananigans/JIHfS/src/Fields/interpolate.jl:13 [inlined]; [2] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/JIHfS/src/Fields/interpolate.jl:44 [inlined]; [3] overdub; @ ~/.julia/packages/Oceananigans/JIHfS/src/Fields/interpolate.jl:44 [inlined]; [4] overdub; @ ~/.julia/packages/Oceananigans/JIHfS/src/Fields/interpolate.jl:59 [inlined]; [5] interpolate(::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceanan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083606906
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083606906:117622,Performance,load,loading,117622,"eldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/JIHfS/src/Simulations/run.jl:88; [10] top-level scope; @ In[2]:61; [11] eval; @ ./boot.jl:373 [inlined]; [12] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1196. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083606906
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:108,Availability,error,errors,108,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:448,Availability,Error,Error,448,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:568,Availability,error,error,568,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:123,Deployability,update,updated,123,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:118734,Performance,load,loading,118734,"onditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/Yz6ub/src/Simulations/run.jl:88; [10] top-level scope; @ In[3]:54; [11] eval; @ ./boot.jl:373 [inlined]; [12] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1196. ```; </details>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:599,Security,access,access,599,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084461600:57,Availability,error,error,57,"@syou83syou83 can you share your code that leads to this error?. check this out: https://gist.github.com/scmx/eca72d44afee0113ceb0349dd54a84a2 for how to create ""expandable"" widgets in your markdown posts",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084461600
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084486180:74,Availability,error,error,74,"Okay, using the code in the original post I can reproduce @syou83syou83's error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084486180
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084515653:10,Testability,test,test,10,I added a test to #2397 but it doesn't catch this bug: https://github.com/CliMA/Oceananigans.jl/blob/5c35f5dcf1ca109938a66913b05cdbc2f1616509/test/test_lagrangian_particle_tracking.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084515653
https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084515653:142,Testability,test,test,142,I added a test to #2397 but it doesn't catch this bug: https://github.com/CliMA/Oceananigans.jl/blob/5c35f5dcf1ca109938a66913b05cdbc2f1616509/test/test_lagrangian_particle_tracking.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084515653
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069:297,Integrability,depend,depending,297,"Yep. the inputs `Ax, Ay, Az, C, D` are used to construct the matrix that solves; ```; Axᵢ₊₁ xᵢ₊₁ + Axᵢ xᵢ₋₁ + Ayⱼ₊₁ xⱼ₊₁ + Ayⱼ xⱼ₋₁ + Azₖ₊₁ xₖ₊₁ + Azₖ xⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) xᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) xᵢⱼₖ = b; ```; with periodic or zero-flux boundary condition depending on the topology of the grid (i.e. bounded topology -> zero flux BC, periodic topology -> periodic BC). If you need a matrix to solve the discretized Poisson equation at `ᶜᶜᶜ`:; ```; Ax = zeros(N...); Ay = zeros(N...); Az = zeros(N...); C = zeros(grid, N...); D = zeros(grid, N...); for i = 1:grid.Nx, j = 1:grid.Ny, k = 1:grid.Nz; Ax[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δyᶠᶜᵃ(i, j, k, grid) / Δxᶠᶜᵃ(i, j, k, grid); Ay[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δxᶜᶠᵃ(i, j, k, grid) / Δyᶜᶠᵃ(i, j, k, grid); Az[i, j, k] = Δxᶜᶜᵃ(i, j, k, grid) * Δyᶜᶜᵃ(i, j, k, grid) / Δzᵃᵃᶠ(i, j, k, grid); end; reduced_dim = (false, false, false); matrix_constructors, diagonal, problem_size = matrix_from_coefficients(arch, grid, (Ax, Ay, Az, C, D), reduced_dim); matrix = arch_sparse_matrix(arch, matrix_constructors); ```; Take care that, with these coefficients, the RHS will have to be multiplied by the volume. (otherwise you can always divide the coefficients by the volume before constructing the matrix)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109351042:740,Testability,test,test,740,"Say we want to retrieve linear operator `A` given a function `linear_operation(x)` that applied on `x` returns `A*x`. Then, we can apply the `linear_operation` to all unit vectors and each time we get a column of `A`. [thanks @glwagner!]. For example, say we have a 1D case in which `A` is d²/dx²:. ```Julia; using OffsetArrays. L = 1; N = 8; H = 1; δ = L/N. poisson(f, i) = (f[i+1] - 2*f[i] + f[i-1])/δ^2. function fill_halos!(f::OffsetVector); f[0] = f[N]; f[N+1] = f[1]. return nothing; end. interior(f::OffsetVector) = f[1:N]. A = OffsetArray(zeros(N, N)). for j in 1:N; eⱼ = OffsetArray(zeros(N+2H), -H); eⱼ[j] = 1; fill_halos!(eⱼ); ∇²eⱼ = 0 * eⱼ; for i in 1:N; ∇²eⱼ[i] = poisson(eⱼ, i); end. A[:, j] = interior(∇²eⱼ); end. @show A. # test if A does the job. # compute the laplacian of f poisson() function; f = OffsetArray(rand(N+2H, ), -H); fill_halos!(f). ∇²f = 0 * f. for i in 1:N; ∇²f[i] = poisson(f, i); end. # compute the laplacian of f using matrix A; ∇²f_matrix = A * interior(f); ```. returns. ```Julia; julia> @show A; A = [-128.0 64.0 0.0 0.0 0.0 0.0 0.0 64.0; 64.0 -128.0 64.0 0.0 0.0 0.0 0.0 0.0; 0.0 64.0 -128.0 64.0 0.0 0.0 0.0 0.0; 0.0 0.0 64.0 -128.0 64.0 0.0 0.0 0.0; 0.0 0.0 0.0 64.0 -128.0 64.0 0.0 0.0; 0.0 0.0 0.0 0.0 64.0 -128.0 64.0 0.0; 0.0 0.0 0.0 0.0 0.0 64.0 -128.0 64.0; 64.0 0.0 0.0 0.0 0.0 0.0 64.0 -128.0]; 8×8 OffsetArray(::Matrix{Float64}, 1:8, 1:8) with eltype Float64 with indices 1:8×1:8:; -128.0 64.0 0.0 0.0 0.0 0.0 0.0 64.0; 64.0 -128.0 64.0 0.0 0.0 0.0 0.0 0.0; 0.0 64.0 -128.0 64.0 0.0 0.0 0.0 0.0; 0.0 0.0 64.0 -128.0 64.0 0.0 0.0 0.0; 0.0 0.0 0.0 64.0 -128.0 64.0 0.0 0.0; 0.0 0.0 0.0 0.0 64.0 -128.0 64.0 0.0; 0.0 0.0 0.0 0.0 0.0 64.0 -128.0 64.0; 64.0 0.0 0.0 0.0 0.0 0.0 64.0 -128.0; ```. and; ```julia; julia> isapprox(interior(∇²f), ∇²f_matrix); true; ```; For a 2D case with `A = ∂²/∂x² + ∂²/∂y²` we have:. ```Julia; using OffsetArrays. Lx = 2; Ly = 3; Nx = 12; Ny = 18; H = 1; δx = Lx/Nx; δy = Ly/Ny. poisson(f::OffsetMatrix, i, j) = (f[i+1, j]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109351042
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109351042:2601,Testability,test,test,2601,"(f); ```. returns. ```Julia; julia> @show A; A = [-128.0 64.0 0.0 0.0 0.0 0.0 0.0 64.0; 64.0 -128.0 64.0 0.0 0.0 0.0 0.0 0.0; 0.0 64.0 -128.0 64.0 0.0 0.0 0.0 0.0; 0.0 0.0 64.0 -128.0 64.0 0.0 0.0 0.0; 0.0 0.0 0.0 64.0 -128.0 64.0 0.0 0.0; 0.0 0.0 0.0 0.0 64.0 -128.0 64.0 0.0; 0.0 0.0 0.0 0.0 0.0 64.0 -128.0 64.0; 64.0 0.0 0.0 0.0 0.0 0.0 64.0 -128.0]; 8×8 OffsetArray(::Matrix{Float64}, 1:8, 1:8) with eltype Float64 with indices 1:8×1:8:; -128.0 64.0 0.0 0.0 0.0 0.0 0.0 64.0; 64.0 -128.0 64.0 0.0 0.0 0.0 0.0 0.0; 0.0 64.0 -128.0 64.0 0.0 0.0 0.0 0.0; 0.0 0.0 64.0 -128.0 64.0 0.0 0.0 0.0; 0.0 0.0 0.0 64.0 -128.0 64.0 0.0 0.0; 0.0 0.0 0.0 0.0 64.0 -128.0 64.0 0.0; 0.0 0.0 0.0 0.0 0.0 64.0 -128.0 64.0; 64.0 0.0 0.0 0.0 0.0 0.0 64.0 -128.0; ```. and; ```julia; julia> isapprox(interior(∇²f), ∇²f_matrix); true; ```; For a 2D case with `A = ∂²/∂x² + ∂²/∂y²` we have:. ```Julia; using OffsetArrays. Lx = 2; Ly = 3; Nx = 12; Ny = 18; H = 1; δx = Lx/Nx; δy = Ly/Ny. poisson(f::OffsetMatrix, i, j) = (f[i+1, j] - 2*f[i, j] + f[i-1, j])/δx^2 + (f[i, j+1] - 2*f[i, j] + f[i, j-1])/δy^2. interior(f::OffsetMatrix) = f[1:Nx, 1:Ny]. function fill_halos!(f::OffsetMatrix); f[0, :] = f[Nx, :]; f[Nx+1, :] = f[1, :]. f[:, 0] = f[:, Ny]; f[:, Ny+1] = f[:, 1]. return nothing; end. A = OffsetArray(zeros(Nx*Ny, Nx*Ny)). make_column(f::OffsetMatrix) = reshape(interior(f), (Nx*Ny, 1)). for j in 1:Ny, i in 1:Nx; eᵢⱼ = OffsetArray(zeros(Nx+2H, Ny+2H), -H, -H); eᵢⱼ[i, j] = 1; fill_halos!(eᵢⱼ); ∇²eᵢⱼ = 0 * eᵢⱼ. for j in 1:Ny, i in 1:Nx; ∇²eᵢⱼ[i, j] = poisson(eᵢⱼ, i, j); end. A[:, Nx*(j-1)+i] = make_column(∇²eᵢⱼ); end. # test if A does the job. # compute the laplacian of f poisson() function; f = rand(Nx+2H, Ny+2H); f = OffsetArray(f, -H, -H); fill_halos!(f). ∇²f = 0 * f. for j in 1:Ny, i in 1:Nx; ∇²f[i, j] = poisson(f, i, j); end. # compute the laplacian of f using matrix A; ∇²f_matrix = A * make_column(f); ```. and we can confirm that. ```Julia; julia> isapprox(make_column(∇²f), ∇²f_matrix); true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109351042
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239:12,Integrability,rout,route,12,"I went that route before, that would be prohibitive memory-wise also on moderately small grids, especially if you try to do it on 3D settings. You can sparsify the vectors if you want to alleviate it. Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I remember @sandreza had a good trick to calculate a matrix from a linear operation without having to calculate it on all the unit vectors. To sparsify the matrix you can use the utils in matrix_solver_utils.jl because, unfortunately, the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:611,Energy Efficiency,efficient,efficient,611,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:1016,Energy Efficiency,efficient,efficient,1016,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:863,Performance,perform,perform,863,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:381,Safety,avoid,avoid,381,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389:578,Integrability,interface,interfaces,578,"This code works:. ```julia; julia> using CUDA.CUSPARSE, SparseArrays, LinearAlgebra. julia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0]); 3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B = CuSparseMatrixCSC(A); 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B += 1I; 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 1 ⋅ 1; ⋅ 3 ⋅; ⋅ ⋅ 1; ```. There's some `UniformScaling` stuff here: https://github.com/JuliaGPU/CUDA.jl/blob/06e8a4ccca62567d38a567874f82cb58517d8f01/lib/cusparse/interfaces.jl#L179. These appear to be allocating, so it still might make sense to decompose the matrix into a diagonal and off-diagonal component.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109796895:354,Energy Efficiency,efficient,efficiently,354,"more like are the arguments of the constructors of the respective types `CuSparseMatrixCSC` and `SparseMatrixCSC`, which are also the fields of the respective types. (respectively, the dimensions, the integer vector of column pointers, the integer vector of row position and the float vector of nonzero elements) . you should be able to manipulate those efficiently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109796895
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109798525:262,Safety,avoid,avoid,262,"I have tried to follow the discussion but think I missed an important bit, sorry if it was stated above. @navidcy : what's the motvation for building `A` explicitly in the multigrid method? . As has been said before, this is very expensive in 3D and hope we can avoid it if possible. But I say this having forgotten most of what I used to know about mulgrid methods. ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109798525
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1110447124:87,Energy Efficiency,allocate,allocated,87,"You have to define `A` as a `SparseMatrix` before iterating, otherwise the memory gets allocated anyways. The same goes for the vectors `e`, Try this. ```; using OffsetArrays; using SparseArrays. Lx = 2; Ly = 3; Nx = 12; Ny = 18; H = 1; δx = Lx/Nx; δy = Ly/Ny. poisson(f::OffsetMatrix, i, j) = (f[i+1, j] - 2*f[i, j] + f[i-1, j])/δx^2 + (f[i, j+1] - 2*f[i, j] + f[i, j-1])/δy^2. interior(f::OffsetMatrix) = f[1:Nx, 1:Ny]. function fill_halos!(f::OffsetMatrix); f[0, :] = f[Nx, :]; f[Nx+1, :] = f[1, :]. f[:, 0] = f[:, Ny]; f[:, Ny+1] = f[:, 1]. return nothing; end. A = spzeros(Float64, Nx*Ny, Nx*Ny). make_column(f::OffsetMatrix) = reshape(interior(f), (Nx*Ny, 1)). for j in 1:Ny, i in 1:Nx; eᵢⱼ = OffsetArray(spzeros((Nx+2H), (Ny+2H)), -H, -H); eᵢⱼ[i, j] = 1; fill_halos!(eᵢⱼ); ∇²eᵢⱼ = 0 * eᵢⱼ. for j in 1:Ny, i in 1:Nx; ∇²eᵢⱼ[i, j] = poisson(eᵢⱼ, i, j); end. A[:, Nx*(j-1)+i] = make_column(∇²eᵢⱼ); end; ```. then I suggest you to extract the constructors and just deal with those from here on out:; ```; using Oceananigans.Solvers: constructors, arch_sparse_matrix. matrix_constructors = constructors(arch, A); ```; whenever you want to write the matrix explicitly. ```; A = arch_sparse_matrix(arch, matrix_constructors); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1110447124
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1116032682:140,Deployability,update,update,140,"Yea well, the matrix is in `solver.matrix`. Note that the diagonal term `Az/g` is separatly stored in `solver.diagonal` because you have to update the matrix every time `Δt` changes, i.e., you do not want to have it hardcoded in the matrix. Btw, if you want the linear operation for the LHS that is the function you want no? ; `@inbounds L_ηⁿ⁺¹[i, j, 1] = Az_∇h²ᶜᶜᶜ(i, j, 1, grid, ∫ᶻ_Axᶠᶜᶜ, ∫ᶻ_Ayᶜᶠᶜ, ηⁿ⁺¹) - Az * ηⁿ⁺¹[i, j, 1] / (g * Δt^2)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1116032682
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139036029:1481,Availability,ERROR,ERROR,1481,"at64 with indices -2:19×-2:19×1:1; └── max=0.0, min=0.0, mean=0.0. julia> hd_solver; Matrix-based iterative solver with:; ├── Problem size: (16, 16, 1); ├── Grid: 16×16×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo; ├── Bounded x ∈ [-4.0, 4.0] regularly spaced with Δx=0.5; ├── Bounded y ∈ [-4.0, 4.0] regularly spaced with Δy=0.5; └── Flat z; ├── Solution method: cg!; └── Preconditioner: nothing. julia> r; 16×16×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 16×16×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: ZeroFlux, north: ZeroFlux, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 22×22×1 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, 1:1) with eltype Float64 with indices -2:19×-2:19×1:1; └── max=1.0, min=0.0, mean=0.953125. julia> solve!(ϕ_hd, hd_solver, r, 1.0); ERROR: MethodError: no method matching mul!(::Vector{Float64}, ::SparseArrays.SparseMatrixCSC{Float64, Int64}, ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139036029
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139036029:7752,Testability,log,log,7752,"nearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; abstol::Float64, reltol::Float64, maxiter::Int64, log::Bool, statevars::CGStateVariables{Float64, Vector{Float64}}, verbose::Bool, Pl::Identity, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [4] solve!(x::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139036029
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139068720:30,Security,validat,validation,30,I'm trying to run the script `validation/elliptic_solvers/doubly_bounded_poisson.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139068720
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139072099:87,Energy Efficiency,allocate,allocated,87,"Ah, I see why before it was working, I was doing the reshaping under the hood from the allocated array inside the `solve!` function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139072099
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1143182589:224,Energy Efficiency,allocate,allocated,224,"@glwagner, with [dcfbdf4](https://github.com/CliMA/Oceananigans.jl/pull/2396/commits/dcfbdf4d9f1bd89dde82744c31a08d70f17e6b42) @elise-palethorpe tried to make the algebraic multigrid non-allocating but still it seems that `@allocated` gives non-zero. I can't seem to understand why. Could you have a look? Is there a better way to see whether there are allocations other than `@allocated`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1143182589
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1143182589:378,Energy Efficiency,allocate,allocated,378,"@glwagner, with [dcfbdf4](https://github.com/CliMA/Oceananigans.jl/pull/2396/commits/dcfbdf4d9f1bd89dde82744c31a08d70f17e6b42) @elise-palethorpe tried to make the algebraic multigrid non-allocating but still it seems that `@allocated` gives non-zero. I can't seem to understand why. Could you have a look? Is there a better way to see whether there are allocations other than `@allocated`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1143182589
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1143185831:100,Testability,Benchmark,BenchmarkTools,100,"hm, on second thought I think what you did there @elise-palethorpe is fine!; ```Julia; julia> using BenchmarkTools. julia> @btime _solve!(φ_mg_array, ml, r_array);; 146.417 μs (0 allocations: 0 bytes); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1143185831
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1161302426:225,Security,validat,validation,225,Where could we find a function for the free surface equation linear operator? I would like to replace `compute_∇²!` in the following line https://github.com/CliMA/Oceananigans.jl/blob/aea5494a763eb3949b234b5302ddb0a2e9764678/validation/elliptic_solvers/doubly_bounded_poisson.jl#L94,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1161302426
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:357,Availability,ERROR,ERROR,357,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:1163,Availability,ERROR,ERROR,1163,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:22,Safety,avoid,avoid,22,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:136,Security,validat,validation,136,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:381,Availability,ERROR,ERROR,381,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:1215,Availability,ERROR,ERROR,1215,"> ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think you have to preallocate a temporary array probably.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:24,Safety,avoid,avoid,24,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:144,Security,validat,validation,144,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1166869882:34,Testability,test,test,34,@elise-palethorpe we should add a test for the multigrid solver. Perhaps just the poisson equation? Something similar like what's done in `tests/test_preconditioned_conjugate_gradient_solver.jl`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1166869882
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1166869882:139,Testability,test,tests,139,@elise-palethorpe we should add a test for the multigrid solver. Perhaps just the poisson equation? Something similar like what's done in `tests/test_preconditioned_conjugate_gradient_solver.jl`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1166869882
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1168091279:35,Safety,avoid,avoid,35,EDIT: Sorry I see now that it's to avoid additional allocation :) https://github.com/CliMA/Oceananigans.jl/blob/24710f4b9d3733d09f8af0eb459eb9984908175a/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L108. I'm trying to implement a multigrid equivalent of the PCG implicit free surface solver but I don't understand why we need this field https://github.com/CliMA/Oceananigans.jl/blob/aea5494a763eb3949b234b5302ddb0a2e9764678/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L25. I thought the right hand side would change each iteration and is passed to the `solve!` function?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1168091279
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1169211603:18,Deployability,patch,patch,18,"Let's also bump a patch release for this feature, i.e. change . https://github.com/CliMA/Oceananigans.jl/blob/8936bec4f19b9cab49e42b69f475f828553a897a/Project.toml#L4. to `version = ""0.76.7""`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1169211603
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1169211603:24,Deployability,release,release,24,"Let's also bump a patch release for this feature, i.e. change . https://github.com/CliMA/Oceananigans.jl/blob/8936bec4f19b9cab49e42b69f475f828553a897a/Project.toml#L4. to `version = ""0.76.7""`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1169211603
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1169548063:30,Deployability,update,update,30,"@elise-palethorpe, let's also update this. https://github.com/CliMA/Oceananigans.jl/blob/36596d384684c33c1c235f092da4b9b33375eaef/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L60-L63. to add the multigrid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1169548063
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1173021015:101,Testability,test,tests,101,"@elise-palethorpe, we have added the `test_multigrid_solver.jl` but it's never used in the automatic tests. We need to include it there. Perhaps a good place for it is around:; https://github.com/CliMA/Oceananigans.jl/blob/3469cb714343019cedca9a12af9e21d4f9432e0d/test/runtests.jl#L54-L59. E.g., ; ```Julia; if group == :general_solvers || group == :all; @testset ""General Solvers"" begin; include(""test_batched_tridiagonal_solver.jl""); include(""test_preconditioned_conjugate_gradient_solver.jl""); include(""test_multigrid_solver.jl""); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1173021015
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1173021015:264,Testability,test,test,264,"@elise-palethorpe, we have added the `test_multigrid_solver.jl` but it's never used in the automatic tests. We need to include it there. Perhaps a good place for it is around:; https://github.com/CliMA/Oceananigans.jl/blob/3469cb714343019cedca9a12af9e21d4f9432e0d/test/runtests.jl#L54-L59. E.g., ; ```Julia; if group == :general_solvers || group == :all; @testset ""General Solvers"" begin; include(""test_batched_tridiagonal_solver.jl""); include(""test_preconditioned_conjugate_gradient_solver.jl""); include(""test_multigrid_solver.jl""); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1173021015
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1173021015:356,Testability,test,testset,356,"@elise-palethorpe, we have added the `test_multigrid_solver.jl` but it's never used in the automatic tests. We need to include it there. Perhaps a good place for it is around:; https://github.com/CliMA/Oceananigans.jl/blob/3469cb714343019cedca9a12af9e21d4f9432e0d/test/runtests.jl#L54-L59. E.g., ; ```Julia; if group == :general_solvers || group == :all; @testset ""General Solvers"" begin; include(""test_batched_tridiagonal_solver.jl""); include(""test_preconditioned_conjugate_gradient_solver.jl""); include(""test_multigrid_solver.jl""); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1173021015
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:122,Integrability,depend,depending,122,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:289,Security,validat,validation,289,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:124,Integrability,depend,depending,124,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:291,Security,validat,validation,291,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179412493:623,Deployability,update,update,623,"@simone-silvestri, I would like to use the `update_diag!` function similarly to how it's used [here ](https://github.com/CliMA/Oceananigans.jl/blob/dcce559f2cc8d417735eee2f5ce6d9ccdb9b5570/src/Solvers/heptadiagonal_iterative_solver.jl#L307) but I'm a bit confused as to how it works. I'm fairly sure the first two terms of eq 13 in [poisson solvers](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/poisson_solvers/) contribute to the diagonal as well as the 3rd term (ie even though `Δt` only contributes to the diagonal it is not the only term which does so). If this is the case then to update the diagonal without recalculating the first two terms I believe we have to keep track of the previous `Δt` so we can subtract off the old term and then add back on the new term. However `update_diag!` only takes the new `Δt` so I don't understand how it could be doing this update. Any chance you could clarify this? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179412493
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179412493:905,Deployability,update,update,905,"@simone-silvestri, I would like to use the `update_diag!` function similarly to how it's used [here ](https://github.com/CliMA/Oceananigans.jl/blob/dcce559f2cc8d417735eee2f5ce6d9ccdb9b5570/src/Solvers/heptadiagonal_iterative_solver.jl#L307) but I'm a bit confused as to how it works. I'm fairly sure the first two terms of eq 13 in [poisson solvers](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/poisson_solvers/) contribute to the diagonal as well as the 3rd term (ie even though `Δt` only contributes to the diagonal it is not the only term which does so). If this is the case then to update the diagonal without recalculating the first two terms I believe we have to keep track of the previous `Δt` so we can subtract off the old term and then add back on the new term. However `update_diag!` only takes the new `Δt` so I don't understand how it could be doing this update. Any chance you could clarify this? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179412493
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:784,Deployability,update,updated,784,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:1092,Integrability,depend,dependent,1092,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:88,Modifiability,variab,variable,88,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:509,Performance,perform,performed,509,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989:288,Energy Efficiency,efficient,efficient,288,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989:49,Usability,clear,clear,49,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989:234,Usability,simpl,simplifies,234,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052:115,Modifiability,refactor,refactor,115,It's so nice that we have these tests. Seeing them pass makes me so confident that you did this matrix constructor refactor correctly @elise-palethorpe.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052:32,Testability,test,tests,32,It's so nice that we have these tests. Seeing them pass makes me so confident that you did this matrix constructor refactor correctly @elise-palethorpe.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1181619055:23,Testability,test,tests,23,@elise-palethorpe when tests pass let’s merge and open a new issue/PR for the preconditioning.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1181619055
https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1181899132:34,Testability,test,test,34,Just waiting for the 3hr-long gpu test to finish...! :) (@simone-silvestri),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1181899132
https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453:39,Modifiability,refactor,refactoring,39,need a test too I think. Probably some refactoring to come for Lagrangian particles...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453
https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453:7,Testability,test,test,7,need a test too I think. Probably some refactoring to come for Lagrangian particles...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453
https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1084059429:0,Testability,Test,Test,0,Test can come now or later,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1084059429
https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084571227:500,Safety,avoid,avoiding,500,"To summarize a little more: the issue is not that `Pr` is an empty tuple --- this is perfectly fine. The bug is just in showing an empty `NamedTuple` of `Field`. The reason why . ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; ```. works is because `closure` and `model.closure` are different:. ```julia; julia> closure === model.closure; false; ```. This is generically true because we call `with_tracers` on the user-defined closure to build `model.closure`. We can fix this by avoiding `with_tracers` in the model constructor for empty `tracers`, but I'd argue we'll be better off (right now) fixing the bug in `show` for empty `NamedTuple` of `Field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084571227
https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084584409:78,Availability,Error,Error,78,"The problem is bad. ```julia; julia> using Oceananigans. julia> NamedTuple(); Error showing value of type NamedTuple{(), Tuple{}}:; ERROR: ArgumentError: collection must be non-empty; ```. but hilariously. ```julia; julia> NamedTuple(); NamedTuple(). julia> using Oceananigans; [ Info: Oceananigans will use 8 threads. julia> NamedTuple(); NamedTuple(); ```. just fine. I think the order in which the. methods are added to the method table / compiled matters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084584409
https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084584409:132,Availability,ERROR,ERROR,132,"The problem is bad. ```julia; julia> using Oceananigans. julia> NamedTuple(); Error showing value of type NamedTuple{(), Tuple{}}:; ERROR: ArgumentError: collection must be non-empty; ```. but hilariously. ```julia; julia> NamedTuple(); NamedTuple(). julia> using Oceananigans; [ Info: Oceananigans will use 8 threads. julia> NamedTuple(); NamedTuple(); ```. just fine. I think the order in which the. methods are added to the method table / compiled matters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084584409
https://github.com/CliMA/Oceananigans.jl/pull/2399#issuecomment-1084045232:102,Availability,error,error,102,We need a different solution because `with_tracers` can be used (only by CATKE right now) to throw an error if the tracers are not compatible with the closure:. https://github.com/CliMA/Oceananigans.jl/blob/9fb2a9538db828597fce384d5f24132afdd60980/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L60-L66. Should we fix the issue with `show` instead?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2399#issuecomment-1084045232
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717:551,Modifiability,parameteriz,parameterizations,551,"I want to merge this then use it to develop the user API for immersed boundary fluxes. Also, did anyone use this?. Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations. It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:614,Modifiability,parameteriz,parameterizations,614,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:155,Testability,test,test,155,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:1749,Testability,test,tests,1749,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:1013,Usability,intuit,intuition,1013,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:1250,Usability,simpl,simpler,1250,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100249876:459,Testability,test,test,459,"> Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100249876
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100249876:526,Testability,test,test,526,"> Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100249876
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067:261,Integrability,depend,depend,261,"> Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though. Doesn't this depend on the setup? The actual ocean bottom is littered with boulders and other features of various sizes, and there's plenty of work in very steep canyons, ie https://en.wikipedia.org/wiki/Scripps_Canyon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067:215,Testability,test,tests,215,"> Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though. Doesn't this depend on the setup? The actual ocean bottom is littered with boulders and other features of various sizes, and there's plenty of work in very steep canyons, ie https://en.wikipedia.org/wiki/Scripps_Canyon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:673,Integrability,interface,interface,673,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:890,Integrability,interface,interface,890,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:468,Testability,test,test,468,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:535,Testability,test,test,535,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:566,Usability,clear,clear,566,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:691,Integrability,interface,interface,691,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:863,Integrability,interface,interface,863,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:480,Testability,test,test,480,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:547,Testability,test,test,547,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:584,Usability,clear,clear,584,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:1157,Integrability,wrap,wrapping,1157,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:416,Modifiability,rewrite,rewrite,416,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:715,Testability,log,logic,715,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084995421:345,Availability,down,down,345,"Yes, more generally, we should include `nu` in the bracket, as you showed above. Good point. Thanks @glwagner and I agree that your 4 steps seem like a good way to proceed, and well worth trying. I can give this a try next week after my teaching is done for the semester. Unless someone else wanted to give it a try. I don't want to slow things down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084995421
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084996734:31,Testability,test,testing,31,Updating the code is easy; but testing will be more time consuming. So we just need someone who's willing to run experiments.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084996734
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1085976704:638,Energy Efficiency,energy,energy,638,"@glwagner : I added to the overleaf document this morning. There are two forms that one could consider. . The one that I mentioned above, equation 7 in Overleaf, is the cheaper of the two but does not correspond to a symmetric stress tensor. The other one, which is based on the stress tensor, equation 8 in Overlaf, is more expensive, should dissipate more, but does have a symmetric stress tensor. My guess is that the first one should be the default but maybe there is interest in having the second one as an option?. Also, I go through the details in showing how the other two forms do not give rise to negative definite terms in the energy equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1085976704
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089212448:411,Energy Efficiency,energy,energy,411,@glwagner : do you think we should only have one form of viscosity in `ShallowWaterModel` or can we have several?. It occurs to me that the first method with `\nu/h \nabla^2 \vec v` might actually be a pain to impliment in a Finite Volume formulation as it's not in divergence form. If that's the case then I would advocating for the one in divergence form since 1) it's easy to apply and 2) it ensures kinetic energy does not increase because of viscosity. . In that case we could just have the one and leave it at that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089212448
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262:38,Modifiability,variab,variable,38,Can you write these possibilities for variable `ν` (eg `ν` must always appear inside the divergence)? These don't all have the same dimensions --- what's happening?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:132,Energy Efficiency,reduce,reduces,132,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:152,Energy Efficiency,energy,energy,152,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:24,Modifiability,variab,variable,24,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089686499:293,Usability,simpl,simple,293,"Ok, multiplying by `h` then it would seem the possible models are. ```; 1. ∇ ⋅ (ν h ∇u); 2. ∇ ⋅ (ν ∇hu); 3. h ∇ ⋅ (ν ∇u); ```. ? These all have the same dimensions but different properties. I think 3. is what we get if we derive the closure from horizontal dissipation in Navier-Stokes. 2. is simple because it requires no code changes (ie it's the ordinary viscosity, except with `u -> hu`). 1. is supported by the theoretical arguments you listed. Also, I agree that this is first and foremost a _closure_, so ""derivability from Navier-Stokes"" is not paramount.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089686499
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090218750:122,Energy Efficiency,energy,energy,122,"Yes, if we are dealing with the conservative form, `1.` is the one that I am suggesting, and iut does ensure that kinetic energy is disispated by viscosity. I don't believe that `2.` and `3.` have that property.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090218750
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090226616:124,Energy Efficiency,energy,energy,124,"> Yes, if we are dealing with the conservative form, `1.` is the one that I am suggesting, and iut does ensure that kinetic energy is disispated by viscosity. I don't believe that `2.` and `3.` have that property. Right! And just to clarify, it conserves the kinetic energy density `h |u|^2`. The form of kinetic energy is crucial, because `∇ ⋅ (ν ∇u)` _does_ conserve `|u|^2`. Note that `∇ ⋅ (ν ∇hu)` conserves the ""transport variance"" `|hu|^2`. Also,. ```; u ∇ ⋅ (ν ∇hu) = ∇ ⋅ (ν u ∇hu) - ν ∇u ⋅ ∇hu = ∇ ⋅ (ν u ∇hu) - ν h |∇u|^2 - ν u ∇u⋅ ∇h; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090226616
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090226616:267,Energy Efficiency,energy,energy,267,"> Yes, if we are dealing with the conservative form, `1.` is the one that I am suggesting, and iut does ensure that kinetic energy is disispated by viscosity. I don't believe that `2.` and `3.` have that property. Right! And just to clarify, it conserves the kinetic energy density `h |u|^2`. The form of kinetic energy is crucial, because `∇ ⋅ (ν ∇u)` _does_ conserve `|u|^2`. Note that `∇ ⋅ (ν ∇hu)` conserves the ""transport variance"" `|hu|^2`. Also,. ```; u ∇ ⋅ (ν ∇hu) = ∇ ⋅ (ν u ∇hu) - ν ∇u ⋅ ∇hu = ∇ ⋅ (ν u ∇hu) - ν h |∇u|^2 - ν u ∇u⋅ ∇h; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090226616
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090226616:313,Energy Efficiency,energy,energy,313,"> Yes, if we are dealing with the conservative form, `1.` is the one that I am suggesting, and iut does ensure that kinetic energy is disispated by viscosity. I don't believe that `2.` and `3.` have that property. Right! And just to clarify, it conserves the kinetic energy density `h |u|^2`. The form of kinetic energy is crucial, because `∇ ⋅ (ν ∇u)` _does_ conserve `|u|^2`. Note that `∇ ⋅ (ν ∇hu)` conserves the ""transport variance"" `|hu|^2`. Also,. ```; u ∇ ⋅ (ν ∇hu) = ∇ ⋅ (ν u ∇hu) - ν ∇u ⋅ ∇hu = ∇ ⋅ (ν u ∇hu) - ν h |∇u|^2 - ν u ∇u⋅ ∇h; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090226616
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835:161,Integrability,depend,depends,161,If we use `\nabla \cdot (\nu h \nabla u)` then the dissipation term is ` - \nu h | nabla u |^2`. This is accepted and has the nice property that the dissipation depends on the depth. If we use `\nabla \cdot (\nu \nabla u)` then we don't have the right units as we are evolving `h u`. . `\nabla \cdot (\nu \nabla (h u) )` does not give you a negative definite form as you would get ` - \nu \nabla u \nabla (hu)`.; P.S. How do you include latex here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474:233,Testability,test,test,233,"I see what you mean that `h ∇ ⋅ (ν ∇u)` also satisfies some nice properties. I haven't seen that before but why not? Seems like a viable option. Maybe add that to the list of possible viscosity for shallow water?. It would be fun to test what difference these terms have on a simple problem. Just need to think about the problem, and of course get the code working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474:276,Usability,simpl,simple,276,"I see what you mean that `h ∇ ⋅ (ν ∇u)` also satisfies some nice properties. I haven't seen that before but why not? Seems like a viable option. Maybe add that to the list of possible viscosity for shallow water?. It would be fun to test what difference these terms have on a simple problem. Just need to think about the problem, and of course get the code working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1096759204:28,Energy Efficiency,schedul,schedule,28,@glwagner : did you want to schedule a pair programming session sometime to start the proposed PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1096759204
https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696:18,Integrability,message,message,18,I do! I'll send a message on slack.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696
https://github.com/CliMA/Oceananigans.jl/issues/2407#issuecomment-1085082408:174,Deployability,Continuous,ContinuousBoundaryFunction,174,"We can also entertain helpers for ""linear"" and ""quadratic"" drag. But I think we should wait to see whether this is needed, or whether it's easy enough to write it out using `ContinuousBoundaryFunction` as illustrated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2407#issuecomment-1085082408
https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1090354580:66,Security,validat,validation,66,"Here's a visualization from the new ""bumpy baroclinic adjustment"" validation case:. https://user-images.githubusercontent.com/15271942/162013972-d020b628-3f7b-4ce8-ac56-84c77a96bd42.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1090354580
https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1108986503:13,Testability,benchmark,benchmarks,13,I re-ran the benchmarks and included the matrix solver with no preconditioner. Recording the results here for posterity:. ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬────────────┬────────────┬─────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurfaceNoPreconditioner │ 61.099 ms │ 70.657 ms │ 91.448 ms │ 161.977 ms │ 24.25 MiB │ 29768 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurfaceNoPreconditioner │ 17.595 ms │ 23.320 ms │ 22.090 ms │ 26.288 ms │ 4.26 MiB │ 43632 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 12.473 ms │ 14.323 ms │ 14.833 ms │ 19.016 ms │ 5.50 MiB │ 9866 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceNoPreconditioner │ 9.471 ms │ 9.647 ms │ 9.777 ms │ 10.601 ms │ 2.08 MiB │ 18243 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 29.854 ms │ 38.381 ms │ 43.885 ms │ 69.085 ms │ 5.34 MiB │ 8469 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 33.183 ms │ 42.544 ms │ 41.127 ms │ 46.910 ms │ 5.34 MiB │ 8491 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 4.380 ms │ 4.709 ms │ 4.824 ms │ 6.626 ms │ 1.89 MiB │ 10256 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceNoPreconditioner │ 29.694 ms │ 33.940 ms │ 35.731 ms │ 48.457 ms │ 5.34 MiB │ 8490 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 5.987 s │ 5.987 s │ 5.987 s │ 5.987 s │ 462.46 MiB │ 8636458 │ 1 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 6.611 ms │ 7.311 ms │ 7.608 ms │ 9.821 ms │ 1.84 MiB │ 12582 │ 10 │; └───────────────┴─────────────────┴──────────────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1108986503
https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1108986503:145,Testability,benchmark,benchmarks,145,I re-ran the benchmarks and included the matrix solver with no preconditioner. Recording the results here for posterity:. ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬────────────┬────────────┬─────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurfaceNoPreconditioner │ 61.099 ms │ 70.657 ms │ 91.448 ms │ 161.977 ms │ 24.25 MiB │ 29768 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurfaceNoPreconditioner │ 17.595 ms │ 23.320 ms │ 22.090 ms │ 26.288 ms │ 4.26 MiB │ 43632 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 12.473 ms │ 14.323 ms │ 14.833 ms │ 19.016 ms │ 5.50 MiB │ 9866 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceNoPreconditioner │ 9.471 ms │ 9.647 ms │ 9.777 ms │ 10.601 ms │ 2.08 MiB │ 18243 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 29.854 ms │ 38.381 ms │ 43.885 ms │ 69.085 ms │ 5.34 MiB │ 8469 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 33.183 ms │ 42.544 ms │ 41.127 ms │ 46.910 ms │ 5.34 MiB │ 8491 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 4.380 ms │ 4.709 ms │ 4.824 ms │ 6.626 ms │ 1.89 MiB │ 10256 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceNoPreconditioner │ 29.694 ms │ 33.940 ms │ 35.731 ms │ 48.457 ms │ 5.34 MiB │ 8490 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 5.987 s │ 5.987 s │ 5.987 s │ 5.987 s │ 462.46 MiB │ 8636458 │ 1 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 6.611 ms │ 7.311 ms │ 7.608 ms │ 9.821 ms │ 1.84 MiB │ 12582 │ 10 │; └───────────────┴─────────────────┴──────────────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1108986503
https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1108986503:2313,Testability,benchmark,benchmarking,2313,"───────────┼───────────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurfaceNoPreconditioner │ 61.099 ms │ 70.657 ms │ 91.448 ms │ 161.977 ms │ 24.25 MiB │ 29768 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurfaceNoPreconditioner │ 17.595 ms │ 23.320 ms │ 22.090 ms │ 26.288 ms │ 4.26 MiB │ 43632 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 12.473 ms │ 14.323 ms │ 14.833 ms │ 19.016 ms │ 5.50 MiB │ 9866 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceNoPreconditioner │ 9.471 ms │ 9.647 ms │ 9.777 ms │ 10.601 ms │ 2.08 MiB │ 18243 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 29.854 ms │ 38.381 ms │ 43.885 ms │ 69.085 ms │ 5.34 MiB │ 8469 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 33.183 ms │ 42.544 ms │ 41.127 ms │ 46.910 ms │ 5.34 MiB │ 8491 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 4.380 ms │ 4.709 ms │ 4.824 ms │ 6.626 ms │ 1.89 MiB │ 10256 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceNoPreconditioner │ 29.694 ms │ 33.940 ms │ 35.731 ms │ 48.457 ms │ 5.34 MiB │ 8490 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 5.987 s │ 5.987 s │ 5.987 s │ 5.987 s │ 462.46 MiB │ 8636458 │ 1 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 6.611 ms │ 7.311 ms │ 7.608 ms │ 9.821 ms │ 1.84 MiB │ 12582 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴────────────┴────────────┴─────────┴─────────┘; ```. The `PCGImplicitFreeSurfaceSolver` is about 2.5x slower than the `HeptadiagonalIterativeSolver` when there's no preconditioner. The difference is presumably halo filling, but more detailed benchmarking would be required to know for sure. This implies that a faster solver might be obtained with an FFT-based preconditioner, and a `linear_operation!` that didn't require halo filling. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1108986503
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:522,Availability,Error,Error,522,"not really. It is not a problem of domain but of `generate_coordinate` when using a strecthed grid. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; using CUDA. julia> using CUDA. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> CUDA.device!(1); CuContext(0x0000000004338ba0, instance 1c4f1697ea7bdab7). julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> grid; Error showing value of type RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, GPU}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] getindex; @ ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:89 [inlined]; [8] getindex; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:426 [inlined]; [9] (::Oceananigans.Grids.var""#7#8""{Int64, OffsetArrays.Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:995,Availability,ERROR,ERROR,995,"problem of domain but of `generate_coordinate` when using a strecthed grid. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; using CUDA. julia> using CUDA. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> CUDA.device!(1); CuContext(0x0000000004338ba0, instance 1c4f1697ea7bdab7). julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> grid; Error showing value of type RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, GPU}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] getindex; @ ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:89 [inlined]; [8] getindex; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:426 [inlined]; [9] (::Oceananigans.Grids.var""#7#8""{Int64, OffsetArrays.OffsetVector{Float64, CuArra",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:1007,Availability,error,error,1007,"problem of domain but of `generate_coordinate` when using a strecthed grid. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; using CUDA. julia> using CUDA. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> CUDA.device!(1); CuContext(0x0000000004338ba0, instance 1c4f1697ea7bdab7). julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> grid; Error showing value of type RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, GPU}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] getindex; @ ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:89 [inlined]; [8] getindex; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:426 [inlined]; [9] (::Oceananigans.Grids.var""#7#8""{Int64, OffsetArrays.OffsetVector{Float64, CuArra",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:1170,Availability,error,error,1170,"ceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; using CUDA. julia> using CUDA. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> CUDA.device!(1); CuContext(0x0000000004338ba0, instance 1c4f1697ea7bdab7). julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> grid; Error showing value of type RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, GPU}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] getindex; @ ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:89 [inlined]; [8] getindex; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:426 [inlined]; [9] (::Oceananigans.Grids.var""#7#8""{Int64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}})(); @ Oceananigans.Grids ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:75; [10] task_local_storage(body:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:1248,Availability,error,error,1248,"UDA. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> CUDA.device!(1); CuContext(0x0000000004338ba0, instance 1c4f1697ea7bdab7). julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), x = (0, 1), y = (0, 1), z=collect(0:2));. julia> grid; Error showing value of type RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}, GPU}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] getindex; @ ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:89 [inlined]; [8] getindex; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:426 [inlined]; [9] (::Oceananigans.Grids.var""#7#8""{Int64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1}}})(); @ Oceananigans.Grids ~/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:75; [10] task_local_storage(body::Oceananigans.Grids.var""#7#8""{Int64, OffsetArrays.OffsetVector{Float64, CuArra",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:5849,Availability,Error,Error,5849,"lor::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:275; [26] (::REPL.var""#do_respond#66""{Bool, Bool, REPL.var""#77#87""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:846; [27] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [28] invokelatest; @ ./essentials.jl:714 [inlined]; [29] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493; [30] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1232; [31] (::REPL.var""#49#54""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:423. julia> grid.Δzᵃᵃᶜ.parent; 4-element CuArray{Float64, 1}:; Error showing value of type CuArray{Float64, 1}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:5899,Availability,ERROR,ERROR,5899,"lor::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:275; [26] (::REPL.var""#do_respond#66""{Bool, Bool, REPL.var""#77#87""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:846; [27] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [28] invokelatest; @ ./essentials.jl:714 [inlined]; [29] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493; [30] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1232; [31] (::REPL.var""#49#54""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:423. julia> grid.Δzᵃᵃᶜ.parent; 4-element CuArray{Float64, 1}:; Error showing value of type CuArray{Float64, 1}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:5911,Availability,error,error,5911,"lor::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:275; [26] (::REPL.var""#do_respond#66""{Bool, Bool, REPL.var""#77#87""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:846; [27] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [28] invokelatest; @ ./essentials.jl:714 [inlined]; [29] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493; [30] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1232; [31] (::REPL.var""#49#54""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:423. julia> grid.Δzᵃᵃᶜ.parent; 4-element CuArray{Float64, 1}:; Error showing value of type CuArray{Float64, 1}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:6074,Availability,error,error,6074,"eEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:846; [27] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [28] invokelatest; @ ./essentials.jl:714 [inlined]; [29] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493; [30] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1232; [31] (::REPL.var""#49#54""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:423. julia> grid.Δzᵃᵃᶜ.parent; 4-element CuArray{Float64, 1}:; Error showing value of type CuArray{Float64, 1}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:6152,Availability,error,error,6152,")(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:846; [27] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [28] invokelatest; @ ./essentials.jl:714 [inlined]; [29] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493; [30] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1232; [31] (::REPL.var""#49#54""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:423. julia> grid.Δzᵃᵃᶜ.parent; 4-element CuArray{Float64, 1}:; Error showing value of type CuArray{Float64, 1}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] ada",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Energy Efficiency,Adapt,Adapt,7089,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7105,Energy Efficiency,Adapt,Adapt,7105,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7133,Energy Efficiency,adapt,adapt,7133,"/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essenti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7160,Energy Efficiency,Adapt,Adapt,7160,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7176,Energy Efficiency,Adapt,Adapt,7176,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Modifiability,Adapt,Adapt,7089,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7105,Modifiability,Adapt,Adapt,7105,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7133,Modifiability,adapt,adapt,7133,"/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essenti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7160,Modifiability,Adapt,Adapt,7160,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7176,Modifiability,Adapt,Adapt,7176,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:321,Availability,error,error,321,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:607,Availability,Error,Error,607,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:666,Availability,error,error,666,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:613,Integrability,message,message,613,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996:2,Availability,Error,Error,2,> Error message:. Huh. What's the type of `vz_op`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996:8,Integrability,message,message,8,> Error message:. Huh. What's the type of `vz_op`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996
https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478:422,Modifiability,extend,extending,422,"I think it's a clue that . ```julia; vz_op = @at((Face, Center, Center), ∂x(b) / f); ```. is valid. My guess now is that if. ```julia; vz_op = @at (Face, Center, Center) - ∂x(b) / f; ```. is interpreted as. ```julia; loc = (Face, Center, Center); op = ∂x(b) / f; invalid_subtraction = -(loc, op) # not only does this not work, it's also just one `Expr`; vz_op = @at invalid_subtraction; ```. We can try to bandaid this by extending `@at` but I guess it's really just invalid syntax. `@at((Face, Center, Center), ∂x(b) / f)` is the right way to express this --- nice find @iuryt !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1089701673:188,Security,validat,validate,188,"I agree with these!. I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`. For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1089701673
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090353935:203,Security,validat,validate,203,"> I agree with these!; > ; > I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`.; > ; > For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting. Ah, yes, I forgot about that... So `JLD2` requires that the splitting is done with the `.jld2` extension, correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090353935
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090376967:201,Security,validat,validate,201,"> > I agree with these!; > > I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`.; > > For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting.; > ; > Ah, yes, I forgot about that...; > ; > So `JLD2` requires that the splitting is done with the `.jld2` extension, correct?. No, we don't have to require that. But we do need to know what the extension is in order to produce new filenames. We can either ""infer"" the extension, or assume that it's `.jld2`. Do we want to allow other extensions? What's the benefit of that? It might be nice to enforce uniformity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090376967
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1095129322:1236,Availability,checkpoint,checkpointer,1236,"ally all those top-level definitions are there because an object needs to be used before the code where it might otherwise reside is imported. For example `grep` reveals. ```; gregorywagner:src/ (main) $ grep -r AbstractOutputWriter ./* [8:30:01]; ./Models/NonhydrostaticModels/nonhydrostatic_model.jl:using Oceananigans: AbstractModel, AbstractOutputWriter, AbstractDiagnostic; ./Models/ShallowWaterModels/shallow_water_model.jl:using Oceananigans: AbstractModel, AbstractOutputWriter, AbstractDiagnostic; ./Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:using Oceananigans: AbstractModel, AbstractOutputWriter, AbstractDiagnostic; ./Oceananigans.jl: AbstractOutputWriter; ./Oceananigans.jl:abstract type AbstractOutputWriter end; ./OutputWriters/output_writer_utils.jl:ext(fw::AbstractOutputWriter) = throw(""Extension for $(typeof(fw)) is not implemented.""); ./OutputWriters/output_writer_utils.jl:function output_averaging_schedule(ow::AbstractOutputWriter); ./OutputWriters/checkpointer.jl:mutable struct Checkpointer{T, P} <: AbstractOutputWriter; ./OutputWriters/OutputWriters.jl:using Oceananigans: AbstractOutputWriter; ./OutputWriters/OutputWriters.jl:Base.open(ow::AbstractOutputWriter) = nothing; ./OutputWriters/OutputWriters.jl:Base.close(ow::AbstractOutputWriter) = nothing; ./OutputWriters/jld2_output_writer.jl: JLD2OutputWriter{I, T, O, IF, IN, KW} <: AbstractOutputWriter; ./OutputWriters/jld2_output_writer.jl:mutable struct JLD2OutputWriter{O, T, D, IF, IN, KW} <: AbstractOutputWriter; ./OutputWriters/netcdf_output_writer.jl: NetCDFOutputWriter{D, O, I, T, A} <: AbstractOutputWriter; ./OutputWriters/netcdf_output_writer.jl:mutable struct NetCDFOutputWriter{D, O, T, A} <: AbstractOutputWriter; ./Simulations/Simulations.jl:using Oceananigans: AbstractDiagnostic, AbstractOutputWriter, fields; ./Simulations/simulation.jl: output_writers = OrderedDict{Symbol, AbstractOutputWriter}(); ./Utils/output_writer_diagnostic_utils.jl:using Oceananigans: Abstrac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1095129322
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1095129322:1267,Availability,Checkpoint,Checkpointer,1267,"e because an object needs to be used before the code where it might otherwise reside is imported. For example `grep` reveals. ```; gregorywagner:src/ (main) $ grep -r AbstractOutputWriter ./* [8:30:01]; ./Models/NonhydrostaticModels/nonhydrostatic_model.jl:using Oceananigans: AbstractModel, AbstractOutputWriter, AbstractDiagnostic; ./Models/ShallowWaterModels/shallow_water_model.jl:using Oceananigans: AbstractModel, AbstractOutputWriter, AbstractDiagnostic; ./Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:using Oceananigans: AbstractModel, AbstractOutputWriter, AbstractDiagnostic; ./Oceananigans.jl: AbstractOutputWriter; ./Oceananigans.jl:abstract type AbstractOutputWriter end; ./OutputWriters/output_writer_utils.jl:ext(fw::AbstractOutputWriter) = throw(""Extension for $(typeof(fw)) is not implemented.""); ./OutputWriters/output_writer_utils.jl:function output_averaging_schedule(ow::AbstractOutputWriter); ./OutputWriters/checkpointer.jl:mutable struct Checkpointer{T, P} <: AbstractOutputWriter; ./OutputWriters/OutputWriters.jl:using Oceananigans: AbstractOutputWriter; ./OutputWriters/OutputWriters.jl:Base.open(ow::AbstractOutputWriter) = nothing; ./OutputWriters/OutputWriters.jl:Base.close(ow::AbstractOutputWriter) = nothing; ./OutputWriters/jld2_output_writer.jl: JLD2OutputWriter{I, T, O, IF, IN, KW} <: AbstractOutputWriter; ./OutputWriters/jld2_output_writer.jl:mutable struct JLD2OutputWriter{O, T, D, IF, IN, KW} <: AbstractOutputWriter; ./OutputWriters/netcdf_output_writer.jl: NetCDFOutputWriter{D, O, I, T, A} <: AbstractOutputWriter; ./OutputWriters/netcdf_output_writer.jl:mutable struct NetCDFOutputWriter{D, O, T, A} <: AbstractOutputWriter; ./Simulations/Simulations.jl:using Oceananigans: AbstractDiagnostic, AbstractOutputWriter, fields; ./Simulations/simulation.jl: output_writers = OrderedDict{Symbol, AbstractOutputWriter}(); ./Utils/output_writer_diagnostic_utils.jl:using Oceananigans: AbstractOutputWriter, AbstractDiagnostic; ./Utils/out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1095129322
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1095717685:7,Testability,test,tests,7,"If the tests pass, I think this is ready to merge. Took the liberty to bump minor version since this is a breaking API change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1095717685
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096:545,Deployability,update,updated,545,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096:326,Integrability,interface,interface,326,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096:421,Integrability,interface,interface,421,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096:144,Usability,clear,clear,144,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:184,Availability,down,downgrades,184,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:38,Deployability,update,updated,38,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:376,Deployability,update,update,376,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:3,Testability,benchmark,benchmarks,3,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:80,Testability,benchmark,benchmarking,80,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:155,Testability,benchmark,benchmarks,155,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:286,Testability,benchmark,benchmarks,286,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:332,Testability,benchmark,benchmarks,332,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090357885:72,Testability,benchmark,benchmarks,72,Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090357885
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090357885:108,Testability,benchmark,benchmark,108,Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090357885
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:190,Integrability,depend,dependencies,190,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:74,Testability,benchmark,benchmarks,74,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:110,Testability,benchmark,benchmark,110,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:153,Testability,benchmark,benchmarking,153,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:248,Testability,Benchmark,BenchmarkTools,248,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:186,Availability,down,downgrades,186,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:40,Deployability,update,updated,40,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:376,Deployability,update,update,376,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:5,Testability,benchmark,benchmarks,5,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:82,Testability,benchmark,benchmarking,82,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:157,Testability,benchmark,benchmarks,157,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:286,Testability,benchmark,benchmarks,286,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:332,Testability,benchmark,benchmarks,332,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049:478,Integrability,depend,dependency,478,"> > It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.; > ; > Yeah, my question was in the sense of ""is there Julia functionality to do that"". If it requires us to write a script to manipulate the text, then I agree that it'd be too much of a headache for something rather hacky... I guess what `Pkg` provides is: if we add `Oceananigans` as a dependency, compat for `Oceananigans` is imposed on `benchmarks/Project.toml`. But this complicates the purpose of the benchmarks, which is to execute the local code. Maybe we can add lines at the top of the benchmark script like. ```julia; using Pkg; Pkg.dev(""..""); ```. Then we add the local version of Oceananigans to the `Project.toml` before the script is executed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049:531,Testability,benchmark,benchmarks,531,"> > It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.; > ; > Yeah, my question was in the sense of ""is there Julia functionality to do that"". If it requires us to write a script to manipulate the text, then I agree that it'd be too much of a headache for something rather hacky... I guess what `Pkg` provides is: if we add `Oceananigans` as a dependency, compat for `Oceananigans` is imposed on `benchmarks/Project.toml`. But this complicates the purpose of the benchmarks, which is to execute the local code. Maybe we can add lines at the top of the benchmark script like. ```julia; using Pkg; Pkg.dev(""..""); ```. Then we add the local version of Oceananigans to the `Project.toml` before the script is executed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049:597,Testability,benchmark,benchmarks,597,"> > It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.; > ; > Yeah, my question was in the sense of ""is there Julia functionality to do that"". If it requires us to write a script to manipulate the text, then I agree that it'd be too much of a headache for something rather hacky... I guess what `Pkg` provides is: if we add `Oceananigans` as a dependency, compat for `Oceananigans` is imposed on `benchmarks/Project.toml`. But this complicates the purpose of the benchmarks, which is to execute the local code. Maybe we can add lines at the top of the benchmark script like. ```julia; using Pkg; Pkg.dev(""..""); ```. Then we add the local version of Oceananigans to the `Project.toml` before the script is executed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049
https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049:686,Testability,benchmark,benchmark,686,"> > It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.; > ; > Yeah, my question was in the sense of ""is there Julia functionality to do that"". If it requires us to write a script to manipulate the text, then I agree that it'd be too much of a headache for something rather hacky... I guess what `Pkg` provides is: if we add `Oceananigans` as a dependency, compat for `Oceananigans` is imposed on `benchmarks/Project.toml`. But this complicates the purpose of the benchmarks, which is to execute the local code. Maybe we can add lines at the top of the benchmark script like. ```julia; using Pkg; Pkg.dev(""..""); ```. Then we add the local version of Oceananigans to the `Project.toml` before the script is executed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049
https://github.com/CliMA/Oceananigans.jl/issues/2422#issuecomment-1480576168:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422#issuecomment-1480576168
https://github.com/CliMA/Oceananigans.jl/pull/2423#issuecomment-1104626250:571,Availability,error,error,571,"The exponential case looks better if we remove the ""strong wind"" case from the calibration suite:. <img width=""667"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164355857-14fab827-e370-4399-88a2-7754b27efd0c.png"">. those parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 528; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 7.206e+00 | 2.666e-01 | -2.167e+00 | -1.098e-01 | 5.126e-01 | 5.285e-01 |; best particle: 7.059e+00 | 2.598e-01 | -2.157e+00 | -7.290e-02 | 5.130e-01 | 5.206e-01 | error = 3.269783e-01; worst particle: 7.239e+00 | 3.009e-01 | -2.195e+00 | -1.781e-01 | 5.187e-01 | 5.325e-01 | error = 3.280996e-01; minimum: 3.674e+00 | 1.869e-01 | -2.485e+00 | -1.984e-01 | 4.577e-01 | 4.543e-01 |; maximum: 8.483e+00 | 3.067e-01 | -1.784e+00 | 2.202e-01 | 5.799e-01 | 5.876e-01 |; ensemble_variance: 3.643e-02 | 1.827e-04 | 5.238e-04 | 9.216e-04 | 3.471e-08 | 4.297e-08 |; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423#issuecomment-1104626250
https://github.com/CliMA/Oceananigans.jl/pull/2423#issuecomment-1104626250:683,Availability,error,error,683,"The exponential case looks better if we remove the ""strong wind"" case from the calibration suite:. <img width=""667"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164355857-14fab827-e370-4399-88a2-7754b27efd0c.png"">. those parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 528; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 7.206e+00 | 2.666e-01 | -2.167e+00 | -1.098e-01 | 5.126e-01 | 5.285e-01 |; best particle: 7.059e+00 | 2.598e-01 | -2.157e+00 | -7.290e-02 | 5.130e-01 | 5.206e-01 | error = 3.269783e-01; worst particle: 7.239e+00 | 3.009e-01 | -2.195e+00 | -1.781e-01 | 5.187e-01 | 5.325e-01 | error = 3.280996e-01; minimum: 3.674e+00 | 1.869e-01 | -2.485e+00 | -1.984e-01 | 4.577e-01 | 4.543e-01 |; maximum: 8.483e+00 | 3.067e-01 | -1.784e+00 | 2.202e-01 | 5.799e-01 | 5.876e-01 |; ensemble_variance: 3.643e-02 | 1.827e-04 | 5.238e-04 | 9.216e-04 | 3.471e-08 | 4.297e-08 |; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423#issuecomment-1104626250
https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367:20,Modifiability,refactor,refactored,20,"@simone-silvestri I refactored the tuple halo filling (partly to shorten the code but also to filter more stuff from the tuples, and to avoid filling halos for the same fields twice --- sometimes a field can appear twice in a named tuple...) But it looks like my changes broke some stuff, so I might need some help fixing that up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367
https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367:136,Safety,avoid,avoid,136,"@simone-silvestri I refactored the tuple halo filling (partly to shorten the code but also to filter more stuff from the tuples, and to avoid filling halos for the same fields twice --- sometimes a field can appear twice in a named tuple...) But it looks like my changes broke some stuff, so I might need some help fixing that up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367
https://github.com/CliMA/Oceananigans.jl/issues/2427#issuecomment-1095152362:62,Availability,error,error,62,> These should be `jldoctest`'d. They are. But apparently the error made it into the source files: https://github.com/CliMA/Oceananigans.jl/blob/b945655a8363f60d03077253edcd77a56936c5cc/docs/src/model_setup/output_writers.md?plain=1#L89-L101. Apparently these slipped through the cracks here: https://github.com/CliMA/Oceananigans.jl/pull/2246/files#diff-9192b98dd6db72149d0d09e5af4820a650091d3509aeb1c2327c27c3e5d8d1b4 . I'll fix these in https://github.com/CliMA/Oceananigans.jl/pull/2416,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427#issuecomment-1095152362
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095677803:12,Availability,error,error,12,What is the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095677803
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:290,Availability,ERROR,ERROR,290,"Sorry, forgot to paste it:. ```julia; julia> model = HydrostaticFreeSurfaceModel(; grid, coriolis, closure = closure, boundary_conditions,; momentum_advection = momentum_advection,; tracer_advection = tracer_advection,; tracers = tracers, buoyancy = buoyancy, free_surface = free_surface); ERROR: TaskFailedException; Stacktrace:; [1] wait; @ ./task.jl:334 [inlined]; [2] wait; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/cpu.jl:65 [inlined]; [3] wait(::KernelAbstractions.CPU, ev::KernelAbstractions.CPUEvent); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/3ZHln/src/cpu.jl:64; [4] fill_halo_regions!(::NTuple{4, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, ::Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:77682,Availability,error,error,77682,"dBoundaryCondition, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}, tracers::Tuple{Symbol, Symbol}, particles::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/9ZFqp/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:198; [13] top-level scope; @ REPL[55]:1. nested task error: MethodError: no method matching /(::Nothing, ::Int64); Closest candidates are:; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Number, ::Oceananigans.AbstractOperations.BinaryOperation) at ~/.julia/packages/Oceananigans/9ZFqp/src/AbstractOperations/binary_operations.jl:85; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Oceananigans.AbstractOperations.BinaryOperation, ::Number) at ~/.julia/packages/Oceananigans/9ZFqp/src/AbstractOperations/binary_operations.jl:80; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Oceananigans.AbstractOperations.BinaryOperation, ::Oceananigans.AbstractOperations.BinaryOperation) at ~/.julia/packages/Oceananigans/9ZFqp/src/AbstractOperations/binary_operations.jl:64; ...; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any}); @ ~/.julia/packages/Cassette/34vIw/src/overdub.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:1137,Deployability,Continuous,ContinuousBoundaryFunction,1137,"dvection,; tracers = tracers, buoyancy = buoyancy, free_surface = free_surface); ERROR: TaskFailedException; Stacktrace:; [1] wait; @ ./task.jl:334 [inlined]; [2] wait; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/cpu.jl:65 [inlined]; [3] wait(::KernelAbstractions.CPU, ev::KernelAbstractions.CPUEvent); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/3ZHln/src/cpu.jl:64; [4] fill_halo_regions!(::NTuple{4, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, ::Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:4129,Deployability,Continuous,ContinuousBoundaryFunction,4129,"n{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, ::Clock{Float64}, ::Vararg{Any}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.BoundaryConditions ~/.julia/packages/Oceananigans/9ZFqp/src/BoundaryConditions/fill_halo_regions.jl:68; [5] fill_halo_regions!(::NTuple{4, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, ::Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:7583,Deployability,Continuous,ContinuousBoundaryFunction,7583,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:13885,Deployability,Continuous,ContinuousBoundaryFunction,13885,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:19746,Deployability,Continuous,ContinuousBoundaryFunction,19746,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:25557,Deployability,Continuous,ContinuousBoundaryFunction,25557,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:45738,Deployability,Continuous,ContinuousBoundaryFunction,45738,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:67736,Deployability,Continuous,ContinuousBoundaryFunction,67736,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:76123,Deployability,Continuous,ContinuousBoundaryFunction,76123,"at64}, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Tuple{VerticalScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64}, HorizontalScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64}}, boundary_conditions::NamedTuple{(:u, :v, :T), Tuple{FieldBoundaryConditions{Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Nothing, Nothing, Nothing, typeof(wind_stress), Nothing, Tuple{}, Nothing, Nothing}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Int64}, BoundaryCondition{Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:80784,Deployability,Continuous,ContinuousBoundaryFunction,80784,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:89327,Deployability,Continuous,ContinuousBoundaryFunction,89327,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:97310,Deployability,Continuous,ContinuousBoundaryFunction,97310,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195:105376,Deployability,Continuous,ContinuousBoundaryFunction,105376,"Precision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 18, typeof(wind_stress), Nothing, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1095685195
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727:165,Deployability,Update,Update,165,@apaloczy just wanted to thank you for raising this issue!. I'm going to take this strategy to fix it:. 1. First merge #2426 (this changes `fill_halo_regions!`); 2. Update the halo filling interface so that field _location_ is passed into the boundary kernels. We can then use field location to infer the correct metrics. It might make sense to include 2. as part of #2437 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727
https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727:189,Integrability,interface,interface,189,@apaloczy just wanted to thank you for raising this issue!. I'm going to take this strategy to fix it:. 1. First merge #2426 (this changes `fill_halo_regions!`); 2. Update the halo filling interface so that field _location_ is passed into the boundary kernels. We can then use field location to infer the correct metrics. It might make sense to include 2. as part of #2437 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2705,Availability,recover,recover,2705,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1563,Energy Efficiency,energy,energy,1563,"es A b,c. ; 2. **Naming convention**: The prognostic MEKE equation is used to inform the GM coefficient via `kappa_GM = c * sqrt(2 MEKE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2054,Energy Efficiency,energy,energy,2054,"these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows wh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2859,Energy Efficiency,energy,energy,2859,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2892,Energy Efficiency,energy,energy,2892,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1730,Modifiability,variab,variable,1730,"KE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2466,Modifiability,parameteriz,parameterizations,2466,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2705,Safety,recover,recover,2705,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692
https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098371688:273,Availability,error,error,273,"Thanks @tomchor for doing this. I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098371688
https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:485,Availability,error,error,485,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148
https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:342,Integrability,depend,dependence,342,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148
https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:378,Modifiability,portab,portable,378,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148
https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:255,Testability,test,testing,255,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148
https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:330,Testability,Benchmark,Benchmarks,330,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148
https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1097332460:121,Testability,benchmark,benchmarks,121,A couple of notes:. - I've been able to run it with only one core (`Rx=Ry=Rz=1`); - I've been running it outside of the `benchmarks` directory since Julia complains about packages when I try to run it there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1097332460
https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1098396008:280,Testability,benchmark,benchmark,280,A comment is that I found out recently that if I run this script locally on my laptop (with exactly the same command) it works! But running the same code with the same command (at least as far as different `mpiexecjl` are the same) it fails... Has anyone had success running this benchmark? @johnryantaylor I think you were the last person to try it. Did it run successfully with you?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1098396008
https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1098672596:502,Deployability,install,installations,502,> A comment is that I found out recently that if I run this script locally on my laptop (with exactly the same command) it works! But running the same code with the same command (at least as far as different `mpiexecjl` are the same) it fails...; > ; > Has anyone had success running this benchmark? @johnryantaylor I think you were the last person to try it. Did it run successfully with you?. I don't totally grasp what you mean. Are you referring to different outcomes on systems with different MPI installations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1098672596
https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1098672596:289,Testability,benchmark,benchmark,289,> A comment is that I found out recently that if I run this script locally on my laptop (with exactly the same command) it works! But running the same code with the same command (at least as far as different `mpiexecjl` are the same) it fails...; > ; > Has anyone had success running this benchmark? @johnryantaylor I think you were the last person to try it. Did it run successfully with you?. I don't totally grasp what you mean. Are you referring to different outcomes on systems with different MPI installations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1098672596
https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1100217674:508,Deployability,install,installations,508,"> > A comment is that I found out recently that if I run this script locally on my laptop (with exactly the same command) it works! But running the same code with the same command (at least as far as different `mpiexecjl` are the same) it fails...; > > Has anyone had success running this benchmark? @johnryantaylor I think you were the last person to try it. Did it run successfully with you?; > ; > I don't totally grasp what you mean. Are you referring to different outcomes on systems with different MPI installations?. Yes. That's exactly what it was. I was just able to trace this inconsistency back to an issue with MPI, so I'm closing this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1100217674
https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1100217674:289,Testability,benchmark,benchmark,289,"> > A comment is that I found out recently that if I run this script locally on my laptop (with exactly the same command) it works! But running the same code with the same command (at least as far as different `mpiexecjl` are the same) it fails...; > > Has anyone had success running this benchmark? @johnryantaylor I think you were the last person to try it. Did it run successfully with you?; > ; > I don't totally grasp what you mean. Are you referring to different outcomes on systems with different MPI installations?. Yes. That's exactly what it was. I was just able to trace this inconsistency back to an issue with MPI, so I'm closing this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433#issuecomment-1100217674
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695:386,Usability,clear,clear,386,"I think I still prefer to not append the extension and leave things the way they are mainly for three reasons:. - If you don't include the extension, then (using [usual jargon](https://www.computerhope.com/jargon/f/filename.htm)) it's not a complete file name anymore since it doesn't uniquely identify the file. To be correct I think we'd need to go back to `prefix` which isn't super clear imo; - It leads to less clear code if you're postprocessing the output in the name script. Like this pseudo code:. ```julia; simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename). run!(simulation); real_filename = filename * "".jld2""; jldopen(real_filename); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695:416,Usability,clear,clear,416,"I think I still prefer to not append the extension and leave things the way they are mainly for three reasons:. - If you don't include the extension, then (using [usual jargon](https://www.computerhope.com/jargon/f/filename.htm)) it's not a complete file name anymore since it doesn't uniquely identify the file. To be correct I think we'd need to go back to `prefix` which isn't super clear imo; - It leads to less clear code if you're postprocessing the output in the name script. Like this pseudo code:. ```julia; simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename). run!(simulation); real_filename = filename * "".jld2""; jldopen(real_filename); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438:248,Modifiability,variab,variables,248,"Also what we'd call `filename` would be different than what is called file name in the docs for [`JLD2`](https://docs.juliahub.com/JLD2/O1EyT/0.4.22/internals/#JLD2.jldopen) and [`NCDatasets`](https://alexander-barth.github.io/NCDatasets.jl/stable/variables/#NCDatasets.NCDataset-Tuple{NCDatasets.CFVariable}), which might be a source of confusion in new users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098294955:249,Usability,feedback,feedback,249,"> * Like this pseudo code:; > ; > ```julia; > simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename); > ; > run!(simulation); > real_filename = filename * "".jld2""; > jldopen(real_filename); > ```. I appreciate this feedback but can you clarify why this code is ""unclear""?. I think there _is_ a detriment to convenience --- which we have been accepting (without any loss of productivity, if we can be real...) since time eternal with the `prefix` kwarg, before #2416). I do think it'd be nice to solve this with `FieldTimeSeries` so we can write. ```julia; simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename); run!(simulation); u = FieldTimeSeries(filename, ""u""); ```. This is easy... Balanced against the convenience detriment, I think the _cost_ of allowing arbitrary extensions is relatively higher (sharing data, figuring out the format of other people's data...). We also may have many more output writers in the future (Zarr, BSON, whatever), and I think it's friendly to relieve users from the burden of changing the filename.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098294955
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098303653:169,Testability,test,tests,169,The other possibility which achieves the same goal (and which I'm fine with) is to enforce `.nc` in `filename` for `NetCDFOutputWriter`. We'd have to change a lot fewer tests for that too...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098303653
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190:228,Availability,echo,echo,228,"Also to elaborate a bit: file extensions are _always_ arbitrary. The extension is just for people reading the contents of a directory, so they know what kind of data is contained in a file. For example this is fine:. ```bash; $ echo 'println(""Hello world!"")' >> test.txt ; $ julia --project test.txt [11:28:26]; Hello world!; ```. It's just poor communication to put your julia code in files appended with `.txt`. And your text editor won't highlight it correctly 😱 . So I think we really should somehow enforce extensions to help users communicate and love each other.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190:262,Testability,test,test,262,"Also to elaborate a bit: file extensions are _always_ arbitrary. The extension is just for people reading the contents of a directory, so they know what kind of data is contained in a file. For example this is fine:. ```bash; $ echo 'println(""Hello world!"")' >> test.txt ; $ julia --project test.txt [11:28:26]; Hello world!; ```. It's just poor communication to put your julia code in files appended with `.txt`. And your text editor won't highlight it correctly 😱 . So I think we really should somehow enforce extensions to help users communicate and love each other.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190:291,Testability,test,test,291,"Also to elaborate a bit: file extensions are _always_ arbitrary. The extension is just for people reading the contents of a directory, so they know what kind of data is contained in a file. For example this is fine:. ```bash; $ echo 'println(""Hello world!"")' >> test.txt ; $ julia --project test.txt [11:28:26]; Hello world!; ```. It's just poor communication to put your julia code in files appended with `.txt`. And your text editor won't highlight it correctly 😱 . So I think we really should somehow enforce extensions to help users communicate and love each other.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098376380:273,Usability,feedback,feedback,273,"> > * Like this pseudo code:; > > ; > > ```julia; > > simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename); > > ; > > run!(simulation); > > real_filename = filename * "".jld2""; > > jldopen(real_filename); > > ```; > ; > I appreciate this feedback but can you clarify why this code is ""unclear""?; ; Maybe unclear isn't the right word to use here, but I'm just pointing out that you'd end up with two things that a human would call a file name: `filename` (without extension) and `real_filename` (with extension).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098376380
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098378735:171,Testability,test,tests,171,"> The other possibility which achieves the same goal (and which I'm fine with) is to enforce `.nc` in `filename` for `NetCDFOutputWriter`. We'd have to change a lot fewer tests for that too... I personally would prefer that option instead of having the extension be automatically appended. Mostly because the name you pass to the writer (`something.jld2` or whatever it is) uniquely identifies the file that gets generated on your computer. Btw, it would probably be good to hear from other people here too since there isn't a best way to do things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098378735
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:118,Integrability,interface,interface,118,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:364,Integrability,interface,interface,364,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:454,Usability,clear,clearer,454,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:630,Availability,error,error,630,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:677,Availability,down,downside,677,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:783,Availability,down,downside,783,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:1053,Integrability,interface,interface,1053,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:566,Testability,log,logic,566,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345
https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1100276374:236,Testability,test,test,236,> > @tomchor do you approve? Are there any further changes you'd like to see ?; > ; > I was waiting for the checks to pass to review. Let me review it right now. Got it. PR is complete so only minor debugging left (if anything -- every test passed except the one that used a `.jld2` filename),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1100276374
https://github.com/CliMA/Oceananigans.jl/pull/2436#issuecomment-1099245871:7,Testability,test,test,7,I will test it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2436#issuecomment-1099245871
https://github.com/CliMA/Oceananigans.jl/pull/2436#issuecomment-1099254179:773,Testability,test,tested,773,"It seems its working now!; The code below:; ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), +∂x(b) / f); vz .= vz_op; ```; Returns:; ```julia; 1×1×1 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0; ```. I also tested on GPU:. ```julia; grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), +∂x(b) / f); vz .= vz_op; ```. returns:. ```julia; 1×1×1 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2436#issuecomment-1099254179
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153:219,Modifiability,sandbox,sandbox,219,"Everything useful that I have is probably in the draft PR #2275 and the associated branch! They aren't forcing functions, but we hard coded in some drag functions for the flux in the IB case that could be used, and the sandbox has the boundary condition versions of those same functions as a test. It wouldn't take much to turn them into divergences!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153:219,Testability,sandbox,sandbox,219,"Everything useful that I have is probably in the draft PR #2275 and the associated branch! They aren't forcing functions, but we hard coded in some drag functions for the flux in the IB case that could be used, and the sandbox has the boundary condition versions of those same functions as a test. It wouldn't take much to turn them into divergences!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153:292,Testability,test,test,292,"Everything useful that I have is probably in the draft PR #2275 and the associated branch! They aren't forcing functions, but we hard coded in some drag functions for the flux in the IB case that could be used, and the sandbox has the boundary condition versions of those same functions as a test. It wouldn't take much to turn them into divergences!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099599330:108,Testability,log,logic,108,"> #2275. Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099599330
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496:240,Integrability,interface,interface,240,"> Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?. Not exactly, but if you're determining a grid fitted normal direction then these boolean functions determine if the location is an interface with fluid on the left and solid on the right or vice versa for all the options. They are only true on a boundary face, not if its a solid-solid or fluid-fluid wall. https://github.com/CliMA/Oceananigans.jl/blob/8b988b34abcfbfd2e0453aedec5916c22b8c35c7/src/ImmersedBoundaries/conditional_fluxes.jl#L48. I don't think it would be hard to use these to set a directional sign for the normal direction, depending on which way you're doing that. If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496:649,Integrability,depend,depending,649,"> Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?. Not exactly, but if you're determining a grid fitted normal direction then these boolean functions determine if the location is an interface with fluid on the left and solid on the right or vice versa for all the options. They are only true on a boundary face, not if its a solid-solid or fluid-fluid wall. https://github.com/CliMA/Oceananigans.jl/blob/8b988b34abcfbfd2e0453aedec5916c22b8c35c7/src/ImmersedBoundaries/conditional_fluxes.jl#L48. I don't think it would be hard to use these to set a directional sign for the normal direction, depending on which way you're doing that. If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496:101,Testability,log,logic,101,"> Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?. Not exactly, but if you're determining a grid fitted normal direction then these boolean functions determine if the location is an interface with fluid on the left and solid on the right or vice versa for all the options. They are only true on a boundary face, not if its a solid-solid or fluid-fluid wall. https://github.com/CliMA/Oceananigans.jl/blob/8b988b34abcfbfd2e0453aedec5916c22b8c35c7/src/ImmersedBoundaries/conditional_fluxes.jl#L48. I don't think it would be hard to use these to set a directional sign for the normal direction, depending on which way you're doing that. If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100160430:314,Deployability,continuous,continuous,314,"Thanks! . > If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent. I believe with the methods we are using, we only ever need the normal direction of the ""numerical"" or discrete IB. Actually I think we should call _that_ the ""true"" IB; if there's a continuous function from which the discrete specification is derived, maybe we can call that the ""IB generator""? Right now this ""normal"" direction is always aligned with a cardinal direction of the grid (east, west, etc...). In the future we _could_ entertain shaved cells, which would introduced IB faces with non-trivial normals (but still discrete, and calculable from the discrete representation assuming, for example, that the faces of the shaved cells are flat planes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100160430
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100160950:126,Testability,log,logic,126,"But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100160950
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:319,Integrability,interface,interface,319,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:387,Integrability,interface,interface,387,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:428,Integrability,Depend,Depending,428,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:128,Testability,log,logic,128,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:748,Deployability,continuous,continuous,748,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:841,Deployability,Continuous,ContinuousBoundaryFunction,841,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:328,Integrability,interface,interface,328,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:396,Integrability,interface,interface,396,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:437,Integrability,Depend,Depending,437,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:130,Testability,log,logic,130,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1440,Deployability,Continuous,ContinuousBoundaryFunction,1440," practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1626,Deployability,Continuous,ContinuousBoundaryFunction,1626," we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd l",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:725,Integrability,interface,interface,725,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1817,Modifiability,extend,extended,1817,"-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:2553,Modifiability,refactor,refactor,2553,"propriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie _on_ the boundary. A better name is welcome...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:532,Performance,perform,performance,532,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:544,Performance,optimiz,optimization,544,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1069,Usability,simpl,simple,1069,"ced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1145,Integrability,interface,interfaces,1145,"mage"" src=""https://user-images.githubusercontent.com/15271942/163682350-9c0e83e4-48c2-488d-8a2a-67c1c896faf8.png"">. Since I had to dig deep into the immersed boundary implementation, I made a few more long-needed changes:. * Finally, we directly serialize `ImmersedBoundaryGrid`; * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid""; * I cleaned up the output writers utilities a bit as well.; * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:2023,Integrability,interface,interface,2023,"whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to the above, when we support ""open"" boundaries, I think we may actually want an ""Open"" topology that functions similar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1852,Modifiability,extend,extend,1852,"center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1813,Testability,log,logic,1813," few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centrali",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:2568,Usability,simpl,simple,2568," locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to the above, when we support ""open"" boundaries, I think we may actually want an ""Open"" topology that functions similarly to the topologies we use for distributed models work (perhaps, in fact, we can reuse those abstractions). I think the design assumed (though it was never implemented) that we could use ""open boundary condition"" for open boundaries, rather than changing the topology. But with complex domains, it's helpful to _assume_ certain boundary conditions based on _grid topology_ (rather than boundary conditions applied to fields). ImmersedBoundaries are hard-coded",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100709220:309,Deployability,Continuous,ContinuousBoundaryFunction,309,"It's a joyous day... https://user-images.githubusercontent.com/15271942/163684303-d05b97d6-69d6-447a-b214-0f618a780dfb.mp4. This puts a regular value boundary condition at the top, and an immersed value condition at the bottom (opposite signs). Looks good to me. Next is to figure out the shenanigans to get `ContinuousBoundaryFunction` to work. Though we coudl merge this now / soon without that, since we can support no-slip with this and it also allows value boundary condition (on non-immersed boundaries) with immersed boundary grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100709220
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:775,Integrability,interface,interfaces,775,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2128,Integrability,interface,interface,2128," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:1950,Modifiability,extend,extend,1950," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2247,Performance,perform,performance,2247," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:1911,Testability,log,logic,1911," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2326,Testability,test,testing,2326," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:283,Usability,clear,clearer,283,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563:982,Integrability,interface,interfaces,982,"Apologies for confusing the nomenclature, I should have said `exterior_cell` (I named it this to contrast with the function `interior`). Though ""exterior"" and ""interior"" strictly aren't mutually exclusive, they are loosely connected... > So external_cell is just a special case external_node, correct?. Correct, `exterior_cell` is identical to `exterior_node` evaluated at tracer cell centers. > It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. No, there is no assumption. The notion of `exterior_cell` is independent of the immersed boundary implementation. There are `exterior_cell`s for any grid `Bounded` in one or more direction. The implementation for underlying grids is here:. https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/src/Grids/exterior_node.jl. Differences between ""full cell"" immersed boundary methods and other types of methods manifest in the way grid metrics are modified (spacing, areas, and vectors normal to cell interfaces). All immersed boundary methods will both define `external_cell` and any boundary-specific modifications to metrics. We'll also need an interface for specifying the face normal vector, since those normals won't lie along the cardinal directions anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563:1129,Integrability,interface,interface,1129,"Apologies for confusing the nomenclature, I should have said `exterior_cell` (I named it this to contrast with the function `interior`). Though ""exterior"" and ""interior"" strictly aren't mutually exclusive, they are loosely connected... > So external_cell is just a special case external_node, correct?. Correct, `exterior_cell` is identical to `exterior_node` evaluated at tracer cell centers. > It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. No, there is no assumption. The notion of `exterior_cell` is independent of the immersed boundary implementation. There are `exterior_cell`s for any grid `Bounded` in one or more direction. The implementation for underlying grids is here:. https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/src/Grids/exterior_node.jl. Differences between ""full cell"" immersed boundary methods and other types of methods manifest in the way grid metrics are modified (spacing, areas, and vectors normal to cell interfaces). All immersed boundary methods will both define `external_cell` and any boundary-specific modifications to metrics. We'll also need an interface for specifying the face normal vector, since those normals won't lie along the cardinal directions anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806:20,Performance,perform,performance,20,I haven't looked at performance / GPU compilation in detail. I do think there is a type inference issue somewhere in this PR now because the flow over hills experiment is 7-8x slower on my laptop even without any immersed boundary condition. This likely indicates a problem with type inference in the flux divergence function (might also prevent GPU compilation). So we'll have to solve that and also add tests for CPU + GPU...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806:405,Testability,test,tests,405,I haven't looked at performance / GPU compilation in detail. I do think there is a type inference issue somewhere in this PR now because the flow over hills experiment is 7-8x slower on my laptop even without any immersed boundary condition. This likely indicates a problem with type inference in the flux divergence function (might also prevent GPU compilation). So we'll have to solve that and also add tests for CPU + GPU...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100753659:354,Availability,mask,masking,354,"> Not sure I understand this. Is this trying to check whether a location is adjacent to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. Are you confused by the _definition_, or the way it's used? `peripheral_node` and `immersed_peripheral_node` are needed to condition fluxes. `external_node` is needed for masking. For example, vorticity is valid _on_ the boundary, and thus peripheral values of vorticity should not be masked (I don't think...). But we do need to condition fluxes on peripheral nodes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100753659
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100753659:468,Availability,mask,masked,468,"> Not sure I understand this. Is this trying to check whether a location is adjacent to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. Are you confused by the _definition_, or the way it's used? `peripheral_node` and `immersed_peripheral_node` are needed to condition fluxes. `external_node` is needed for masking. For example, vorticity is valid _on_ the boundary, and thus peripheral values of vorticity should not be masked (I don't think...). But we do need to condition fluxes on peripheral nodes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100753659
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039:757,Availability,error,errors,757,"Some progress:. The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary. I updated `flow_over_hills.jl` to introduce an initial perturbation that goes turbulent immediately. Here's a visualization of vorticity alongside total momentum loss for a 64x64 resolution:. https://user-images.githubusercontent.com/15271942/163830810-8f15244b-27e2-4bf0-a7b2-e35d73bd8c79.mp4. The ""reference"" case has a no-slip boundary but no bathymetry. The momentum loss between reference and free-slip case are similar. No-slip and immersed boundary has the most momentum loss. The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction. I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. Overall I'm happy. I'd like to implement a few more convenient features and then I think this implementation is complete. There's still a fair amount of work to do to write tests and documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039:1144,Availability,error,errors,1144,"Some progress:. The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary. I updated `flow_over_hills.jl` to introduce an initial perturbation that goes turbulent immediately. Here's a visualization of vorticity alongside total momentum loss for a 64x64 resolution:. https://user-images.githubusercontent.com/15271942/163830810-8f15244b-27e2-4bf0-a7b2-e35d73bd8c79.mp4. The ""reference"" case has a no-slip boundary but no bathymetry. The momentum loss between reference and free-slip case are similar. No-slip and immersed boundary has the most momentum loss. The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction. I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. Overall I'm happy. I'd like to implement a few more convenient features and then I think this implementation is complete. There's still a fair amount of work to do to write tests and documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039:248,Deployability,update,updated,248,"Some progress:. The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary. I updated `flow_over_hills.jl` to introduce an initial perturbation that goes turbulent immediately. Here's a visualization of vorticity alongside total momentum loss for a 64x64 resolution:. https://user-images.githubusercontent.com/15271942/163830810-8f15244b-27e2-4bf0-a7b2-e35d73bd8c79.mp4. The ""reference"" case has a no-slip boundary but no bathymetry. The momentum loss between reference and free-slip case are similar. No-slip and immersed boundary has the most momentum loss. The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction. I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. Overall I'm happy. I'd like to implement a few more convenient features and then I think this implementation is complete. There's still a fair amount of work to do to write tests and documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039:1325,Testability,test,tests,1325,"Some progress:. The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary. I updated `flow_over_hills.jl` to introduce an initial perturbation that goes turbulent immediately. Here's a visualization of vorticity alongside total momentum loss for a 64x64 resolution:. https://user-images.githubusercontent.com/15271942/163830810-8f15244b-27e2-4bf0-a7b2-e35d73bd8c79.mp4. The ""reference"" case has a no-slip boundary but no bathymetry. The momentum loss between reference and free-slip case are similar. No-slip and immersed boundary has the most momentum loss. The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction. I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. Overall I'm happy. I'd like to implement a few more convenient features and then I think this implementation is complete. There's still a fair amount of work to do to write tests and documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101498039
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101504503:331,Availability,error,errors,331,"@glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up. . The motvation is to assess how much of this is due to pressure errors versus other stuff.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101504503
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101504503:593,Availability,error,errors,593,"@glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up. . The motvation is to assess how much of this is due to pressure errors versus other stuff.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101504503
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101510306:362,Availability,mask,masking,362,"> > Not sure I understand this. Is this trying to check whether a location is adjacent to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?; > ; > Are you confused by the _definition_, or the way it's used? `peripheral_node` and `immersed_peripheral_node` are needed to condition fluxes. `external_node` is needed for masking. For example, vorticity is valid _on_ the boundary, and thus peripheral values of vorticity should not be masked (I don't think...). But we do need to condition fluxes on peripheral nodes. I was a bit confused as to both. But your comments clarified quite a bit, thanks! I think the rest of my doubts will be answered once I have time to read the code more carefully...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101510306
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101510306:476,Availability,mask,masked,476,"> > Not sure I understand this. Is this trying to check whether a location is adjacent to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?; > ; > Are you confused by the _definition_, or the way it's used? `peripheral_node` and `immersed_peripheral_node` are needed to condition fluxes. `external_node` is needed for masking. For example, vorticity is valid _on_ the boundary, and thus peripheral values of vorticity should not be masked (I don't think...). But we do need to condition fluxes on peripheral nodes. I was a bit confused as to both. But your comments clarified quite a bit, thanks! I think the rest of my doubts will be answered once I have time to read the code more carefully...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101510306
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266:266,Deployability,integrat,integrated,266,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. @francispoulin I think he's talking about the fact that the graph on the right (the domain average/integrated momentum) isn't monotonic for IBM cases. Overall it has the correct tendency (loss of momentum) but has small scale fluctuations that aren't physical (i.e. there's no physical mechanism increasing the avg momentum in the domain, so the fluctuations must be numerical in origin).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266:266,Integrability,integrat,integrated,266,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. @francispoulin I think he's talking about the fact that the graph on the right (the domain average/integrated momentum) isn't monotonic for IBM cases. Overall it has the correct tendency (loss of momentum) but has small scale fluctuations that aren't physical (i.e. there's no physical mechanism increasing the avg momentum in the domain, so the fluctuations must be numerical in origin).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949:29,Availability,error,errors,29,"> The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction.; > ; > I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. I can't help there, but I agree it's a good idea. For now I think we should test that these errors are decreasing reasonably fast with resolution. (But that can be done in another PR I think.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949:423,Availability,error,errors,423,"> The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction.; > ; > I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. I can't help there, but I agree it's a good idea. For now I think we should test that these errors are decreasing reasonably fast with resolution. (But that can be done in another PR I think.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949:523,Availability,error,errors,523,"> The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction.; > ; > I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. I can't help there, but I agree it's a good idea. For now I think we should test that these errors are decreasing reasonably fast with resolution. (But that can be done in another PR I think.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949:507,Testability,test,test,507,"> The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction.; > ; > I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. I can't help there, but I agree it's a good idea. For now I think we should test that these errors are decreasing reasonably fast with resolution. (But that can be done in another PR I think.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179:339,Availability,error,errors,339,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently. I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179:606,Availability,error,errors,606,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently. I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179:700,Availability,down,down,700,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently. I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101515457:339,Availability,error,errors,339,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I think it would work flawlessly in that case!. This PR is all about viscous fluxes across immersed boundaries, so when we implement a viscous closure for `ShallowWaterModel` we can try to setup flow around islands or something and do a similar analysis as we've done here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101515457
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101515457:606,Availability,error,errors,606,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I think it would work flawlessly in that case!. This PR is all about viscous fluxes across immersed boundaries, so when we implement a viscous closure for `ShallowWaterModel` we can try to setup flow around islands or something and do a similar analysis as we've done here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101515457
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101520394:1144,Testability,test,test,1144,"> > The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary.; > ; > That's awesome! Just out of curiosity (since I also investigated this I couldn't figure it out), how did you fix the type inference issue?; > ; > cc @wenegrat @whitleyv. Here the issue was introduced in an early commit on this PR --- so it may not be exactly the same issue you faced. On the other hand, I think it happened with the same function that you modified (`conditional_flux`) so there may be a lesson you can glean. I also changed the design of the function (previously it took a function argument, `flux`, now it simply takes the scalar value of the flux). That subtle change might have made an important difference, since in the first case a function is being passed into another function (requiring the compiler to specialize on a function argument, sometimes a tricky thing), and another case it was just a floating point number being passed in (relatively vanilla in comparison). Did you test that kind of change in your PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101520394
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101520394:765,Usability,simpl,simply,765,"> > The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary.; > ; > That's awesome! Just out of curiosity (since I also investigated this I couldn't figure it out), how did you fix the type inference issue?; > ; > cc @wenegrat @whitleyv. Here the issue was introduced in an early commit on this PR --- so it may not be exactly the same issue you faced. On the other hand, I think it happened with the same function that you modified (`conditional_flux`) so there may be a lesson you can glean. I also changed the design of the function (previously it took a function argument, `flux`, now it simply takes the scalar value of the flux). That subtle change might have made an important difference, since in the first case a function is being passed into another function (requiring the compiler to specialize on a function argument, sometimes a tricky thing), and another case it was just a floating point number being passed in (relatively vanilla in comparison). Did you test that kind of change in your PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101520394
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533:339,Availability,error,errors,339,"> > @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > > The motvation is to assess how much of this is due to pressure errors versus other stuff.; > ; > I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently.; > ; > I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!. Does the total energy do the same thing or is it just the momentum?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533:604,Availability,error,errors,604,"> > @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > > The motvation is to assess how much of this is due to pressure errors versus other stuff.; > ; > I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently.; > ; > I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!. Does the total energy do the same thing or is it just the momentum?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533:705,Availability,down,down,705,"> > @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > > The motvation is to assess how much of this is due to pressure errors versus other stuff.; > ; > I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently.; > ; > I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!. Does the total energy do the same thing or is it just the momentum?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533:904,Energy Efficiency,energy,energy,904,"> > @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > > The motvation is to assess how much of this is due to pressure errors versus other stuff.; > ; > I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently.; > ; > I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!. Does the total energy do the same thing or is it just the momentum?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101526910:17,Energy Efficiency,energy,energy,17,> Does the total energy do the same thing or is it just the momentum?. I'll add that to `flow_over_hills.jl`!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101526910
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112:19,Energy Efficiency,energy,energy,19,> > Does the total energy do the same thing or is it just the momentum?; > ; > I'll add that to `flow_over_hills.jl`!. Thanks. . Given the fact that the reference case flows over a flat bottom it doesn't suprise me that the mometum decreases monotonically. . The 2nd and 3rd case are flowing over topography and there should be a periodic effect of the topography on the momentum. No? Total momentum must vary because of the forcing and I don't know exactly what that should look like. But if the energy is not monotonic that would be a clear sign that something is going wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112:497,Energy Efficiency,energy,energy,497,> > Does the total energy do the same thing or is it just the momentum?; > ; > I'll add that to `flow_over_hills.jl`!. Thanks. . Given the fact that the reference case flows over a flat bottom it doesn't suprise me that the mometum decreases monotonically. . The 2nd and 3rd case are flowing over topography and there should be a periodic effect of the topography on the momentum. No? Total momentum must vary because of the forcing and I don't know exactly what that should look like. But if the energy is not monotonic that would be a clear sign that something is going wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112:537,Usability,clear,clear,537,> > Does the total energy do the same thing or is it just the momentum?; > ; > I'll add that to `flow_over_hills.jl`!. Thanks. . Given the fact that the reference case flows over a flat bottom it doesn't suprise me that the mometum decreases monotonically. . The 2nd and 3rd case are flowing over topography and there should be a periodic effect of the topography on the momentum. No? Total momentum must vary because of the forcing and I don't know exactly what that should look like. But if the energy is not monotonic that would be a clear sign that something is going wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:1080,Integrability,interface,interface,1080,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:225,Usability,simpl,simplify,225,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:1123,Usability,simpl,simple,1123,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101585372:87,Usability,clear,clearn,87,I like the proposed idea for how to specify `FieldBoundaryConditions`. That seems very clearn and friendly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101585372
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104021544:80,Deployability,release,release,80,"@glwagner I tested the no-slip boundary condition on the classic case of a lock-release gravity current in a rectilinear channel (see video) and compared the position of the front of the dense current as a function of time for the case of an immersed boundary with the no-slip condition, a real boundary with the no-slip condition, and an immersed boundary with the slip condition. . https://user-images.githubusercontent.com/31293515/164257859-0deb6cf1-f6b7-414a-a86d-8b47d194b98a.mp4. ![Xfr](https://user-images.githubusercontent.com/31293515/164257805-0ac9a5e4-a575-442c-b676-1660c052a2ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104021544
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104021544:12,Testability,test,tested,12,"@glwagner I tested the no-slip boundary condition on the classic case of a lock-release gravity current in a rectilinear channel (see video) and compared the position of the front of the dense current as a function of time for the case of an immersed boundary with the no-slip condition, a real boundary with the no-slip condition, and an immersed boundary with the slip condition. . https://user-images.githubusercontent.com/31293515/164257859-0deb6cf1-f6b7-414a-a86d-8b47d194b98a.mp4. ![Xfr](https://user-images.githubusercontent.com/31293515/164257805-0ac9a5e4-a575-442c-b676-1660c052a2ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104021544
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104403293:82,Deployability,release,release,82,"> @glwagner I tested the no-slip boundary condition on the classic case of a lock-release gravity current in a rectilinear channel (see video) and compared the position of the front of the dense current as a function of time for the case of an immersed boundary with the no-slip condition, a real boundary with the no-slip condition, and an immersed boundary with the slip condition. ; > ; > ; > ; > https://user-images.githubusercontent.com/31293515/164257859-0deb6cf1-f6b7-414a-a86d-8b47d194b98a.mp4; > ; > ; > ; > ; > ; > ![Xfr](https://user-images.githubusercontent.com/31293515/164257805-0ac9a5e4-a575-442c-b676-1660c052a2ed.png); > ; > ; > ; > ; > ; > . @raphaelouillon I think I introduced a bug when I introduced support for GradientBoundaryCondition :-/ I'll let you know when that's fixed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104403293
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104403293:14,Testability,test,tested,14,"> @glwagner I tested the no-slip boundary condition on the classic case of a lock-release gravity current in a rectilinear channel (see video) and compared the position of the front of the dense current as a function of time for the case of an immersed boundary with the no-slip condition, a real boundary with the no-slip condition, and an immersed boundary with the slip condition. ; > ; > ; > ; > https://user-images.githubusercontent.com/31293515/164257859-0deb6cf1-f6b7-414a-a86d-8b47d194b98a.mp4; > ; > ; > ; > ; > ; > ![Xfr](https://user-images.githubusercontent.com/31293515/164257805-0ac9a5e4-a575-442c-b676-1660c052a2ed.png); > ; > ; > ; > ; > ; > . @raphaelouillon I think I introduced a bug when I introduced support for GradientBoundaryCondition :-/ I'll let you know when that's fixed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104403293
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:33,Availability,down,down,33,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:993,Deployability,Continuous,ContinuousBoundaryFunction,993,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:909,Integrability,interface,interface,909,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1767,Performance,perform,performant,1767,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:188,Testability,log,log,188,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1486,Testability,log,logarithm,1486,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1603,Testability,log,logarithm,1603,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1794,Testability,test,tests,1794,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1307,Usability,clear,clearly,1307,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550:368,Energy Efficiency,Energy,Energy,368,"Here's some results for reference (flat bottom no slip), ""no slip"", ""free slip"", and ""bottom drag"" for fractional heights h=0.1 and h=0.2:. # h = 0.1; https://user-images.githubusercontent.com/15271942/164373427-e614311e-7ff0-492c-a0de-6156eadd24ae.mp4. # h = 0.2; https://user-images.githubusercontent.com/15271942/164373538-08dcc7ff-820c-4492-9a75-a4a406d2c416.mp4. Energy always decreases (rapidly). Momentum is more squirrely, but fortunately we do find that specifying drag / no-slip seems to extract more momentum than otherwise (eg than with free slip boundary conditions). The amount of momentum lost with a free-slip boundary condition and hills of size `h=0.2` is roughly equivalent to the flat bottom case with no-slip. There's also transient periods with `h=0.2` where the case with no-slip boundary conditions has more momentum than free-slip. I'm going to run a few more cases at higher resolution. We should also have a more quantitative validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550:953,Security,validat,validation,953,"Here's some results for reference (flat bottom no slip), ""no slip"", ""free slip"", and ""bottom drag"" for fractional heights h=0.1 and h=0.2:. # h = 0.1; https://user-images.githubusercontent.com/15271942/164373427-e614311e-7ff0-492c-a0de-6156eadd24ae.mp4. # h = 0.2; https://user-images.githubusercontent.com/15271942/164373538-08dcc7ff-820c-4492-9a75-a4a406d2c416.mp4. Energy always decreases (rapidly). Momentum is more squirrely, but fortunately we do find that specifying drag / no-slip seems to extract more momentum than otherwise (eg than with free slip boundary conditions). The amount of momentum lost with a free-slip boundary condition and hills of size `h=0.2` is roughly equivalent to the flat bottom case with no-slip. There's also transient periods with `h=0.2` where the case with no-slip boundary conditions has more momentum than free-slip. I'm going to run a few more cases at higher resolution. We should also have a more quantitative validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550:964,Testability,test,test,964,"Here's some results for reference (flat bottom no slip), ""no slip"", ""free slip"", and ""bottom drag"" for fractional heights h=0.1 and h=0.2:. # h = 0.1; https://user-images.githubusercontent.com/15271942/164373427-e614311e-7ff0-492c-a0de-6156eadd24ae.mp4. # h = 0.2; https://user-images.githubusercontent.com/15271942/164373538-08dcc7ff-820c-4492-9a75-a4a406d2c416.mp4. Energy always decreases (rapidly). Momentum is more squirrely, but fortunately we do find that specifying drag / no-slip seems to extract more momentum than otherwise (eg than with free slip boundary conditions). The amount of momentum lost with a free-slip boundary condition and hills of size `h=0.2` is roughly equivalent to the flat bottom case with no-slip. There's also transient periods with `h=0.2` where the case with no-slip boundary conditions has more momentum than free-slip. I'm going to run a few more cases at higher resolution. We should also have a more quantitative validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269:184,Testability,log,logarithm,184,"> We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269:301,Testability,log,logarithm,301,"> We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269:5,Usability,clear,clearly,5,"> We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105200836:73,Energy Efficiency,energy,energy,73,"Movies are looking very good @glwagner ! . Great to see that the kinetic energy is only decreasing. . The momentum oscillating seems very reasonable to me. The topography does act like a force can change the momentum, but I don't have a reference to site.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105200836
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240:186,Testability,log,logarithm,186,"> > We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness.; > ; > That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR... Ah, can't you link to the relevant results? It's good to keep track of all this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240:303,Testability,log,logarithm,303,"> > We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness.; > ; > That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR... Ah, can't you link to the relevant results? It's good to keep track of all this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240:7,Usability,clear,clearly,7,"> > We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness.; > ; > That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR... Ah, can't you link to the relevant results? It's good to keep track of all this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105427369:455,Testability,test,test,455,"Higher resolution... ## h = 0.1; https://user-images.githubusercontent.com/15271942/164504233-495feaa3-47b9-46f7-8c31-b26c2ec1301c.mp4. ## h = 0.2; https://user-images.githubusercontent.com/15271942/164504265-94bd02b7-a78f-4bac-92ee-47ce3150f092.mp4. the `h = 0.2` are weird. Possibly the viscosity is not high enough so at that topographic height the solution is dominated by form drag / topographic interaction. I'm running another suite at lower Re to test that. Overall it looks like things are working, but cases with strong topographic interaction may require a new pressure solver if the momentum budget is important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105427369
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:5,Deployability,update,update,5,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:414,Security,validat,validation,414,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:879,Security,validat,validation,879,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:29,Testability,test,testing,29,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:52,Testability,test,tests,52,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:181,Testability,test,test,181,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:274,Testability,test,tests,274,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:425,Testability,test,tests,425,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:493,Testability,test,tests,493,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:543,Testability,test,test,543,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:752,Testability,test,test,752,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:267,Usability,simpl,simple,267,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:609,Usability,simpl,simple,609,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105588048:46,Energy Efficiency,energy,energy,46,Interesting that the `h=0.2` case has kinetic energy increasing for the case of free-slip. I don't suspect that is physical but should go away with increased resolution. The movies are very fun to watch!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105588048
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106174320:92,Availability,error,error,92,"@glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106174320
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106333798:310,Availability,error,errors,310,"@glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (https://github.com/CliMA/Oceananigans.jl/issues/1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since https://github.com/CliMA/Oceananigans.jl/issues/1277?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106333798
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106333798:12,Testability,test,tested,12,"@glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (https://github.com/CliMA/Oceananigans.jl/issues/1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since https://github.com/CliMA/Oceananigans.jl/issues/1277?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106333798
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075:265,Availability,error,errors,265,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Ah, a closure tuple! We might need to add more code to support that. Can you paste the whole error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075:576,Availability,error,error,576,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Ah, a closure tuple! We might need to add more code to support that. Can you paste the whole error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075:14,Testability,test,tested,14,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Ah, a closure tuple! We might need to add more code to support that. Can you paste the whole error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714:94,Availability,error,error,94,"> @glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?. Nice catch! Thank you!!! Indeed, all the cases I was running were `Flat` in `y` and so I didn't catch that bug. The issue is clear:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L62-L68. PS you might already know but just in case, here's some tips for github: you can generate a link by browsing the code and clicking on the line number to bring up a prompt:. <img width=""473"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164772983-7776dd60-7da0-4371-88b7-0475156f35fb.png"">. when you paste the link in a PR like this one it will show the line:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L67. In addition, you can actually go into ""Files changed"" on this PR and _suggest_ the change directly: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714:406,Usability,clear,clear,406,"> @glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?. Nice catch! Thank you!!! Indeed, all the cases I was running were `Flat` in `y` and so I didn't catch that bug. The issue is clear:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L62-L68. PS you might already know but just in case, here's some tips for github: you can generate a link by browsing the code and clicking on the line number to bring up a prompt:. <img width=""473"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164772983-7776dd60-7da0-4371-88b7-0475156f35fb.png"">. when you paste the link in a PR like this one it will show the line:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L67. In addition, you can actually go into ""Files changed"" on this PR and _suggest_ the change directly: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714:1283,Usability,feedback,feedback-in-your-pull-request,1283,"> @glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?. Nice catch! Thank you!!! Indeed, all the cases I was running were `Flat` in `y` and so I didn't catch that bug. The issue is clear:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L62-L68. PS you might already know but just in case, here's some tips for github: you can generate a link by browsing the code and clicking on the line number to bring up a prompt:. <img width=""473"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164772983-7776dd60-7da0-4371-88b7-0475156f35fb.png"">. when you paste the link in a PR like this one it will show the line:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L67. In addition, you can actually go into ""Files changed"" on this PR and _suggest_ the change directly: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:265,Availability,error,errors,265,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:1888,Availability,down,downsides,1888,"`no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would at least produce correct results in a straightforward way. I won't be able to spend too much time on working out the kinks for wall-resolved LES since the priority of the Climate Modeling Alliance is flux boundary conditions for wall-modeled LES and large-scale GCM problems...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:979,Integrability,interface,interface,979,"so catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would at least produce correct results in a straightforward way. I won't be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:14,Testability,test,tested,14,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:713,Testability,log,logical,713,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166
https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107514765:142,Testability,test,tested,142,"Thanks @tomchor and @raphaelouillon with your help on this PR! I implemented preliminary support for closure tuples, but it still needs to be tested. There's still some work to do to support proper both wall-modeled and wall-resolved LES in complex domains but I think this is a good start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107514765
https://github.com/CliMA/Oceananigans.jl/pull/2439#issuecomment-1100211147:23,Testability,test,tests,23,Great! I'll merge when tests pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2439#issuecomment-1100211147
https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112309201:114,Energy Efficiency,energy,energy,114,"Top: biharmonic diffusion. Bottom: WENO vector invariant with ""divergence damping"" with nu = 100 m^2 / s. Kinetic energy. ![image](https://user-images.githubusercontent.com/33547697/165781484-adc3d55d-bf58-4366-8cda-9565eb3ab5c1.png). Vorticity. ![image](https://user-images.githubusercontent.com/33547697/165783429-b40b86e4-4998-4140-855b-0fea58fe2a67.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112309201
https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591:363,Integrability,Message,Message,363,"Yes !. On Thu, Apr 28, 2022 at 06:33:13AM -0700, Gregory L. Wagner wrote:; > @christophernhill does MITgcm have a divergence viscosity feature?; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112209787; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591
https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112486769:248,Availability,error,error,248,I am confused about the formula. The Laplacian of the velocity is divided into two parts. The first is the gradient of the divergence and the second is the curl of the curtl of the velocity. The first should be zero but is not because of numerical error. Is this really the term that we are using to diffuse? Just wanted to confirm that I understand this correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112486769
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276:100,Testability,test,test,100,"@apaloczy I think this should fix your issue --- let me know if it doesn't!. We might want to add a test now or later. I think maybe just a trivial test that repeats an existing test for `Value/Gradient` boundary conditions, but on an `ImmersedBoundaryGrid` with no immersed nodes, would be sufficient. We could also test that we can apply `Value` boundary condition on curvilinear grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276:148,Testability,test,test,148,"@apaloczy I think this should fix your issue --- let me know if it doesn't!. We might want to add a test now or later. I think maybe just a trivial test that repeats an existing test for `Value/Gradient` boundary conditions, but on an `ImmersedBoundaryGrid` with no immersed nodes, would be sufficient. We could also test that we can apply `Value` boundary condition on curvilinear grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276:178,Testability,test,test,178,"@apaloczy I think this should fix your issue --- let me know if it doesn't!. We might want to add a test now or later. I think maybe just a trivial test that repeats an existing test for `Value/Gradient` boundary conditions, but on an `ImmersedBoundaryGrid` with no immersed nodes, would be sufficient. We could also test that we can apply `Value` boundary condition on curvilinear grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276:317,Testability,test,test,317,"@apaloczy I think this should fix your issue --- let me know if it doesn't!. We might want to add a test now or later. I think maybe just a trivial test that repeats an existing test for `Value/Gradient` boundary conditions, but on an `ImmersedBoundaryGrid` with no immersed nodes, would be sufficient. We could also test that we can apply `Value` boundary condition on curvilinear grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100703276
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100708867:56,Availability,error,error,56,"Actually, we can't test this because while it fixes the error, it seems there's another bug that prevents the boundary condition from being fulfilled. However, I put a fix for this second bug in #2437 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100708867
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100708867:19,Testability,test,test,19,"Actually, we can't test this because while it fixes the error, it seems there's another bug that prevents the boundary condition from being fulfilled. However, I put a fix for this second bug in #2437 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100708867
https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1101493170:57,Testability,test,tests,57,@sandreza @simone-silvestri this is ready to review. The tests should pass (it's just a CI issue that they aren't) and no changes should be needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1101493170
https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100300521:650,Deployability,update,updated,650,"I think we should write a `Field` tutorial that covers this (and everything else...) It's been on my todo list for so many eons. . `fill_halo_regions!` certainly is important. This function fills the halo regions of a field --- that is, a buffer of cells that surrounds the ""interior"" (physical part) of the domain. The halo regions are touched when we evaluate gradients or interpolate across boundaries. They are also used for distributed models (there the halo regions need to be communicated between different regions / processes). In general, the halo regions are linked to the interior values of the field --- so every time interior values are updated, halo regions must be updated for the entire state to be consistent. In short, we need to fill halo regions so that 1) spurious fluxes are not added while evaluating flux divergences across `Bounded` boundaries for `FluxBoundaryConditions`; 2) periodicity is correctly enforced in `Periodic` directions, 3) fluxes are correct for `Value/Gradient` boundary conditions. . I think our philosophy is generally that we want an API in which users don't need to call this function. It's just that people want to do ~~crazy~~ creative and cool!! things and writing an API that supports it all is hard. Or maybe more importantly its a chicken-egg problem so we (developers) need to _see_ the applications in action _first_, then we can design an API (at least for those wild applications out there). That docs section would blur the boundaries between ""developer documentation"" and ordinary documentation (we also need developer documentation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100300521
https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100300521:680,Deployability,update,updated,680,"I think we should write a `Field` tutorial that covers this (and everything else...) It's been on my todo list for so many eons. . `fill_halo_regions!` certainly is important. This function fills the halo regions of a field --- that is, a buffer of cells that surrounds the ""interior"" (physical part) of the domain. The halo regions are touched when we evaluate gradients or interpolate across boundaries. They are also used for distributed models (there the halo regions need to be communicated between different regions / processes). In general, the halo regions are linked to the interior values of the field --- so every time interior values are updated, halo regions must be updated for the entire state to be consistent. In short, we need to fill halo regions so that 1) spurious fluxes are not added while evaluating flux divergences across `Bounded` boundaries for `FluxBoundaryConditions`; 2) periodicity is correctly enforced in `Periodic` directions, 3) fluxes are correct for `Value/Gradient` boundary conditions. . I think our philosophy is generally that we want an API in which users don't need to call this function. It's just that people want to do ~~crazy~~ creative and cool!! things and writing an API that supports it all is hard. Or maybe more importantly its a chicken-egg problem so we (developers) need to _see_ the applications in action _first_, then we can design an API (at least for those wild applications out there). That docs section would blur the boundaries between ""developer documentation"" and ordinary documentation (we also need developer documentation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100300521
https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100305964:768,Deployability,update,updated,768,"> I think we should write a `Field` tutorial that covers this (and everything else...) It's been on my todo list for so many eons. If you start a PR I can help populate it over time (I'm guessing other people would probably wanna contribute too). > `fill_halo_regions!` certainly is important. This function fills the halo regions of a field --- that is, a buffer of cells that surrounds the ""interior"" (physical part) of the domain. The halo regions are touched when we evaluate gradients or interpolate across boundaries. They are also used for distributed models (there the halo regions need to be communicated between different regions / processes). In general, the halo regions are linked to the interior values of the field --- so every time interior values are updated, halo regions must be updated for the entire state to be consistent. In short, we need to fill halo regions so that 1) spurious fluxes are not added while evaluating flux divergences across `Bounded` boundaries for `FluxBoundaryConditions`; 2) periodicity is correctly enforced in `Periodic` directions, 3) fluxes are correct for `Value/Gradient` boundary conditions.; > ; > I think our philosophy is generally that we want an API in which users don't need to call this function. It's just that people want to do ~crazy~ creative and cool!! things and writing an API that supports it all is hard. Or maybe more importantly its a chicken-egg problem so we (developers) need to _see_ the applications in action _first_, then we can design an API (at least for those wild applications out there).; > ; > That docs section would blur the boundaries between ""developer documentation"" and ordinary documentation (we also need developer documentation...). We could put that in a section called ""Information for advanced users"" or something like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100305964
https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100305964:798,Deployability,update,updated,798,"> I think we should write a `Field` tutorial that covers this (and everything else...) It's been on my todo list for so many eons. If you start a PR I can help populate it over time (I'm guessing other people would probably wanna contribute too). > `fill_halo_regions!` certainly is important. This function fills the halo regions of a field --- that is, a buffer of cells that surrounds the ""interior"" (physical part) of the domain. The halo regions are touched when we evaluate gradients or interpolate across boundaries. They are also used for distributed models (there the halo regions need to be communicated between different regions / processes). In general, the halo regions are linked to the interior values of the field --- so every time interior values are updated, halo regions must be updated for the entire state to be consistent. In short, we need to fill halo regions so that 1) spurious fluxes are not added while evaluating flux divergences across `Bounded` boundaries for `FluxBoundaryConditions`; 2) periodicity is correctly enforced in `Periodic` directions, 3) fluxes are correct for `Value/Gradient` boundary conditions.; > ; > I think our philosophy is generally that we want an API in which users don't need to call this function. It's just that people want to do ~crazy~ creative and cool!! things and writing an API that supports it all is hard. Or maybe more importantly its a chicken-egg problem so we (developers) need to _see_ the applications in action _first_, then we can design an API (at least for those wild applications out there).; > ; > That docs section would blur the boundaries between ""developer documentation"" and ordinary documentation (we also need developer documentation...). We could put that in a section called ""Information for advanced users"" or something like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2442#issuecomment-1100305964
https://github.com/CliMA/Oceananigans.jl/issues/2443#issuecomment-1100804033:46,Safety,avoid,avoid,46,I guess when there are no tracers you want to avoid showing kappa.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2443#issuecomment-1100804033
https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101589518:49,Availability,error,error,49,I clicked on `this code` but then obtained a 404 error. Could the link not be quite right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101589518
https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101591884:51,Availability,error,error,51,> I clicked on `this code` but then obtained a 404 error. Could the link not be quite right?. Sorry that was because I had linked to a branch that got merged and doesn't exist anymore. I updated the original issue with a working link,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101591884
https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101591884:187,Deployability,update,updated,187,> I clicked on `this code` but then obtained a 404 error. Could the link not be quite right?. Sorry that was because I had linked to a branch that got merged and doesn't exist anymore. I updated the original issue with a working link,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101591884
https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630:4,Availability,error,error,4,"The error comes from here:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. My guess is that the eigenvalues aren't constructed properly. There's some code in the solver constructor:. https://github.com/CliMA/Oceananigans.jl/blob/aea1e043aa6f965ed599f151b6ace85f25df8cfa/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L44. which (just a guess) looks like we are trying to hack something together rather than properly using an interface defined by `PencilFFTs`. We have to read the `PencilFFTs` documentation and discover how to correctly define these arrays that are meant to be used in the above broadcasting operation. I think there is another issue about this, might be worth searching so we don't have a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630
https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630:539,Integrability,interface,interface,539,"The error comes from here:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. My guess is that the eigenvalues aren't constructed properly. There's some code in the solver constructor:. https://github.com/CliMA/Oceananigans.jl/blob/aea1e043aa6f965ed599f151b6ace85f25df8cfa/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L44. which (just a guess) looks like we are trying to hack something together rather than properly using an interface defined by `PencilFFTs`. We have to read the `PencilFFTs` documentation and discover how to correctly define these arrays that are meant to be used in the above broadcasting operation. I think there is another issue about this, might be worth searching so we don't have a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1103448537:26,Testability,test,tests,26,Any idea why [distributed tests](https://buildkite.com/clima/oceananigans/builds/6805#646493ef-a91c-418c-b51f-4cafeced8ff1) fail?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1103448537
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:831,Deployability,update,update,831,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:160,Testability,test,test,160,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:293,Testability,test,test,293,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:491,Testability,test,tests,491,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:611,Testability,test,tests,611,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:935,Testability,test,test,935,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:1088,Testability,test,test,1088,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657:1172,Testability,test,test,1172,"> Possibly related to discussion on #2347 ? Broadcasting ordinary arrays with PencilArrays is fragile. It needs to be fixed... I think that's correct. A way to test this is to change the following lines: ; https://github.com/CliMA/Oceananigans.jl/blob/3ba95e07a27d93129a87f266aecc3c11d20aac14/test/test_distributed_models.jl#L471-L472. to . ```julia; arch = MultiArch(ranks=(1, 4, 1)) ; grid = RectilinearGrid(arch, topology=topo, size=(8, 2, 8), extent=(1, 2, 3)) ; ```. And it should make tests pass. For some reason I found that the condition `Rx*Nx == Ry*Ny == Rz*Nz` needs to be satisfied in order to make tests pass (see https://github.com/CliMA/Oceananigans.jl/issues/2445). I don't necessarily recommend merging that way, since this doesn't fix the issue, instead it circumvents it, but I'm pretty sure we won't be able to update the packages (including updating to julia 1.7) before fixing this issue. On the other hand, this test passes right now on main only because of a coincidence, and there's most likely a bug in code (based on answer by @glwagner and @jipolanco), so the test is not doing its intended purpose. That might be an argument for removing that test until we have time to fix the issue, since it's keeping us from updating other packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105085657
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942:200,Integrability,depend,dependency,200,"Another possibility is to write some tests using `HydrostaticFreeSurfaceModel` with `ExplicitFreeSurface`, which is entirely explicit and thus requires only halo filling via MPI (with no PencilArrays dependency)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942:37,Testability,test,tests,37,"Another possibility is to write some tests using `HydrostaticFreeSurfaceModel` with `ExplicitFreeSurface`, which is entirely explicit and thus requires only halo filling via MPI (with no PencilArrays dependency)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1119583275:4,Testability,test,tests,4,All tests pass except the cleanup cpu. ; i’ll merge.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1119583275
https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1119583659:16,Testability,test,tests,16,We need to make tests shorter… :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1119583659
https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104258234:47,Testability,test,testing,47,Ok @simone-silvestri I think this is ready for testing!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104258234
https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104259906:22,Deployability,update,updates,22,"@adelinehillier these updates are relevant to you too. Not sure what the effect this change will have on the closure + closure accuracy, so we'll have to see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104259906
https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:353,Energy Efficiency,reduce,reduced,353,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829
https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:252,Integrability,interface,interfaces,252,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829
https://github.com/CliMA/Oceananigans.jl/issues/2452#issuecomment-1480005451:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2452#issuecomment-1480005451
https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113:168,Deployability,update,update,168,"@simone-silvestri if we want to unify the user interface across all models, we could introduce the type `AdvectionScheme` (which will be rather trivial now, but we can update it in the future). Then we can have syntax like. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. Or,. ```julia; model = NonhydrostaticModel(; grid, advection=WENO5()); ```. which the model constructor interprets as. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=WENO5(grid)); ```. (this is nice too, because we can build `WENO5` on the grid under the hood). We could also _always_ ""regularize"" the advection scheme with `grid`, so that. ```julia; advection = AdvectionScheme(momentum=WENO5(), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. translates to. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); ```. under the hood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113
https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113:47,Integrability,interface,interface,47,"@simone-silvestri if we want to unify the user interface across all models, we could introduce the type `AdvectionScheme` (which will be rather trivial now, but we can update it in the future). Then we can have syntax like. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. Or,. ```julia; model = NonhydrostaticModel(; grid, advection=WENO5()); ```. which the model constructor interprets as. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=WENO5(grid)); ```. (this is nice too, because we can build `WENO5` on the grid under the hood). We could also _always_ ""regularize"" the advection scheme with `grid`, so that. ```julia; advection = AdvectionScheme(momentum=WENO5(), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. translates to. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); ```. under the hood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113
https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130039874:20,Usability,clear,clear,20,The name seems very clear and I like how this is structured.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130039874
https://github.com/CliMA/Oceananigans.jl/pull/2456#issuecomment-1105845116:36,Deployability,update,update,36,Right -- this is the correct way to update an existing PR from a fork. Well done @fadaie91 !,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2456#issuecomment-1105845116
https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1107997633:11,Deployability,update,updated,11,We haven't updated the parameters yet --- @adelinehillier any news on that front?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1107997633
https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024:860,Integrability,interface,interfaces,860,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024
https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024:220,Usability,guid,guideline,220,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024
https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1117378118:149,Deployability,update,updated,149,@sandreza do you want to take on reading the parameters off @adelinehillier figure and updating the defaults? It could be fun to test CATKE with the updated parameters in the 1 deg simulation too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1117378118
https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1117378118:129,Testability,test,test,129,@sandreza do you want to take on reading the parameters off @adelinehillier figure and updating the defaults? It could be fun to test CATKE with the updated parameters in the 1 deg simulation too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1117378118
https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1121385581:29,Deployability,update,updated,29,"@simone-silvestri and I have updated the parameters by inspecting the figure and copying the values into the source code. However, the scale of the plots doesn't allow us to accurately infer some very small, but very-importantly-non-zero parameter values (like `Cᵇc`, `Cᴷcʳ`, and `Cᵂu★`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1121385581
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107073824:25,Availability,down,download,25,"I added dropbox links to download the boundary conditions. This is what the annual cycle of wind stress, surface temperature, and surface salinity looks like:. https://user-images.githubusercontent.com/15271942/164838809-22922935-df1e-4bf0-9361-d9a4f66dea34.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107073824
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:637,Modifiability,variab,variably,637,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2473,Modifiability,variab,variably,2473,"2 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stoppi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4269,Modifiability,variab,variably,4269,"2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stoppin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:775,Safety,risk,risk,775,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2611,Safety,risk,risk,2611,"00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4407,Safety,risk,risk,4407,"⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:748,Security,validat,validated,748,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2584,Security,validat,validated,2584,"00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4380,Security,validat,validated,4380,"⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:24,Availability,down,down,24,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:486,Modifiability,variab,variably,486,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:624,Safety,risk,risk,624,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:2232,Safety,risk,risk,2232,"1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:597,Security,validat,validated,597,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:2205,Security,validat,validated,2205,"1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:3483,Testability,test,tested,3483,"x|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 993.451 ms; │ ├── max(u): (6.23e-01, 2.08e-01, 2.96e-03) m s⁻¹; │ ├── extrema(T): (-4.27, 50.74) ᵒC; └ └── max|η|: 1.22e+00 m; ```. so there is almost certainly a bug with how `IsopycnalSkewSymmetricDiffusivity` is implemented. @navidcy @sandreza . Now I know we have tested the diffusivity a fair amount in `y, z` domains, but have we tested `x, z`? I don't think we've ever tried 3D either. We should probably put GM in a double gyre and see what happens (with and without immersed boundaries).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:3551,Testability,test,tested,3551,"x|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 993.451 ms; │ ├── max(u): (6.23e-01, 2.08e-01, 2.96e-03) m s⁻¹; │ ├── extrema(T): (-4.27, 50.74) ᵒC; └ └── max|η|: 1.22e+00 m; ```. so there is almost certainly a bug with how `IsopycnalSkewSymmetricDiffusivity` is implemented. @navidcy @sandreza . Now I know we have tested the diffusivity a fair amount in `y, z` domains, but have we tested `x, z`? I don't think we've ever tried 3D either. We should probably put GM in a double gyre and see what happens (with and without immersed boundaries).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713:210,Security,validat,validation,210,"I added a script for looking at coarse, 3D baroclinic adjustment with GM starting with either a gradient in `y` or in `x`: https://github.com/CliMA/Oceananigans.jl/blob/0d04d4014c9ecc06deb158c42a2b3e3cd7699b31/validation/mesoscale_turbulence/coarse_baroclinic_adjustment.jl. It was tricky to get this to work in the first place; it seems we need diffusion to stabilize GM right now. I settled on adding biharmonic diffusivity with a time scale of 10 days. The script computes a mean in the direction perpendicular to the initial gradient. When the gradient is initially in `y`:. https://user-images.githubusercontent.com/15271942/164878441-a0660d6e-3241-4ec4-a473-cf0c65c70fa6.mp4. When the gradient is in `x`:. https://user-images.githubusercontent.com/15271942/164878658-18604606-9374-4008-894e-29ee7e49782a.mp4. From this it seems that the diffusivity is at least doing the right thing (but the stencil may still be non-optimal). We also need to test on a lat-lon grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713:949,Testability,test,test,949,"I added a script for looking at coarse, 3D baroclinic adjustment with GM starting with either a gradient in `y` or in `x`: https://github.com/CliMA/Oceananigans.jl/blob/0d04d4014c9ecc06deb158c42a2b3e3cd7699b31/validation/mesoscale_turbulence/coarse_baroclinic_adjustment.jl. It was tricky to get this to work in the first place; it seems we need diffusion to stabilize GM right now. I settled on adding biharmonic diffusivity with a time scale of 10 days. The script computes a mean in the direction perpendicular to the initial gradient. When the gradient is initially in `y`:. https://user-images.githubusercontent.com/15271942/164878441-a0660d6e-3241-4ec4-a473-cf0c65c70fa6.mp4. When the gradient is in `x`:. https://user-images.githubusercontent.com/15271942/164878658-18604606-9374-4008-894e-29ee7e49782a.mp4. From this it seems that the diffusivity is at least doing the right thing (but the stencil may still be non-optimal). We also need to test on a lat-lon grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107520465:113,Usability,simpl,simply,113,"I see that the two animations are similar, but not exactly the same. I presume the initial condigurations aren't simply rotated by 90 degrees?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107520465
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777:311,Security,validat,validation,311,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777:208,Usability,clear,clear,208,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107524673:251,Testability,test,test,251,"Thanks @glwagner . It seems that the `ramp` changes with the direction of the gradient, but the tracer doesn't. That's why we have a difference. Thanks. This is a rather complicated problem that you are investigating and I wonder whether getting a 3D test for `IsopycnalSkewSymmetricDiffusivity` might be an easier way to find the bug? Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107524673
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107528360:260,Testability,test,test,260,"> Thanks @glwagner . It seems that the `ramp` changes with the direction of the gradient, but the tracer doesn't. That's why we have a difference. Thanks.; > ; > This is a rather complicated problem that you are investigating and I wonder whether getting a 3D test for `IsopycnalSkewSymmetricDiffusivity` might be an easier way to find the bug? Just a thought. Agree! Partly I'm not sure what to expect. It seems that GM is noisy in general, so I'm not sure whether our implementation is ""more noisy"" than it should be. These examples are 3D but maybe you mean with an x, y gradient rather than in x or y independently? I was thinking that maybe a 3D double gyre with GM might be helpful, what do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107528360
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441:394,Availability,down,down,394,"Sorry, you mentioned the tests only tested `y,z`, but not `x,z` or `x,y,z`. I thought if those tests could be done that might help to identify the problem. Maybe?. A double gyre might help but that introduces boundaries, or at least more boundaries, so maybe more compliated?. It is interesting that we get an instability in a lat-lon grid but not a Cartesian grid. If you re-scale the lengths down say by a factor of 10, or even 100, these two should agree. I wonder if we still get an instability? If we did in the lat-lon grid but not the Cartesian one, maybe that would point to a problem with diffusing on a sphere? Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441:25,Testability,test,tests,25,"Sorry, you mentioned the tests only tested `y,z`, but not `x,z` or `x,y,z`. I thought if those tests could be done that might help to identify the problem. Maybe?. A double gyre might help but that introduces boundaries, or at least more boundaries, so maybe more compliated?. It is interesting that we get an instability in a lat-lon grid but not a Cartesian grid. If you re-scale the lengths down say by a factor of 10, or even 100, these two should agree. I wonder if we still get an instability? If we did in the lat-lon grid but not the Cartesian one, maybe that would point to a problem with diffusing on a sphere? Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441:36,Testability,test,tested,36,"Sorry, you mentioned the tests only tested `y,z`, but not `x,z` or `x,y,z`. I thought if those tests could be done that might help to identify the problem. Maybe?. A double gyre might help but that introduces boundaries, or at least more boundaries, so maybe more compliated?. It is interesting that we get an instability in a lat-lon grid but not a Cartesian grid. If you re-scale the lengths down say by a factor of 10, or even 100, these two should agree. I wonder if we still get an instability? If we did in the lat-lon grid but not the Cartesian one, maybe that would point to a problem with diffusing on a sphere? Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441:95,Testability,test,tests,95,"Sorry, you mentioned the tests only tested `y,z`, but not `x,z` or `x,y,z`. I thought if those tests could be done that might help to identify the problem. Maybe?. A double gyre might help but that introduces boundaries, or at least more boundaries, so maybe more compliated?. It is interesting that we get an instability in a lat-lon grid but not a Cartesian grid. If you re-scale the lengths down say by a factor of 10, or even 100, these two should agree. I wonder if we still get an instability? If we did in the lat-lon grid but not the Cartesian one, maybe that would point to a problem with diffusing on a sphere? Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107538441
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107686859:516,Testability,test,tests,516,"@christophernhill pointed me to this MITgcm setup: https://github.com/MITgcm/MITgcm/tree/c6adb04bff0a8860ffa46b74e8a11a6a6228274f/verification/front_relax/input. which is very similar and has no horizontal diffusion. However, it does look like it might have horizontal biharmonic viscosity with [`viscA4=1e11`](https://github.com/MITgcm/MITgcm/blob/c6adb04bff0a8860ffa46b74e8a11a6a6228274f/verification/front_relax/input/data#L9) --- can someone else confirm that I'm interpreting that correctly?. I'll re-run these tests with just biharmonic viscosity but no horizontal diffusion (laplacian or biharmonic) and see what happens. Maybe if the results are noisy then we can be sure there's an issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107686859
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1110244312:724,Security,validat,validation,724,"@xiaozhour and I looked into some direct comparisons with MITgcm and found a few differences that we are continuing to investigate. One thing worth noting is that in the MITgcm computation the xz and yz components of the diffusivity tensor that act on vertical gradients are directly set to zero, whereas the zz component is treated implicitly. In the simulation below I increase the initial horizontal gradient by a factor of two and set the initial tracer to be constant. A numerical instability develops eventually leading to NaNs in the tracer field. By setting the Redi-component to zero the solution remains stable. The file is located here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/modified_baroclinic_adjustment.jl. https://user-images.githubusercontent.com/22668662/165390858-211bce67-fb10-4ae4-8e60-3516b49e5031.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1110244312
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1111148813:298,Security,validat,validation,298,"It's not trivial for us to use the same kind of biharmonic diffusion as MITgcm (because MITgcm scales with grid factors and time-step somehow) -- are we sure that's the same too? It looks like it might not be:. https://github.com/CliMA/Oceananigans.jl/blob/990df6a9165413468475aa37035416e8044a9937/validation/mesoscale_turbulence/modified_baroclinic_adjustment.jl#L44. @simone-silvestri knows some of these finer details. I think we can pull the ""MITgcm-like"" biharmonic implementation from the 1 deg setup and use it here. Maybe we should actually formalize that to make these comparisons easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1111148813
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1117409246:610,Testability,test,test,610,"> It does seem like the additional fix for the boundary condition on GM is essential. I recently tried the 1 degree setup (switching to v0.75.3 of Oceananigans) and saw that there are still stability issues. Given that the solution blows up within 10 iterations it's probably more worthwhile to use the CPU for debugging purposes. It took 50 minutes to precompile on the GPU with TEOS10 + GM + Biharmonic viscosity + Vertical Diffusivity + Convective Adjustment. Also, the CPU is pretty fast at 1 deg resolution! I was able to do 30 day runs. So we may only need GPU for production runs. @sandreza how did you test on the latest Oceananigans? It looks like `main` isn't merged here but needs to be. What do you think about testing CATKE in this setup without GM?. I think the current implementation of GM isn't valid for TEOS10: . https://github.com/CliMA/Oceananigans.jl/blob/c493f19b555c9d36ef8616eca8cec2e4796e60c0/src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl#L59. I believe we need separate functions for each `buoyancy.model`. With a nonlinear equation of state, we have to write this stencil in terms of `thermal_expansion` and `haline_contraction`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1117409246
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1117409246:723,Testability,test,testing,723,"> It does seem like the additional fix for the boundary condition on GM is essential. I recently tried the 1 degree setup (switching to v0.75.3 of Oceananigans) and saw that there are still stability issues. Given that the solution blows up within 10 iterations it's probably more worthwhile to use the CPU for debugging purposes. It took 50 minutes to precompile on the GPU with TEOS10 + GM + Biharmonic viscosity + Vertical Diffusivity + Convective Adjustment. Also, the CPU is pretty fast at 1 deg resolution! I was able to do 30 day runs. So we may only need GPU for production runs. @sandreza how did you test on the latest Oceananigans? It looks like `main` isn't merged here but needs to be. What do you think about testing CATKE in this setup without GM?. I think the current implementation of GM isn't valid for TEOS10: . https://github.com/CliMA/Oceananigans.jl/blob/c493f19b555c9d36ef8616eca8cec2e4796e60c0/src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl#L59. I believe we need separate functions for each `buoyancy.model`. With a nonlinear equation of state, we have to write this stencil in terms of `thermal_expansion` and `haline_contraction`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1117409246
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119052363:17,Performance,optimiz,optimize,17,We maybe want to optimize the construction of the `SparseInverse`.; I naively wrote a serial code to do that because I didn't know that `CUDA.jl` had implemented a GPU version of the `qr` factorization. Since the construction of the preconditioner is embarrassingly parallelizable we can shift it to the GPU easily,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119052363
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119057526:81,Deployability,update,updated,81,it looks like `validation/near_global_lat_lon/near_global_quarter_degree.jl` was updated elsewhere so we need to resolve merge conflicts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119057526
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119057526:15,Security,validat,validation,15,it looks like `validation/near_global_lat_lon/near_global_quarter_degree.jl` was updated elsewhere so we need to resolve merge conflicts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119057526
https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119869105:255,Security,validat,validation,255,I think we can merge now. Maybe it'd be nice to have the realistic case in a similar file as `one_degree_setups/idealized_near_global_one_degree.jl` (if it isn't there already)?. https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/near_global_lat_lon/one_degree_setups/idealized_near_global_one_degree.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119869105
